<HEAD>
<LINK REL=STYLESHEET TYPE="text/css" HREF="../../prof/p1sty.txt" TITLE="Bibliography">
<TITLE>notes on "On the Building Blocks of Mathematical Logic"</TITLE>
</HEAD>
<BODY CLASS=bi2>
<A HREF="index.htm"><IMG SRC="../../../rbjgifs/up.gif" ALT=UP BORDER=0 ALIGN=LEFT></A>
<CENTER><H3><IMG SRC="../../../rbjgifs/lgnote.gif" ALT=Notes BORDER=0 ALIGN=MIDDLE> by 
<A HREF="../../rbj.htm"><IMG SRC="../../../rbjgifs/rbjin1.gif" ALT=RBJ BORDER=0 ALIGN=MIDDLE></A> on </H3>
<H1>On the Building Blocks of Mathematical Logic</H1>
<H3>by <A HREF="s.htm#Sch&ouml;nfinkel">Moses Sch&ouml;nfinkel</A></H3>
</CENTER>
This is the first published work in the field which came later to be known as <A HREF="../../logic/cl/index.htm">combinatory logic</A>.
<P>
Sch&ouml;nfinkel shows how the use of bound variables in logic can be dispensed with.
The use of higher order functions makes possible the reduction of logic to a language 
consisting of one constructor (the application of a function to an argument) and three primitive 
constants U, C (now usually called K) and S.
A function is termed "higher order" if it will accept a function as an argument, or return one as its result.
U, C, and S are all higher order functions.
<P>
The meaning of these primitives may be understood through the following informal definitions:
<DL>
<DT>Cxy = (C(x))(y) = x
<DD>C is a function which given any value x, returns the constant x valued function.
<DT>Sfgx = ((S(f))(g))(x) = (f(x))(g(x))
<DD>S is a function which combines two functions, say f and g, supplied as successive 
arguments.
The resulting function, given a value x, returns the value obtained by applying the value of f at x to 
the value of g at x.
<DT>UPQ = (U(P))(Q) = forall x. not( P(x) and Q(x) )
<DD>U is a generalised <EM>scheffer stroke</EM>.
It should be thought of as applying to two predicates and returns the universal quantification of the 
negated conjunction of the two predicates.
</DL>
<P>
These combinators are sufficient to enable arbitrary first order predicates to be expressed without the use of
bound variables, which appear in first order logic whenever a quantifier is used.
This can be demonstrated most straightforwardly using a simple algorithm which converts lambda-expressions to combinators.
They are not limited to <I>first-order</I> predicates, but without some constraints (equivalent to those found in first order logic, or more liberally and appropriately to those in Church's Simple Theory of Types <I><A HREF="c.htm#Church40">[Church40]</A></I>) the logic which results from the use of these combinators is at risk of proving inconsistent.
Combinatory logic has traditionally tried to avoid type constraints and has therefore been dogged with difficulties in achieving strength and consistency.
<P>
Sch&ouml;nfinkel's paper remains an accessible introduction to combinatory logic which makes clear the original motivation for this innovation.
<P>
<CENTER>
<HR WIDTH=70%>
<A HREF="index.htm"><IMG SRC="../../../rbjgifs/up.gif" ALT="UP" BORDER=0></A>
<A HREF="../../index.htm"><IMG SRC="../../../rbjgifs/home.gif" ALT="HOME" BORDER=0></A>
&copy; <A HREF="../../rbj.htm"><IMG SRC="../../../rbjgifs/rbjin1.gif" ALT=RBJ BORDER=0 ALIGN=ABSMIDDLE></A>
created 1995/12/9 modified 1998/12/10
</CENTER>
</BODY>




