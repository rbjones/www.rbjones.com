<HTML>
<HEAD><TITLE>Metatheory and reflection</TITLE>
</HEAD>
<BODY BGCOLOR="C0E0E0" LINK="#404080" VLINK="000000">
<A HREF="jrh0116.htm#end"><IMG SRC="../../rbjgifs/left.gif" ALT=left BORDER=0 ALIGN=LEFT></A>
<A HREF="jrh0100.htm"><IMG SRC="../../rbjgifs/up.gif" ALT=up BORDER=0></A>
<A NAME="start"></A>
<CENTER><H2>Metatheory and reflection</H2></CENTER>
<P>
 <P>
<A NAME="par175"></A>
If our speculation above is wrong, what is to be done when we come across an
inference pattern that can't be implemented efficiently as an LCF derived
rule? One alternative is to throw in whatever additional proof procedures might
be deemed necessary. But for a serious project of formalization, we need a high
level of assurance that the rule is correct. If it doesn't actually perform a
formal proof, how can this be done?
<P>
<A NAME="par176"></A>
One idea is to use metatheory. Suppose we formalize the object logic under
consideration, its syntax and its notion of provability, in an additional layer
of logic, the metalogic. The idea is that metatheorems (i.e. theorems in the
metalogic) can then be proved which justify formally the <EM> possibility</EM> of
proving a result in the object logic, without actually producing the proof in
complete detail. One can use another layer of logic for this purpose, as
discussed by <A HREF="jrh01b.htm#pollack-extensibility"><EM>[pollack-extensibility]</EM></A>. This metalogic can then be
particularly simple and transparent, since few mathematical resources are
needed to support the proofs of typical metatheorems. However, it's also
possible to use the <EM> same</EM> logic; this is often referred to as <EM>
reflection</EM>. From G&ouml;del's work we already know how a system can formalize its
own notion of provability. The only extra ingredient needed is a rule acting as
a bridge between the internal formalization and the logic itself:<A HREF="jrh01f.htm#44"><SUP>44</SUP></A>
<P>
<A NAME="par177"></A>
<CENTER><TABLE><TR><TD><CENTER>
 <IMG SRC="../../rbjgifs/turnstil.gif" ALT="|-" BORDER=0> <IMG SRC="../../rbjgifs/exists.gif" ALT=exists BORDER=0>p<FONT SIZE=5>.</FONT> Prov(p,<IMG SRC="../../rbjgifs/qqtel.gif" ALT=qqtel><IMG SRC="../../rbjgifs/phi.gif" ALT="phi"><IMG SRC="../../rbjgifs/qqter.gif" ALT=qqter>)
<HR>
<IMG SRC="../../rbjgifs/turnstil.gif" ALT="|-" BORDER=0> <IMG SRC="../../rbjgifs/phi.gif" ALT="phi">
</CENTER></TD></TR></TABLE></CENTER>
<P>
<A NAME="par178"></A>
It is clear that if the system is 1-consistent, this rule does not introduce
any new theorems, since all provable existential statements are true. However
the absence of hypotheses in the above theorems was crucial. The subtly
different rule with a nonempty set of hypotheses, or equivalently an additional
axiom scheme of the form <IMG SRC="../../rbjgifs/turnstil.gif" ALT="|-" BORDER=0> (<IMG SRC="../../rbjgifs/exists.gif" ALT=exists BORDER=0>p<FONT SIZE=5>.</FONT> Prov(p,<IMG SRC="../../rbjgifs/qqtel.gif" ALT=qqtel><IMG SRC="../../rbjgifs/phi.gif" ALT="phi"><IMG SRC="../../rbjgifs/qqter.gif" ALT=qqter>)) <IMG SRC="../../rbjgifs/implies.gif" ALT=implies BORDER=0> <IMG SRC="../../rbjgifs/phi.gif" ALT="phi"> <EM>
does</EM> make the logic stronger. In the special case where <IMG SRC="../../rbjgifs/phi.gif" ALT="phi"> is <B>F</B>, it
amounts to a statement of consistency, which G&ouml;del's second theorem rules
out, and in fact <A HREF="jrh01b.htm#lob-theorem"><EM>[lob-theorem]</EM></A> proved that such a theorem is provable in
the original system only in the trivial case where <IMG SRC="../../rbjgifs/turnstil.gif" ALT="|-" BORDER=0> <IMG SRC="../../rbjgifs/phi.gif" ALT="phi">. Since these
assertions amount to an expression of confidence in the formal system, as seen
by reflecting on it from outside (the system is consistent, everything provable
is true),<A HREF="jrh01f.htm#45"><SUP>45</SUP></A> they
were dubbed 'reflection principles' by <A HREF="jrh01b.htm#feferman-transfinite"><EM>[feferman-transfinite]</EM></A>, who,
following on from work by <A HREF="jrh01b.htm#turing-ordinals"><EM>[turing-ordinals]</EM></A>, investigated their iterated
addition as a principled way of making a formal system stronger. Our reflection
rules are intended rather to be a principled way of making proofs in a system
easier.
<P>
<A NAME="par179"></A>
The value of using metalogic or reflection in this way depends, of course, on
the fact that the metalogical proof of provability is easier (in some
practically meaningful sense) than doing a full proof in the object
logic.<A HREF="jrh01f.htm#46"><SUP>46</SUP></A> For example,
this definitely seems to be the case for the Deduction Theorem and
Skolemization steps discussed above: the metatheorem can be established once
and for all in a general form by induction over the structure of object logic
proofs, and thereafter instantiated for the cases in hand very cheaply. But
we've already expressed scepticism over whether these examples are realistic
for logics that one would actually use in practice.
<P>
<A NAME="par180"></A>
The most popular examples cited are simple algebraic manipulations. Suppose one
wants to justify a<SUB>1</SUB> + ... + a<SUB>n</SUB> = b<SUB>1</SUB> + ... + b<SUB>n</SUB> (for real numbers,
say) where the a<SUB>i</SUB> and b<SUB>i</SUB> are permutations of each other. An object-level
proof would need to rewrite delicately with the associative and commutative
laws; this is in fact what HOL's function <B> AC_CONV</B> does automatically.
When implemented in a simple-minded way this takes O(n<SUP>2</SUP>) time; even when
done carefully, O(n  log(n)). However we can prove a metatheorem stating
that if the multisets {a<SUB>1</SUB>, ..., a<SUB>n</SUB>} and {b<SUB>1</SUB>, ..., b<SUB>n</SUB>} are
equal, then the equation holds, without any further proof.
<A HREF="jrh01b.htm#davis-schwartz"><EM>[davis-schwartz]</EM></A> say confidently that 'the introduction of an appropriate
''algebra'' rule of inference shortens to 1 the difficulty of a sentence
which asserts an algebraic identity'. But assigning a difficulty of 1 is of
no practical significance. What of the complexity of checking multiset
equality? In fact, it is O(n<SUP>2</SUP>) in the worst case, according to
<A HREF="jrh01b.htm#knuth-ss"><EM>[knuth-ss]</EM></A>. Even if the elements are pairwise orderable somehow, we can't
do better than O(n  log(n)). So all this additional layer of complexity, and
the tedium of proving a precise metatheorem, has achieved nothing except
perhaps shaving something off the constant factor.
<P>
<A NAME="par181"></A>
The constant factor is not even likely to change much. However it would change
a lot more if the multiset equality test didn't have to be performed in some
formal system, but could be evaluated directly by a program. This suggests
another popular variant of the reflection idea: computational reflection. The
idea is to verify that a program will correctly implement a rule of inference
(e.g. correctly test for multiset equality and in the case of success, add the
appropriate equation to the stock of theorems), then add that program to the
implementation of the theorem prover, so thereafter it can be executed
directly. This does indeed offer much more efficiency, and in certain special
situations like arithmetical calculation, the speedup could be considerable. It
would also be a systematic way of gaining confidence in the many theorems which
are nowadays proved with the aid of computer checking. The proof of the
4-colour theorem has already been mentioned; more prosaic examples include
simply assertions that large numbers are prime. Journals in some fields already
have to confront difficult questions about what constitutes a proof in this
context; the issue is discussed by <A HREF="jrh01b.htm#lam-proof"><EM>[lam-proof]</EM></A> for example.
<P>
<A NAME="par182"></A>
However there are a number of difficulties with the scheme. In particular,
correctly formalizing the semantics of real programming languages, and then
proving nontrivial programs correct, is difficult. The formal system becomes
dramatically more complicated, since its rules effectively include the full
semantics of the implementation language, instead of being separate and
abstract. (This has a negative effect on the possibility of <EM> checking</EM>
proofs using simple proof-checking programs, an oft-suggested idea to increase
confidence in the correctness of machine-checked proofs.) And finally,
reflection, though extensively studied, has not often been exploited in
practice, the work of <A HREF="jrh01b.htm#boyer-moore-meta"><EM>[boyer-moore-meta]</EM></A> being probably the most
significant example to date.<A HREF="jrh01f.htm#47"><SUP>47</SUP></A>
<P>
<A NAME="par183"></A>
We should add that the idea of proving program correctness doesn't necessarily
demand some kind of logical reflection principle to support it. Boyer and
Moore, for example, need no such thing. Typical decision procedures only
involve a rather restricted part of the logic (e.g. tautologies or arithmetic
inequalities), and the semantics of this fragment can perfectly easily be
internalized, even though by Tarski's theorem this cannot be done for the whole
logic. (Nuprl's type theory, stratified by universe level, allows one to come
very close to the ideal: the semantics of one layer can be formalized in the
next layer up.) Ostensibly 'syntactic' manipulations can often be done directly
in ordinary logic or set theory, defining some appropriate semantics; following
<A HREF="jrh01b.htm#howe-computational"><EM>[howe-computational]</EM></A>, this is often called 'partial reflection'. For
example, the above method for justifying an AC rearrangement based on multiset
equality can easily be carried out in the object theory.
<P>
<A NAME="par184"></A>
We should also point out the following. It is often stated that, issues of
efficiency apart, some of the theorems in mathematics books <EM> are</EM>
metatheorems, or can only be proved using metatheory --- 'most of' them
according to <A HREF="jrh01b.htm#aiello-meta"><EM>[aiello-meta]</EM></A>. <A HREF="jrh01b.htm#matthews-fs0-theory"><EM>[matthews-fs0-theory]</EM></A> is one of the few
who cites an example:
<P>
<A NAME="par185"></A>
<BLOCKQUOTE>
For instance in a book on algebra one might read:
<P>
<A NAME="par186"></A>
<BLOCKQUOTE>
'If A is an abelian group, then, for all a, b in A, the equivalence
<P>
<A NAME="par187"></A>
 (a o b) o ... o (a o b)<SUP>n times</SUP> =
   (a o ... o a)<SUP>n times</SUP> o
   (b o ... o b)<SUP>n times</SUP> 
<P>
<A NAME="par188"></A>
holds'
</BLOCKQUOTE>
<P>
<A NAME="par189"></A>
... On the other hand, instead of a book, imagine a proof development system
for algebra; there the theorem cannot be stated, since it is not a theorem of
abelian group theory, it is, rather, a meta-theorem, a theorem <EM> about</EM>
abelian group theory.
</BLOCKQUOTE>
<P>
<A NAME="par190"></A>
But all this is from the completely irrelevant perspective of an axiomatization
of group theory in first order logic. As we have already stated, any serious
development of group theory is going to use higher-order or set-theoretic
devices, as Bourbaki does for example. With these mathematical resources,
iterated operations are trivially definable and their basic properties easily
provable --- this appears right at the very beginning of the well-known algebra
textbook of <A HREF="jrh01b.htm#lang-algebra"><EM>[lang-algebra]</EM></A> for example, and in section 1.4 of
<A HREF="jrh01b.htm#jacobson1"><EM>[jacobson1]</EM></A>! The stress on direct first order axiomatizations in the AI
community probably results from a laudable scepticism in some quarters towards
the fancy new logics being promulgated by others, but it completely fails to
reflect real mathematical practice. What <EM> is</EM> true is that one often sees
statements like 'the other cases are similar' or 'by symmetry we may assume
that m <IMG SRC="../../rbjgifs/le.gif" ALT=le> n'. These have the flavour of metatheorems in that they relate
similar <EM> proofs</EM> rather than <EM> theorems</EM>. But bear in mind that when
presenting proofs informally, this is just one of many devices used to
abbreviate them. Certainly, a way of formalizing statements like this is as
metatheorems connecting proofs. But another is simply to do (or program the
computer to do!) all the cases explicitly, or to use an object-level theorem
directly as justification, e.g.
<P>
<A NAME="par191"></A>
 (<IMG SRC="../../rbjgifs/forall.gif" ALT=forall BORDER=0>m, n<FONT SIZE=5>.</FONT> P(m,n) <IMG SRC="../../rbjgifs/equiv.gif" ALT=iff BORDER=0> P(n,m)) <IMG SRC="../../rbjgifs/implies.gif" ALT=implies BORDER=0>
           ((<IMG SRC="../../rbjgifs/forall.gif" ALT=forall BORDER=0>m, n<FONT SIZE=5>.</FONT> P(m,n)) <IMG SRC="../../rbjgifs/equiv.gif" ALT=iff BORDER=0> (<IMG SRC="../../rbjgifs/forall.gif" ALT=forall BORDER=0>m, n<FONT SIZE=5>.</FONT> m <IMG SRC="../../rbjgifs/le.gif" ALT=le> n <IMG SRC="../../rbjgifs/implies.gif" ALT=implies BORDER=0> P(m,n)) 
<P>
<A NAME="par192"></A>
Performing similar proofs in different contexts may anyway be a hint that one
should be searching for a suitable mathematical generalization to include all
the cases.
<P>
<A NAME="par193"></A>
So, we have yet to find the LCF approach inadequate, and yet to see really
useful implementations of reflection. Whatever exotic principles are added, the
provable sentences will form a recursively enumerable set (we are after all
considering a computer implementation), and once again there will be unprovable
statements and infeasible ones. Now since we haven't come across any
interesting infeasible statements yet it seems extremely conjectural that they
won't still be infeasible in the expanded system. Boyer reports that the
metafunction facility of NQTHM is not widely used in practice, even though it
is the <EM> only</EM> way for an ordinary user to add new facilities to NQTHM. And
<A HREF="jrh01b.htm#constable-programs"><EM>[constable-programs]</EM></A>, who are no enemies of the idea of reflection as
indicated by their extensive writings on the subject, say: 'Of all these
methods [of providing extensibility] we have found the LCF idea easiest to use
and the most powerful.'
<P>
<A NAME="par194"></A>
<A NAME="end"></A>
<HR>
<CENTER>
<A HREF="jrh0116.htm#end"><IMG SRC="../../rbjgifs/left.gif" ALT=left BORDER=0 ALIGN=LEFT></A>
<A HREF="jrh0118.htm#start"><IMG SRC="../../rbjgifs/right.gif" ALT=right BORDER=0 ALIGN=RIGHT></A>
<A HREF="jrh0100.htm"><IMG SRC="../../rbjgifs/up.gif" ALT=up BORDER=0></A>
<A HREF="../index.htm"><IMG SRC="../../rbjgifs/home.gif" ALT=home BORDER=0></A>
 <A HREF="http://www.abo.fi/~jharriso/">John Harrison</A>
 96/8/13; HTML by <A HREF="http://www.rbjones.com/rbjpub/rbj.htm"><IMG SRC=../../rbjgifs/rbjin1.gif BORDER=0 ALIGN=TOP></A> 96/8/16
</CENTER>
</BODY></HTML>
