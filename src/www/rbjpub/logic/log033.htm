<HTML>
<HEAD>
<LINK REL=STYLESHEET TYPE="text/css" HREF="../prof/p1sty.txt" TITLE="Resource">
<TITLE>MainFrame: HOST Implementation Features</TITLE>
<META name="description" contents="An overview of the main features of a proposed implementation of Higher Order Set Theory.">
<META name="keywords" contents="RbJ FormaL MethoD SeT TheorY HOL ImplementatioN">
</HEAD>
<BODY CLASS=con>
<CENTER><H1>HOST Implementation Features</H1>
<P>
<A NAME="Intro"></A>
<TABLE BORDER CELLPADDING=3 WIDTH=80% CLASS=con><CAPTION><B>Introduction</B></CAPTION>
<TR><TD>
The features described here are the <I>desired</I> features of a <I>proposed</I> implementation of <A TARGET="_top" HREF="log011.htm">Higher Order Set Theory</A>.
At present this is totally fantastic, but I hope to be progressing the details of the design alongside prototyping activities, and that should help this to evolve towards the achievable.
<P>
The two principle design requirements are that:
<OL>
<LI>The system should be suitable for the <A HREF="#Semantic">support of a variety of notations</A> in the context of a single logical foundation.
<LI>The system be able to perform, in the context of a proof, <A HREF="#Efficient">efficient symbolic or numerical computations</A> by comparison with tools not based on proof (e.g. Mathematica, Maple).
</OL>
</TD></TR>
</TABLE>
<P>
<A NAME="LCF"></A>
<TABLE BORDER CELLPADDING=3 WIDTH=80% CLASS=con><CAPTION><B>The LCF Paradigm</B></CAPTION>
<TR><TD>
The system will be implemented broadly following <I><A HREF="../cs/cslog001.htm">the LCF paradigm</A></I> but with some novel features:
<OL>
<LI>Combine the LCF "proof is computation" with "computation is proof" by embedding core standard ML into the object language and implementing evaluation of ML during rewriting in the logical kernel.
<LI>The dominant proof flavour is "proof by evaluation".
<LI>No TACTICS (in the traditional sense).
<LI>Context sensitive domain specific proof automation.
</OL>
</TD></TR>
</TABLE>
<P>
<A NAME="Generic"></A>
<TABLE BORDER CELLPADDING=3 WIDTH=80% CLASS=con><CAPTION><B>Notational Genericism through Semantic Embedding</B></CAPTION>
<TR><TD>
Consideration will be given to the ease with which diverse notations can be semantically embedded into HOST.
The embedding of SML in the kernel will make this easier because this will make available mutually recursive datatype definitions for abstract syntax.
The semantic embedding will also make more convenient definition of semantic functions (using pattern matching) over these syntactic domains.
Consideration will also be given to whether special support for languages presented in XML should be provided.
</TD></TR>
</TABLE>
<P>
<A NAME="Efficient"></A>
<TABLE BORDER CELLPADDING=3 WIDTH=80% CLASS=con><CAPTION><B>Computational Efficiency</B></CAPTION>
<TR><TD>
The primary purpose of the semantic embedding of SML in the kernel is to enable evaluation of functions defined in the object language to be done efficiently during proof.
This will mean that arithmetic computations involving functions defined in the object language using embedded SML will be evaluated, during the course of proofs, as a part of rewriting, without any performance penalty.
<P>
Unfortunately, well behaved arithemetic facilities are at present available only for integers.
Floating point arithmetic is not suitable for use in this context.
A rational arithmetic package is available for CAML, but this still falls short of the needs for a computationally efficient implementation of classical analysis.
Such an implementation will be needed before proof based mathematics can displace less rigorous methods as a practical method of solving real engineering problems.
</TD></TR>
</TABLE>
<P>
<A NAME="MegaKernel"></A>
<TABLE BORDER CELLPADDING=3 WIDTH=80% CLASS=con><CAPTION><B>Huge Powerful Logical MegaKernel</B></CAPTION>
<TR><TD>
As indicated above, though the primitive logic is quite simple, the logical kernel is much more complex, incorporating the logic of a large subset of core standard ML.
Getting this (derived) logic right is the main theoretical challenge in this proposal, and may take some time.
Prototyping of the kernel will take place concurrently with this more theoretical work.
<P>
At a first cut this is just a problem of devising a routine embedding of a well defined small programming language into higher order set theory, which is rather like a routine rewriting of the semantics (which is currently defined using a structured operational semantics).
The benefit from doing this will however be sensitive to how well the embedding is integrated with the rest of the object language.
To get a good solution will not be a routine exercise.
</TD></TR>
</TABLE>
<H3><A TARGET="_top" HREF="log026.htm"></A></H3>
<TABLE CELLPADDING=10 CLASS=con><TR><TD COLSPAN=3>
<CENTER>HOST is a <A TARGET="_top" HREF="log005.htm"><I>Mathematical Foundation System</I></A>,<BR>
<A TARGET="_top" HREF="../philos/maths/faq012.htm"><B>Are Foundations Necessary?</B></A></CENTER></TD></TR>
<TR><TH><A TARGET="_top" HREF="log012.htm">HOST rationale</A></TH>
<TH><A TARGET="_top" HREF="log013.htm">HOST pedigree</A></TH>
<TH><A TARGET="_top" HREF="log011.htm">HOST features</A></TH></TR></TABLE>
<P>
<HR WIDTH=70%>
<A HREF="index.htm"><IMG SRC="../../rbjgifs/up.gif" ALT="UP" BORDER=0></A>
<A HREF="../index.htm"><IMG SRC="../../rbjgifs/home.gif" ALT="HOME" BORDER=0></A>
&copy; <A HREF="../rbj.htm"><IMG SRC="../../rbjgifs/rbjin1.gif" ALT="RBJ" ALIGN=absmiddle BORDER=0></A>
created 1997/12/08 modified 1997/12/08
</CENTER>
</BODY>
</HTML>





