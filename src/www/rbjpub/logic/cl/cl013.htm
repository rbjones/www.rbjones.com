<HEAD>
<LINK REL=STYLESHEET TYPE="text/css" HREF="../../prof/p1sty.txt" TITLE="Factasia">
<TITLE>Typed Lambda Logic's</TITLE>
</HEAD>
<BODY CLASS=con>
<A TARGET="_top" HREF="index.htm"><IMG SRC="../../../rbjgifs/up.gif" ALT=UP ALIGN=LEFT BORDER=0></A>
<A TARGET="_top" HREF="cl001.htm"><IMG SRC="../../../rbjgifs/lskicube.gif" ALT="Lambda-SKI cube" BORDER=0 ALIGN=RIGHT></A>
<CENTER>
<H1>Typed Lambda Logic's (T<IMG SRC="../../../rbjgifs/lambdal.gif" ALT="Lambda">L)</H1>
<H2>Church's Simple Theory of Types</H2>
</CENTER>
The simple theory of types is probably the simplest logic to describe and to understand.
Of course that depends on what you already understand before you start!
The hardest bit to understand is the idea of higher order functions, which is present in both pure combinatory logic and in the type-free lambda calculus.
If you understand the lambda calculus its a small step to the simple theory of types.
<P>
The simple theory of types is arrived at from the lambda calculus by adding a type system, and then some logical constants, and then beefing up the inference rules to reflect the intended meaning of the constants.
<P>
First the type system.
The type system is based on the premise that there are two collections of elements, the first of which may be thought of as individuals in some domain of discourse (which we will call <I>ind</I>) and the second of which may be thought of either as truth values or as propositions (which we will call <I>bool</I>, anticipating a two valued logic).
These two collections are the primitive types.
<P>
The full collection of types is obtained by constructing function spaces.
From any two types, <I>t</I> and <I>u</I>, not necessarily distinct, a space of functions may be constructed, which we write as <I>t <IMG SRC="../../../rbjgifs/func1.gif" ALT=function BORDER=0> u</I> and which contains all the functions with domain <I>t</I> and co-domain <I>u</I>,
i.e. those functions which are defined for all elements of <I>t</I> and yield values which are elements of <I>u</I>.
The types are therefore the closure of the set {<I>ind, bool</I>} under the function space constructor "<IMG SRC="../../../rbjgifs/func1.gif" ALT=function BORDER=0>".
<P>
A grammar for the language of types is as follows:
<CENTER>
<TABLE CELLPADDING=5>
<TR><TD>Type</TD><TD>::=</TD><TD>bool</TD><TD>|</TD><TD>ind</TD><TD>|</TD><TD>(Type <IMG SRC="../../../rbjgifs/func1.gif" ALT=function BORDER=0> Type)
</TD></TR></TABLE>
</CENTER>
<P>
The terms of the simple theory of types are the terms of the type-free lambda calculus, decorated with types and subject to formation constraints defined using these annotations.
A term is either a constant name decorated with a type, or a variable name decorated with a type, or the application of one term to another (shown by juxtaposition with the function on the left), or a lambda abstraction in which the bound variable name is decorated with a type.
<P>
A grammar for the terms is as follows:
<CENTER>
<TABLE CELLPADDING=5>
<TR><TD>Term</TD><TD>::=</TD><TD>Cname:Type</TD><TD>|</TD><TD>Vname:Type</TD><TD>|</TD><TD>Term Term</TD><TD>|</TD><TD>(<IMG SRC="../../../rbjgifs/lambda.gif" ALT=lambda BORDER=0> Vname:Type. Term)
</TD></TR></TABLE>
</CENTER>
The formation constraints imposed concern function application and functional abstraction.
They determine the type of a function formed by abstraction, ensuring that the type of the bound variable in the abstraction is the domain of the function type of the abstraction and also that the type of the body of the lambda expression is the type of the co-domain of the resulting function.
When a function is applied the type constraints require that the type of the argument is the same as the domain of the function space type associated with the function.
<HR>
<CENTER>
<A HREF="index.htm"><IMG SRC="../../../rbjgifs/up.gif" ALT=up BORDER=0></A>
<A HREF="../../index.htm"><IMG SRC="../../../rbjgifs/home.gif" ALT=home BORDER=0></A>
&copy; <A HREF="../../rbj.htm">
<IMG SRC="../../../rbjgifs/rbjin1.gif" ALT=RBJ ALIGN=absmiddle BORDER=0></A>
created 1995/12/9 modified 1997/12/2
</CENTER>
</BODY>





