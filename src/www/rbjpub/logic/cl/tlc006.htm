<HTML>
<LINK REL=STYLESHEET TYPE="text/css" HREF="../../prof/p1sty.txt" TITLE="Factasia">
<HEAD><TITLE>MainFrame: Pure Type Systems</TITLE>
<META name="description" contents=".">
<META name="keywords" contents="RbJ FactasiA">
</HEAD>
<BODY CLASS=con>
<CENTER><IMG SRC="../../../rbjgifs/pts.gif" ALT="Pure Type Systems" BORDER=0  ALIGN=TOP WIDTH=55 HEIGHT=39>
<H3>Pure Type Systems</H3></CENTER>

<A NAME="overview"></A>
<TABLE>
<TR VALIGN=TOP><TD WIDTH=200><H1>Overview:</H1>
</TD>
<TD>
<TABLE BORDER=3 CLASS=con CELLPADDING=5 WIDTH="100%">
<TR><TD><FONT SIZE=4><B>
Distilling an essence of type assignment for the lambda calculus.</B></FONT></TD></TR>
</TABLE>
</TD></TR></TABLE>

Pure type systems are a family of typed lambda calculi each member of which is
determined by a triple (S,A,R) where:
<TABLE>
<TR VALIGN=TOP>
<TH WIDTH=50>S</TH><TD>is a subset of the constants of the system known as the <EM>sorts</EM></TD>
</TR>
<TR VALIGN=TOP>
<TH>A</TH><TD>is a set of <EM>axioms</EM> of the form: <EM>c:s</EM>,
where <EM>c</EM> is a constant and <I>s</I> is a sort.</TD>
</TR>
<TR VALIGN=TOP>
<TH>R</TH><TD>is a set of triples of sorts which determines what function spaces can be constructed in the system and 
what sort each function space inhabits</TD>
</TR>
</TABLE>
Each PTS is a formal system in which judgements of the form:
<P>
<CENTER>
Context <IMG SRC="../../../rbjgifs/turnstil.gif" ALT=turnstile"> TypeAssignment
</CENTER>
<P>
may be derived.
These judgements assign a type to some term of the typed lambda calculus in the given context. 
<P>
<CENTER>
<TABLE><TR><TH WIDTH=150>
<A HREF="#Syntax"><IMG SRC="../../../rbjgifs/syntax.gif" ALT="syntax" BORDER=0></A></TH>
<TH WIDTH=150><A HREF="#ProofRules"><IMG SRC="../../../rbjgifs/prufrule.gif" ALT="proof rules" BORDER=0></A></TH>
<TH WIDTH=150><A HREF="#Semantics"><IMG SRC="../../../rbjgifs/semantcs.gif" ALT="semantics" BORDER=0></A></TH>
</TR></TABLE>
</CENTER>

<P>
<A NAME="Syntax"></A>

<TABLE>
<TR VALIGN=TOP><TD WIDTH=200><H1>Syntax:</H1>
</TD><TD>

<TABLE BORDER=3 CLASS=con CELLPADDING=5 WIDTH="100%">
<TR><TD><FONT SIZE=4><B>
</B></FONT>
</TD></TR></TABLE>

</TD></TR></TABLE>

<CENTER>
<TABLE>
<TR><TD WIDTH=75>Term </TD><TD>::=</TD><TD></TD><TD WIDTH=250>Variable</TD><TD></TD></TR>
<TR><TD ROWSPAN=5></TD><TD></TD><TD>|</TD><TD>Constant</TD><TD></TD></TR>
<TR><TD></TD><TD WIDTH=15>|</TD><TD>Term Term</TD><TD COLSPAN=3>(Function Application)</TR>
<TR><TD></TD><TD>|</TD><TD> <IMG SRC="../../../rbjgifs/lambda.gif" ALT=lambda"> Variable: Term. Term</TD><TD>(Functional Abstraction)</TD></TR>
<TR><TD></TD><TD>|</TD><TD WIDTH=175> <IMG SRC="../../../rbjgifs/cpi.gif" ALT=pi"> Variable: Term. Term</TD><TD>(Dependent Function Space Construction)</TD></TR>
<TR><TD HEIGHT=5></TD></TR>
<TR><TD>TypeAssignment</TD><TD>::=</TD><TD></TD><TD>Term : Term</TD><TD>&nbsp;</TD><TD>&nbsp;</TD><TD>&nbsp;</TD></TR>
<TR><TD HEIGHT=5></TD></TR>
<TR><TD WIDTH=75>Declaration</TD><TD> ::=</TD><TD>&nbsp;</TD><TD>Variable : Term</TD><TD>&nbsp;</TD><TD></TD><TD>&nbsp;</TD></TR>
<TR><TD HEIGHT=5></TD></TR>
<TR><TD>Declaration-list</TD><TD>::=</TD><TD></TD><TD> Declaration , Declaration-list </TD><TD></TD></TR>
<TR><TD></TD><TD></TD><TD>|</TD><TD>Declaration</TD><TD COLSPAN=3>&nbsp;</TR>
<TR><TD HEIGHT=5></TD></TR>
<TR><TD>Context</TD><TD> ::=</TD><TD></TD><TD>(Declaration-list | )</TD></TR>
<TR><TD HEIGHT=5></TD></TR>
<TR><TD>Judgement</TD><TD> ::=</TD><TD></TD><TD>Context <IMG SRC="../../../rbjgifs/turnstil.gif" ALT="turnstile"> TypeAssignment</TD></TR>
</TABLE>
</CENTER>

<P>

<A NAME="ProofRules"></A>

<TABLE>
<TR VALIGN=TOP><TD WIDTH=200><H1>ProofRules:</H1>
</TD><TD>

<TABLE BORDER=3 CLASS=con CELLPADDING=5 WIDTH="100%">
<TR><TD><FONT SIZE=4><B>
</B></FONT>
</TD></TR></TABLE>

</TD></TR></TABLE>


<CENTER>
<TABLE CELLPADDING=10>
<TR><TH>Axioms</TH><TD ALIGN=CENTER><IMG SRC="../../../rbjgifs/turnstil.gif" ALT="turnstile"> c:s</TD>
<TD>if (c:s) <IMG SRC="../../../rbjgifs/memberof.gif" ALT="memberof"> A</TD></TR>
<TR><TH>Start Rule</TH>
<TD ALIGN=CENTER><IMG SRC="../../../rbjgifs/ctor.gif" ALT="T"> <IMG SRC="../../../rbjgifs/turnstil.gif" ALT="turnstile"> A:s<BR>
<HR NOSHADE>
<IMG SRC="../../../rbjgifs/ctor.gif" ALT="T">, x:A <IMG SRC="../../../rbjgifs/turnstil.gif" ALT="turnstile"> x:A
</TD>
<TD>if x is fresh
</TD></TR>
<TR><TH>Weakening Rule</TH>
<TD ALIGN=CENTER><IMG SRC="../../../rbjgifs/ctor.gif" ALT="T"> <IMG SRC="../../../rbjgifs/turnstil.gif" ALT="turnstile"> B:C; <IMG SRC="../../../rbjgifs/ctor.gif" ALT="T"> <IMG SRC="../../../rbjgifs/turnstil.gif" ALT="turnstile"> A:s<BR>
<HR NOSHADE>
<IMG SRC="../../../rbjgifs/ctor.gif" ALT="T">, x:A <IMG SRC="../../../rbjgifs/turnstil.gif" ALT="turnstile"> B:C
</TD>
<TD>if x is fresh</TD></TR>
<TR><TH>Application Rule</TH>
<TD ALIGN=CENTER><IMG SRC="../../../rbjgifs/ctor.gif" ALT="T"> <IMG SRC="../../../rbjgifs/turnstil.gif" ALT="turnstile"> F:(<IMG SRC="../../../rbjgifs/cpi.gif" ALT="PI">x:A.B):s;  <IMG SRC="../../../rbjgifs/ctor.gif" ALT="T"> <IMG SRC="../../../rbjgifs/turnstil.gif" ALT="turnstile"> C:A<BR>
<HR NOSHADE>
<IMG SRC="../../../rbjgifs/ctor.gif" ALT="T"> <IMG SRC="../../../rbjgifs/turnstil.gif" ALT="turnstile"> (F C) : (B[x:=C])
</TD>
<TD></TD></TR>
<TR><TH>Conversion Rule</TH>
<TD ALIGN=CENTER><IMG SRC="../../../rbjgifs/ctor.gif" ALT="T"> <IMG SRC="../../../rbjgifs/turnstil.gif" ALT="turnstile"> A:B; <IMG SRC="../../../rbjgifs/ctor.gif" ALT="T"> <IMG SRC="../../../rbjgifs/turnstil.gif" ALT="turnstile"> B':s,  B=B'<BR>
<HR NOSHADE>
<IMG SRC="../../../rbjgifs/ctor.gif" ALT="T"> <IMG SRC="../../../rbjgifs/turnstil.gif" ALT="turnstile"> A:B'
</TD>
<TD></TD></TR>
<TR><TH>Abstraction Rule</TH>
<TD ALIGN=CENTER>
<IMG SRC="../../../rbjgifs/ctor.gif" ALT="T">, x : A <IMG SRC="../../../rbjgifs/turnstil.gif" ALT="turnstile"> b:B;
<IMG SRC="../../../rbjgifs/ctor.gif" ALT="T"> <IMG SRC="../../../rbjgifs/turnstil.gif" ALT="turnstile">  (<IMG SRC="../../../rbjgifs/cpi.gif" ALT="PI">x:A.B):s
<BR>
<HR NOSHADE>
<IMG SRC="../../../rbjgifs/ctor.gif" ALT="T"> <IMG SRC="../../../rbjgifs/turnstil.gif" ALT="turnstile"> (<IMG SRC="../../../rbjgifs/lambda.gif" ALT="lambda">x:A.b) : (<IMG SRC="../../../rbjgifs/cpi.gif" ALT="PI">x:A.B)
</TD>
<TD></TD></TR>
<TR><TH><IMG SRC="../../../rbjgifs/cpi.gif" ALT="PI"> Rules</TH>
<TD ALIGN=CENTER><IMG SRC="../../../rbjgifs/ctor.gif" ALT="T"> <IMG SRC="../../../rbjgifs/turnstil.gif" ALT="turnstile"> A:s<SUB>1</SUB>; <IMG SRC="../../../rbjgifs/ctor.gif" ALT="T">, x:A <IMG SRC="../../../rbjgifs/turnstil.gif" ALT="turnstile"> B:s<SUB>2</SUB><BR>
<HR NOSHADE>
<IMG SRC="../../../rbjgifs/ctor.gif" ALT="T"> <IMG SRC="../../../rbjgifs/turnstil.gif" ALT="turnstile"> (<IMG SRC="../../../rbjgifs/cpi.gif" ALT="PI">x:A.B):s<SUB>3</SUB>
</TD>
<TD>if (s<SUB>1</SUB>, s<SUB>2</SUB>, s<SUB>3</SUB>) <IMG SRC="../../../rbjgifs/memberof.gif" ALT="memberof"> R</TD></TR>
</TABLE>
</CENTER>

<P>
<A NAME="Semantics"></A>

<TABLE>
<TR VALIGN=TOP><TD WIDTH=200><H1>Semantics:</H1>
</TD><TD>

<TABLE BORDER=3 CLASS=con CELLPADDING=5 WIDTH="100%">
<TR><TD><FONT SIZE=4><B>
</B></FONT>
</TD></TR></TABLE>

</TD></TR></TABLE>

Whereas all other aspects of this account of Pure Type Systems are taken from Barendregt, the following discussion
 of the semantics of these systems is my own attempt to make sense of the systems, and is therefore put forward in a tentative way.
<P>
<H3>The Purposes of Semantics</H3>
<P>
A semantics for a formal system many serve many purposes, and depending on what purpose is to be served, different approaches to defining the semantics may be appropriate.
<P>
The first, and arguably primary purpose of the semantics is to tell us what the statements in the language mean!
Typically, for a logical system this would be done by identifying the kind of thing which the language is talking about (an <I>interpretation</I>) and then, in terms of such an interpretation, what the value of expression and the truth value of formulae in the language is.
<P>
A second purpose of a semantics is to reassure us that the logical system is consistent.
This comes in two parts.
The first is to show that the rules of inference preserve "truth" (under all interpretations).
The second is to show that there are interpretations under which the axioms are true (called models).
Strictly speaking one also wants to know that not all formulae are true (since otherwise a consistency proof could be carried through with a debased semantics in which all formulae are deemed valid).
<P>
To a mathematician or professional logician there is one further and more difficult stage, which is to understand what all the models are and possibly to understand the structure of this collection as a mathematical domain.
Hackers may be happy to manage without this, especially since the answer often comes out in inscrutable category theory.
<P>
Here I am concerned primarily with the easiest part, which is to mention the semantics of the language, without particular concern for its consistency or for a complete understanding of the full range of models.
However some discussion of models in relation to consistency I can manage.
<P>
<H3>Classical Set Theoretic Interpretations</H3>
<P>
For the benefit of those with a better familiarity with classical set theory than with typed lambda calculi I make the following observations on the relationship between the two (which substantially influence my presentation of the semantics which follows).
<P>
Clearly these lambda calculi are primarily about <I>functions</I> which are also well treated in set theory.
The other things we see are <I>types</I> which are awfully like sets.
In fact, when we look at the language there is an obvious set-theoretic interpretation, and under that obvious interpretation all the axioms and rules are sound with the exeption only of some instances of the <IMG SRC="../../../rbjgifs/cpi.gif" ALT="PI"> rules.
<P>
Depending on the collection of <IMG SRC="../../../rbjgifs/cpi.gif" ALT="PI"> rules you have you will find either that:
<OL>
<LI>just about any set theory will provide a model
<LI>a set theory will provide a model if its <I>big</I> enough
<LI>no well founded set theory can provide a (well-founded, set-theoretic) model
</OL>
Case 1 is uninteresting, but an example of this is the simply typed lambda calculus.
<P>
Case 2 is more interesting.
The <IMG SRC="../../../rbjgifs/cpi.gif" ALT="PI"> rules are essentially about closure under the dependent function space contructor.
In set theory, read "axiom of replacement".
If you chose a set theory with "universes" then every set is a member of a larger set which is closed under the replacement axiom, and hence closed under the dependent function space constructor.
A model of such a set theory will provide "natural" models for the pure type systems whose rules follow certain constraints.
Here's my conjecture about a sufficient constraint:
<BLOCKQUOTE>
The sorts are partially ordered and the allowed instances of the <IMG SRC="../../../rbjgifs/cpi.gif" ALT="PI"> rule are all monotonically increasing, i.e. s<SUB>3</SUB> <IMG SRC="../../../rbjgifs/ge.gif" ALT="&ge;"> s<SUB>2</SUB> and  s<SUB>3</SUB> <IMG SRC="../../../rbjgifs/ge.gif" ALT="&ge;"> s<SUB>1</SUB>
</BLOCKQUOTE>
For this class of pure type systems a consistency proof should work out very simple using a plain old set-theoretic model (but I'm just <I>guessing</I>!).
<P>
Case 3
<P>
Satisfying the monotonicity constraint on the sorts is intended to ensure that the system is <I>well-founded</I>, and failing it means  that the pure type systems might not have any well-founded models.
The simplest example of such a system is probably the system <IMG SRC="../../../rbjgifs/lambda.gif" ALT="Lambda" BORDER=0>2 (the polymorphic or "second order" lambda calculus).
I believe this was proved by John Reynolds in his paper "polymorphism is not set theoretic" (you need to interpret both "polymorphism" and "set theoretic" carefully for this to be a true claim, it sounds a tad more general than it is).
<P>
These are really the interesting systems, since the others can be read as offerring less than you get in classical set theory.
In a sense the point of these typed lambda-calculi is just that they provide a basis for investigating kinds of polymorphism, which is, ways of getting round the awkwardness imposed by the classical constraint to well foundedness.
One way is to drop the well foundedness, and the problem then is to get something which is consistent and strong (if you are interested in doing  mathematics).
<P>
Anyway, these awkward type systems are generally studied by people into <I>proof theory</I> and their consistency is generally established by normalisation results (i.e., by reasoning about syntax) rather than by semantic methods.
Once you have a proof of normalisation you can make syntactic models, though you no longer need a model for the consistency proof and you don't need a particular model for describing the semantics.
(of course, its all really much more complicated than this)

If you want a hint of more motivation, the most trendy (although getting a bit long in the tooth these days) aspect of practical computing which militates against well-foundedness and might therefore benefit from these more interesting type systems is inheritance in object oriented languages.
If you attempt this naively in a well founded set theory the types turn out too "big" to be sets (i.e. the same size as the universe).

<H3>The Semantics</H3>
An interpretation of a PTS (S,A,R) consists of:
<P>
<CENTER>
<TABLE>
<TR><TD>A universe of discourse U.</TD></TR>
<TR><TD>An assignment of an element of U to each member of C.</TD></TR>
<TR><TD>A relation "<IMG SRC="../../../rbjgifs/memberof.gif" ALT="member of">" over U x U.</TD></TR>
<TR><TD>A partial function <I>apply</I>: U x U ~&gt; U.</TD></TR>
<TR><TD>A partial function <I>pi</I>: U ~&gt; U.</TD></TR>
</TABLE>
</CENTER>
<P>
An interpretation is:
<CENTER>
<TABLE>
<TR VALIGN=TOP>
<TD ROWSPAN=4><I>set theoretic</I></TD>
<TD ROWSPAN=3>if</TD>
<TD>U is a subclass of the domain of some set theory
</TD></TR>
<TR VALIGN=TOP><TD>"<IMG SRC="../../../rbjgifs/memberof.gif" ALT="member of">" is the restriction of the set membership relationship over that domain to U</TD>
</TR>
<TR><TD>apply(x,y)=z iff z is a unique value such that &lt;y,z&gt;<IMG SRC="../../../rbjgifs/memberof.gif" ALT="member of"> x</TD></TR>
<TR><TD>and</TD><TD>pi f <IMG SRC="../../../rbjgifs/subsetof.gif" ALT="is a subset of"> {g | dom(g) = dom(f) <IMG SRC="../../../rbjgifs/and.gif" ALT="and"><IMG SRC="../../../rbjgifs/forall.gif" ALT="forall">x. g(x) <IMG SRC="../../../rbjgifs/memberof.gif" ALT="member of"> f(x)}</TD></TR>
<TR VALIGN=TOP><TD ROWSPAN=1><I>well founded</I></TD>
<TD ROWSPAN=1>if</TD>
<TD>there is no infinite sequence of elements e<SUB>i</SUB> of U such that: <IMG SRC="../../../rbjgifs/forall.gif" ALT="for all">i. e<SUB>i+1</SUB> <IMG SRC="../../../rbjgifs/memberof.gif" ALT="member of"> e<SUB>i</SUB>.
</TR>
<TR VALIGN=TOP><TD ROWSPAN=3><I>standard</I></TD><TD ROWSPAN=2>if</TD><TD>it is set theoretic</TD></TR>
<TR><TD>it is well founded</TD></TR>
<TR><TD>and</TD><TD>pi f = {g | dom(g) = dom(f) <IMG SRC="../../../rbjgifs/and.gif" ALT="and"> <IMG SRC="../../../rbjgifs/forall.gif" ALT="forall">x. g(x) <IMG SRC="../../../rbjgifs/memberof.gif" ALT="member of"> f(x)}
</TD></TR>
</TABLE>
</CENTER>
<P>
Now I've set this up so that the semantics can be given <I>as if</I> it were a direct interpretation in a classical set theory, (just by chosing suggestive names), but all the key terms can be interpreted in ways which are quite non-standard, so it could be a non-well-founded set theory or a syntactic model.
<P>
In the context of an interpretation (U, ass, <IMG SRC="../../../rbjgifs/memberof.gif" ALT="member of">, apply, pi) and an assignment <I>val</I> of values to free variables the meaning <I>m</I> of the various constructs of the language is defined as follows.
The terms may or may not have a value, if they have no value then any term formed from them has no value and any judgement of which they are a part is false.
In the following undefinedness is not treated explicity but arises from the application of partial functions or from the use of definite descriptions which are not satisfied in the domain of the interpretation.
<CENTER>
<TABLE>
<TR><TD>m val c</TD><TD WIDTH=20>=</TD><TD>ass c</TD></TR>
<TR><TD>m val v</TD><TD>=</TD><TD>val v</TD></TR>
<TR><TD>m val (f a)</TD><TD>=</TD><TD>apply(m val f, m val a)</TD></TR>
<TR><TD>m val (<IMG SRC="../../../rbjgifs/lambda.gif" ALT=lambda"> Variable: Term1. Term2)</TD><TD>=</TD><TD><IMG SRC="../../../rbjgifs/lambda.gif" ALT=lambda"> v: (m val Term1) . m  ([Variable=&gt;v]val) Term2</TD></TR>
<TR><TD>m val (<IMG SRC="../../../rbjgifs/cpi.gif" ALT=PI"> Variable: Term1. Term2)</TD><TD>=</TD><TD><IMG SRC="../../../rbjgifs/cpi.gif" ALT=PI"> v: (m val Term1) . m  ([Variable=&gt;v]val) Term2</TD></TR>
<TR><TD>m val (Variable: Term)</TD><TD>=</TD><TD>(m val Variable) <IMG SRC="../../../rbjgifs/memberof.gif" ALT="member of"> (m val Term)</TD></TR>
<TR><TD>m val (Declaration, Declaration-list)</TD><TD>=</TD><TD>(m val Declaration) <IMG SRC="../../../rbjgifs/and.gif" ALT="and"> m val Declaration-list</TD></TR>
<TR><TD>m val [] (* empty list of declarations *)</TD><TD>=</TD><TD>true</TD></TR>
<TR><TD>m val (Declaration-list <IMG SRC="../../../rbjgifs/turnstil.gif" ALT="turnstile"> Type-assignment)</TD><TD>=</TD><TD>(m val Declaration-list) <IMG SRC="../../../rbjgifs/implies.gif" ALT="implies"> (m val Type-assignment)</TD></TR>
<TR><TD>&nbsp;</TD><TD>&nbsp;</TD></TR>
<TR><TD>&nbsp;</TD><TD>&nbsp;</TD></TR>
<TR><TD>&nbsp;</TD><TD>&nbsp;</TD></TR>
</TABLE>
</CENTER>
<P>
A judgement is satisfied by an interpretation if its value as defined above is <i>true</i> for every assignment to its variables.
An interpration which satisfies each of a set of judgements (which we might call a theory) is a model for that set of judgements.
<P>
A proof rule is sound if any interpretation which satisfies all the premises also satisfies the conclusion.
<P>
<CENTER>
<HR WIDTH=70%>
<A TARGET="_top" HREF="index.htm"><IMG SRC="../../../rbjgifs/up.gif" ALT="UP" BORDER=0></A>
<A TARGET="_top" HREF="../../index.htm"><IMG SRC="../../../rbjgifs/home.gif" ALT="HOME" BORDER=0></A>
&copy;
<A HREF="../../rbj.htm" TARGET="_top"><IMG SRC="../../../rbjgifs/rbjin1.gif" ALT=RBJ ALIGN=ABSMIDDLE BORDER=0></A>
created 1996-01-01 modified 2013-06-05
</CENTER></BODY></HTML>
