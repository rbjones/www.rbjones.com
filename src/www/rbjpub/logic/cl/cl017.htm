<HTML>
<LINK REL=STYLESHEET TYPE="text/css" HREF="../../prof/p1sty.txt" TITLE="Factasia">
<HEAD><TITLE>MainFrame: The Lambda-calculus, Combinatory Logic, and Type Systems</TITLE>
<META name="description" contents="An overview of the Factasia material on The Lambda-calculus, Combinatory Logic, and Type Systems">
<META name="keywords" contents="RbJ FactasiA LambdA CalculuS CombinatoR TypE LogiC">
</HEAD>
<BODY CLASS=con>
<CENTER><H1>The Lambda-calculus, Combinatory Logic, and Type Systems</H1></CENTER>

<A NAME="overview"></A>
<TABLE>
<TR VALIGN=TOP><TD WIDTH=200><H1>Overview:</H1>
</TD>
<TD>
<TABLE BORDER=3 CLASS=con CELLPADDING=5 WIDTH="100%">
<TR><TD><FONT SIZE=4><B>
Three interrelated topics at the heart of logic and computer science.</B></FONT></TD></TR>
</TABLE>
</TD></TR></TABLE>

<TABLE WIDTH="100%">
<TR VALIGN=TOP><TD WIDTH="30%">

<TABLE CELLPADDING=5 WIDTH="100%" CLASS=co2>
<TR VALIGN=TOP><TD>
<CENTER><A HREF="#Lambda"><B>The <IMG SRC="../../../rbjgifs/lambda.gif" ALT=Lambda ALIGN=BOTTOM BORDER=0>-Calculus</B></A></CENTER>
<FONT SIZE=2>
A pure calculus of functional abstraction and function application, with applications throughout logic and computer science.</FONT>
</TD></TR>
<TR VALIGN=TOP><TD>
<CENTER><A HREF="#Types"><B>Types</B></A></CENTER>
<FONT SIZE=2>
The <IMG SRC="../../../rbjgifs/lambda.gif" ALT=Lambda ALIGN=BOTTOM BORDER=0>-calculus is good tool for exploring type systems, invaluable both in the foundations of mathematics and for practical programming languages.
</FONT>
</TD></TR>
<TR VALIGN=TOP><TD>
<CENTER><A HREF="#PTS"><B>Pure Type Systems</B></A></CENTER>
<FONT SIZE=2>
A further generalisation and systematic presentation of the class of type systems found in the <IMG SRC="../../../rbjgifs/lambda.gif" ALT=Lambda ALIGN=BOTTOM BORDER=0>-cube.
</FONT>
</TD></TR>
</TABLE>

</TD><TD WIDTH="30%">

<TABLE CELLPADDING=5 WIDTH="100%" CLASS=co2>
<TR VALIGN=TOP><TD>
<CENTER><A HREF="#Combinators"><B>Combinators</B></A></CENTER>
<FONT SIZE=2>
Combinatory logic shows that bound variables can be eliminated without loss of expressiveness.
It has applications both in the foundations of mathematics and in the implementation of functional programming languages.
</FONT>
</TD></TR>
<TR VALIGN=TOP><TD>
<CENTER><A HREF="#Programming"><B>Programming Languages</B></A></CENTER>
<FONT SIZE=2>
The connections between the lambda-calculus and programming languages are diverse and pervasive.
Type systems are an important aspect of programming language design.
</FONT>
</TD></TR>
</TABLE>

</TD><TD WIDTH="40%">

<TABLE CELLPADDING=5 WIDTH="100%" CLASS=co2>
<TR VALIGN=TOP><TD>
<CENTER><A HREF="#LSKICube"><B>The <IMG SRC="../../../rbjgifs/lskicube.gif" ALT="Lambda-SKI cube" BORDER=0 ALIGN=MIDDLE>-cube</B></A></CENTER>
<FONT SIZE=2>
A graphical presentation of the relationship between combinatory logic, lambda calculi and related logical systems.
</FONT>
</TD></TR>
<TR VALIGN=TOP><TD>
<CENTER><A HREF="#LCube"><B>The <IMG SRC="../../../rbjgifs/lamcube.gif" ALT="Lambda cube" BORDER=0 ALIGN=MIDDLE>-cube</B></A></CENTER>
<FONT SIZE=2>
A graphical presentation of the relationship between various typed <IMG SRC="../../../rbjgifs/lambda.gif" ALT=Lambda ALIGN=BOTTOM BORDER=0>-calculi, illuminating the structure of Coquand's Calculus of Constructions.
</FONT>
</TD></TR>
</TABLE>

</TD></TR></TABLE>


<P>
<A NAME="Lambda"></A>

<TABLE>
<TR VALIGN=TOP><TD WIDTH=200><H1>The <IMG SRC="../../../rbjgifs/lambdal.gif" ALT=Lambda ALIGN=BOTTOM BORDER=0>-calculus</H1>
</TD><TD>

<TABLE BORDER=3 CLASS=con CELLPADDING=5 WIDTH="100%">
<TR><TD><FONT SIZE=4><B>
A pure calculus of functional abstraction and function application, with applications throughout logic and computer science.</B></FONT>
</TD></TR></TABLE>

</TD></TR></TABLE>

<TABLE WIDTH="100%">
<TR VALIGN=TOP><TD WIDTH="33%">

<TABLE CELLPADDING=5 WIDTH="100%" CLASS=co2>
<TR VALIGN=TOP><TD>
<CENTER><B></B></CENTER>
<FONT SIZE=2>
</FONT>
</TD></TR>
</TABLE>

</TD><TD WIDTH="33%">

<TABLE CELLPADDING=5 WIDTH="100%" CLASS=co2>
<TR VALIGN=TOP><TD>
<CENTER><B></B></CENTER>
<FONT SIZE=2>
</FONT>
</TD></TR>
</TABLE>

</TD><TD WIDTH="33%">

<TABLE CELLPADDING=5 WIDTH="100%" CLASS=co2>
<TR VALIGN=TOP><TD>
<CENTER><B></B></CENTER>
<FONT SIZE=2>
</FONT>
</TD></TR>
</TABLE>

</TD></TR></TABLE>

<A NAME="Combinators"></A>
<TABLE>
<TR VALIGN=TOP><TD WIDTH=200><H1>Combinators</H1>
</TD><TD>

<TABLE BORDER=3 CLASS=con CELLPADDING=5 WIDTH="100%">
<TR><TD><FONT SIZE=4><B>
Combinatory logic shows that bound variables can be eliminated without loss of expressiveness.
It has applications both in the foundations of mathematics and in the implementation of functional programming languages.
</B></FONT>
</TD></TR></TABLE>

</TD></TR></TABLE>

<P>
Combinatory logic was invented by Moses Sh&ouml;nfinkel in 1920.
The work was published in 1924 in a paper entitled 
<A HREF="../../philos/bibliog/s.htm#Sch&ouml;nfinkel"><EM>On the building blocks of 
mathematical logic</EM></A><A HREF="../../philos/bibliog/schonf24.htm">.
<IMG SRC="../../../rbjgifs/smnote.gif" BORDER=0 ALT="notes" ALIGN=TOP></A>
<P>
At this time reducing logic to the simplest possible primitive basis was still thought to be 
worthwhile (it is not so greatly valued today).
Sch&ouml;nfinkel showed how the use of bound variables in logic could be dispensed with.
The use of "curried" higher order functions makes possible the reduction of logic to a language 
consisting of one constructor (the application of a function to an argument) and three primitive 
constants U, C (now usually called K) and S.
<P>
Sch&ouml;nfinkel's paper remains an accessible introduction to combinatory logic which makes 
clear the original motivation for this innovation.
This original motivation was vigorously pursued later by H.B.Curry and his collaborators.
The results of Curry's programme were published in <EM>Combinatory Logic</EM>, Vols <A 
HREF="../../philos/bibliog/c.htm#Curry58">1</A> &amp; <A 
HREF="../../philos/bibliog/c.htm#Curry72">2</A>.
<P>
While Sch&ouml;finkel was successful in showing that combinators could provide plausible 
notation, the semantic and proof theoretic aspects were more difficult to put in place.
The difficulty is more pronounced if it hoped to use combinatory logic as a foundation for 
mathematics, than it is for the use of combinators in less demanding roles (e.g. for programming languages).
<P>
The <EM>Pure</EM> combinatory logic may be thought of as Sch&ouml;nfinkels system with the 
logical operator "U" omitted (though the presentation may vary).
<EM>Illative</EM> combinatory logics are formed by adding additional logical primitives to the pure combinators.
There are many illative combinatory logics, which vary among themselves in substance as well as in presentation.
<P>
Pure combinatory logic is so closely related to Church's lambda-calculus that it is best studied alongside the lambda-calculus, for which the most comprehensive modern text is probably <A 
HREF="../../philos/bibliog/b.htm#Barendregt84"><EM>The Lambda Calculus</EM></A>.
A very popular and entertaining introduction to the pure combinators may be found in <A 
HREF="../../philos/bibliog/s.htm#Smullyan85"><EM>To Mock a Mockingbird</EM></A>.
<P>
Research on illative combinatory logics has been continued by Curry's students, Roger Hindley 
and Jonathan Seldin, and by Martin Bunder.
Hindley, Lercher and Seldin published <A HREF="../../philos/bibliog/h.htm#Hindley72"><EM>An 
Introduction to Combinatory Logic</EM></A>, an excellent and readable short introduction to the subject, now superseded by the more comprehensive <A 
HREF="../../philos/bibliog/h.htm#Hindley86"><EM>An Introduction to Combinators and the 
Lambda-Calculus</EM></A>
<P>
Recently <A HREF=" http://math.boisestate.edu/~holmes">Randall Holmes</A> has 
developed logical systems based on combinatory logic and the lambda calculus using methods
derived from Quine's formulations of set theory.
<P>
The attempt to make a foundation for mathematics using the illative combinatory logic were 
blighted by Curry's paradox and semantic opacity.
While systems avoiding this paradox have been devised, they are typically weak, and lack
the kind of convincing semantic intuition found in first order set theory.

<TABLE WIDTH="100%">
<TR VALIGN=TOP><TD WIDTH="33%">

<TABLE CELLPADDING=5 WIDTH="100%" CLASS=co2>
<TR VALIGN=TOP><TD>
<CENTER><B></B></CENTER>
<FONT SIZE=2>
</FONT>
</TD></TR>
</TABLE>

</TD><TD WIDTH="33%">

<TABLE CELLPADDING=5 WIDTH="100%" CLASS=co2>
<TR VALIGN=TOP><TD>
<CENTER><B></B></CENTER>
<FONT SIZE=2>
</FONT>
</TD></TR>
</TABLE>

</TD><TD WIDTH="33%">

<TABLE CELLPADDING=5 WIDTH="100%" CLASS=co2>
<TR VALIGN=TOP><TD>
<CENTER><B></B></CENTER>
<FONT SIZE=2>
</FONT>
</TD></TR>
</TABLE>

</TD></TR></TABLE>


<P>
<A NAME="Types"></A>

<TABLE>
<TR VALIGN=TOP><TD WIDTH=200><H1>Types</H1>
</TD><TD>

<TABLE BORDER=3 CLASS=con CELLPADDING=5 WIDTH="100%">
<TR><TD><FONT SIZE=4><B>
The <IMG SRC="../../../rbjgifs/lambda.gif" ALT=Lambda ALIGN=BOTTOM BORDER=0>-calculus is good tool for exploring type systems, invaluable both in the foundations of mathematics and for practical programming languages.
</B></FONT>
</TD></TR></TABLE>

</TD></TR></TABLE>

<TABLE WIDTH="100%">
<TR VALIGN=TOP><TD WIDTH="33%">

<TABLE CELLPADDING=5 WIDTH="100%" CLASS=co2>
<TR VALIGN=TOP><TD>
<CENTER><B></B></CENTER>
<FONT SIZE=2>
</FONT>
</TD></TR>
</TABLE>

</TD><TD WIDTH="33%">

<TABLE CELLPADDING=5 WIDTH="100%" CLASS=co2>
<TR VALIGN=TOP><TD>
<CENTER><B></B></CENTER>
<FONT SIZE=2>
</FONT>
</TD></TR>
</TABLE>

</TD><TD WIDTH="33%">

<TABLE CELLPADDING=5 WIDTH="100%" CLASS=co2>
<TR VALIGN=TOP><TD>
<CENTER><B></B></CENTER>
<FONT SIZE=2>
</FONT>
</TD></TR>
</TABLE>

</TD></TR></TABLE>


<P>
<A NAME="LSKICube"></A>

<TABLE>
<TR VALIGN=TOP><TD WIDTH=200><H1><A TARGET="_top" HREF="cl001.htm">The <IMG SRC="../../../rbjgifs/lambdal.gif" ALT=Lambda ALIGN=BOTTOM BORDER=0>-SKI Cube</A></H1>
</TD><TD>

<TABLE BORDER=3 CLASS=con CELLPADDING=5 WIDTH="100%">
<TR><TD><FONT SIZE=4>
<CENTER>
<A TARGET="_top" HREF="cl001.htm"><A HREF="cl005.htm"><IMG SRC="../../../rbjgifs/lskimap.gif" ALT=cubemap USEMAP="#map1" BORDER=0 ALIGN=CENTER></A>
</FONT>
</CENTER>
</TD></TR></TABLE>

</TD></TR></TABLE>

<MAP NAME="map1">
<AREA COORDS="0,180,50,220" HREF="cl006.htm">
<AREA COORDS="38,128,82,172" HREF="cl007.htm">
<AREA COORDS="0,48,45,92" HREF="cl008.htm">
<AREA COORDS="38,0,85,42" HREF="cl009.htm">
<AREA COORDS="130,180,200,231" HREF="cl010.htm">
<AREA COORDS="177,120,256,175" HREF="cl011.htm">
<AREA COORDS="122,50,171,85" HREF="cl012.htm">
<AREA COORDS="175,0,255,50" HREF="cl013.htm">
<AREA COORDS="80,85,140,150" HREF="cl005.htm">
</MAP>

<TABLE WIDTH="100%" CLASS=co2>
<TR VALIGN=TOP><TD>
The <IMG SRC="../../../rbjgifs/lambda.gif" ALT=lambda>-SKI cube is a way of presenting a number of related calculi and logics which are obtainable from pure combinatory logic by one or more of three kinds of extension.
<P>
<A HREF="cl006.htm"><I>The origin</I></A> of the cube is pure Combinatory Logic (c).
<P>
The three kinds of extension considered are called <A HREF="cl003.htm"><I>the axes</I></A> of the cube.
<P>
The cube presents eight systems or kinds of system which are arranged at <A HREF="cl005.htm"><I>the vertices</I></A> of the cube.
<P>
Those systems sharing a particular value on one of the dimensions of the cube are arranged around one of <A HREF="cl004.htm"><I>the faces</I></A> of the cube.
</TD></TR></TABLE>


<P>
<A NAME="LCube"></A>

<TABLE>
<TR VALIGN=TOP><TD WIDTH=200><H1><A TARGET="_top" HREF="tlc001.htm">The <IMG SRC="../../../rbjgifs/lambdal.gif" ALT=Lambda ALIGN=BOTTOM BORDER=0>-cube</A></H1>
</TD><TD>

<TABLE BORDER=3 CLASS=con CELLPADDING=5 WIDTH="100%">
<TR><TD><FONT SIZE=4>
<CENTER>
<A TARGET="_top" HREF="tlc001.htm"><IMG SRC="../../../rbjgifs/lcubemap.gif" ALT=cubemap BORDER=0 ALIGN=RIGHT></A></FONT>
</CENTER>
</TD></TR></TABLE>

</TD></TR></TABLE>

<TABLE WIDTH="100%" CLASS=co2>
<TR VALIGN=TOP><TD>

The <IMG SRC="../../../rbjgifs/lambda.gif" ALT=lambda> cube is a way of presenting the fine structure of Coquand's
Calculus of Constructions relating that system to a variety of other typed lambda calculi.
This idea is due to <A TARGET="_top" HREF="../../philos/bibliog/b.htm#Barendregt">Henk Barendregt</A>,
and is presented in his <A TARGET="_top" HREF="../../philos/bibliog/b.htm#Barendregt91"><I>Introduction to Generalised Type Systems</I></A>
which is my principle source in preparing this material.
<P>
The eight systems at <I>the vertices</I> of the cube are obtained by extending the simply typed lambda calculus
(<IMG SRC="../../../rbjgifs/lambda.gif" ALT=lambda><IMG SRC="../../../rbjgifs/func1.gif" ALT=fun>) at
<I>the origin</I> of the cube along one or more of <I>the axes</I> of the cube.
The cube has six <I>faces</I> (like they do).

</TD></TR></TABLE>


<P>
<A NAME="PTS"></A>

<TABLE>
<TR VALIGN=TOP><TD WIDTH=200><H1><A TARGET="_top" HREF="tlc004.htm"><IMG SRC="../../../rbjgifs/pts.gif" ALT="Pure Type Systems" BORDER=0  ALIGN=TOP WIDTH=55 HEIGHT=39></A></H1>
</TD><TD>

<TABLE BORDER=3 CLASS=con CELLPADDING=5 WIDTH="100%">
<TR><TD><FONT SIZE=4><B>
<A TARGET="_top" HREF="tlc004.htm">Pure Type Systems</A> - distilling an essence of type assignment for the lambda calculus.
</B></FONT>
</TD></TR></TABLE>

</TD></TR></TABLE>


<TABLE BORDER=0 CLASS=co2>
<TR><TD>
Pure type systems are a family of typed lambda calculi each member of which is
determined by a triple (S,A,R) where:
<TABLE>
<TR VALIGN=TOP>
<TH WIDTH=50>S</TH><TD>is a subset of the constants of the system known as the <EM>sorts</EM></TD>
</TR>
<TR VALIGN=TOP>
<TH>A</TH><TD>is a set of <EM>axioms</EM> of the form: <EM>c:s</EM>,
where <EM>c</EM> is a constant and <I>s</I> is a sort.</TD>
</TR>
<TR VALIGN=TOP>
<TH>R</TH><TD>is a set of triples of sorts which determines what function spaces can be constructed in the system and 
what sort each function space inhabits</TD>
</TR>
</TABLE>
Each PTS is a formal system in which judgements of the form:
<P>
<CENTER>
Context <IMG SRC="../../../rbjgifs/turnstil.gif" ALT=turnstile"> TypeAssignment
</CENTER>
<P>
may be derived.
These judgements assign a type to some term of the typed lambda calculus in the given context. 
</TD><TH>
<IMG SRC="../../../rbjgifs/syntax.gif" ALT="syntax" BORDER=0>
<P>
<IMG SRC="../../../rbjgifs/prufrule.gif" ALT="proof rules" BORDER=0>
<BR>
<IMG SRC="../../../rbjgifs/semantcs.gif" ALT="semantics" BORDER=0>
</TH></TR></TABLE>
</CENTER>

<P>
<A NAME="Programming"></A>

<TABLE>
<TR VALIGN=TOP><TD WIDTH=200><H1>Programming Languages</H1>
</TD><TD>

<TABLE BORDER=3 CLASS=con CELLPADDING=5 WIDTH="100%">
<TR><TD><FONT SIZE=4><B>
The connections between the lambda-calculus and programming languages are diverse and pervasive.
Type systems are an important aspect of programming language design.
</B></FONT>
</TD></TR></TABLE>

</TD></TR></TABLE>


<TABLE WIDTH="100%">
<TR VALIGN=TOP><TD WIDTH="33%">

<TABLE CELLPADDING=5 WIDTH="100%" CLASS=co2>
<TR VALIGN=TOP><TD>
<CENTER><B>LISP</B></CENTER>
<FONT SIZE=2>
The list processing language LISP devised by John McCarthy in the late 1950's.
LISP was the first of many <I>functional</I> programming languages which are closely related to the lambda calculus. 
It was and remains the dominant language for programming in the field of Artificial Intelligence.
</FONT>
</TD></TR>
<TR VALIGN=TOP><TD>
<CENTER><B>Computability</B></CENTER>
<FONT SIZE=2>
The lambda calculus was first devised by <A TARGET="_top" HREF="../../philos/bibliog/c.htm#Church">Alonzo Church</A>, first to provide a foundation for mathematics and then to show the existence of unsolvable problems.
This lead to the development of a major branch of mathematical logic, the theory of computation, which inter alia, gives us via <I>Church's Thesis</I> (essentially that anything which can be computed can be computed using the lambda calculus) a grip on the limits in principle of what we can program computers to do.
</FONT>
</TD></TR>
</TABLE>

</TD><TD WIDTH="33%">

<TABLE CELLPADDING=5 WIDTH="100%" CLASS=co2>
<TR VALIGN=TOP><TD>
<CENTER><B>ML</B></CENTER>
<FONT SIZE=2>
The language ML (for <I>MetaLanguage</I>) was developed at Edinburgh by Robin Milner et.al. for use in the development of proof tools.
It incorporated a polymorphic strict type system which owes its origin to work on the lambda calculus.
</FONT>
</TD></TR>
<TR VALIGN=TOP><TD>
<CENTER><B>Combinator Graphs</B></CENTER>
<FONT SIZE=2>
The connection between the lambda calculus and pure combinatory logic was exploited to yield efficient techniques for the evaluation of functional programs by the reduction of graphs of combinators.
These techniques were popular in the 1980's, used notably by David Turner in implementations of his pure functional language <I>Miranda</I>.
</FONT>
</TD></TR>
<TR VALIGN=TOP><TD>
<CENTER><B>Formal Semantics</B></CENTER>
<FONT SIZE=2>
Work on the semantics of programming languages, notably that on <I>denotational</I> semantics, has made use of the lambda calculus, which has also provided a testbed for some of this work.
</FONT>
</TD></TR>
</TABLE>

</TD><TD WIDTH="33%">

<TABLE CELLPADDING=5 WIDTH="100%" CLASS=co2>
<TR VALIGN=TOP><TD>
<CENTER><B>Programs from Proofs</B></CENTER>
<FONT SIZE=2>
The constructive type theories devised by the philosopher per Martin L&ouml;f influenced work on the design of programming languages and on the verification of programs.
By opening out the expressiveness of type systems by the introduction of "dependent types" they made it possible for types to be used as specifications for programs.
Through the <I>Propositions as Types</I> metaphor it became possible to extract correct functional programs from proofs (of the propositions corresponding to their specifications).
</FONT>
</TD></TR>
<TR VALIGN=TOP><TD>
<CENTER><B>Type Systems</B></CENTER>
<FONT SIZE=2>
It has now almost taken for granted that a programming language (whether functional or imperative) should have a type system, and devising the type system is an important early part of the design of the language.
There is a rich literature on type systems which can be drawn on by language designers.
</FONT>
</TD></TR>
</TABLE>

</TD></TR></TABLE>


<P>
<CENTER>
<HR WIDTH=70%>
<A TARGET="_top" HREF="index.htm"><IMG SRC="../../../rbjgifs/up.gif" ALT="UP" BORDER=0></A>
<A TARGET="_top" HREF="../../index.htm"><IMG SRC="../../../rbjgifs/home.gif" ALT="HOME" BORDER=0></A>
&copy;
<A HREF="../../rbj.htm" TARGET="_top"><IMG SRC="../../../rbjgifs/rbjin1.gif" ALT=RBJ ALIGN=ABSMIDDLE BORDER=0></A>
created 1998/7/28 modified 1999/9/30
</CENTER></BODY></HTML>