<?xml version="1.0"?>
<!DOCTYPE ProofPower SYSTEM "pp-symbol.ent">
<xldoc xmlns="http://www.x-logic.org/xmlns/draft/xld"
       xmlns:xhtml="http://www.w3.org/TR/xhtml1/strict"
       id="$Id: gst-functions.xml,v 1.3 2012/08/11 21:01:52 rbj Exp $"
       name="gst-functions"
       title="The theory of functions in GST"
       description="Definitions and theorems concerning functions in GST."
       keywords="x-logic xml logic proofpower gst hol set theory functions"
       class="con"
       root="../../../"
       path="rbjpub/pp/gst/"
       up="../index.html"
       rbjhome="../../rbj.htm"
       maintitle="mnt">

<section title="Overview">
<abstract>
This document introduces definitions and derives results relating to the representation of functions in galactic set theory.
</abstract>
<secbody>
<sbcol>
<secref title="Introduction"/>
<secref title="Ordered Pairs"/>
<secref title="Relations"/>
<secref title="Domain, Range and Field"/>
</sbcol>
<sbcol>
<secref title="Functions"/>
<secref title="Functional Abstraction"/>
<secref title="Application and Extensionality"/>
<secref title="Proof Contexts"/>
<subsec title="Listing of Theory gst-fun" href="gst-fun.html" />
</sbcol>
</secbody>
</section>

<ft lang="xl-ign" rest="">
set_flag("pp_show_HOL_types", true);
set_flag("pp_show_HOL_types", false);
</ft>

<section title="Introduction">
<abstract>
A new "gst-fun" theory is created as a child of "gst-ax".
The theory will contain the definitions of ordered pairs, relations and functions and related material for general use.
</abstract>
<secbody>
<sbcol>
<subsec title="Motivation">
Most of the specification work which I am likely to do with galactic set theory will make use of functions.
My first application of the functions will be in the theory of pure functors, which is frivolous and unlikely to be widely applied, and so I am creating this theory first so that more generally applicable results which are required for the theory of pure functors will be available separately.
I have no clear idea of what this theory will contain, it will initially contain basic materials about functions, but will be augmented by anything else that turns out to be necessary elsewhere and which can appropriately be placed here.
</subsec>
</sbcol>
<sbcol>
<subsec title="The Theory gst-fun">
The new theory is first created, together with a proof context which we will build up as we develop the theory.
<ft lang="xl-sml" rest="">
open_theory "gst-ax";
force_new_theory "gst-fun";
force_new_pc "gst-fun";
merge_pcs ["xl_cs_&exist;_conv"] "gst-fun";
set_merge_pcs ["basic_hol", "gst-ax", "gst-fun"];
</ft>
</subsec>
</sbcol>
</secbody>
</section>

<section title="Ordered Pairs">
<abstract>
We now introduce ordered pairs, which are required for representing functions as graphs.
</abstract>
<secbody>
<sbcol>
<subsec title="Ordered Pairs">
<ft lang="xl-sml" rest="">
declare_infix (240,"&mapsto;<sub>g</sub>");
</ft>
<hide>
<ft lang="xl-sml" rest="">
set_goal([],&qqtel;&exist; $&mapsto;<sub>g</sub>:GS &rarr; GS &rarr; GS&bull;
	&forall;s t u v:GS&bull;
	(s &mapsto;<sub>g</sub> t = u &mapsto;<sub>g</sub> v
	&hArr; s = u &and; t = v)
	&and; Pair<sub>g</sub> s t &isin;<sub>g</sub> Gx (s &mapsto;<sub>g</sub> t)
&qqter;);
a (&exist;_tac &qqtel;&lambda;s t:GS&bull; Pair<sub>g</sub> (Unit s) (Pair<sub>g</sub> s t)&qqter;);
a (rewrite_tac[] THEN REPEAT strip_tac
	THEN_TRY all_var_elim_asm_tac
	THEN REPEAT strip_tac);
a (lemma_tac &qqtel;galaxy (Gx (Pair<sub>g</sub> s t))&qqter;
	THEN1 rewrite_tac [galaxy_Gx]);
a (lemma_tac &qqtel;Pair<sub>g</sub> s t &isin;<sub>g</sub> Gx (Pair<sub>g</sub> s t)&qqter;
	THEN1 rewrite_tac [t_in_Gx_t_thm]);
a (strip_asm_tac (&forall;_elim &qqtel;Gx (Pair<sub>g</sub> s t)&qqter; GClosePair<sub>g</sub>));
a (lemma_tac &qqtel;(Unit s) &isin;<sub>g</sub> Gx (Pair<sub>g</sub> s t)&qqter;);
(* *** Goal "1" *** *)
a (lemma_tac &qqtel;s &isin;<sub>g</sub> Gx (Pair<sub>g</sub> s t)&qqter;);
(* *** Goal "1.1" *** *)
a (fc_tac [GalaxiesTransitive_thm]);
a (fc_tac [get_spec &qqtel;transitive&qqter;]);
a (LEMMA_T &qqtel;Pair<sub>g</sub> s t &sube;<sub>g</sub> Gx (Pair<sub>g</sub> s t)&qqter; ante_tac
	THEN1 asm_fc_tac[]
	THEN once_rewrite_tac [gst_relext_clauses]
	THEN strip_tac);
a (spec_nth_asm_tac 1 &qqtel;s&qqter;);
a (POP_ASM_T ante_tac THEN rewrite_tac [get_spec &qqtel;Pair<sub>g</sub>&qqter;]);
(* *** Goal "1.2" *** *)
a (strip_asm_tac (&forall;_elim &qqtel;Gx (Pair<sub>g</sub> s t)&qqter; GCloseUnit)
	THEN asm_fc_tac[]);
(* *** Goal "2" *** *)
a (LEMMA_T &qqtel;(Pair<sub>g</sub> s t) &isin;<sub>g</sub> (Pair<sub>g</sub> (Unit s) (Pair<sub>g</sub> s t))&qqter;asm_tac 
	THEN1 (once_rewrite_tac [get_spec &qqtel;Pair<sub>g</sub>&qqter;]
		THEN REPEAT strip_tac));
a (LEMMA_T &qqtel;Gx (Pair<sub>g</sub> s t) &sube;<sub>g</sub> Gx (Pair<sub>g</sub> (Unit s) (Pair<sub>g</sub> s t))&qqter; ante_tac
	THEN1 (all_fc_tac [Gx_mono_thm2]));
a (once_rewrite_tac [get_spec &qqtel;$&sube;<sub>g</sub>&qqter;]
	THEN STRIP_T (fn x =&gt; all_fc_tac [x]));
xl_set_cs_&exist;_thm(pop_thm ());
</ft>
</hide>
This is more abstract than the usual definition since it conceals the way in which ordered pairs are encoded.
We can't hide everything about the representation, because we will need to know at least that galaxies are closed under formation of ordered pairs, usually a much tighter constraint is known but I will say nothing stronger until I know why it is needed.
Behind the scenes the usual definition is used to prove that this looser definition is a conservative extension.
<holconst><holsig>
 $&mapsto;<sub>g</sub> : GS &rarr; GS &rarr; GS
</holsig>
<holpred>
	&forall;s t u v:GS&bull;
	(s &mapsto;<sub>g</sub> t = u &mapsto;<sub>g</sub> v
	&hArr; s = u &and; t = v)
	&and; Pair<sub>g</sub> s t &isin;<sub>g</sub> Gx (s &mapsto;<sub>g</sub> t)
</holpred>
</holconst>
<ft lang="xl-sml" rest="">
add_pc_thms "gst-fun" [get_spec &qqtel;$&mapsto;<sub>g</sub>&qqter;];
set_merge_pcs ["basic_hol", "gst-ax", "gst-fun"];
</ft>
</subsec>
<subsec title="Projections">
The following functions may be used for extracting the components of ordered pairs.
<hide>
<ft lang="xl-sml" rest="">
set_goal([], &qqtel;&exist; fst snd&bull;
&forall;s t&bull;
	fst(s &mapsto;<sub>g</sub> t) = s
	&and; snd(s &mapsto;<sub>g</sub> t) = t&qqter;);
a (&exist;_tac &qqtel;&lambda;p&bull;&epsilon;x&bull;&exist;y&bull;p=x &mapsto;<sub>g</sub> y&qqter;);
a (&exist;_tac &qqtel;&lambda;p&bull;&epsilon;y&bull;&exist;x&bull;p=x &mapsto;<sub>g</sub> y&qqter;);
a (rewrite_tac[] THEN REPEAT &forall;_tac);
a (all_&epsilon;_tac);
(* *** Goal "1" *** *)
a (&exist;_tac &qqtel;t&qqter; THEN &exist;_tac &qqtel;s&qqter;
 THEN prove_tac[]);
(* *** Goal "2" *** *)
a (&exist;_tac &qqtel;s&qqter; THEN &exist;_tac &qqtel;t&qqter;
 THEN prove_tac[]);
(* *** Goal "3" *** *)
a (&exist;_tac &qqtel;t&qqter; THEN &exist;_tac &qqtel;s&qqter;
 THEN prove_tac[]);
(* *** Goal "4" *** *)
a (eq_sym_nth_asm_tac 1);
a (eq_sym_nth_asm_tac 4);
a (asm_rewrite_tac[]);
xl_set_cs_&exist;_thm (pop_thm ());
</ft>
</hide>
<holconst><holsig>
 fst snd : GS &rarr; GS
</holsig>
<holpred>
&forall;s t&bull;
	fst(s &mapsto;<sub>g</sub> t) = s
	&and; snd(s &mapsto;<sub>g</sub> t) = t
</holpred>
</holconst>
<hide>
<ft lang="xl-sml" rest="">
add_pc_thms "gst-fun" [get_spec &qqtel;fst&qqter;];
set_merge_pcs ["basic_hol", "gst-ax", "gst-fun"];
</ft>
</hide>
</subsec>
</sbcol>
</secbody>
</section>


<section title="Relations">
<abstract>
A relation is defined as a set of ordered pairs.
Cartesian product and relation space are defined.
</abstract>
<secbody>
<sbcol>
<subsec title="Cartesian Product">
The following theorem is required to introduce the conservative specification of cartesian product.
The witness for the proof is shown, involving a double application of replacement.
This is necessary because the loose specification of ordered pair does not provide sufficient information for a more conventional definition using separation.
<ft lang="xl-sml" rest="">
declare_infix(240,"&cross;<sub>g</sub>");
set_goal([],&qqtel;&exist; $&cross;<sub>g</sub>&bull; 
&forall;s t e&bull; e &isin;<sub>g</sub> s &cross;<sub>g</sub> t &hArr;
	&exist;l r&bull;l &isin;<sub>g</sub> s &and; r &isin;<sub>g</sub> t
	&and; e = l &mapsto;<sub>g</sub> r
&qqter;);
a (&exist;_tac &qqtel;
&lambda;s t&bull; &lcup;<sub>g</sub> (
	Imagep
	(&lambda;se&bull; (Imagep (&lambda;te&bull; se &mapsto;<sub>g</sub> te) t))
	s)
&qqter;);
</ft>
<hide>
<ft lang="xl-sml" rest="">
a (prove_tac[]);
(* *** Goal "1" *** *)
a (&exist;_tac &qqtel;e''&qqter;
	THEN &exist;_tac &qqtel;snd(e)&qqter;
	THEN asm_rewrite_tac[]);
a (DROP_NTH_ASM_T 1 
	(fn x=&gt; fc_tac [
	(once_rewrite_rule
		[gst_relext_clauses] x)]));
a (asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a (&exist;_tac &qqtel;Imagep (&lambda; te&bull; l &mapsto;<sub>g</sub> te) t&qqter;);
a (prove_tac[]);
(* *** Goal "2.1" *** *)
a (&exist;_tac &qqtel;r&qqter;
 THEN prove_tac[]);
(* *** Goal "2.2" *** *)
a (&exist;_tac &qqtel;l&qqter;
 THEN prove_tac[]);
xl_set_cs_&exist;_thm (pop_thm ());
</ft>
</hide>
</subsec>
</sbcol>
<sbcol>
<subsec>
After completing this proof cartesian product can be specified by conservative extension as follows:
<holconst><holsig>
 $&cross;<sub>g</sub> : GS &rarr; GS &rarr; GS
</holsig>
<holpred>
&forall;s t e&bull; e &isin;<sub>g</sub> s &cross;<sub>g</sub> t &hArr;
	&exist;l r&bull;l &isin;<sub>g</sub> s &and; r &isin;<sub>g</sub> t
	&and; e = l &mapsto;<sub>g</sub> r
</holpred>
</holconst>
<hide>
<ft lang="xl-sml" rest="">
val &cross;<sub>g</sub>_spec = get_spec &qqtel;$&cross;<sub>g</sub>&qqter;;
</ft>
</hide>
</subsec>
</sbcol>
</secbody>

<secbody>
<sbcol>
<subsec title="Pair-Projection inverse theorem">
<ft lang="xl-sml" rest="">
set_goal ([],&qqtel;&forall;s t p&bull; p &isin;<sub>g</sub> s &cross;<sub>g</sub> t
	&rArr; fst(p) &mapsto;<sub>g</sub> snd(p) = p&qqter;);
a (prove_tac[&cross;<sub>g</sub>_spec]);
a (asm_rewrite_tac[]);
val f&mapsto;<sub>g</sub>s_thm = save_pop_thm "f&mapsto;<sub>g</sub>s_thm";
</ft>
</subsec>
<subsec title="Var in Product theorem">
<ft lang="xl-sml" rest="">
set_goal([],&qqtel;&forall;p s t&bull;
	p &isin;<sub>g</sub> (s &cross;<sub>g</sub> t)
	&rArr; fst p &isin;<sub>g</sub> s &and; snd p &isin;<sub>g</sub> t&qqter;);
a (prove_tac[get_spec&qqtel;$&cross;<sub>g</sub>&qqter;]
      THEN_TRY asm_rewrite_tac[]);
val v&isin;<sub>g</sub>&cross;<sub>g</sub>_thm = 
	save_pop_thm "v&isin;<sub>g</sub>&cross;<sub>g</sub>_thm";
add_pc_thms "gst-fun" [v&isin;<sub>g</sub>&cross;<sub>g</sub>_thm];
set_merge_pcs ["basic_hol", "gst-ax", "gst-fun"];
</ft>
</subsec>
</sbcol>
<sbcol>
<subsec title="Pair in Product theorem">
<ft lang="xl-sml" rest="">
set_goal([],&qqtel;&forall;l r s t&bull;
	(l &mapsto;<sub>g</sub> r) &isin;<sub>g</sub> (s &cross;<sub>g</sub> t)
	&hArr; l &isin;<sub>g</sub> s &and; r &isin;<sub>g</sub> t&qqter;);
a (prove_tac[get_spec&qqtel;$&cross;<sub>g</sub>&qqter;]);
a (&exist;_tac &qqtel;l&qqter;
	THEN &exist;_tac &qqtel;r&qqter;
	THEN asm_prove_tac[]);
val &mapsto;<sub>g</sub>&isin;<sub>g</sub>&cross;<sub>g</sub>_thm = save_pop_thm "&mapsto;<sub>g</sub>&isin;<sub>g</sub>&cross;<sub>g</sub>_thm";
add_pc_thms "gst-fun" [&mapsto;<sub>g</sub>&isin;<sub>g</sub>&cross;<sub>g</sub>_thm];
set_merge_pcs ["basic_hol", "gst-ax", "gst-fun"];
</ft>
</subsec>
</sbcol>
</secbody>

<secbody>
<sbcol>

<subsec title="Relation Space">
This is the set of all relations over some domain and codomain, i.e. the power set of the cartesian product.
<ft lang="xl-sml" rest="">
declare_infix(240,"&harr;<sub>g</sub>");
</ft>
<holconst><holsig>
 $&harr;<sub>g</sub> : GS &rarr; GS &rarr; GS
</holsig>
<holpred>
&forall;s t&bull; s &harr;<sub>g</sub> t = &weierp;<sub>g</sub>(s &cross;<sub>g</sub> t)
</holpred>
</holconst>
</subsec>
<subsec title="Relation Subset Product Theorem">
We prove here that relations are subsets of cartesian products.
<ft lang="xl-sml" rest="">
set_goal ([], &qqtel;&forall;s t r&bull; r &isin;<sub>g</sub> s &harr;<sub>g</sub> t &hArr; r &sube;<sub>g</sub> (s &cross;<sub>g</sub> t)&qqter;);
a (prove_tac[get_spec&qqtel;$&harr;<sub>g</sub>&qqter;,
	gst_relext_clauses]);
val &harr;<sub>g</sub>&sube;<sub>g</sub>&cross;<sub>g</sub>_thm = save_pop_thm "&harr;<sub>g</sub>&sube;<sub>g</sub>&cross;<sub>g</sub>_thm";
</ft>
</subsec>
</sbcol>
<sbcol>
<subsec title="Relation Space Non-Empty">
We prove here that the empty set is a member of every relation space.
<ft lang="xl-sml" rest="">
set_goal ([], &qqtel;&forall;s t&bull; &empty;<sub>g</sub> &isin;<sub>g</sub> s &harr;<sub>g</sub> t&qqter;);
a (prove_tac[get_spec&qqtel;$&harr;<sub>g</sub>&qqter;,
	gst_relext_clauses]);
val &empty;<sub>g</sub>&isin;<sub>g</sub>&harr;<sub>g</sub>_thm = save_pop_thm "&empty;<sub>g</sub>&isin;<sub>g</sub>&harr;<sub>g</sub>_thm";
add_pc_thms "gst-fun" [&empty;<sub>g</sub>&isin;<sub>g</sub>&harr;<sub>g</sub>_thm];
set_merge_pcs ["basic_hol", "gst-ax", "gst-fun"];
</ft>
</subsec>
</sbcol>
</secbody>

<secbody>
<sbcol>
<subsec title="Another Pair-Projection Inverse Theorem">
Couched in terms of membership of relation spaces.
<ft lang="xl-sml" rest="">
set_goal ([], &qqtel;&forall;p r s t&bull;
	p &isin;<sub>g</sub> r &and;
	r &isin;<sub>g</sub> s &harr;<sub>g</sub> t &rArr;
	fst(p) &mapsto;<sub>g</sub> snd(p) = p&qqter;); 
a (prove_tac[
	get_spec &qqtel;$&harr;<sub>g</sub>&qqter;,
	&sube;<sub>g</sub>_thm]); 
a (REPEAT
	(asm_fc_tac[f&mapsto;<sub>g</sub>s_thm])); 
val f&mapsto;<sub>g</sub>s_thm1 =
	save_pop_thm "f&mapsto;<sub>g</sub>s_thm1"; 
</ft>
</subsec>
</sbcol>
<sbcol>
<subsec title="Member of Relation Theorem">
<ft lang="xl-sml" rest="">
set_goal ([],&qqtel;&forall;p r s t&bull;
	p &isin;<sub>g</sub> r &and;
	r &isin;<sub>g</sub> s &harr;<sub>g</sub> t &rArr;
	fst(p) &isin;<sub>g</sub> s &and;
	snd(p) &isin;<sub>g</sub> t&qqter;); 
a (prove_tac[
	get_spec &qqtel;$&harr;<sub>g</sub>&qqter;,
	&sube;<sub>g</sub>_thm]); 
a (asm_fc_tac[]); 
a (fc_tac[v&isin;<sub>g</sub>&cross;<sub>g</sub>_thm]); 
a (asm_fc_tac[]); 
a (fc_tac[v&isin;<sub>g</sub>&cross;<sub>g</sub>_thm]); 
val &isin;<sub>g</sub>&harr;<sub>g</sub>_thm =
	save_pop_thm "&isin;<sub>g</sub>&harr;<sub>g</sub>_thm";
</ft>
</subsec>
</sbcol>
</secbody>

<secbody>
<sbcol>
<subsec title="Relations">
<holconst><holsig>
 rel : GS &rarr; BOOL
</holsig>
<holpred>
&forall;x&bull; rel x &hArr;
	&forall;y&bull; y &isin;<sub>g</sub> x &rArr; &exist;s t&bull; y = s &mapsto;<sub>g</sub> t
</holpred>
</holconst>
<hide>
<ft lang="xl-sml" rest="">
val rel_def = get_spec &qqtel;rel&qqter;;
</ft>
</hide>
</subsec>
</sbcol>
<sbcol>	
<subsec title="Empty Set a Relation">
<ft lang="xl-sml" rest="">
val rel_&empty;<sub>g</sub>_thm = prove_thm (
	"rel_&empty;<sub>g</sub>_thm",
	&qqtel;rel &empty;<sub>g</sub>&qqter;,
	prove_tac[get_spec&qqtel;rel&qqter;]);
</ft>
</subsec>
</sbcol>
</secbody>

<secbody>
<sbcol>
<subsec title="Relational Composition">
<ft lang="xl-sml" rest="">
declare_infix (250,"o<sub>g</sub>");
</ft>
<holconst><holsig>
 $o<sub>g</sub> : GS &rarr; GS &rarr; GS
</holsig>
<holpred>
&forall;f g&bull; f o<sub>g</sub> g =
	Imagep
	(&lambda;p&bull; (fst(fst p) &mapsto;<sub>g</sub> snd(snd p)))
	(Sep (g &cross;<sub>g</sub> f) &lambda;p&bull; &exist;q r s&bull; p = (q &mapsto;<sub>g</sub> r) &mapsto;<sub>g</sub> (r &mapsto;<sub>g</sub> s))
</holpred>
</holconst>

<ft lang="xl-gft" rest="">
o<sub>g</sub>_thm =
   &turnstil; &forall;f g x&bull; x &isin;<sub>g</sub> f o<sub>g</sub> g &hArr;
	&exist;q r s&bull; q &mapsto;<sub>g</sub> r &isin;<sub>g</sub> g &and; r &mapsto;<sub>g</sub> s &isin;<sub>g</sub> f
		&and; x = q &mapsto;<sub>g</sub> s
o<sub>g</sub>_thm2 =
   &turnstil; &forall; f g x y&bull; x &mapsto;<sub>g</sub> y &isin;<sub>g</sub> f o<sub>g</sub> g
	&hArr; (&exist; z&bull; x &mapsto;<sub>g</sub> z &isin;<sub>g</sub> g &and; z &mapsto;<sub>g</sub> y &isin;<sub>g</sub> f)

o<sub>g</sub>_associative_thm =
   &turnstil; &forall;f g h&bull; (f o<sub>g</sub> g) o<sub>g</sub> h = f o<sub>g</sub> g o<sub>g</sub> h

o<sub>g</sub>_rel_thm =
   &turnstil; &forall; r s&bull; rel r &and; rel s &rArr; rel (r o<sub>g</sub> s)
</ft>
<hide>
<ft lang="xl-sml" rest="">
set_goal([], &qqtel;&forall;f g x&bull; x &isin;<sub>g</sub> f o<sub>g</sub> g &hArr;
	&exist;q r s&bull; q &mapsto;<sub>g</sub> r &isin;<sub>g</sub> g
	&and; r &mapsto;<sub>g</sub> s &isin;<sub>g</sub> f &and; x = q &mapsto;<sub>g</sub> s&qqter;);
a (rewrite_tac (map get_spec [&qqtel;$o<sub>g</sub>&qqter;]));
a (REPEAT strip_tac);
(* *** Goal "1" *** *)
a (MAP_EVERY &exist;_tac [&qqtel;q&qqter;, &qqtel;r&qqter;, &qqtel;s&qqter;]);
a (DROP_NTH_ASM_T 3 ante_tac
	THEN asm_rewrite_tac []);
(* *** Goal "2" *** *)
a (&exist;_tac &qqtel;(q &mapsto;<sub>g</sub> r) &mapsto;<sub>g</sub> r &mapsto;<sub>g</sub> s&qqter;
	THEN asm_rewrite_tac[]);
a (prove_&exist;_tac);
val o<sub>g</sub>_thm = save_pop_thm "o<sub>g</sub>_thm";
</ft>
<ft lang="xl-sml" rest="">
set_goal([], &qqtel;&forall;f g x y&bull; x &mapsto;<sub>g</sub> y &isin;<sub>g</sub> f o<sub>g</sub> g &hArr;
	&exist;z&bull; x &mapsto;<sub>g</sub> z &isin;<sub>g</sub> g
	&and; z &mapsto;<sub>g</sub> y &isin;<sub>g</sub> f&qqter;);
a (REPEAT_N 4 strip_tac
	THEN rewrite_tac [o<sub>g</sub>_thm]
	THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a (&exist;_tac &qqtel;r&qqter; THEN asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a (MAP_EVERY &exist;_tac [&qqtel;x&qqter;, &qqtel;z&qqter;, &qqtel;y&qqter;]
	THEN asm_rewrite_tac[]);
val o<sub>g</sub>_thm2 = save_pop_thm "o<sub>g</sub>_thm2";

set_goal ([], &qqtel;&forall;r s&bull; rel r &and; rel s &rArr;  rel (r o<sub>g</sub> s)&qqter;);
a (rewrite_tac [get_spec &qqtel;rel&qqter;, o<sub>g</sub>_thm] THEN REPEAT strip_tac);
a (&exist;_tac &qqtel;q&qqter; THEN &exist;_tac &qqtel;s'&qqter; THEN strip_tac);
val o<sub>g</sub>_rel_thm = save_pop_thm "o<sub>g</sub>_rel_thm";

set_goal([], &qqtel;&forall;f g h&bull; (f o<sub>g</sub> g) o<sub>g</sub> h = f o<sub>g</sub> (g o<sub>g</sub> h)&qqter;);
a (once_rewrite_tac [gs_ext_axiom]);
a (rewrite_tac [o<sub>g</sub>_thm]);
a (REPEAT step_strip_tac);
(* *** Goal "1" *** *)
a (prove_&exist;_tac THEN all_var_elim_asm_tac);
a (MAP_EVERY &exist;_tac [&qqtel;s'&qqter;, &qqtel;r'&qqter;] THEN asm_rewrite_tac[]);
a (&exist;_tac &qqtel;q&qqter; THEN asm_rewrite_tac[]);
a (&exist;_tac &qqtel;q'&qqter; THEN asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a (prove_&exist;_tac THEN all_var_elim_asm_tac);
a (MAP_EVERY &exist;_tac [&qqtel;s&qqter;, &qqtel;r'&qqter;] THEN asm_rewrite_tac[] THEN strip_tac);
(* *** Goal "2.1" *** *)
a (&exist;_tac &qqtel;q'&qqter; THEN asm_rewrite_tac[]);
(* *** Goal "2.2" *** *)
a (&exist;_tac &qqtel;s'&qqter; THEN asm_rewrite_tac[]);
val o<sub>g</sub>_associative_thm = save_pop_thm "o<sub>g</sub>_associative_thm"; 

add_pc_thms "gst-fun" [o<sub>g</sub>_thm2];
set_merge_pcs ["basic_hol", "gst-ax", "gst-fun"];
</ft>
</hide>
</subsec>
</sbcol>
</secbody>
</section>

<section title="Domain, Range and Field" tag="DomRanField">
<abstract>
The domain, range and field of a relation are defined.
</abstract>
<secbody>
<sbcol>
<subsec title="domain">
The domain is the set of elements which are related to something under the relationship.
<holconst><holsig>
 dom : GS &rarr; GS
</holsig>
<holpred>
&forall;x&bull; dom x = Sep (Gx x) (&lambda;w&bull; &exist;v&bull; w &mapsto;<sub>g</sub> v &isin;<sub>g</sub> x)
</holpred>
</holconst>
<ft lang="xl-gft" rest="">
dom_&empty;<sub>g</sub>_thm =
	&turnstil; dom &empty;<sub>g</sub> = &empty;<sub>g</sub>
dom_thm =
	&turnstil; &forall; r y&bull; y &isin;<sub>g</sub> dom r &hArr; (&exist; x&bull; y &mapsto;<sub>g</sub> x &isin;<sub>g</sub> r)
</ft>
<hide>
<ft lang="xl-sml" rest="">
set_goal([],&qqtel;dom &empty;<sub>g</sub> = &empty;<sub>g</sub>&qqter;);
a (prove_tac[get_spec&qqtel;dom&qqter;,
	gst_relext_clauses]);
val dom_&empty;<sub>g</sub>_thm =
	save_pop_thm "dom_&empty;<sub>g</sub>_thm";

set_goal([], &qqtel;&forall;r y&bull; y &isin;<sub>g</sub> dom r &hArr; &exist; x&bull; y &mapsto;<sub>g</sub> x &isin;<sub>g</sub> r&qqter;);
a (rewrite_tac [get_spec &qqtel;dom&qqter;] THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a (&exist;_tac &qqtel;v&qqter; THEN asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a (LEMMA_T  &qqtel;(Pair<sub>g</sub> y x) &isin;<sub>g</sub> Gx (y &mapsto;<sub>g</sub> x)&qqter; asm_tac
	THEN1 rewrite_tac [get_spec &qqtel;$&mapsto;<sub>g</sub>&qqter;]);
a (lemma_tac &qqtel;Gx (y &mapsto;<sub>g</sub> x) &sube;<sub>g</sub> Gx r&qqter; THEN1 fc_tac [Gx_mono_thm2]);
a (LEMMA_T &qqtel;y &isin;<sub>g</sub> Pair<sub>g</sub> y x&qqter; asm_tac THEN1 rewrite_tac []);
a (lemma_tac &qqtel;y &isin;<sub>g</sub> Gx (y &mapsto;<sub>g</sub> x)&qqter;);
(* *** Goal "2.1" *** *)
a (lemma_tac &qqtel;galaxy (Gx (y &mapsto;<sub>g</sub> x))&qqter; THEN1 rewrite_tac[galaxy_Gx]);
a (fc_tac [GalaxiesTransitive_thm]);
a (fc_tac [get_spec &qqtel;transitive&qqter;]);
a (ASM_FC_T (MAP_EVERY ante_tac) []
	THEN once_rewrite_tac [get_spec &qqtel;$&sube;<sub>g</sub>&qqter;]
	THEN REPEAT strip_tac);
a (spec_nth_asm_tac 1 &qqtel;y&qqter;);
(* *** Goal "2.2" *** *)
a (DROP_NTH_ASM_T 3 (asm_tac o (once_rewrite_rule [get_spec&qqtel;$&sube;<sub>g</sub>&qqter;])));
a (spec_nth_asm_tac 1 &qqtel;y&qqter;);
(* *** Goal "3" *** *)
a (&exist;_tac &qqtel;x&qqter; THEN strip_tac);
val dom_thm = save_pop_thm "dom_thm";
</ft>
</hide>
</subsec>
</sbcol>
<sbcol>
<subsec title="range">
<holconst><holsig>
 ran : GS &rarr; GS
</holsig>
<holpred>
&forall;x&bull; ran x = Sep (Gx x) (&lambda;w&bull; &exist;v&bull; v &mapsto;<sub>g</sub> w &isin;<sub>g</sub> x)
</holpred>
</holconst>
<ft lang="xl-gft" rest="">
ran_&empty;<sub>g</sub>_thm
	&turnstil; ran &empty;<sub>g</sub> = &empty;<sub>g</sub>
ran_thm =
	&turnstil; &forall;r y&bull; y &isin;<sub>g</sub> ran r &hArr; &exist; x&bull; x &mapsto;<sub>g</sub> y &isin;<sub>g</sub> r
</ft>
<hide>
<ft lang="xl-sml" rest="">
set_goal([],&qqtel;ran &empty;<sub>g</sub> = &empty;<sub>g</sub>&qqter;);
a (prove_tac[get_spec &qqtel;ran&qqter;, gst_relext_clauses]);
val ran_&empty;<sub>g</sub>_thm =	save_pop_thm "ran_&empty;<sub>g</sub>_thm";

set_goal([], &qqtel;&forall;r y&bull; y &isin;<sub>g</sub> ran r &hArr; &exist; x&bull; x &mapsto;<sub>g</sub> y &isin;<sub>g</sub> r&qqter;);
a (rewrite_tac [get_spec &qqtel;ran&qqter;] THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a (&exist;_tac &qqtel;v&qqter; THEN asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a (LEMMA_T  &qqtel;(Pair<sub>g</sub> x y) &isin;<sub>g</sub> Gx (x &mapsto;<sub>g</sub> y)&qqter; asm_tac
	THEN1 rewrite_tac [get_spec &qqtel;$&mapsto;<sub>g</sub>&qqter;]);
a (lemma_tac &qqtel;Gx (x &mapsto;<sub>g</sub> y) &sube;<sub>g</sub> Gx r&qqter; THEN1 fc_tac [Gx_mono_thm2]);
a (LEMMA_T &qqtel;y &isin;<sub>g</sub> Pair<sub>g</sub> x y&qqter; asm_tac THEN1 rewrite_tac []);
a (lemma_tac &qqtel;y &isin;<sub>g</sub> Gx (x &mapsto;<sub>g</sub> y)&qqter;);
(* *** Goal "2.1" *** *)
a (lemma_tac &qqtel;galaxy (Gx (x &mapsto;<sub>g</sub> y))&qqter; THEN1 rewrite_tac[galaxy_Gx]);
a (fc_tac [GalaxiesTransitive_thm]);
a (fc_tac [get_spec &qqtel;transitive&qqter;]);
a (ASM_FC_T (MAP_EVERY ante_tac) []
	THEN once_rewrite_tac [get_spec &qqtel;$&sube;<sub>g</sub>&qqter;]
	THEN REPEAT strip_tac);
a (spec_nth_asm_tac 1 &qqtel;y&qqter;);
(* *** Goal "2.2" *** *)
a (DROP_NTH_ASM_T 3 (asm_tac o (once_rewrite_rule [get_spec&qqtel;$&sube;<sub>g</sub>&qqter;])));
a (spec_nth_asm_tac 1 &qqtel;y&qqter;);
(* *** Goal "3" *** *)
a (&exist;_tac &qqtel;x&qqter; THEN strip_tac);
val ran_thm = save_pop_thm "ran_thm";
</ft>
</hide>
</subsec>
</sbcol>
</secbody>

<secbody>
<sbcol>
<subsec title="Relation Subset of Cartesian Product">
<ft lang="xl-gft" rest="">
rel_sub_cp_thm = 
	&turnstil; &forall; x&bull; rel x &hArr; (&exist; s t&bull; x &sube;<sub>g</sub> s &cross;<sub>g</sub> t)
</ft>

<hide>
<ft lang="xl-sml" rest="">
set_goal ([], &qqtel;&forall;x&bull; rel x &hArr; &exist;s t&bull; x &sube;<sub>g</sub> s &cross;<sub>g</sub> t&qqter;);
a (once_rewrite_tac [gst_relext_clauses]);
a (rewrite_tac[get_spec&qqtel;rel&qqter;, &cross;<sub>g</sub>_spec]
	THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a (&exist;_tac &qqtel;dom x&qqter; THEN &exist;_tac &qqtel;ran x&qqter; THEN REPEAT strip_tac);
a (asm_fc_tac[]);
a (&exist;_tac &qqtel;s&qqter; THEN &exist;_tac &qqtel;t&qqter;
	THEN asm_rewrite_tac[get_spec &qqtel;dom&qqter;, get_spec &qqtel;ran&qqter;]);
a (lemma_tac &qqtel;Pair<sub>g</sub> s t &isin;<sub>g</sub> Gx e&qqter; THEN1 asm_rewrite_tac [get_spec &qqtel;$&mapsto;<sub>g</sub>&qqter;]);
a (LEMMA_T &qqtel;s &isin;<sub>g</sub> Pair<sub>g</sub> s t&qqter; asm_tac THEN1 rewrite_tac[]);
a (LEMMA_T &qqtel;t &isin;<sub>g</sub> Pair<sub>g</sub> s t&qqter; asm_tac THEN1 rewrite_tac[]);
a (all_fc_tac [Gx_trans_thm3]);
a (LEMMA_T &qqtel;Gx e &sube;<sub>g</sub> Gx x&qqter; (fn x =&gt; fc_tac [rewrite_rule [get_spec &qqtel;$&sube;<sub>g</sub>&qqter;] x])
	THEN1 fc_tac [Gx_mono_thm2]
	THEN REPEAT strip_tac);
(* *** Goal "1.1" *** *)
a (DROP_NTH_ASM_T 10 ante_tac THEN asm_rewrite_tac[] THEN strip_tac);
a (&exist;_tac &qqtel;t&qqter; THEN asm_rewrite_tac[]);
(* *** Goal "1.2" *** *)
a (DROP_NTH_ASM_T 10 ante_tac THEN asm_rewrite_tac[] THEN strip_tac);
a (&exist;_tac &qqtel;s&qqter; THEN asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a (asm_fc_tac[]);
a (&exist;_tac &qqtel;l&qqter; THEN &exist;_tac &qqtel;r&qqter; THEN asm_rewrite_tac[]);
val rel_sub_cp_thm = save_pop_thm "rel_sub_cp_thm";
</ft>
</hide>
</subsec>
</sbcol>
</secbody>

<secbody>
<sbcol>
<subsec title="field">
<hide>
<ft lang="xl-sml" rest="">
set_goal([],&qqtel;&exist;field&bull; &forall;s e&bull;
e &isin;<sub>g</sub> (field s) &hArr; e &isin;<sub>g</sub> (dom s) &or; e &isin;<sub>g</sub> (ran s)&qqter;);
a (&exist;_tac &qqtel;&lambda;x&bull; (dom x) &cup;<sub>g</sub> (ran x)&qqter;);
a (prove_tac[]);
xl_set_cs_&exist;_thm (pop_thm ());
</ft>
</hide>
<holconst><holsig>
 field : GS &rarr; GS
</holsig>
<holpred>
&forall;s e&bull; e &isin;<sub>g</sub> (field s)
&hArr; e &isin;<sub>g</sub> (dom s) &or; e &isin;<sub>g</sub> (ran s)
</holpred>
</holconst>
<hide>
<ft lang="xl-sml" rest="">
add_pc_thms "gst-fun" ([
	get_spec &qqtel;field&qqter;,
	rel_&empty;<sub>g</sub>_thm,
	dom_&empty;<sub>g</sub>_thm,
	ran_&empty;<sub>g</sub>_thm]);
set_merge_pcs ["basic_hol", "gst-ax", "gst-fun"];
</ft>
</hide>
</subsec>
</sbcol>
<sbcol>
<subsec title="The field of the empty set">
<ft lang="xl-gft" rest="">
field_&empty;<sub>g</sub>_thm = &turnstil; field &empty;<sub>g</sub> = &empty;<sub>g</sub>
</ft>
<hide>
<ft lang="xl-sml" rest="">
set_goal([],&qqtel;field &empty;<sub>g</sub> = &empty;<sub>g</sub>&qqter;);
a (prove_tac[gst_relext_clauses]);
val field_&empty;<sub>g</sub>_thm =
	save_pop_thm "field_&empty;<sub>g</sub>_thm";
add_pc_thms "gst-fun" ([field_&empty;<sub>g</sub>_thm]);
set_merge_pcs ["basic_hol", "gst-ax", "gst-fun"];
</ft>
</hide>
</subsec>
</sbcol>
</secbody>
</section>

<section title="Functions">
<abstract>
Definition of partial and total functions and the corresponding function spaces.
</abstract>
<secbody>
<sbcol>
<subsec title="fun">
<holconst><holsig>
 fun : GS &rarr; BOOL
</holsig>
<holpred>
&forall;x&bull; fun x &hArr; rel x &and;
	&forall;s t u&bull; s &mapsto;<sub>g</sub> u &isin;<sub>g</sub> x
		&and; s &mapsto;<sub>g</sub> t &isin;<sub>g</sub> x
		&rArr; u = t
</holpred>
</holconst>
<hide>
<ft lang="xl-sml" rest="">
val fun_def = get_spec &qqtel;fun&qqter;;
</ft>
</hide>
</subsec>
</sbcol>
<sbcol>
<subsec title="lemmas">
<ft lang="xl-gft" rest="">
fun_&empty;<sub>g</sub>_thm =
	&turnstil; fun &empty;<sub>g</sub>
o<sub>g</sub>_fun_thm =
	&turnstil; &forall; f g&bull; fun f &and; fun g &rArr; fun (f o<sub>g</sub> g)
ran_o<sub>g</sub>_thm =
	&turnstil; &forall; f g&bull; ran (f o<sub>g</sub> g) &sube;<sub>g</sub> ran f
dom_o<sub>g</sub>_thm =
	&turnstil; &forall; f g&bull; dom (f o<sub>g</sub> g) &sube;<sub>g</sub> dom g
dom_o<sub>g</sub>_thm2 =
	&turnstil; &forall; f g&bull; ran g &sube;<sub>g</sub> dom f &rArr; dom (f o<sub>g</sub> g) = dom g
</ft>
<hide>
<ft lang="xl-sml" rest="">
val fun_&empty;<sub>g</sub>_thm = prove_thm (
	"fun_&empty;<sub>g</sub>_thm", &qqtel;fun &empty;<sub>g</sub>&qqter;,
	prove_tac[
	 get_spec &qqtel;fun&qqter;]);

set_goal([], &qqtel;&forall;f g&bull; fun f &and; fun g &rArr; fun (f o<sub>g</sub> g)&qqter;);
a (rewrite_tac [get_spec &qqtel;fun&qqter;] THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a (all_fc_tac [o<sub>g</sub>_rel_thm]);
(* *** Goal "2" *** *)
a (lemma_tac &qqtel;z = z'&qqter; THEN1 all_asm_fc_tac[]);
a (all_var_elim_asm_tac THEN all_asm_fc_tac[]);
val o<sub>g</sub>_fun_thm = save_pop_thm "o<sub>g</sub>_fun_thm";

set_goal ([], &qqtel;&forall;f g&bull; ran (f o<sub>g</sub> g) &sube;<sub>g</sub> ran f&qqter;);
a (once_rewrite_tac [gst_relext_clauses]);
a (rewrite_tac [ran_thm] THEN REPEAT strip_tac);
a (&exist;_tac &qqtel;z&qqter; THEN strip_tac);
val ran_o<sub>g</sub>_thm = save_pop_thm "ran_o<sub>g</sub>_thm";

set_goal ([], &qqtel;&forall;f g&bull; dom (f o<sub>g</sub> g) &sube;<sub>g</sub> dom g&qqter;);
a (once_rewrite_tac [gst_relext_clauses]);
a (rewrite_tac [dom_thm] THEN REPEAT strip_tac);
a (&exist;_tac &qqtel;z&qqter; THEN strip_tac);
val dom_o<sub>g</sub>_thm = save_pop_thm "dom_o<sub>g</sub>_thm";

set_goal([], &qqtel;&forall; f g&bull; ran g &sube;<sub>g</sub> dom f &rArr; dom (f o<sub>g</sub> g) = dom g&qqter;);
a (once_rewrite_tac [gst_relext_clauses]
	THEN rewrite_tac [ran_thm, dom_thm]
	THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a (&exist;_tac &qqtel;z&qqter; THEN asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a (spec_nth_asm_tac 2 &qqtel;x&qqter;);
(* *** Goal "2.1" *** *)
a (spec_nth_asm_tac 1 &qqtel;e&qqter;);
(* *** Goal "2.2" *** *)
a (&exist;_tac &qqtel;x'&qqter; THEN &exist;_tac &qqtel;x&qqter; THEN asm_rewrite_tac[]);
val dom_o<sub>g</sub>_thm2 = save_pop_thm "dom_o<sub>g</sub>_thm2";
</ft>
</hide>
</subsec>
</sbcol>
</secbody>

<secbody>
<sbcol>
<subsec title="Partial Function Space">
This is the set of all partial functions (i.e. many one mapings) over some domain and codomain.
<ft lang="xl-sml" rest="">
declare_infix (240, "&nrarr;<sub>g</sub>");
</ft>
<holconst><holsig>
 $&nrarr;<sub>g</sub> : GS &rarr; GS &rarr; GS
</holsig>
<holpred>
&forall;s t&bull; s &nrarr;<sub>g</sub> t = Sep (s &harr;<sub>g</sub> t) fun
</holpred>
</holconst>
</subsec>
</sbcol>
<sbcol>
<subsec title="Partial Function Space Non-Empty">
First the theorem that the empty set is a partial function over any domain and codomain.
<ft lang="xl-sml" rest="">
set_goal([],
	&qqtel;&forall;s t&bull; &empty;<sub>g</sub> &isin;<sub>g</sub> s &nrarr;<sub>g</sub> t&qqter;);
a (prove_tac[
	get_spec &qqtel;$&nrarr;<sub>g</sub>&qqter;,
	fun_&empty;<sub>g</sub>_thm]);
val &empty;<sub>g</sub>&isin;<sub>g</sub>&nrarr;<sub>g</sub>_thm =
	save_pop_thm "&empty;<sub>g</sub>&isin;<sub>g</sub>&nrarr;<sub>g</sub>_thm";
</ft>
And then that every partial function space is non-empty.
<ft lang="xl-sml" rest="">
set_goal([],
	&qqtel;&forall;s t&bull; &exist; f&bull; f &isin;<sub>g</sub> s &nrarr;<sub>g</sub> t&qqter;);
a (REPEAT strip_tac
	THEN &exist;_tac &qqtel;&empty;<sub>g</sub>&qqter;
	THEN
	rewrite_tac [&empty;<sub>g</sub>&isin;<sub>g</sub>&nrarr;<sub>g</sub>_thm]);
val &exist;&nrarr;<sub>g</sub>_thm =
	save_pop_thm "&exist;&nrarr;<sub>g</sub>_thm";
</ft>
</subsec>
</sbcol>
</secbody>

<secbody>
<sbcol>
<subsec title="Function Space">
This is the set of all total functions over some domain and codomain.
<ft lang="xl-sml" rest="">
declare_infix (240, "&rarr;<sub>g</sub>");
</ft>
<holconst><holsig>
 $&rarr;<sub>g</sub> : GS &rarr; GS &rarr; GS
</holsig>
<holpred>
&forall;s t&bull; s &rarr;<sub>g</sub> t = Sep (s &nrarr;<sub>g</sub> t)
	&lambda;r&bull; dom r = s
</holpred>
</holconst>
</subsec>
<subsec title="Function Space Non-Empty">
First, for the special case of function spaces with empty domain we prove the theorem that the empty set is a member:
<ft lang="xl-sml" rest="">
set_goal([],&qqtel;&forall;s t&bull; &empty;<sub>g</sub> &isin;<sub>g</sub> &empty;<sub>g</sub> &rarr;<sub>g</sub> t&qqter;);
a (prove_tac[get_spec &qqtel;$&rarr;<sub>g</sub>&qqter;,
	fun_&empty;<sub>g</sub>_thm,
	&empty;<sub>g</sub>&isin;<sub>g</sub>&nrarr;<sub>g</sub>_thm]);
val &empty;<sub>g</sub>&isin;<sub>g</sub>&empty;<sub>g</sub>&rarr;<sub>g</sub>_thm =
	save_pop_thm "&empty;<sub>g</sub>&isin;<sub>g</sub>&empty;<sub>g</sub>&rarr;<sub>g</sub>_thm";
</ft>
</subsec>
</sbcol>
<sbcol>
<subsec>
Then that whenever the codomain is non-empty the function space is non-empty.
<ft lang="xl-gft" rest="">
&exist;&rarr;<sub>g</sub>_thm =
   &turnstil; &forall; s t&bull; (&exist; x&bull; x &isin;<sub>g</sub> t) &rArr; (&exist; f&bull; f &isin;<sub>g</sub> s &rarr;<sub>g</sub> t)
</ft>
<hide>
<ft lang="xl-sml" rest="">
set_goal([],
	&qqtel;&forall;s t&bull; (&exist;x&bull; x &isin;<sub>g</sub> t)
	&rArr; &exist; f&bull; f &isin;<sub>g</sub> s &rarr;<sub>g</sub> t&qqter;);
a (REPEAT strip_tac
	THEN &exist;_tac &qqtel;s &cross;<sub>g</sub> (Unit x)&qqter;);
a (rewrite_tac [get_spec &qqtel;$&rarr;<sub>g</sub>&qqter;,
	get_spec &qqtel;$&nrarr;<sub>g</sub>&qqter;,
	get_spec &qqtel;$&harr;<sub>g</sub>&qqter;]);
a (once_rewrite_tac
	[gst_relext_clauses]);
a (rewrite_tac[
	get_spec &qqtel;dom&qqter;,
	get_spec &qqtel;fun&qqter;,
	get_spec &qqtel;rel&qqter;,
	get_spec &qqtel;$&cross;<sub>g</sub>&qqter;]
	THEN REPEAT strip_tac
	THEN TRY (asm_rewrite_tac[])
	THEN TRY prove_&exist;_tac);
(* *** Goal "1" *** *)
a (&exist;_tac &qqtel;x&qqter; THEN REPEAT strip_tac
	THEN &exist;_tac &qqtel;l&qqter;
	THEN asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a (LEMMA_T &qqtel;e &mapsto;<sub>g</sub> x &isin;<sub>g</sub> s &cross;<sub>g</sub> Unit x&qqter; asm_tac
	THEN1 asm_rewrite_tac [&mapsto;<sub>g</sub>&isin;<sub>g</sub>&cross;<sub>g</sub>_thm]);
a (lemma_tac &qqtel;Gx (e &mapsto;<sub>g</sub> x) &sube;<sub>g</sub> Gx (s &cross;<sub>g</sub> Unit x)&qqter;  THEN1 fc_tac [Gx_mono_thm2]);
a (LEMMA_T &qqtel;Pair<sub>g</sub> e x &isin;<sub>g</sub> Gx(e &mapsto;<sub>g</sub> x)&qqter; asm_tac THEN1 rewrite_tac [get_spec&qqtel;$&mapsto;<sub>g</sub>&qqter;]);
a (LEMMA_T &qqtel;e &isin;<sub>g</sub> Pair<sub>g</sub> e x&qqter; asm_tac THEN1 rewrite_tac[]);
a (lemma_tac &qqtel;e &isin;<sub>g</sub> Gx (e &mapsto;<sub>g</sub> x)&qqter; THEN1 all_fc_tac [Gx_trans_thm3]);
a (DROP_NTH_ASM_T 4 (fn x =&gt; fc_tac [rewrite_rule [get_spec &qqtel;$&sube;<sub>g</sub>&qqter;] x]));
val &exist;&rarr;<sub>g</sub>_thm = save_pop_thm "&exist;&rarr;<sub>g</sub>_thm";
</ft>
</hide>
</subsec>
</sbcol>
</secbody>
</section>

<section title="Functional Abstraction">
<abstract>
Functional abstraction is defined as a new variable binding construct yeilding a functional set.
</abstract>
<secbody>
<sbcol>
<subsec title="Abstraction">
<p>
Because of the closeness to lambda abstraction "&lambda;<sub>g</sub>" is used as the name of a new binder for set theoretic functional abstraction.
<ft lang="xl-sml" rest="">
declare_binder "&lambda;<sub>g</sub>";
</ft>
To define a functional set we need a HOL function over sets together with a set which is to be the domain of the function.
Specification of the range is not needed.
The binding therefore yields a function which maps sets to sets (maps the domain to the function).
</p>
<p>
The following definition is a placeholder, a more abstract definition might eventually be substituted.
The function is defined as that subset of the cartesian product of the set s and its image under the function f which coincides with the graph of f over s.
</p>
<holconst><holsig>
$&lambda;<sub>g</sub>: (GS &rarr; GS) &rarr;
	GS  &rarr; GS
</holsig>
<holpred>
&forall;f s&bull; $&lambda;<sub>g</sub> f s =
	Sep (s &cross;<sub>g</sub> (Imagep f s))
	(&lambda;p&bull; snd p = f (fst p))
</holpred>
</holconst>
</subsec>
</sbcol>
</secbody>
</section>

<section title="Application and Extensionality">
<abstract>
In this section we define function application and show that functions are extensional.
</abstract>
<secbody>
<sbcol>
<subsec title="Application">
Application by juxtaposition cannot be overloaded and is used for application of HOL functions.
Application of functional sets is therefore defined as an infix operator whose name is the empty name subscripted by "g".
<ft lang="xl-sml" rest="">
declare_infix (250,"<sub>g</sub>");
</ft>
<p>
The particular form shown here is innovative in the value specified for applications of functions to values outside their domain.
The merit of the particular value chosen is that it makes true an extensionality theorem which quantifies over all sets as arguments to the function, which might not otherwise be the case.
Whether this form is useful I don't know.
Generally a result with fewer conditionals is harder to prove but easier to use, but in this case I'm not so sure of the benefit.
</p>
It may be noted that it may also be used to apply a non-functional relation, if what you want it some arbitrary value (selected by the choice function) to which some object relates.
<holconst><holsig>
 $<sub>g</sub> : GS &rarr; GS &rarr; GS
</holsig>
<holpred>
&forall;f x&bull; f <sub>g</sub> x =
	if &exist;y&bull; x &mapsto;<sub>g</sub> y &isin;<sub>g</sub> f
	then &epsilon;y&bull; x &mapsto;<sub>g</sub> y &isin;<sub>g</sub> f
	else f
</holpred>
</holconst>
<ft lang="xl-gft" rest="">
app_thm1 = 
	&turnstil; &forall;f x&bull; (&exist;<sub>1</sub>y&bull; x &mapsto;<sub>g</sub> y &isin;<sub>g</sub> f)
	  &rArr; x &mapsto;<sub>g</sub> (f <sub>g</sub> x) &isin;<sub>g</sub> f

app_thm2 = 
	&turnstil; &forall;f x y&bull; fun f &and; (x &mapsto;<sub>g</sub> y &isin;<sub>g</sub> f)
	  &rArr; f <sub>g</sub> x = y

app_thm3 = 
	&turnstil; &forall;f x&bull; fun f &and; x &isin;<sub>g</sub> dom f
	  &rArr; x &mapsto;<sub>g</sub> f <sub>g</sub> x &isin;<sub>g</sub> f

o<sub>g</sub>_<sub>g</sub>_thm = 
	&turnstil; &forall;f g x&bull; fun f &and; fun g &and; x &isin;<sub>g</sub> dom g &and; ran g &sube;<sub>g</sub> dom f
	  &rArr; (f o<sub>g</sub> g) <sub>g</sub> x = f <sub>g</sub> g <sub>g</sub> x
</ft>
<hide>
<ft lang="xl-sml" rest="">

set_goal([],&qqtel;&forall;f x&bull; (&exist;<sub>1</sub>y&bull; x &mapsto;<sub>g</sub> y &isin;<sub>g</sub> f)
	&rArr; x &mapsto;<sub>g</sub> (f <sub>g</sub> x) &isin;<sub>g</sub> f&qqter;);
a (prove_tac[get_spec&qqtel;$<sub>g</sub>&qqter;]);
a (LEMMA_T &qqtel;&exist; y&bull; x &mapsto;<sub>g</sub> y &isin;<sub>g</sub> f&qqter;
	(fn x=&gt; rewrite_tac[x])
	THEN1 (
		&exist;_tac &qqtel;y&qqter;
		THEN prove_tac[]));
a (all_&epsilon;_tac);
a (&exist;_tac &qqtel;y&qqter; THEN prove_tac[]);
val app_thm1 = save_pop_thm "app_thm1";
</ft>
<p>
Note that the result is not conditional on f being a function.
</p>
<p>
The next theorem applies to functions only and obtains the necessary uniqueness of image from that assumption.
</p>
<ft lang="xl-sml" rest="">
set_goal([],&qqtel;
&forall;f x y&bull; fun f &and; (x &mapsto;<sub>g</sub> y &isin;<sub>g</sub> f)
	&rArr; f <sub>g</sub> x = y
&qqter;);
a (prove_tac[get_spec&qqtel;$<sub>g</sub>&qqter;,
	get_spec &qqtel;fun&qqter;]);
a (LEMMA_T
	&qqtel;&exist; y&bull; x &mapsto;<sub>g</sub> y &isin;<sub>g</sub> f&qqter;
	(fn x=&gt; rewrite_tac[x])
	THEN1 (
		&exist;_tac &qqtel;y&qqter;
		THEN prove_tac[]));
a (all_&epsilon;_tac);
a (&exist;_tac &qqtel;y&qqter;
	THEN prove_tac[]);
a (REPEAT (asm_fc_tac[]));
val app_thm2 = save_pop_thm "app_thm2";

set_goal([], &qqtel;&forall;f x&bull; fun f &and; x &isin;<sub>g</sub> dom f &rArr; x &mapsto;<sub>g</sub> f <sub>g</sub> x &isin;<sub>g</sub> f&qqter;);
a (rewrite_tac [get_spec &qqtel;fun&qqter;, get_spec &qqtel;dom&qqter;, get_spec &qqtel;$<sub>g</sub>&qqter;]
	THEN REPEAT strip_tac);
a (LEMMA_T &qqtel;&exist;y&bull; x &mapsto;<sub>g</sub> y &isin;<sub>g</sub> f&qqter; rewrite_thm_tac
	THEN1 (&exist;_tac &qqtel;v&qqter; THEN asm_rewrite_tac[]));
a (&epsilon;_tac &qqtel;&epsilon; y&bull; x &mapsto;<sub>g</sub> y &isin;<sub>g</sub> f&qqter;);
a (&exist;_tac &qqtel;v&qqter; THEN strip_tac);
val app_thm3 = save_pop_thm "app_thm3";

set_goal([], &qqtel;&forall;f g x&bull; fun f &and; fun g &and; x &isin;<sub>g</sub> dom g &and; ran g &sube;<sub>g</sub> dom f
	&rArr; (f o<sub>g</sub> g) <sub>g</sub> x = f <sub>g</sub> g <sub>g</sub> x&qqter;);
a (REPEAT strip_tac);
a (lemma_tac &qqtel;fun (f o<sub>g</sub> g)&qqter; THEN1 all_fc_tac [o<sub>g</sub>_fun_thm]);
a (lemma_tac &qqtel;x &isin;<sub>g</sub> dom (f o<sub>g</sub> g)&qqter;
	THEN1 all_fc_tac [once_rewrite_rule [gst_relext_clauses] dom_o<sub>g</sub>_thm]);
(* *** Goal "1" *** *)
a (all_fc_tac [dom_o<sub>g</sub>_thm2] THEN asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a (PC_T "hol" (strip_asm_tac (list_&forall;_elim [&qqtel;f o<sub>g</sub> g&qqter;, &qqtel;x&qqter;] app_thm3)));
a (GET_NTH_ASM_T 1 strip_asm_tac);
a (LEMMA_T &qqtel;g <sub>g</sub> x = z&qqter; rewrite_thm_tac THEN1 all_fc_tac [app_thm2]); 
a (LEMMA_T &qqtel;f <sub>g</sub> z = (f o<sub>g</sub> g) <sub>g</sub> x&qqter; rewrite_thm_tac THEN1 all_fc_tac [app_thm2]); 
val o<sub>g</sub>_<sub>g</sub>_thm = save_pop_thm "o<sub>g</sub>_<sub>g</sub>_thm"; 
</ft>
</hide>
</subsec>
<subsec title='The "Type" of an Application (1)'>
The following theorem states that the result of applying a partial function to a value in its domain is a value in its codomain.&and;
<ft lang="xl-sml" rest="">
set_goal([],
	&qqtel;&forall;f s t u&bull; f &isin;<sub>g</sub> s &nrarr;<sub>g</sub> t &and;
	u &isin;<sub>g</sub> dom f &rArr;
	f <sub>g</sub> u &isin;<sub>g</sub> t&qqter;); 
a (prove_tac[
	get_spec &qqtel;$&nrarr;<sub>g</sub>&qqter;,
	get_spec &qqtel;dom&qqter;]);
a (all_fc_tac [app_thm2] THEN asm_rewrite_tac[]);
a (all_fc_tac [f&mapsto;<sub>g</sub>s_thm1]);
a (all_fc_tac [&isin;<sub>g</sub>&harr;<sub>g</sub>_thm]); 
a (POP_ASM_T ante_tac THEN asm_rewrite_tac []);
val <sub>g</sub>&isin;<sub>g</sub>_thm = save_pop_thm "<sub>g</sub>&isin;<sub>g</sub>_thm";
</ft>
</subsec>
<subsec title='The "Type" of an Application (2)'>
The following theorem states that the result of applying a total function to a value in its domain is a value in its codomain.
<ft lang="xl-sml" rest="">
set_goal([],
	&qqtel;&forall;f s t u&bull; f &isin;<sub>g</sub> s &rarr;<sub>g</sub> t &and;
	u &isin;<sub>g</sub> s &rArr;
	f <sub>g</sub> u &isin;<sub>g</sub> t&qqter;); 
a (prove_tac[
	get_spec &qqtel;$&rarr;<sub>g</sub>&qqter;]);
a (bc_thm_tac <sub>g</sub>&isin;<sub>g</sub>_thm);
a (&exist;_tac &qqtel;s&qqter;
	THEN asm_rewrite_tac[]); 
val <sub>g</sub>&isin;<sub>g</sub>_thm1 = save_pop_thm "<sub>g</sub>&isin;<sub>g</sub>_thm1";
</ft>
</subsec>
<subsec title='Partial functions are total'>
Every partial function is total over its domain.
(there is an ambiguity in the use of the term "domain" for a partial function.
It might mean the left hand operand of some partial function space construction within which the partial function concerned may be found, or it might mean the set of values over which the function is defined.
Here we are saying that if f is a partial function over A, then its domain is some subset of A and f is a total function over that subset of A.)
<ft lang="xl-sml" rest="">
set_goal([],&qqtel;&forall;f s t u&bull; f &isin;<sub>g</sub> s &nrarr;<sub>g</sub> t &rArr; f &isin;<sub>g</sub> dom f &rarr;<sub>g</sub> t&qqter;); 
a (rewrite_tac[
	get_spec &qqtel;$&rarr;<sub>g</sub>&qqter;,
	get_spec &qqtel;$&harr;<sub>g</sub>&qqter;,
	get_spec &qqtel;dom&qqter;,
	get_spec &qqtel;$&nrarr;<sub>g</sub>&qqter;]);
a (once_rewrite_tac[gst_relext_clauses]); 
a (REPEAT strip_tac); 
a (rewrite_tac[get_spec &qqtel;$&cross;<sub>g</sub>&qqter;]); 
a (asm_fc_tac[]); 
a (all_fc_tac[
	f&mapsto;<sub>g</sub>s_thm,
	v&isin;<sub>g</sub>&cross;<sub>g</sub>_thm]); 
a (&exist;_tac &qqtel;fst e&qqter;
	THEN &exist;_tac &qqtel;snd e&qqter;
	THEN asm_rewrite_tac[]
	THEN strip_tac); 
(* *** Goal "1" *** *)
a (LEMMA_T &qqtel;Pair<sub>g</sub> (fst e) (snd e) &isin;<sub>g</sub> Gx (fst e &mapsto;<sub>g</sub> snd e)&qqter; ante_tac
	THEN1 rewrite_tac [get_spec &qqtel;$&mapsto;<sub>g</sub>&qqter;]);
a (pure_rewrite_tac[asm_rule &qqtel;fst e &mapsto;<sub>g</sub> snd e = e&qqter;]
	THEN strip_tac);
a (LEMMA_T &qqtel;Gx e &sube;<sub>g</sub> Gx f&qqter; ante_tac THEN1 fc_tac [Gx_mono_thm2]);
a (rewrite_tac [gst_relext_clauses] THEN strip_tac THEN asm_fc_tac[]);
a (LEMMA_T &qqtel;fst e &isin;<sub>g</sub> Pair<sub>g</sub> (fst e) (snd e)&qqter; asm_tac THEN1 rewrite_tac[]);
a (all_fc_tac [Gx_trans_thm3]);
(* *** Goal "2" *** *)
a (&exist;_tac &qqtel;snd e&qqter;	THEN asm_rewrite_tac[]); 
val &isin;<sub>g</sub>&nrarr;<sub>g</sub>&rArr;&isin;<sub>g</sub>&rarr;<sub>g</sub>_thm = save_pop_thm "&isin;<sub>g</sub>&nrarr;<sub>g</sub>&rArr;&isin;<sub>g</sub>&rarr;<sub>g</sub>_thm";
</ft>
</subsec>
</sbcol>
</secbody>
<secbody title="The Identity Function">
<sbcol>
<subsec title="specification">
<holconst><holsig>
 id : GS &rarr; GS
</holsig>
<holpred>
&forall;s&bull; id s = Sep
	(s &cross;<sub>g</sub> s)
	&lambda;x&bull; fst x = snd x
</holpred>
</holconst>
</subsec>
</sbcol>
<sbcol>
<subsec title="lemmas">
<ft lang="xl-gft" rest="">
id_thm1 =
	&turnstil; &forall;s x&bull; x &isin;<sub>g</sub> id s	
	  &hArr; &exist;y&bull; y &isin;<sub>g</sub> s &and; x = y &mapsto;<sub>g</sub> y

id_ap_thm =
	&turnstil; &forall;s x&bull; x &isin;<sub>g</sub> s	
	  &rArr; (id s) <sub>g</sub> x = x

id&isin;<sub>g</sub>&nrarr;<sub>g</sub>_thm1 =
	&turnstil; &forall;s t u&bull; s &sube;<sub>g</sub> t &cap;<sub>g</sub> u
	  &rArr; id s &isin;<sub>g</sub> t &nrarr;<sub>g</sub> u

id&isin;<sub>g</sub>&nrarr;<sub>g</sub>_thm2 =
	&turnstil; &forall;s t u&bull; s &sube;<sub>g</sub> t
	  &rArr; id s &isin;<sub>g</sub> t &nrarr;<sub>g</sub> t

id_clauses =
	&turnstil; &forall;s&bull; rel(id s) &and; fun (id s)
	  &and; dom(id s) = s &and; ran(id s) = s
</ft>
<hide>
<ft lang="xl-sml" rest="">
val idg_def = get_spec &qqtel;id&qqter;;

set_goal([],&qqtel;&forall;s x&bull;
	x &isin;<sub>g</sub> id s	
	&hArr; &exist;y&bull; y &isin;<sub>g</sub> s
	&and; x = y &mapsto;<sub>g</sub> y&qqter;);
a (prove_tac[get_spec &qqtel;id&qqter;]
	THEN_TRY (asm_rewrite_tac[
	get_spec&qqtel;$&harr;<sub>g</sub>&qqter;,
	get_spec&qqtel;$&cross;<sub>g</sub>&qqter;]));
(* *** Goal "1" *** *)
a (fc_tac[get_spec&qqtel;$&cross;<sub>g</sub>&qqter;]);
a (asm_ante_tac &qqtel;fst x = snd x&qqter;
	THEN asm_rewrite_tac[]
	THEN strip_tac
	THEN all_var_elim_asm_tac);
a (&exist;_tac &qqtel;r&qqter; THEN asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a (REPEAT (&exist;_tac &qqtel;y&qqter;) THEN asm_rewrite_tac[]);
val id_thm1 =
	save_pop_thm "id_thm1";

set_goal([],&qqtel;&forall;s x&bull;
	x &isin;<sub>g</sub> s	
	&rArr; (id s) <sub>g</sub> x = x&qqter;);
a (once_rewrite_tac[gst_relext_clauses]);
a (rewrite_tac[get_spec &qqtel;$<sub>g</sub>&qqter;, id_thm1]);
a (REPEAT_N 4 strip_tac);
a (LEMMA_T &qqtel;&exist; y y'&bull; y' &isin;<sub>g</sub> s &and; x = y' &and; y = y'&qqter;
	(fn x=&gt; rewrite_tac[x] THEN asm_tac x)
	THEN1 (REPEAT_N 2 (&exist;_tac &qqtel;x&qqter;)
		THEN asm_rewrite_tac[]));
a (all_&epsilon;_tac
	THEN asm_rewrite_tac[]);
val id_ap_thm = save_pop_thm "id_ap_thm"; 

set_goal([],&qqtel;&forall;s t u&bull; s &sube;<sub>g</sub> t &cap;<sub>g</sub> u &rArr; id s &isin;<sub>g</sub> t &nrarr;<sub>g</sub> u&qqter;);
a (rewrite_tac[gst_relext_clauses]);
a (prove_tac[get_spec &qqtel;$&nrarr;<sub>g</sub>&qqter;,
	get_spec &qqtel;id&qqter;,
	get_spec &qqtel;$&harr;<sub>g</sub>&qqter;,
	get_spec &qqtel;$&cross;<sub>g</sub>&qqter;]);
(* *** Goal "1" *** *)
a (once_rewrite_tac[gst_relext_clauses]);
a (prove_tac[get_spec &qqtel;$&cross;<sub>g</sub>&qqter;]);
a (MAP_EVERY &exist;_tac [&qqtel;l&qqter;, &qqtel;r&qqter;] THEN REPEAT strip_tac
	THEN (REPEAT (asm_fc_tac[])));
(* *** Goal "2" *** *)
a (prove_tac[get_spec &qqtel;fun&qqter;,
	get_spec &qqtel;rel&qqter;,
	get_spec &qqtel;$&cross;<sub>g</sub>&qqter;]);
val id&isin;<sub>g</sub>&nrarr;<sub>g</sub>_thm1 = save_pop_thm "id&isin;<sub>g</sub>&nrarr;<sub>g</sub>_thm1";

set_goal([],&qqtel;&forall;s t u&bull; s &sube;<sub>g</sub> t &rArr; id s &isin;<sub>g</sub> t &nrarr;<sub>g</sub> t&qqter;);
a (prove_tac[]);
a (bc_thm_tac id&isin;<sub>g</sub>&nrarr;<sub>g</sub>_thm1);
a (asm_rewrite_tac [
	prove_rule [gst_relext_clauses]
	&qqtel;t &cap;<sub>g</sub> t = t&qqter;]);
val id&isin;<sub>g</sub>&nrarr;<sub>g</sub>_thm2 = save_pop_thm "id&isin;<sub>g</sub>&nrarr;<sub>g</sub>_thm2";

set_goal ([], &qqtel;&forall;s&bull; rel (id s)&qqter;);
a (rewrite_tac [get_spec &qqtel;rel&qqter;, get_spec &qqtel;id&qqter;]
	THEN REPEAT strip_tac);
a (fc_tac [get_spec &qqtel;$&cross;<sub>g</sub>&qqter;]);
a (&exist;_tac &qqtel;l&qqter; THEN &exist;_tac &qqtel;r&qqter;
	THEN asm_rewrite_tac[]);
val rel_id_lem = pop_thm();

set_goal([], &qqtel;&forall;s&bull; rel(id s) &and; fun (id s) &and; dom(id s) = s &and; ran(id s) = s&qqter;);
a (rewrite_tac [rel_id_lem] THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a (rewrite_tac [fun_def, rel_id_lem, get_spec &qqtel;id&qqter;]
	THEN REPEAT strip_tac
	THEN all_var_elim_asm_tac
	THEN strip_tac);
(* *** Goal "2" *** *)
a (rewrite_tac[get_spec &qqtel;dom&qqter;]);
a (once_rewrite_tac [gst_relext_clauses]);
a (rewrite_tac[get_spec &qqtel;id&qqter;] THEN REPEAT strip_tac);
(* *** Goal "2.1" *** *)
a (LEMMA_T &qqtel;e &mapsto;<sub>g</sub> e &isin;<sub>g</sub> (Sep (s &cross;<sub>g</sub> s) (&lambda; x&bull; fst x = snd x))&qqter; asm_tac
	THEN1 (rewrite_tac[] THEN strip_tac));
a (fc_tac [Gx_trans_thm2]);
a (LEMMA_T &qqtel;Pair<sub>g</sub> e e &isin;<sub>g</sub> Gx (e &mapsto;<sub>g</sub> e)&qqter; asm_tac THEN1 rewrite_tac []);
a (lemma_tac &qqtel;galaxy (Gx (Sep (s &cross;<sub>g</sub> s) (&lambda; x&bull; fst x = snd x)))&qqter; THEN1 rewrite_tac [galaxy_Gx]);
a (all_fc_tac [get_spec &qqtel;Gx&qqter;]);
a (LEMMA_T &qqtel;e &isin;<sub>g</sub> Pair<sub>g</sub> e e&qqter; asm_tac THEN1 prove_tac[]);
a (all_fc_tac [Gx_trans_thm3]);
(* *** Goal "2.2" *** *)
a (&exist;_tac &qqtel;e&qqter; THEN asm_rewrite_tac[]);
(* *** Goal "3" *** *)
a (rewrite_tac[get_spec &qqtel;ran&qqter;]);
a (once_rewrite_tac [gst_relext_clauses]);
a (rewrite_tac[get_spec &qqtel;id&qqter;] THEN REPEAT strip_tac);
(* *** Goal "3.1" *** *)
a (LEMMA_T &qqtel;e &mapsto;<sub>g</sub> e &isin;<sub>g</sub> (Sep (s &cross;<sub>g</sub> s) (&lambda; x&bull; fst x = snd x))&qqter; asm_tac
	THEN1 (rewrite_tac[] THEN strip_tac));
a (fc_tac [Gx_trans_thm2]);
a (LEMMA_T &qqtel;Pair<sub>g</sub> e e &isin;<sub>g</sub> Gx (e &mapsto;<sub>g</sub> e)&qqter; asm_tac THEN1 rewrite_tac []);
a (lemma_tac &qqtel;galaxy (Gx (Sep (s &cross;<sub>g</sub> s) (&lambda; x&bull; fst x = snd x)))&qqter; THEN1 rewrite_tac [galaxy_Gx]);
a (all_fc_tac [get_spec &qqtel;Gx&qqter;]);
a (LEMMA_T &qqtel;e &isin;<sub>g</sub> Pair<sub>g</sub> e e&qqter; asm_tac THEN1 prove_tac[]);
a (all_fc_tac [Gx_trans_thm3]);
(* *** Goal "3.2" *** *)
a (&exist;_tac &qqtel;e&qqter; THEN asm_rewrite_tac[]);
val id_clauses = save_pop_thm "id_clauses";

add_pc_thms "gst-fun" ([id_clauses]);
set_merge_pcs ["basic_hol", "gst-ax", "gst-fun"];
</ft>
</hide>
</subsec>
</sbcol>
</secbody>
</section>

<section title="Proof Contexts">
<abstract>
Finalisation of a proof context.
</abstract>
<secbody>
<sbcol>
</sbcol>
<sbcol>
<subsec title="Proof Context">
<ft lang="xl-sml" rest="">
add_pc_thms "gst-fun" ([
	field_&empty;<sub>g</sub>_thm,
	fun_&empty;<sub>g</sub>_thm,
	&empty;<sub>g</sub>&isin;<sub>g</sub>&nrarr;<sub>g</sub>_thm]);
set_merge_pcs ["basic_hol", "gst-ax", "gst-fun"];
commit_pc "gst-fun";
</ft>
</subsec>
</sbcol>
</secbody>
</section>

</xldoc>






