<?xml version="1.0"?>
<!DOCTYPE ProofPower SYSTEM "pp-symbol.ent">
<xldoc xmlns="http://www.x-logic.org/xmlns/draft/xld"
       xmlns:xhtml="http://www.w3.org/TR/xhtml1/strict"
       id="$Id: x002.xml,v 1.2 2003/01/02 13:41:11 rbj Exp $"
       name="x002"
       title="Transitive and Well-Founded Relations as Properties"
       description="A theory of transitive and well-founded relations in ProofPower HOL"
       keywords="logic proofpower hol relations transitive well-founded"
       class="con"
       root="../../"
       path="rbjpub/pp/"
       up="index.html"
       rbjhome="../rbj.htm"
       maintitle="mnt">

<section title="Overview">
<abstract>

</abstract>
<secbody>
<sbcol>
<secref title="Introduction"/>
<secref title="Transitive Relations"/>
<secref title="Well-Founded Relations"/>
</sbcol>
<sbcol>
<secref title="Proof Context"/>
<subsec title="Listing of Theory wf_relp" href="wf_relp.html" />
</sbcol>
</secbody>
</section>

<ft lang="xl-ign" rest="">
set_flag("pp_show_HOL_types", true);
set_flag("pp_show_HOL_types", false);
</ft>

<section title="Introduction">
<abstract>
A new "wf_relp" theory is created as a child of "wf_rel".
The purpose of this theory is entirely cosmetic.
I want to use the results in developing set theory but I want to avoid use of the membership sign in a context in which it is likely to cause confusion.
</abstract>
<secbody>
<sbcol>
<subsec title="Introduction">
One of the principle well-founded relations of interest in this application is &isin;<sub>g</sub>, which has type
<ft lang="xl-gft" rest="">
&qqco;GS &rarr; GS &rarr; BOOL&qqter;
</ft>
so I would like a version of "well-founded" which has type:
<ft lang="xl-gft" rest="">
&qqco;('a &rarr; 'a &rarr; BOOL) &rarr; BOOL&qqter;
&lt;/subsec&gt;
&lt;subsec title="The Theory wf_relp"&gt;
The new theory is first created, together with a proof context which we will build up as we develop the theory.
</ft>
<ft lang="xl-sml" rest="">
open_theory "hol";
force_new_theory "wf_relp";
force_new_pc "wf_relp";
merge_pcs ["xl_cs_&exist;_conv"] "wf_relp";
set_merge_pcs ["hol", "wf_relp"];
</ft>
</subsec>
</sbcol>
</secbody>
</section>

<section title="Transitive Relations">
<abstract>
Elementary results about transitive relations and transitive closure.
</abstract>
<secbody>
<sbcol>
<subsec title="Definitions">
<holconst><holsig>
trans: ('a  &rarr; 'a &rarr; BOOL) &rarr; BOOL
</holsig>
<holpred>
&forall; r &bull;
 trans r &equiv; &forall; s t u&bull; r s t &and; r t u &rArr; r s u
</holpred>
</holconst>
<holconst><holsig>
tc: ('a  &rarr; 'a &rarr; BOOL) &rarr;  ('a  &rarr; 'a &rarr; BOOL)
</holsig>
<holpred>
&forall; r &bull;
 tc r = &lambda; s t&bull; &forall;tr&bull; trans tr &and; (&forall;v u&bull; r v u &rArr; tr v u) &rArr; tr s t
</holpred>
</holconst>
</subsec>
<subsec title="Theorems">
<ft lang="xl-sml" rest="">
set_goal([],&qqtel;&forall;r&bull; trans (tc r)&qqter;);
a (rewrite_tac(map get_spec [&qqtel;tc&qqter;,&qqtel;trans&qqter;]));
a (REPEAT strip_tac);
a (all_asm_fc_tac []);
a (all_asm_fc_tac []);
val tran_tc_thm = save_pop_thm("tran_tc_thm");

set_goal([],&qqtel;&forall; r x y z&bull; tc r x y &and; tc r y z &rArr; tc r x z&qqter;);
a (prove_tac [rewrite_rule [get_spec &qqtel;trans&qqter;] tran_tc_thm]);
val tran_tc_thm2 = save_pop_thm("tran_tc_thm2");

set_goal([],&qqtel;&forall;r x y &bull; r x y &rArr; tc r x y&qqter;);
a (rewrite_tac [get_spec &qqtel;tc&qqter;, sets_ext_clauses]
	THEN REPEAT strip_tac);
a (all_asm_fc_tac[]);
val tc_incr_thm = save_pop_thm("tc_incr_thm");
</ft>

<ft lang="xl-sml" rest="">
set_goal([],&qqtel;&forall; r x y&bull; tc r x y &and; &not; r x y &rArr; &exist;z&bull; tc r x z &and; r z y&qqter;);
a (REPEAT strip_tac);
a (lemma_tac &qqtel;&forall;q&bull; trans q &and; (&forall;v w&bull; r v w &rArr; q v w) &rArr; q x y&qqter;);
a (asm_ante_tac &qqtel;tc r x y&qqter;);
a (rewrite_tac [get_spec &qqtel;tc&qqter;,
	get_spec &qqtel;trans&qqter;]);
a (spec_nth_asm_tac 1 &qqtel;&lambda;v w&bull; r v w &or; &exist;u&bull; tc r v u &and; r u w&qqter;);
</ft>
<ft lang="xl-gft" rest="">
(* *** Goal "2.1" *** *)

(*  4 *)  &qqtel;tc r x y&qqter;
(*  3 *)  &qqtel;&not; r x y&qqter;
(*  2 *)  &qqtel;&forall; q&bull; trans q &and; (&forall; v w&bull; r v w &rArr; q v w) &rArr; q x y&qqter;
(*  1 *)  &qqtel;&not; trans (&lambda; v w&bull; r v w &or; (&exist; u&bull; tc r v u &and; r u w))&qqter;

(* ?&turnstil; *)  &qqtel;&exist; z&bull; tc r x z &and; r z y&qqter;
</ft>
<ft lang="xl-sml" rest="">
a (swap_nth_asm_concl_tac 1
	THEN rewrite_tac [get_spec &qqtel;trans&qqter;]
	THEN REPEAT strip_tac);
(* *** Goal "2.1.1" *** *)
a (&exist;_tac &qqtel;t&qqter;
	THEN asm_rewrite_tac[]);
a (all_fc_tac [tc_incr_thm]);
(* *** Goal "2.1.2" *** *)
a (&exist;_tac &qqtel;u'&qqter;
	THEN asm_rewrite_tac[]);
a (REPEAT (all_asm_fc_tac [tran_tc_thm2,tc_incr_thm]));
(* *** Goal "2.1.3" *** *)
a (&exist;_tac &qqtel;t&qqter;
	THEN asm_rewrite_tac[]);
a (REPEAT(all_asm_fc_tac [tran_tc_thm2,tc_incr_thm]));
(* *** Goal "2.1.4" *** *)
a (&exist;_tac &qqtel;u''&qqter;
	THEN asm_rewrite_tac[]);
a (REPEAT(all_asm_fc_tac [tran_tc_thm2,tc_incr_thm]));
(* *** Goal "2.2" *** *)
a (swap_nth_asm_concl_tac 1
	THEN asm_rewrite_tac []);
(* *** Goal "2.3" *** *)
a (swap_nth_asm_concl_tac 1
	THEN asm_rewrite_tac []);
val tc_decomp_thm = save_pop_thm "tc_decomp_thm";
</ft>

<ft lang="xl-sml" rest="">
set_goal([],&qqtel;&forall; r1 r2&bull; (&forall; x y&bull; r1 x y &rArr; r2 x y)
	&rArr; (&forall; x y&bull; tc r1 x y &rArr; tc r2 x y)&qqter;);
a (rewrite_tac [get_spec &qqtel;tc&qqter;]);
a (REPEAT strip_tac);
a (spec_nth_asm_tac 3 &qqtel;tr&qqter;);
a (all_asm_fc_tac[]);
a (all_asm_fc_tac[]);
val tc_mono_thm = save_pop_thm "tc_mono_thm";
</ft>

<ft lang="xl-sml" rest="">
set_goal([],&qqtel;&forall; r p&bull; (&forall; x y&bull; r x y &rArr; p x)
	&rArr; (&forall; x y&bull; tc r x y &rArr; p x)&qqter;);
a (rewrite_tac [get_spec &qqtel;tc&qqter;]);
a (REPEAT strip_tac);
a (SPEC_NTH_ASM_T 1 &qqtel;&lambda;x y:'a &bull; (p x):BOOL&qqter;
	(fn x =&gt; strip_asm_tac (rewrite_rule[] x))
	THEN_TRY all_asm_fc_tac[]);
a (swap_nth_asm_concl_tac 1
	THEN rewrite_tac [get_spec &qqtel;trans&qqter;]
	THEN REPEAT strip_tac);
val tc_p_thm = save_pop_thm "tc_p_thm";
</ft>
</subsec>
</sbcol>
</secbody>
</section>


<section title="Well-Founded Relations">
<abstract>
Definition of well-founded and transitive-well-founded and proof that the transitive closure of a well-founded relation is transitive-well-founded.
</abstract>
<secbody>
<sbcol>
<subsec title="Definitions">
<holconst><holsig>
well_founded: ('a &rarr; 'a &rarr; BOOL) &rarr; BOOL
</holsig>
<holpred>
&forall; r &bull;
 well_founded r &equiv; &forall; s &bull; (&forall; x &bull; (&forall; y &bull; r y x &rArr; s y) &rArr; s x) &rArr; &forall; x &bull; s x
</holpred>
</holconst>
<holconst><holsig>
twfp: ('a &rarr; 'a &rarr; BOOL) &rarr; BOOL
</holsig>
<holpred>
&forall; r &bull;
 twfp r &equiv; well_founded r &and; trans r
</holpred>
</holconst>
</subsec>
<subsec title="Theorems">
The first thing I need to prove here is that the transitive closure of a well-founded relation is also well-founded.
This provides a form of induction with a stronger induction hypothesis.
Naturally we would expect this to be proven inductively and the question is therefore what property to use in the inductive proof, the observation that the transitive closure of a relation is well-founded is not explicitly the ascription of a property to the field of the relation.
The obvious method is to relativise the required result to the transitive closure of a set, giving a property of sets, and then to prove that this property is hereditary if the relation is well-founded.
<p/>
The following definitions are not essential but perhaps make the argument clearer.
<ft lang="xl-sml" rest="">
set_goal([],&qqtel;&forall;s r&bull; well_founded r &rArr; &forall;x&bull; (&forall;y&bull; tc r y x &rArr; (&forall;z&bull; tc r z y &rArr; s z) &rArr; s y)
	&rArr; (&forall;y&bull; tc r y x &rArr; s y)&qqter;);
a (rewrite_tac [get_spec &qqtel;well_founded&qqter;]);
a (REPEAT_N 3 strip_tac);
a (SPEC_NTH_ASM_T 1 &qqtel;&lambda;x &bull; (&forall;y&bull; tc r y x &rArr; (&forall;z&bull; tc r z y &rArr; s z) &rArr; s y)
	&rArr; (&forall;y&bull; tc r y x &rArr; s y)&qqter; ante_tac
	THEN rewrite_tac[]
	THEN REPEAT strip_tac);
a (fc_tac [list_&forall;_elim [&qqtel;r&qqter;,&qqtel;y&qqter;,&qqtel;x&qqter;] tc_decomp_thm]);
(* *** Goal "1" *** *)
a (spec_nth_asm_tac 7 &qqtel;y&qqter;);
(* *** Goal "1.1" *** *)
a (all_fc_tac [tran_tc_thm2]);
a (spec_nth_asm_tac 10 &qqtel;y''&qqter;);
a (asm_fc_tac[]);
(* *** Goal "1.2" *** *)
a (spec_nth_asm_tac 7 &qqtel;y&qqter;);
a (spec_nth_asm_tac 3 &qqtel;z&qqter;);
(* *** Goal "2" *** *)
a (spec_nth_asm_tac 8 &qqtel;z&qqter;);
(* *** Goal "2.1" *** *)
a (lemma_tac &qqtel;tc r z x&qqter;
	THEN1 fc_tac [tc_incr_thm]);
a (lemma_tac &qqtel;tc r y'' x&qqter;
	THEN1 strip_asm_tac (list_&forall;_elim [&qqtel;r&qqter;,&qqtel;y''&qqter;,&qqtel;z&qqter;,&qqtel;x&qqter;] tran_tc_thm2));
a (spec_nth_asm_tac 12 &qqtel;y''&qqter;);
a (spec_nth_asm_tac 6 &qqtel;z'&qqter;);
(* *** Goal "2.2" *** *)
a (asm_fc_tac[]);
val tcwf_lemma1 = save_pop_thm "tcwf_lemma1";
</ft>
<ft lang="xl-sml" rest="">
set_goal([],&qqtel;&forall;r&bull; well_founded r &rArr; &forall;s&bull; (&forall;t&bull; (&forall;u&bull; tc r u t &rArr; s u) &rArr; s t) &rArr; (&forall;e&bull; s e)&qqter;);
a (REPEAT strip_tac THEN fc_tac [tcwf_lemma1]);
a (spec_nth_asm_tac 2 &qqtel;e&qqter;);
a (list_spec_nth_asm_tac 3 [&qqtel;e&qqter;,&qqtel;s&qqter;,&qqtel;u&qqter;]);
a (spec_nth_asm_tac 7 &qqtel;y&qqter;);
a (spec_nth_asm_tac 4 &qqtel;u'&qqter;);
val tcwf_lemma2 = save_pop_thm "tcwf_lemma2";
</ft>
<ft lang="xl-sml" rest="">
set_goal([],&qqtel;&forall;r&bull; well_founded r &rArr; well_founded (tc r)&qqter;);
a (strip_tac THEN strip_tac
	THEN fc_tac [tcwf_lemma1]);
a (rewrite_tac [get_spec &qqtel;well_founded&qqter;]);
a (REPEAT strip_tac);
a (spec_nth_asm_tac 1 &qqtel;x&qqter;);
a (list_spec_nth_asm_tac 4 [&qqtel;x&qqter;,&qqtel;s&qqter;,&qqtel;y&qqter;]);
a (spec_nth_asm_tac 6 &qqtel;y'&qqter;);
a (spec_nth_asm_tac 4 &qqtel;y''&qqter;);
val wf_tc_wf_thm = save_pop_thm "wf_tc_wf_thm";
</ft>
<ft lang="xl-sml" rest="">
set_goal([], &qqtel;&forall;r&bull; well_founded (tc r) &rArr; well_founded r&qqter;);
a (rewrite_tac [get_spec &qqtel;well_founded&qqter;]
	THEN REPEAT strip_tac);
a (spec_nth_asm_tac 2 &qqtel;s&qqter;);
(* *** Goal "1" *** *)
a (spec_nth_asm_tac 3 &qqtel;x'&qqter;);
a (all_asm_fc_tac [tc_incr_thm]);
a (all_asm_fc_tac []);
(* *** Goal "2" *** *)
a (asm_rewrite_tac[]);
val tc_wf_wf_thm = save_pop_thm "tc_wf_wf_thm";
</ft>
<ft lang="xl-sml" rest="">
set_goal([],&qqtel;&forall;r&bull; well_founded r &rArr; twfp (tc r)&qqter;);
a (REPEAT strip_tac);
a (fc_tac [wf_tc_wf_thm]);
a (asm_rewrite_tac [get_spec &qqtel;twfp&qqter;, tran_tc_thm]);
val tc_wf_twf_thm = save_pop_thm "tc_wf_twf_thm";
</ft>
</subsec>
<subsec title="Tactics etc.">
<ft lang="xl-ign" rest="">
fun &lib;GEN_INDUCTION_T&rib; (thm : THM) (ttac : THM -&gt; TACTIC) : TERM -&gt; TACTIC = (
	let	fun bad_thm thm = thm_fail "GEN_INDUCTION_T" 29021 [thm];
		val (p, body) = (dest_simple_&forall; (concl thm))
			handle Fail _ =&gt; bad_thm thm;
		val (ant, suc) = (dest_&rArr; body)
			handle Fail _ =&gt; bad_thm thm;
		val (x, px) = (dest_simple_&forall; suc)
			handle Fail _ =&gt; bad_thm thm;
		val (xn, xty) = dest_var x;
		val tac = induction_strip_tac ttac ant;
	in	if not (px ~=$ (mk_app(p, x))handle Fail _ =&gt; true)
(*		orelse not(is_nil(asms thm))	*)
		then bad_thm thm
		else 
	fn t =&gt;
	let	val (tn, tty) = (dest_var t)
			handle Fail _ =&gt; term_fail "GEN_INDUCTION_T" 29024 [t];
		val tym = (type_match tty xty)
			handle Fail _ =&gt; fail "GEN_INDUCTION_T" 29023
			[fn()=&gt;string_of_term t, fn()=&gt;string_of_type xty];
		val thm1 = inst_type_rule tym thm;
	in
	fn (gl as (asms, conc)) =&gt;
		if not (is_free_in t conc)
		then term_fail "GEN_INDUCTION_T" 29026 [t]
		else if any asms (is_free_in t)
		then term_fail "GEN_INDUCTION_T" 29025 [t]
		else
	let	val actp = mk_simple_&lambda;(t, conc);
		val is_actp = 
			(fn t =&gt; is_app t andalso fst(dest_app t) ~=$ actp);
		val conv = (ONCE_MAP_C(COND_C is_actp simple_&beta;_conv fail_conv));
		val thm2 = conv_rule conv (simple_&forall;_elim actp thm1);
		val new_conc = induction_rename xn tn (concl thm2);
		val thm3 = &equiv;_mp_rule (refl_conv new_conc) thm2;
	in	(intro_&forall;_tac(t,t) THEN &rArr;_thm_tac thm3 THEN tac) gl
	end
	end
	end
);
</ft>
<ft lang="xl-sml" rest="">
fun WF_INDUCTION_T (thm : THM) (ttac : THM -&gt; TACTIC) : TERM -&gt; TACTIC = (
	let	fun bad_thm thm = thm_fail "WF_INDUCTION_T" 29021 [thm];
		val (wf, r) = (dest_app (concl thm))
			handle Fail _ =&gt; bad_thm thm;
		val sthm = &forall;_elim r tcwf_lemma2
			handle Fail _ =&gt; bad_thm thm;
		val ithm = &rArr;_elim sthm thm
			handle Fail _ =&gt; bad_thm thm;
	in GEN_INDUCTION_T ithm ttac
	end
);
</ft>
<ft lang="xl-sml" rest="">
fun wf_induction_tac (thm : THM) : TERM -&gt; TACTIC = (
	let	val ttac = (WF_INDUCTION_T thm strip_asm_tac)
			handle ex =&gt; reraise ex "wf_induction_tac";
	in
	fn tm =&gt;
	let	val tac = (ttac tm) handle ex =&gt; reraise ex "wf_induction_tac";
	in	fn gl =&gt; ((tac gl) handle ex =&gt; reraise ex "wf_induction_tac")
	end
	end
);
</ft>

<ft lang="xl-sml" rest="">
set_goal([], &qqtel;&forall;r&bull; well_founded r &rArr; &forall;x&bull; &not;&exist;p v&bull; p v &and; &forall;y&bull; p y &rArr; tc r y x &and; &exist;z&bull; p z &and; r z y&qqter;);
a (strip_tac THEN strip_tac THEN strip_tac);
a (wf_induction_tac (asm_rule &qqtel;well_founded r&qqter;) &qqtel;x&qqter;);
a contr_tac;
a (all_asm_fc_tac[]);
a (spec_nth_asm_tac 6 &qqtel;v&qqter;);
a (SPEC_NTH_ASM_T 1 &qqtel;&lambda;x&bull; p x &and; tc r x v&qqter; ante_tac
	THEN rewrite_tac[]
	THEN REPEAT strip_tac);
a (&exist;_tac &qqtel;z&qqter;
	THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a (fc_tac [tc_incr_thm]);
(* *** Goal "2" *** *)
a (spec_nth_asm_tac 7 &qqtel;y&qqter;);
a (&exist;_tac &qqtel;z'&qqter; THEN asm_rewrite_tac[]);
a (lemma_tac &qqtel;tc r z' y&qqter; THEN1 fc_tac [tc_incr_thm]);
a (all_fc_tac [tran_tc_thm2]);
val wf_nochain_thm = save_pop_thm "wf_nochain_thm";
</ft>

<ft lang="xl-sml" rest="">
set_goal([], &qqtel;&forall;r&bull; (&forall;x&bull; &not;&exist;p v&bull; p v &and; &forall;y&bull; p y &rArr; tc r y x &and; &exist;z&bull; p z &and; r z y) &rArr; well_founded r&qqter;);
a (rewrite_tac [get_spec &qqtel;well_founded&qqter;]);
a contr_tac;
a (DROP_NTH_ASM_T 3 ante_tac
	THEN rewrite_tac[]
	THEN strip_tac);
a (&exist;_tac &qqtel;x&qqter;
	THEN rewrite_tac[]);
a (lemma_tac &qqtel;&exist;rel&bull; rel = &lambda; v w&bull; &not; s v &and; &not; s w &and; r v w&qqter;
	THEN1 prove_&exist;_tac);
a (&exist;_tac &qqtel;&lambda;q&bull; tc rel q x&qqter;	THEN rewrite_tac[]);
a (spec_nth_asm_tac 3 &qqtel;x&qqter;);
a (&exist;_tac &qqtel;y&qqter; THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a (lemma_tac &qqtel;rel y x&qqter; THEN1 asm_rewrite_tac[]);
a (all_asm_fc_tac [tc_incr_thm]);
(* *** Goal "2" *** *)
a (lemma_tac &qqtel;&forall;x y&bull; rel x y &rArr; r x y&qqter;
	THEN1 (strip_tac THEN strip_tac
	THEN asm_rewrite_tac[] THEN REPEAT strip_tac));
a (all_fc_tac [tc_mono_thm]);
(* *** Goal "3" *** *)
a (lemma_tac &qqtel;&not; s y'&qqter;);
(* *** Goal "3.1" *** *)
a (lemma_tac &qqtel;&forall; x y&bull; rel x y &rArr; &not; s x&qqter;
	THEN1
	(REPEAT &forall;_tac
	THEN asm_rewrite_tac []
	THEN REPEAT strip_tac));
a (all_asm_fc_tac[rewrite_rule[](list_&forall;_elim [&qqtel;rel&qqter;, &qqtel;&lambda;x&bull;&not; s x&qqter;] tc_p_thm)]);
(* *** Goal "3.2" *** *)
a (spec_nth_asm_tac 7 &qqtel;y'&qqter;);
a (&exist;_tac &qqtel;y''&qqter; THEN REPEAT strip_tac);
a (lemma_tac &qqtel;tc rel y'' y'&qqter;);
(* *** Goal "3.2.1" *** *)
a (lemma_tac &qqtel;rel y'' y'&qqter;
	THEN1 asm_rewrite_tac[]);
a (all_asm_fc_tac[tc_incr_thm]);
(* *** Goal "3.2.2" *** *)
a (all_asm_fc_tac[tran_tc_thm2]);
val nochain_wf_thm = save_pop_thm "nochain_wf_thm";
</ft>

<ft lang="xl-sml" rest="">
set_goal([], &qqtel;&forall;r&bull;(&forall;x&bull; &not;&exist;p v&bull; p v &and; &forall;y&bull; p y &rArr; tc r y x &and; &exist;z&bull; p z &and; r z y)
	&rArr; &forall;x&bull; (&exist;y&bull; r y x) &rArr; &exist;z&bull; r z x &and; &not;&exist;v&bull; r v z &and; r v x&qqter;);
a contr_tac;
a (DROP_NTH_ASM_T 3 ante_tac
	THEN rewrite_tac[]
	THEN REPEAT strip_tac
	THEN rewrite_tac[]
);
a (&exist;_tac &qqtel;x&qqter;
	THEN &exist;_tac &qqtel;&lambda;w&bull; r w x&qqter;
	THEN &exist;_tac &qqtel;y&qqter;
	THEN asm_rewrite_tac[]);
a (strip_tac THEN asm_rewrite_tac[]);
a (REPEAT strip_tac);
(* *** Goal "1" *** *)
a (all_asm_fc_tac [tc_incr_thm]);
(* *** Goal "2" *** *)
a (spec_nth_asm_tac 2  &qqtel;y'&qqter;);
a (&exist;_tac &qqtel;v&qqter; THEN asm_rewrite_tac[]);
val nochain_min_thm = save_pop_thm "nochain_min_thm";
</ft>

<ft lang="xl-sml" rest="">
set_goal([], &qqtel;&forall;r&bull; well_founded r &rArr; &forall;x&bull; (&exist;y&bull; r y x) &rArr; &exist;z&bull; r z x &and; &not;&exist;v&bull; r v z &and; r v x&qqter;);
a (REPEAT_N 2 strip_tac);
a (strip_asm_tac ( &forall;_elim &qqtel;r&qqter; wf_nochain_thm));
a (ante_tac (&forall;_elim &qqtel;r&qqter; nochain_min_thm));
a (GET_NTH_ASM_T 1 ante_tac);
a (rewrite_tac [prove_rule [] &qqtel;&forall;a b&bull; a &rArr; (a &rArr; b) &rArr; b&qqter; ]);
val wf_min_thm = save_pop_thm "wf_min_thm";
</ft>

<ft lang="xl-sml" rest="">
set_goal([], &qqtel;&exist;r: BOOL&rarr;BOOL&rarr;BOOL&bull;(&forall;x&bull; (&exist;y&bull; r y x) &rArr; &exist;z&bull; r z x &and; &not;&exist;v&bull; r v z &and; r v x) &and; &not; well_founded r&qqter;);
a (&exist;_tac &qqtel;&lambda;x y:BOOL&bull; y&qqter;
	THEN rewrite_tac [get_spec &qqtel;well_founded&qqter;]
	THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a (&exist;_tac &qqtel;F&qqter; THEN asm_rewrite_tac []);
(* *** Goal "2" *** *)
a (&exist;_tac &qqtel;$&not;&qqter; THEN REPEAT strip_tac);
(* *** Goal "2.1" *** *)
a (spec_nth_asm_tac 1  &qqtel;x&qqter;);
(* *** Goal "2.2" *** *)
a (&exist;_tac &qqtel;T&qqter; THEN rewrite_tac[]);
val minr_not_wf_thm = save_pop_thm "minr_not_wf_thm";
</ft>
</subsec>
</sbcol>
</secbody>
</section>

<section title="Proof Context">
<abstract>
In this section I will create a decent proof context for recursive definitions, eventually.
</abstract>
<secbody>
<sbcol>
</sbcol>
<sbcol>
<subsec title="Proof Context">
<ft lang="xl-sml" rest="">
(* commit_pc "wf_relp"; *)
</ft>
</subsec>
</sbcol>
</secbody>
</section>

</xldoc>






