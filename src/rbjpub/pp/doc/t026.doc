=IGN
$Id: t026.doc,v 1.2 2008/07/18 14:15:45 rbj Exp $
open_theory "ifos";
set_merge_pcs ["hol1", "'GS1", "'misc2", "'ifos"];
=TEX
\documentclass[11pt,a4paper]{article}
\usepackage{latexsym}
\usepackage{ProofPower}
\ftlinepenalty=9999
\usepackage{A4}

%\def\ExpName{\mbox{{\sf exp}
%\def\Exp#1{\ExpName(#1)}

\tabstop=0.4in
\newcommand{\ignore}[1]{}

\title{Infinitarily Definable Sets}
\makeindex
\usepackage[unicode,pdftex]{hyperref}
\hypersetup{pdfauthor={Roger Bishop Jones}}
\hypersetup{colorlinks=true, urlcolor=black, citecolor=black, filecolor=black, linkcolor=black}

\author{Roger Bishop Jones}
\date{\ }

\begin{document}
\begin{titlepage}
\maketitle
\begin{abstract}
This is my third approach to set theory conceived as a maximal consistent theory of set comprehension.
It differs from the previous attempt (in t024) by simplification of the treatment of infinitary logic, allowing only a single binary relation.
\end{abstract}

\vfill

\begin{centering}

{\footnotesize

Created: 2008/07/11

Last Change $ $Date: 2008/07/18 14:15:45 $ $

\href{http://www.rbjones.com/rbjpub/pp/doc/t026.pdf}
{http://www.rbjones.com/rbjpub/pp/doc/t026.pdf}

$ $Id: t026.doc,v 1.2 2008/07/18 14:15:45 rbj Exp $ $

\copyright\ Roger Bishop Jones; Licenced under Gnu LGPL

}%footnotesize

\end{centering}

\thispagestyle{empty}
\end{titlepage}

\newpage
\addtocounter{page}{1}
%\section{DOCUMENT CONTROL}
%\subsection{Contents list}
{\parskip=0pt\tableofcontents}
%\newpage
%\subsection{Document cross references}

\subsection*{To Do}
\begin{itemize}
\item 
\item 
\end{itemize}

{\raggedright
\bibliographystyle{fmu}
\bibliography{rbj,fmu}
} %\raggedright

\newpage
\section{INTRODUCTION}

The idea is to obtain exotic models of set theory using definability in first order set theory as a source of candidate sets.

To ensure that we get all the well-founded sets we start with definability in infinitary first order set theory ({\it ifos}).
Given any membership structure, i.e. a domain of discourse and a membership relation over that domain, each formula of {\it ifos} with one free variable will define a subset of the domain of discourse (you may prefer to think of these as classes, since in the domains we work with they will mostly have very large size).

If we take as our domain of discourse the formulae of {\it ifos}, then the semantics of {\it ifos} provides a functor which given one membership relation over that domain will yield another membership relation.
If this functor had a fixed point then it would provide a rich interpretation of {\it ifos}.
Over the entire set of formulae of {\it ifos} there can be no such fixed point, for the resulting interpretation would include paradoxical collections such as the Russell set.

It seems clear however that some subsets of the formulae of {\it ifos} do have fixed points under the semantics of {\it ifos}.
For example, the formulae denoting well-founded sets, or those denoting well-founded sets or their complements.

It is the purpose of this work to see whether obtain models for rich non-well-founded set theories can be obtained in this way.

\section{INFINITARY SET THEORY}

=SML
open_theory "misc2";
force_new_theory "Ûifosİ";
force_new_pc Û"'ifos"İ;
merge_pcs ["'savedthm_cs_¶_proof"] "'ifos";
set_merge_pcs ["hol1", "'GS1", "'misc2", "'ifos"];
=TEX

\subsection{Syntax}

\subsubsection{Constructors, Discriminators and Destructors}

Preliminary to presenting the inductive definition of the required classes we define the nuts and bolts operations on the required syntactic entities (some of which will be used in the inductive definition).

A constructor puts together some syntactic entity from its constituents, discriminators distinguist between the different kinds of entity and destructors take them apart.

``Atomic'' formulae are just membership predicates.
So its just an ordered pair of `terms' (and in our case that just means variable names)  tagged with a zero.

¹HOLCONST
Ü ÛMkAfİ : GS ¸ GS ­ GS
÷üüüüüüüüüüü
Ü µlr· MkAf lr = (Nat‰g 0) í‰g ((Fst lr) í‰g (Snd lr))
°

¹HOLCONST
Ü ÛIsAfİ : GS ­ BOOL
÷üüüüüüüüüüü
Ü    µt· IsAf t = fst t = (Nat‰g 0)
°

¹HOLCONST
Ü ÛAfSetİ : GS ­ GS
÷üüüüüüüüüüü
Ü  AfSet = Ìx· fst(snd x)
°

¹HOLCONST
Ü ÛAfMemİ : GS ­ GS
÷üüüüüüüüüüü
Ü  AfMem = Ìx· snd(snd x)
°

¹HOLCONST
Ü ÛMkCfİ : GS ¸ GS ­ GS
÷üüüüüüüüüüü
Ü µvc· MkCf vc = (Nat‰g 1) í‰g ((Fst vc) í‰g (Snd vc))
°

¹HOLCONST
Ü ÛIsCfİ : GS ­ BOOL
÷üüüüüüüüüüü
Ü    µt· IsCf t = fst t = (Nat‰g 1)
°

¹HOLCONST
Ü ÛCfVarsİ : GS ­ GS
÷üüüüüüüüüüü
Ü  CfVars = Ìx· fst(snd x)
°

¹HOLCONST
Ü ÛCfFormsİ : GS ­ GS
÷üüüüüüüüüüü
Ü  CfForms = Ìx· snd(snd x)
°

=GFT
ÛIs_clausesİ =
   ô (µ x· IsAf (MkAf x))
       ± (µ x· ³ IsAf (MkCf x))
       ± (µ x· ³ IsCf (MkAf x))
       ± (µ x· IsCf (MkCf x))

ÛIs_not_fc_clausesİ =
   ô (µ x· IsAf x ´ ³ IsCf x) ± (µ x· IsCf x ´ ³ IsAf x)
=TEX

\ignore{
=SML
set_goal([], ¬(µx· IsAf (MkAf x))
	± (µx· ³ IsAf (MkCf x))
	± (µx· ³ IsCf (MkAf x))
	± (µx· IsCf (MkCf x))
	®);
a (rewrite_tac [get_spec ¬IsAf®,
	get_spec ¬MkAf®,
	get_spec ¬IsCf®,
	get_spec ¬MkCf®]);
a (contr_tac THEN FC_T (MAP_EVERY ante_tac) [natg_one_one_thm] 
	THEN PC_T1 "lin_arith" prove_tac[]);
val Is_clauses = pop_thm();

add_pc_thms "'ifos" (map get_spec [] @ [ord_nat_thm, Is_clauses]);
set_merge_pcs ["hol1", "'GS1", "'misc2", "'ifos"];

set_goal ([], ¬
	(µx· IsAf x ´ ³ IsCf x)
±	(µx· IsCf x ´ ³ IsAf x)
®);
a (rewrite_tac (map get_spec [¬IsAf®, ¬IsCf®]));
a (REPEAT strip_tac THEN asm_rewrite_tac[]
	THEN contr_tac THEN FC_T (MAP_EVERY ante_tac) [natg_one_one_thm]
	THEN PC_T1 "lin_arith" rewrite_tac[]);
val Is_not_fc_clauses = save_pop_thm "Is_not_fc_clauses";
=TEX

}%ignore

Some derived syntax:

¹HOLCONST
Ü ÛMkNotİ : GS ­ GS
÷üüüüüüüüüüü
Ü µf· MkNot f = MkCf (š‰g, Pair f f)
°

\subsubsection{The Inductive Definition of Syntax}

This is accomplished by defining the required closure condition (closure under the above constructors for arguments of the right kind) and then taking the intersection of all sets which satisfy the closure condition.

The closure condition is:

¹HOLCONST
Ü ÛRepClosedİ: GS SET ­ BOOL
÷üüüüüüüüüüü
Ü µ s· RepClosed s ¤
Ü	(µ s2 m· MkAf (s2, m)  s)
Ü±	(µ vars fs· X‰g fs € s ´ MkCf (vars, fs)  s)
°

The well-formed syntax is then the smallest set closed under these constructions.

¹HOLCONST
Ü ÛSyntaxİ : GS SET
÷üüüüüüüüüüü
Ü Syntax = ¥{x | RepClosed x}
°

=GFT
Ûsyntax_€_repclosed_thmİ =
	ô µ s· RepClosed s ´ Syntax € s
=TEX

\ignore{
=SML
set_goal([], ¬µs· RepClosed s ´ Syntax € s®);
a (rewrite_tac [get_spec ¬Syntax®]
	THEN REPEAT strip_tac THEN asm_fc_tac[]);
val syntax_€_repclosed_thm = pop_thm ();
=TEX
}%ignore

This is an ``inductive datatype'' so we should expect the usual kinds of theorems.

Informally these should say:

\begin{itemize}
\item Syntax is closed under the two constructors.
\item The syntax constructors are injections, have disjoint ranges, and partition the syntax. 
\item Any syntactic property which is preserved by the constructors (i.e. is true of any construction if it is true of all its syntactic constituents) is true of everything in syntax (this is an induction principle).
\end{itemize}

=GFT
Ûrepclosed_syntax_lemmaİ =
	ô RepClosed Syntax

Ûrepclosed_syntax_thmİ =
	ô (µ s m· MkAf (s, m)  Syntax)
       ± (µ vars fs
       · (µ x· x  X‰g fs ´ x  Syntax) ´ MkCf (vars, fs)  Syntax)

Ûrepclosed_syntax_lemma1İ =
	ô µ s· RepClosed s ´ Syntax € s

Ûrepclosed_syntax_lemma2İ =
	ô µ p· RepClosed {x|p x} ´ (µ x· x  Syntax ´ p x)
=TEX

\ignore{
=SML
set_goal([], ¬RepClosed Syntax®);
a (rewrite_tac (map get_spec [¬RepClosed®])
	THEN strip_tac);
(* *** Goal "1" *** *)
a (rewrite_tac (map get_spec [¬RepClosed®, ¬Syntax®])
	THEN REPEAT strip_tac THEN asm_fc_tac [] THEN asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a (rewrite_tac (map get_spec [ ¬Syntax®])
	THEN REPEAT strip_tac
	THEN all_asm_fc_tac[]);
a (fc_tac [get_spec ¬RepClosed®]);
a (lemma_tac ¬µ x· x  X‰g fs ´ x  s®
	THEN1 (REPEAT strip_tac THEN all_asm_fc_tac[]));
a (all_asm_fc_tac[]);
a (asm_rewrite_tac[]);
val repclosed_syntax_lemma = pop_thm ();

val repclosed_syntax_thm = save_thm ("repclosed_syntax_thm",
	rewrite_rule [get_spec ¬RepClosed®] repclosed_syntax_lemma);

set_goal([], ¬µs· RepClosed s ´ Syntax € s®);
a (rewrite_tac [get_spec ¬Syntax®]
	THEN prove_tac[]);
val repclosed_syntax_lemma1 = save_pop_thm "repclosed_syntax_lemma1";

set_goal([], ¬µp· RepClosed {x | p x} ´ µx· x  Syntax ´ p x®);
a (rewrite_tac [get_spec ¬Syntax®] THEN REPEAT strip_tac);
a (asm_fc_tac[]);
val repclosed_syntax_lemma2 = save_pop_thm "repclosed_syntax_lemma2";
=TEX
}%ignore

We need to be able to define functions by recursion over this syntax.
To do that we need to prove that the syntax of comprehensions is well-founded.
This is itself equivalent to an induction principle, so we can try and derive it using the induction principles already available.

We must first define the relation of priority over the syntax, i.e. the relation between an element of the syntax and its constitutents.

¹HOLCONST
Ü ÛScPrecİ : GS REL
÷üüüüüüüüüüü
Ü µÁ Ç· ScPrec Á Ç ¤
Ü	¶ord fs· Á ‰g fs ± {Á; Ç} € Syntax ± Ç = MkCf (ord, fs)
°

=GFT
ÛScPrec_tc__thmİ =
	ô µ x y· ScPrec x y ´ tc $‰g x y

Ûwell_founded_ScPrec_thmİ =
	ô well_founded ScPrec

Ûwell_founded_tcScPrec_thmİ =
	ô well_founded (tc ScPrec)
=TEX

\ignore{
=SML
set_goal([], ¬µx y· ScPrec x y ´ tc $‰g x y®);
a (rewrite_tac (map get_spec [¬ScPrec®, ¬MkCf®]));
a (REPEAT strip_tac THEN asm_rewrite_tac [í_tc_thm]);
a (lemma_tac ¬tc $‰g fs (ord í‰g fs) ± tc $‰g (ord í‰g fs) (Nat‰g 1 í‰g ord í‰g fs)®
	THEN1 rewrite_tac [í_tc_thm]);
a (all_fc_tac [tc_incr_thm]);
a (all_fc_tac [tran_tc_thm2]);
a (all_fc_tac [tran_tc_thm2]);
val ScPrec_tc__thm = pop_thm ();

set_goal ([], ¬well_founded ScPrec®);
a (rewrite_tac [get_spec ¬well_founded®]);
a (REPEAT strip_tac);
a (asm_tac (µ_elim ¬s® gs_cv_ind_thm));
a (lemma_tac ¬µ x· (µ y· tc $‰g y x ´ s y) ´ s x®
	THEN1 REPEAT strip_tac);
(* *** Goal "1" *** *)
a (lemma_tac ¬µ y· ScPrec y x ´ s y®
	THEN1 (REPEAT strip_tac THEN all_fc_tac [ScPrec_tc__thm]
		THEN asm_fc_tac []));
a (asm_fc_tac[]);
(* *** Goal "2" *** *)
a (asm_fc_tac[]);
a (asm_rewrite_tac[]);
val well_founded_ScPrec_thm =  save_pop_thm "well_founded_ScPrec_thm";

set_goal([], ¬well_founded (tc ScPrec)®);
a (asm_tac well_founded_ScPrec_thm);
a (fc_tac [wf_tc_wf_thm]);
val well_founded_tcScPrec_thm = save_pop_thm ("well_founded_tcScPrec_thm");
=TEX

}%ignore

=SML
val ÛSC_INDUCTION_Tİ = WF_INDUCTION_T well_founded_ScPrec_thm;
val Ûsc_induction_tacİ = wf_induction_tac well_founded_ScPrec_thm;
=TEX

The set Syntax gives us the syntactically well-formed phrases of our language.
It will be useful to have some predicates which incorporate well-formedness, which are defined here.

=GFT
Ûsyntax_disj_thmİ =
   ô µ x
     · x  Syntax
         ´ (¶ s m· x = MkAf (s, m))
           ² (¶ vars fs· (µ y· y ‰g fs ´ y  Syntax) ± x = MkCf (vars, fs))

Ûsyntax_cases_thmİ =
   ô µ x· x  Syntax ´ IsAf x ² IsCf x

Ûis_fc_clausesİ =
   ô µ x
     · x  Syntax
         ´ (IsAf x ´ (¶ s m· x = MkAf (s, m)))
           ± (IsCf x
             ´ (¶ vars fs
             · (µ y· y ‰g fs ´ y  Syntax) ± x = MkCf (vars, fs)))

Ûsyn_proj_clausesİ =
    ô (µ s m· AfSet (MkAf (s, m)) = s)
       ± (µ s m· AfMem (MkAf (s, m)) = m)
       ± (µ v f· CfVars (MkCf (v, f)) = v)
       ± (µ v f· CfForms (MkCf (v, f)) = f)

Ûis_fc_clauses2İ =
   ô µ x· x  Syntax ´ IsCf x ´ (µ y· y ‰g CfForms x ´ y  Syntax)

Ûsyn_con_neq_clausesİ =
   ô µ x y· ³ MkAf x = MkCf y

Ûsyn_comp_fc_clausesİ =
   ô µ v f· MkCf (v, f)  Syntax ´ (µ y· y ‰g f ´ y  Syntax)

Ûscprec_fc_clausesİ =
   ô µ Á Ç vars fs· Ç  Syntax ´ Ç = MkCf (vars, fs) ± Á ‰g fs ´ ScPrec Á Ç

Ûscprec_fc_clauses2İ =
   ô µ t· t  Syntax ´ IsCf t ´ (µ f· f ‰g CfForms t ´ ScPrec f t)
=TEX

\ignore{
=SML
set_goal([], ¬µx·	x  Syntax
´	(¶s m· x = MkAf (s, m))
  ²	(¶vars fs· (µy· y ‰g fs ´ y  Syntax) ± x = MkCf (vars, fs))
®);
a (contr_tac);
a (lemma_tac ¬RepClosed (Syntax \ {x})®
	THEN1 (rewrite_tac [get_spec ¬RepClosed®]
		THEN strip_tac));
(* *** Goal "1" *** *)
a (strip_tac THEN strip_tac
	THEN rewrite_tac [repclosed_syntax_thm]);
a (spec_nth_asm_tac 2 ¬s2®);
a (spec_nth_asm_tac 1 ¬m®);
a (swap_nth_asm_concl_tac 1 THEN (SYM_ASMS_T rewrite_tac));
(* *** Goal "2" *** *)
a (REPEAT_N 3 strip_tac);
a (spec_nth_asm_tac 2 ¬vars®);
a (DROP_NTH_ASM_T 2 ante_tac THEN rewrite_tac [get_spec ¬X‰g®]
	THEN strip_tac);
a (lemma_tac ¬µ y· y ‰g fs ´ y  Syntax®
	THEN1 (REPEAT strip_tac THEN all_asm_fc_tac[]));
a (all_fc_tac [rewrite_rule [get_spec ¬X‰g®] repclosed_syntax_thm]);
a (asm_rewrite_tac[]);
a (spec_nth_asm_tac 4 ¬fs®);
(* *** Goal "2.1" *** *)
a (asm_fc_tac[]);
(* *** Goal "2.2" *** *)
a (swap_nth_asm_concl_tac 1 THEN asm_rewrite_tac[]);
(* *** Goal "3" *** *)
a (asm_tac repclosed_syntax_lemma1);
a (spec_nth_asm_tac 1 ¬Syntax \ {x}®);
a (spec_nth_asm_tac 1 ¬x®);
val syntax_disj_thm = save_pop_thm "syntax_disj_thm";

set_goal([], ¬µx· x  Syntax ´ IsAf x ² IsCf x®);
a (REPEAT_N 2 strip_tac THEN fc_tac [syntax_disj_thm]
	THEN asm_rewrite_tac[]);
val syntax_cases_thm = save_pop_thm "syntax_cases_thm";

set_goal([], ¬µx·	x  Syntax
´	(IsAf x ´ ¶s m· x = MkAf (s, m))
±	(IsCf x ´ ¶vars fs· (µy· y ‰g fs ´ y  Syntax) ± x = MkCf (vars, fs))
®);
a (REPEAT_N 2 strip_tac);
a (asm_tac (syntax_disj_thm));
a (asm_fc_tac[] THEN asm_rewrite_tac [Is_clauses]);
(* *** Goal "1" *** *)
a (¶_tac ¬s® THEN ¶_tac ¬m® THEN asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a (¶_tac ¬vars® THEN ¶_tac ¬fs® THEN asm_rewrite_tac[]);
val is_fc_clauses = save_pop_thm "is_fc_clauses";

set_goal([], ¬(µs m· AfSet (MkAf (s, m)) = s)
	±	(µs m· AfMem (MkAf (s, m)) = m)
	±	(µv f· CfVars (MkCf (v, f)) = v)
	±	(µv f· CfForms (MkCf (v, f)) = f)
®);
a (rewrite_tac (map get_spec [
	¬MkAf®, ¬MkCf®,
	¬AfSet®, ¬AfMem®, ¬CfVars®, ¬CfForms®]));
val syn_proj_clauses = save_pop_thm "syn_proj_clauses";

add_pc_thms "'ifos" [syn_proj_clauses];
set_merge_pcs ["hol1", "'GS1", "'misc2", "'ifos"];

set_goal([], ¬µx·	x  Syntax
´	(IsCf x ´ (µy· y ‰g (CfForms x) ´ y  Syntax))
®);
a (REPEAT strip_tac
	THEN all_fc_tac [is_fc_clauses]
	THEN GET_NTH_ASM_T 1 (var_elim_asm_tac o concl)
	THEN_TRY asm_rewrite_tac[]);
a (DROP_NTH_ASM_T 2 (asm_tac o (rewrite_rule[]))
	THEN all_asm_fc_tac[]);
val is_fc_clauses2 = save_pop_thm "is_fc_clauses2";

set_goal([], ¬µx y· ³ MkAf x = MkCf y®);
a (rewrite_tac (map get_spec [¬MkAf®, ¬MkCf®]));
a (contr_tac THEN FC_T (MAP_EVERY ante_tac) [natg_one_one_thm]
	THEN (PC_T1 "lin_arith" rewrite_tac[]));
val syn_con_neq_clauses = save_pop_thm "syn_con_neq_clauses";

add_pc_thms "'ifos" [syn_con_neq_clauses];
set_merge_pcs ["hol1", "'GS1", "'misc2", "'ifos"];

set_goal([], ¬
	(µv f· MkCf (v, f)  Syntax ´ (µy· y ‰g f ´ y  Syntax))®);
a (REPEAT strip_tac
	THEN FC_T (MAP_EVERY (strip_asm_tac o (rewrite_rule []))) [is_fc_clauses2]
	THEN asm_fc_tac[]);
val syn_comp_fc_clauses = save_pop_thm "syn_comp_fc_clauses";

set_goal([], ¬µÁ Ç vars fs· Ç  Syntax ´
		(Ç = MkCf (vars, fs) ± Á ‰g fs) ´ ScPrec Á Ç
®);
a (rewrite_tac [get_spec ¬ScPrec®]);
a (REPEAT µ_tac THEN strip_tac THEN strip_tac);
a (¶_tac ¬vars® THEN ¶_tac ¬fs® THEN asm_rewrite_tac[]);
a (REPEAT strip_tac THEN var_elim_nth_asm_tac 1);
(* *** Goal "1" *** *)
a (var_elim_nth_asm_tac 2);
a (fc_tac [syn_comp_fc_clauses]);
a (asm_fc_tac[]);
(* *** Goal "2" *** *)
a (var_elim_nth_asm_tac 2);
val scprec_fc_clauses = save_pop_thm "scprec_fc_clauses";

set_goal ([], ¬µt· t  Syntax ´ 
	(IsCf t ´ µf· f ‰g CfForms t ´ ScPrec (f) t)®);
a (REPEAT strip_tac
	THEN all_fc_tac [is_fc_clauses]
	THEN DROP_NTH_ASM_T 3 ante_tac
	THEN asm_rewrite_tac[]
	THEN strip_tac
	THEN all_fc_tac [scprec_fc_clauses]
	THEN POP_ASM_T ante_tac
	THEN_TRY asm_rewrite_tac []);
val scprec_fc_clauses2 = save_pop_thm "scprec_fc_clauses2";
=TEX
}%ignore

\subsection{Semantics}

The semantics of infinitary first order logic is given by defining ``truth in an interpretation''.

\subsubsection{Domains}

We consider here some of the value domains which are significant in the semantics.

The following type abbreviations are introduced:

\begin{description}
\item{RV}
Relation Value - this is the type for the meaning of a formula with free variables.
The parameters are the type of the domain of discourse and the type of truth values.
\item{ST}
Structure = a structure is a domain of discourse (a set) together with a binary relation (the membership relation) over that domain.
The membership relation need not (and will not) be boolean.
The parameters are the type of the domain of discourse and the type of truth values.
\end{description}

=SML
declare_type_abbrev (Û"BR"İ, ["'a", "'b"], ”'a ­ 'a ­ 'b®);
declare_type_abbrev("ÛRVİ", ["'a","'b"], ”'a IS ­ 'b®);
declare_type_abbrev("ÛSTİ", ["'a","'b"], ”'a SET ¸ ('a, 'b)BR®);
=TEX

To help in the location of fixed points we want a semantics which is monotonic, and therefore define here orderings on these domains relative to which we expect the sematantics to be monotonic.

The ordering on relations derives from the ordering on the truth values, using the operator {\it Pw}.

¹HOLCONST
Ü ÛRvOİ : ('b ­ 'b ­ BOOL) ­ ('a, 'b) RV ­ ('a, 'b) RV ­ BOOL
÷üüüüüüüüüüü
Ü µr· RvO r = Pw r
°

=GFT
Ûrvo_lubs_exist_thmİ =
	ô µ r· LubsExist r ´ LubsExist (RvO r)

Ûrvo_glbs_exist_thmİ =
	ô µ r· GlbsExist r ´ GlbsExist (RvO r)
=TEX

\ignore{
=SML
set_goal([], ¬µr· LubsExist r ´ LubsExist (RvO r)®);
a (REPEAT strip_tac
	THEN rewrite_tac [get_spec ¬RvO®]
	THEN REPEAT_N 2 (bc_tac [pw_lubs_exist_thm])
	THEN strip_tac);
val rvo_lubs_exist_thm = save_pop_thm "rvo_lubs_exist_thm";

set_goal([], ¬µr· GlbsExist r ´ GlbsExist (RvO r)®);
a (REPEAT strip_tac
	THEN rewrite_tac [get_spec ¬RvO®]
	THEN REPEAT_N 2 (bc_tac [pw_glbs_exist_thm])
	THEN strip_tac);
val rvo_glbs_exist_thm = save_pop_thm "rvo_glbs_exist_thm";
=TEX
}%ignore

¹HOLCONST
Ü ÛRvIsOİ : ('b ­ 'b ­ BOOL) ­ ('a, 'b) RV IS ­ ('a, 'b) RV IS ­ BOOL
÷üüüüüüüüüüü
Ü µr· RvIsO r = IsEO (RvO r)
°

=GFT
Ûrviso_lubs_exist_thmİ =
	ô µ r· LubsExist r ´ LubsExist (RvIsO r)

Ûrviso_glbs_exist_thmİ =
	ô µ r· GlbsExist r ´ GlbsExist (RvIsO r)
=TEX

\ignore{
=SML
set_goal([], ¬µr· LubsExist r ´ LubsExist (RvIsO r)®);
a (REPEAT strip_tac
	THEN rewrite_tac [get_spec ¬RvIsO®]
	THEN bc_tac [is_lubs_exist_thm]
	THEN bc_tac [rvo_lubs_exist_thm]
	THEN strip_tac);
val rviso_lubs_exist_thm = save_pop_thm "rviso_lubs_exist_thm";

set_goal([], ¬µr· GlbsExist r ´ GlbsExist (RvIsO r)®);
a (REPEAT strip_tac
	THEN rewrite_tac [get_spec ¬RvIsO®]
	THEN bc_tac [is_glbs_exist_thm]
	THEN bc_tac [rvo_glbs_exist_thm]
	THEN strip_tac);
val rviso_glbs_exist_thm = save_pop_thm "rviso_glbs_exist_thm";
=TEX
}%ignore

¹HOLCONST
Ü ÛStOİ : ('b ­ 'b ­ BOOL) ­ ('a, 'b) ST ­ ('a, 'b) ST ­ BOOL
÷üüüüüüüüüüü
Ü µr· StO r = DerivedOrder Snd (Pw (Pw r))
°

=GFT
Ûsto_lubs_exist_thmİ =
	ô µ r· LubsExist r ´ LubsExist (StO r)

Ûsto_glbs_exist_thmİ =
	ô µ r· GlbsExist r ´ GlbsExist (StO r)
=TEX

\ignore{
=SML
set_goal([], ¬µr· LubsExist r ´ LubsExist (StO r)®);
a (REPEAT strip_tac
	THEN rewrite_tac [get_spec ¬StO®]
	THEN bc_tac [lubsexist_dosnd_thm]
	THEN bc_tac [pw_lubs_exist_thm]
	THEN bc_tac [pw_lubs_exist_thm]
	THEN strip_tac);
val sto_lubs_exist_thm = save_pop_thm "sto_lubs_exist_thm";

set_goal([], ¬µr· GlbsExist r ´ GlbsExist (StO r)®);
a (REPEAT strip_tac
	THEN rewrite_tac [get_spec ¬StO®]
	THEN bc_tac [glbsexist_dosnd_thm]
	THEN bc_tac [pw_glbs_exist_thm]
	THEN bc_tac [pw_glbs_exist_thm]
	THEN strip_tac);
val sto_glbs_exist_thm = save_pop_thm "sto_glbs_exist_thm";
=TEX
}%ignore

\subsubsection{Formula Evaluation}

Now we define the evaluation of formulae, i.e. the notion of truth in a structure given a variable assignment.

There are two cases in the syntax, atomic and compound formulae.

The truth values of the atomic formulae (which are all membership claims) are obtained from a structure given the values of the arguments, which are always variables, i.e. to evaluate an atomic formula you look up the values of the arguments in the current context (variable assignment) and then look up the truth value of the membership relation for those arguments in the structure.
Note that this specification is generic in the type of truth values.

¹HOLCONST
Ü ÛEvalAfİ : 't REL ­ GS ­ ('a, 't) ST ­ ('a, 't) RV
÷üüüüüüüüüüü
Ü µ$¼‰t (at:GS) (st:('a, 't) ST) (va:'a IS)· EvalAf $¼‰t at st va =
Ü	let set = AfSet at
Ü	and mem = AfMem at
Ü	in 
Ü		let rv = (Snd st)
Ü		in rv (IsVal va set) (IsVal va mem)
°

To evaluate a compound formula you must first evaluate the constituent formulae in every context obtainable by modification of those variables which are bound by the compound formula.
You need only remember the resulting truth values, the compound formulae are in this sense ``truth functional'', and, though this may involve evaluating a very large number of instances of subformulae, it can only yield some subset of the available truth values.

The definition of the truth function depends upon the type of truth values, and is therefore a parameter of the semantics.

The relevant definitions for three and four valued truth types are given here.

=SML
declare_type_abbrev(Û"CFE"İ, ["'t"], ”'t SET ­ 't®);
=TEX

¹HOLCONST
Ü ÛEvalCf_tf3İ : TTV CFE
÷üüüüüüüüüüü
Ü µresults· EvalCf_tf3 results = 
Ü	if results € {pTrue} then pFalse
Ü		else if (pFalse)  results then pTrue
Ü		else pU
°

¹HOLCONST
Ü ÛEvalCf_tf4İ : FTV CFE
÷üüüüüüüüüüü
Ü µresults· EvalCf_tf4 results = 
Ü	if results € {fTrue} then fFalse
Ü		else if results € {fTrue; fB} then fB
Ü		else if fT  results then fT else fTrue
°

This definition shows how the set of truth values of instances of the constituents is obtained from the denotations of the constituent formulae.

¹HOLCONST
Ü ÛEvalCfİ : 't CFE ­ GS ­ ('a, 't) ST ­ ('a, 't) RV SET ­ ('a, 't) RV
÷üüüüüüüüüüü
Ü µetf f· EvalCf etf f = Ìst rvs va· 
Ü	let Î = CfVars f
Ü	and V = Fst st
Ü	in etf {pb | ¶rv v·
Ü		  rv  rvs
Ü		± IsDom v = X‰g Î
Ü		± IsRan v € V
Ü		± pb = rv (IsOverRide v va)}
°

Now we define a parameterised functor of which the semantic function is a fixed point.

¹HOLCONST
Ü ÛEvalFormFunctİ : 't CFE ¸ 't REL ¸ ('a, 't) ST ­ (GS ­ ('a, 't) RV) ­ (GS ­ ('a, 't) RV)
÷üüüüüüüüüüü
Ü µcfe $¼‰t st· EvalFormFunct (cfe, $¼‰t, st) = Ìef f·
Ü	if f  Syntax
Ü	then if IsAf f
Ü	     then EvalAf $¼‰t f st
Ü	     else
Ü		if IsCf f
Ü		then let rvs = FunImage ef (X‰g(CfForms f))
Ü		     in  EvalCf cfe f st rvs
Ü		else Åx·T
Ü	else Åx·T
°

The semantics of formulae is then given by:

¹HOLCONST
Ü ÛEvalFormİ : 't CFE ¸ 't REL ¸ ('a, 't) ST ­ GS ­ ('a, 't) RV
÷üüüüüüüüüüü
Ü µcfe $¼‰t st· EvalForm (cfe, $¼‰t, st) = fix (EvalFormFunct (cfe, $¼‰t, st))
°

To use this definition we need to show that there exists a fixed point, for which we must show that the functor respects some well-founded relation.

=GFT
Ûevalformfunct_respect_thmİ =
   ô µ cfe ¼‰t st· EvalFormFunct (cfe, ¼‰t, st) respects ScPrec

Ûevalformfunct_fixp_lemmaİ =
   ô µ cfe ¼‰t st
     · EvalForm (cfe, ¼‰t, st)
         = EvalFormFunct (cfe, ¼‰t, st) (EvalForm (cfe, ¼‰t, st))

Ûevalformfunct_thmİ =
   ô µ cfe ¼‰t st
     · EvalForm (cfe, ¼‰t, st)
         = (Ì f
         · if f  Syntax
           then
             if IsAf f
             then EvalAf ¼‰t f st
             else if IsCf f
             then
               let rvs = FunImage (EvalForm (cfe, ¼‰t, st)) (X‰g (CfForms f))
               in EvalCf cfe f st rvs
             else Å x· T
           else Å x· T)

Ûevalformfunct_thm2İ =
   ô µ cfe ¼‰t st f
     · EvalForm (cfe, ¼‰t, st) f
         = (if f  Syntax
           then
             if IsAf f
             then EvalAf ¼‰t f st
             else if IsCf f
             then
               let rvs = FunImage (EvalForm (cfe, ¼‰t, st)) (X‰g (CfForms f))
               in EvalCf cfe f st rvs
             else Å f· T
           else Å f· T)
=TEX

\ignore{
=SML
set_merge_pcs ["hol", "'GS1", "'misc2", "'ifos"];

set_goal([], ¬µcfe $¼‰t st· (EvalFormFunct (cfe, $¼‰t, st)) respects ScPrec®);
a (rewrite_tac [get_spec ¬EvalFormFunct®, get_spec ¬$respects®]
	THEN REPEAT strip_tac);
a (cases_tac ¬IsAf x® THEN asm_rewrite_tac[]);
a (cases_tac ¬IsCf x® THEN asm_rewrite_tac[]);
a (cases_tac ¬x  Syntax® THEN asm_rewrite_tac[]);
a (lemma_tac ¬FunImage g (X‰g (CfForms x)) = FunImage h (X‰g (CfForms x))®
	THEN_TRY asm_rewrite_tac[get_spec ¬X‰g®]);
a (PC_T1 "hol1" rewrite_tac [get_spec ¬FunImage®]
	THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a (all_fc_tac [scprec_fc_clauses2]);
a (all_asm_fc_tac[tc_incr_thm]);
a (all_asm_fc_tac[]);
a (¶_tac ¬a® THEN asm_rewrite_tac[]);
a (POP_ASM_T (fn x => rewrite_thm_tac (eq_sym_rule x)));
a (asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a (all_fc_tac [scprec_fc_clauses2]);
a (all_asm_fc_tac[tc_incr_thm]);
a (all_asm_fc_tac[]);
a (¶_tac ¬a® THEN asm_rewrite_tac[]);
val evalformfunct_respect_thm = save_pop_thm "evalformfunct_respect_thm";

set_goal([], ¬µcfe $¼‰t st· EvalForm (cfe, $¼‰t, st) = EvalFormFunct (cfe, $¼‰t, st) (EvalForm (cfe, $¼‰t, st))®);
a (asm_tac well_founded_ScPrec_thm);
a (asm_tac evalformfunct_respect_thm);
a (REPEAT µ_tac);
a (list_spec_nth_asm_tac 1 [¬cfe®, ¬$¼‰t®, ¬st®]);
a (all_fc_tac [µ_elim ¬ScPrec® (µ_elim ¬EvalFormFunct (cfe, $¼‰t, st)® (get_spec ¬fix®))]);
a (rewrite_tac [get_spec ¬EvalForm®]);
a (asm_rewrite_tac[]);
val evalformfunct_fixp_lemma = save_pop_thm "evalformfunct_fixp_lemma";

val evalformfunct_thm = save_thm ("evalformfunct_thm",
	rewrite_rule [get_spec ¬EvalFormFunct®] evalformfunct_fixp_lemma);

set_goal([], ¬µ cfe $¼‰t st f
     · EvalForm (cfe, $¼‰t, st) f
         = if f  Syntax
             then
               if IsAf f
               then EvalAf $¼‰t f st
               else if IsCf f
               then
                 let rvs = FunImage (EvalForm (cfe, $¼‰t, st)) (X‰g (CfForms f))
                 in EvalCf cfe f st rvs
               else Å f· T
             else Å f· T®);
a (REPEAT strip_tac THEN rewrite_tac[rewrite_rule [](once_rewrite_rule [ext_thm] evalformfunct_thm)]);
val evalformfunct_thm2 = save_pop_thm "evalformfunct_thm2";
=TEX
}%ignore

\subsubsection{Some Orderings}

We will be looking for fixed points of the semantics and one approach to this is to take greatest of least fixed points over various subdomains of the formulae of this set theory.
This is why we are working with non-standard truth value types, so that we can arrange for the semantics to be monotonic relative to orderings derived from that on the truth values.

In order to prove that the semantics is monotonic, we must first define the partial orderings relative to which the semantics is monotonic, and we must obtain fixpoint theorems for the orderings.

We have at present two cases under consideration, according to whether three or four truth values are adopted.

The three valued case turns out in some respects more complex than the four valued case, because it is necessary to make do with chain completeness and the fixed point theorem is more difficult to prove (though in fact the proof has been completed).
I will therefore progress only the four valued case until I find a reason to further progress the three valued case.

Here is the beginning of the three valued case which I started before.

It is also necessary to prove that these partial orderings are CCPOs (chain complete partial orders), this being the weakest condition for which we have a suitable fixed point theorem.
It is convenient to be slightly more definite, to make the orderings all reflexive, and show that they are reflexive CCPOs (for which we use the term CCRPO).

The following ordering is applicable to partial relations.

=SML
declare_infix(300, "¼‰f‰t‰3");
=TEX

¹HOLCONST
Ü Û$¼‰f‰t‰3İ : ('a ­ TTV) ­ ('a ­ TTV) ­ BOOL
÷üüüüüüüüüüü
Ü $¼‰f‰t‰3 = Pw $¼‰t‰3
°

=GFT
Ûccrpou_¼‰f‰t‰3_thmİ =
	ô CcRpoU $¼‰f‰t‰3
=TEX

\ignore{
=SML
set_goal([], ¬CcRpoU $¼‰f‰t‰3®);
a (rewrite_tac [get_spec ¬$¼‰f‰t‰3®]);
a (asm_tac ccrpou_¼‰t‰3_thm);
a (fc_tac [pw_ccrpou_thm]);
val ccrpou_¼‰f‰t‰3_thm = save_pop_thm "ccrpou_¼‰f‰t‰3_thm";
=TEX
}%ignore

Lets now get on with the four valued case.

=SML
declare_infix(300, "¼‰f‰t‰4");
=TEX

¹HOLCONST
Ü Û$¼‰f‰t‰4İ : ('a ­ FTV) ­ ('a ­ FTV) ­ BOOL
÷üüüüüüüüüüü
Ü $¼‰f‰t‰4 = Pw $¼‰t‰4
°

=GFT
Ûccrpou_¼‰f‰t‰4_thmİ =
	ô  $¼‰f‰t‰4
=TEX

\ignore{
=IGN
set_goal([], ¬CcRpoU $¼‰f‰t‰3®);
a (rewrite_tac [get_spec ¬$¼‰f‰t‰3®]);
a (asm_tac ccrpou_¼‰t‰3_thm);
a (fc_tac [pw_ccrpou_thm]);
val ccrpou_¼‰f‰t‰3_thm = save_pop_thm "ccrpou_¼‰f‰t‰3_thm";
=TEX
}%ignore


=GFT
Ûevalcf_tf4_increasing_lemmaİ =
   ô Increasing (SetO $¼‰t‰4) $¼‰t‰4 EvalCf_tf4
=TEX

\ignore{
=SML
set_goal([], ¬Increasing (SetO $¼‰t‰4) $¼‰t‰4 EvalCf_tf4®);
a (rewrite_tac (map get_spec [¬Increasing®, ¬SetO®, ¬$¼‰t‰4®, ¬EvalCf_tf4®]));
a (REPEAT_N 3 strip_tac THEN_TRY asm_rewrite_tac[]);
a (cases_tac ¬y € {fTrue}® THEN_TRY asm_rewrite_tac[]);
(* *** Goal "1" *** *)
a (cases_tac ¬x € {fTrue}® THEN_TRY asm_rewrite_tac[]);
a (POP_ASM_T (strip_asm_tac o (pc_rule1 "hol1" rewrite_rule[])));
a (all_asm_fc_tac[]);
(* *** Goal "1.1" *** *)
a (var_elim_asm_tac ¬x' = y'®);
a (DROP_NTH_ASM_T 4 (strip_asm_tac o (pc_rule1 "hol1" rewrite_rule[])));
a (all_asm_fc_tac[]);
(* *** Goal "1.2" *** *)
a (var_elim_asm_tac ¬x' = fB® THEN_TRY asm_rewrite_tac[]);
a (cases_tac ¬x € {fTrue; fB}® THEN_TRY asm_rewrite_tac[]);
a (POP_ASM_T (strip_asm_tac o (pc_rule1 "hol1" rewrite_rule[])));
a (strip_asm_tac (µ_elim ¬x'® ftv_cases_thm)
	THEN	var_elim_nth_asm_tac 1);
(* *** Goal "1.2.1" *** *)
a (spec_nth_asm_tac 9 ¬fFalse®);
(* *** Goal "1.2.1.1" *** *)
a (lemma_tac ¬fFalse  y®
	THEN1 (asm_rewrite_tac[]));
a (DROP_NTH_ASM_T 10 (strip_asm_tac o (pc_rule1 "hol1" rewrite_rule[])));
a (all_asm_fc_tac[]);
(* *** Goal "1.2.1.2" *** *)
a (lemma_tac ¬fT  y®
	THEN1 (SYM_ASMS_T rewrite_tac));
a (DROP_NTH_ASM_T 10 (strip_asm_tac o (pc_rule1 "hol1" rewrite_rule[])));
a (all_asm_fc_tac[]);
(* *** Goal "1.2.2" *** *)
a (spec_nth_asm_tac 9 ¬fT®);
(* *** Goal "1.2.2.1" *** *)
a (lemma_tac ¬fT  y®
	THEN1 (asm_rewrite_tac[]));
a (DROP_NTH_ASM_T 10 (strip_asm_tac o (pc_rule1 "hol1" rewrite_rule[])));
a (all_asm_fc_tac[]);
(* *** Goal "1.2.2.2" *** *)
a (lemma_tac ¬fT  y®
	THEN1 (SYM_ASMS_T rewrite_tac));
a (DROP_NTH_ASM_T 10 (strip_asm_tac o (pc_rule1 "hol1" rewrite_rule[])));
a (all_asm_fc_tac[]);
(* *** Goal "1.3" *** *)
a (var_elim_asm_tac ¬y' = fT® THEN_TRY asm_rewrite_tac[]);
a (cases_tac ¬x € {fTrue; fB}® THEN_TRY asm_rewrite_tac[]);
a (POP_ASM_T (strip_asm_tac o (pc_rule1 "hol1" rewrite_rule[])));
a (strip_asm_tac (µ_elim ¬x''® ftv_cases_thm)
	THEN	var_elim_nth_asm_tac 1);
(* *** Goal "1.3.1" *** *)
a (spec_nth_asm_tac 9 ¬fFalse®);
(* *** Goal "1.3.1.1" *** *)
a (lemma_tac ¬fFalse  y®
	THEN1 (asm_rewrite_tac[]));
a (DROP_NTH_ASM_T 10 (strip_asm_tac o (pc_rule1 "hol1" rewrite_rule[])));
a (all_asm_fc_tac[]);
(* *** Goal "1.3.1.2" *** *)
a (DROP_NTH_ASM_T 9 (strip_asm_tac o (pc_rule1 "hol1" rewrite_rule[])));
a (all_asm_fc_tac[]);
(* *** Goal "1.3.2" *** *)
a (DROP_NTH_ASM_T 7 (strip_asm_tac o (pc_rule1 "hol1" rewrite_rule[])));
a (all_asm_fc_tac[]);
(* *** Goal "2" *** *)
a (cases_tac ¬x € {fTrue}® THEN_TRY asm_rewrite_tac[]);
(* *** Goal "2.1" *** *)
a (cases_tac ¬y € {fTrue; fB}® THEN_TRY asm_rewrite_tac[]);
(* *** Goal "2.1.1" *** *)
a (lemma_tac ¬fB  y®
	THEN1 (GET_NTH_ASM_T 1 ante_tac
		THEN GET_NTH_ASM_T 3 ante_tac
		THEN PC_T1 "hol1" rewrite_tac[]
		THEN REPEAT strip_tac
		THEN asm_fc_tac[]
		THEN var_elim_nth_asm_tac 1));
a (spec_nth_asm_tac 5 ¬fB®);
(* *** Goal "2.1.1.1" *** *)
a (DROP_NTH_ASM_T 5 (strip_asm_tac o (pc_rule1 "hol1" rewrite_rule[])));
a (var_elim_nth_asm_tac 2 THEN asm_fc_tac []);
(* *** Goal "2.1.2" *** *)
a (cases_tac ¬fT  y® THEN asm_rewrite_tac[]);
a (lemma_tac ¬fFalse  y®);
(* *** Goal "2.1.2.1" *** *)
a (GET_NTH_ASM_T 2 ante_tac THEN (PC_T1 "hol1" rewrite_tac[])
	THEN strip_tac);
a (strip_asm_tac (µ_elim ¬x'® ftv_cases_thm)
	THEN	var_elim_nth_asm_tac 1);
(* *** Goal "2.1.2.2" *** *)
a (spec_nth_asm_tac 6 ¬fFalse®);
(* *** Goal "2.1.2.2.1" *** *)
a (GET_NTH_ASM_T 6 ante_tac THEN (PC_T1 "hol1" rewrite_tac[])
	THEN contr_tac);
a (var_elim_nth_asm_tac 2
	THEN all_asm_fc_tac[]);
(* *** Goal "2.1.2.2.2" *** *)
a (var_elim_nth_asm_tac 1);
a (DROP_NTH_ASM_T 5 (strip_asm_tac o (pc_rule1 "hol1" rewrite_rule[])));
a (asm_fc_tac[]);
(* *** Goal "2.2" *** *)
a (cases_tac ¬y € {fTrue; fB}® THEN_TRY asm_rewrite_tac[]);
(* *** Goal "2.2.1" *** *)
a (lemma_tac ¬fB  y®
	THEN1 (GET_NTH_ASM_T 1 ante_tac
		THEN GET_NTH_ASM_T 3 ante_tac
		THEN PC_T1 "hol1" rewrite_tac[]
		THEN REPEAT strip_tac
		THEN asm_fc_tac[]
		THEN var_elim_nth_asm_tac 1));
a (cases_tac ¬x € {fTrue; fB}® THEN asm_rewrite_tac[]);
(* *** Goal "2.2.1.1" *** *)
a (DROP_NTH_ASM_T 1 (strip_asm_tac o (pc_rule1 "hol1" rewrite_rule[])));
a (strip_asm_tac (µ_elim ¬x'® ftv_cases_thm)
	THEN	var_elim_nth_asm_tac 1);
a (spec_nth_asm_tac 9 ¬fFalse®);
(* *** Goal "2.2.1.1.1" *** *)
a (lemma_tac ¬fFalse  y®
	THEN1 asm_rewrite_tac[]);
a (DROP_NTH_ASM_T 8 (strip_asm_tac o (pc_rule1 "hol1" rewrite_rule[])));
a (spec_nth_asm_tac 1 ¬fFalse®);
(* *** Goal "2.2.1.1.2" *** *)
a (var_elim_nth_asm_tac 1);
a (DROP_NTH_ASM_T 6 (strip_asm_tac o (pc_rule1 "hol1" rewrite_rule[])));
a (spec_nth_asm_tac 1 ¬fT®);
(* *** Goal "2.2.1.2" *** *)
a (DROP_NTH_ASM_T 5 (strip_asm_tac o (pc_rule1 "hol1" rewrite_rule[])));
a (spec_nth_asm_tac 1 ¬fT®);
a (spec_nth_asm_tac 10 ¬fT®);
(* *** Goal "2.2.1.2.1" *** *)
a (DROP_NTH_ASM_T 3 ante_tac THEN asm_rewrite_tac[]);
(* *** Goal "2.2.1.2.2" *** *)
a (DROP_NTH_ASM_T 2 ante_tac THEN asm_rewrite_tac[]);
(* *** Goal "2.2.2" *** *)
a (cases_tac ¬x € {fTrue; fB}® THEN_TRY asm_rewrite_tac[]);
a (cases_tac ¬fT  y® THEN_TRY asm_rewrite_tac[]);
a (cases_tac ¬fT  x® THEN_TRY asm_rewrite_tac[]);
a (spec_nth_asm_tac 8 ¬fT®);
(* *** Goal "2.2.2.1" *** *)
a (DROP_NTH_ASM_T 4 ante_tac THEN asm_rewrite_tac[]);
(* *** Goal "2.2.2.2" *** *)
a (DROP_NTH_ASM_T 2 ante_tac THEN asm_rewrite_tac[]);
val evalcf_tf4_increasing_lemma = save_pop_thm "evalcf_tf4_increasing_lemma";
=TEX
}%ignore

\subsubsection{Monotonicity}

=GFT
Ûevalaf_increasing_lemmaİ =
   ô µ tr g· CRpoU tr ´ Increasing (StO tr) (RvO tr) (EvalAf tr g)
=TEX

\ignore{
=SML
set_goal([], ¬µ tr g· CRpoU tr ´ Increasing (StO tr) (RvO tr) (EvalAf tr g)®);
a (rewrite_tac (map get_spec [¬Increasing®, ¬EvalAf®, ¬StO®, ¬RvO®,
	¬Pw®, ¬DerivedOrder®, ¬IsEO®, ¬DpoEO®, ¬dpoUdef®, ¬dpoOdef®])
	THEN REPEAT strip_tac);
a (rewrite_tac [let_def]);
a (spec_nth_asm_tac 1 ¬AfRel g® THEN_TRY asm_rewrite_tac[]);
val evalaf_increasing_lemma = pop_thm();
=TEX
}%ignore

To get a monotonicity result for the semantics of first order logic it is necessary to adjust the type of the semantic function.

The function which we wish to be monotonic is the mapping for each fixed domain of discourse and each particular formula, which take a membership structure (an interpretation of set theory over the gived domain) and returns the relation represented by the formula in that context.

The following function accepts one compound argument containing the relevent context and yields a function which we expect to be monotonic:

¹HOLCONST
Ü ÛMonoEvalFormİ : 't CFE ¸ 't REL ¸ 'a SET ¸ GS ­ ('a, 't) BR ­ ('a, 't) RV
÷üüüüüüüüüüü
Ü µc r s g ris· MonoEvalForm (c, r, s, g) ris = EvalForm (c, r, (s, ris)) g
°

=GFT
Ûmonoevalform_increasing_lemmaİ =
   ô µ c r s g
     · CRpoU r ± Increasing (SetO r) r c
         ´ Increasing (Pw (Pw r)) (RvO r) (MonoEvalForm (c, r, s, g))

Ûevalform_increasing_thmİ =
   ô µ c r s g
     · CRpoU r ± Increasing (SetO r) r c
         ´ Increasing (Pw (Pw r)) (RvO r) (Ì ris· EvalForm (c, r, s, ris) g)
=TEX

\ignore{
=SML
set_goal ([], ¬µc r s g· CRpoU r ± Increasing (SetO r) r c
	´ Increasing (Pw (Pw r)) (RvO r) (MonoEvalForm (c,r,s,g))®);
a (REPEAT strip_tac);
a (sc_induction_tac ¬g® THEN_TRY asm_rewrite_tac[]);
a (rewrite_tac ((map get_spec [¬Increasing®, ¬MonoEvalForm®, ¬RvO®, ¬RvIsO®])@[evalformfunct_thm2])
	THEN REPEAT strip_tac);
a (cases_tac ¬t  Syntax® THEN asm_rewrite_tac[]);
(* *** Goal "1" *** *)
a (cases_tac ¬IsAf t® THEN asm_rewrite_tac[]);
(* *** Goal "1.1" *** *)
a (fc_tac [inst_type_rule [(”'a®, ”'b®), (”'b®, ”'a®)] evalaf_increasing_lemma]);
a (spec_nth_asm_tac 1 ¬t® THEN fc_tac [get_spec ¬Increasing®]);
a (POP_ASM_T ante_tac THEN rewrite_tac [get_spec¬StO®,get_spec¬RvO®,
	get_spec ¬DerivedOrder®] THEN strip_tac);
a (LIST_SPEC_NTH_ASM_T 1 [¬(s,x)®, ¬(s,y)®] ante_tac
	THEN rewrite_tac[]
	THEN strip_tac);
(* *** Goal "1.2" *** *)
a (cases_tac ¬IsCf t® THEN asm_rewrite_tac[]);
(* *** Goal "1.2.1" *** *)
a (rewrite_tac ((map get_spec [¬Pw®, ¬X‰g®, ¬EvalCf®])@[let_def]));
a (strip_tac THEN FC_T bc_tac [get_spec ¬Increasing®]);
a (rewrite_tac [get_spec ¬SetO®] THEN REPEAT strip_tac);
(* *** Goal "1.2.1.1" *** *)
a (GET_NTH_ASM_T 4 (strip_asm_tac o (rewrite_rule [get_spec ¬FunImage®])));
a (¶_tac ¬EvalForm (c, r, s, y) a (IsOverRide v x')®
	THEN strip_tac);
(* *** Goal "1.2.1.1.1" *** *)
a (¶_tac ¬EvalForm (c, r, s, y) a®);
a (¶_tac ¬v® THEN asm_rewrite_tac[get_spec ¬FunImage®]);
a (¶_tac ¬a® THEN asm_rewrite_tac[]);
(* *** Goal "1.2.1.1.2" *** *)
a (asm_rewrite_tac[]);
a (GET_NTH_ASM_T 1 (rewrite_thm_tac o eq_sym_rule));
a (lemma_tac ¬tc ScPrec a t®);
(* *** Goal "1.2.1.1.2.1" *** *)
a (fc_tac [scprec_fc_clauses]);
a (all_fc_tac [is_fc_clauses2]);
a (all_fc_tac [scprec_fc_clauses2]);
a (fc_tac [tc_incr_thm]);
(* *** Goal "1.2.1.1.2.2" *** *)
a (all_asm_fc_tac[]);
a (fc_tac[get_spec ¬Increasing®]);
a (GET_NTH_ASM_T 1 ante_tac THEN rewrite_tac [get_spec ¬RvIsO®, get_spec ¬RvO®]
	THEN STRIP_T (fn x => fc_tac[x]));
a (POP_ASM_T ante_tac THEN rewrite_tac [get_spec ¬MonoEvalForm®, get_spec ¬Pw®]
	THEN STRIP_T rewrite_thm_tac);
(* *** Goal "1.2.1.2" *** *)
a (GET_NTH_ASM_T 4 (strip_asm_tac o (rewrite_rule [get_spec ¬FunImage®])));
a (¶_tac ¬EvalForm (c, r, s, x) a (IsOverRide v x')®
	THEN strip_tac);
(* *** Goal "1.2.1.2.1" *** *)
a (¶_tac ¬EvalForm (c, r, s, x) a®);
a (¶_tac ¬v® THEN asm_rewrite_tac[get_spec ¬FunImage®]);
a (¶_tac ¬a® THEN asm_rewrite_tac[]);
(* *** Goal "1.2.1.2.2" *** *)
a (asm_rewrite_tac[]);
a (GET_NTH_ASM_T 1 (rewrite_thm_tac o eq_sym_rule));
a (lemma_tac ¬tc ScPrec a t®);
(* *** Goal "1.2.1.2.2.1" *** *)
a (fc_tac [scprec_fc_clauses]);
a (all_fc_tac [is_fc_clauses2]);
a (all_fc_tac [scprec_fc_clauses2]);
a (fc_tac [tc_incr_thm]);
(* *** Goal "1.2.1.2.2.2" *** *)
a (all_asm_fc_tac[]);
a (fc_tac[get_spec ¬Increasing®]);
a (GET_NTH_ASM_T 1 ante_tac THEN rewrite_tac [get_spec ¬RvIsO®, get_spec ¬RvO®]
	THEN STRIP_T (fn x => fc_tac[x]));
a (POP_ASM_T ante_tac THEN rewrite_tac [get_spec ¬MonoEvalForm®, get_spec ¬Pw®]
	THEN STRIP_T rewrite_thm_tac);
(* *** Goal "1.2.2" *** *)
a (fc_tac [inst_type_rule [(”'a®, ”'b®), (”GS ­ 'b DPO®, ”'a®)] pw_crpou_thm]);
a (fc_tac [crpou_fc_clauses] THEN asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a (fc_tac [inst_type_rule [(”'a®, ”'b®), (”GS ­ 'b DPO®, ”'a®)] pw_crpou_thm]);
a (fc_tac [crpou_fc_clauses] THEN asm_rewrite_tac[]);
val monoevalform_increasing_lemma = pop_thm ();

set_goal([], ¬µ c r s g
     · CRpoU r ± Increasing (SetO r) r c
         ´ Increasing (Pw (Pw r)) (RvO r) (Ìris·EvalForm (c, r, s, ris) g)®);
a (REPEAT µ_tac);
a (lemma_tac ¬(Ìris·EvalForm (c, r, s, ris) g) = MonoEvalForm (c, r, s, g)®
	THEN1 rewrite_tac [ext_thm, get_spec ¬MonoEvalForm®]);
a (asm_rewrite_tac[monoevalform_increasing_lemma]);
val evalform_increasing_thm = save_pop_thm "evalform_increasing_thm";
=TEX
}%ignore

\subsubsection{Proof Contexts}

=SML
add_pc_thms "'ifos" [];
commit_pc "'ifos";

force_new_pc "Ûifosİ";
merge_pcs ["hol", "'GS1", "'misc2", "'ifos"] "ifos";
commit_pc "ifos";

force_new_pc "Ûifos1İ";
merge_pcs ["hol1", "'GS1", "'misc2", "'ifos"] "ifos1";
commit_pc "ifos1";
=TEX

\newpage
\section{SEMANTIC FIXED POINTS}

We now look for fixed points of the semantics of infinitary set theory.

=SML
open_theory "ifos";
force_new_theory "Ûsfpİ";
force_new_pc Û"'sfp"İ;
merge_pcs ["'savedthm_cs_¶_proof"] "'sfp";
set_merge_pcs ["hol1", "'GS1", "'misc2", "'ifos", "'sfp"];
=TEX

\subsection{The Semantic Functor}

First we use the semantics above to define a functor which transforms membership relations.

The input membership relation is that in the membership structure relative to which the semantics is defined.

The output membership relation is obtained by considering the sets determined by formulae whose sole free variable is the empty set.
Thus. under this resulting membership relation, (which will be a four-valued relation) the truth value of the claim that {\it m} is a member of {\it s} (where {\it m} and {\it s} are elements of the domain of discourse, which is sets coding formulae of infinitary first order set theory) is the value under the semantics for the formulae coded by {\it s} in the context of the variable assignment in which only the variable coded by the empty set is assigned a value and that value is {\it t}.

The following function creates a variable assignment with just a value for the empty set.

¹HOLCONST
Ü ÛParam_šİ : GS ­ GS IS
÷üüüüüüüüüüü
Ü µp· Param_š p = Ìx· if x = š‰g then dpoE p else dpoB
°

¹HOLCONST
Ü ÛSemanticFunctorİ: GS SET ­ (GS, FTV) BR ­ (GS, FTV) BR
÷üüüüüüüüü
Ü µ d $‰v· SemanticFunctor d $‰v =
	Ìs m· EvalForm (EvalCf_tf4, $¼‰t‰4, (d, $‰v)) s (Param_š m)
°

=GFT
Ûsemanticfunctor_increasing_thmİ =
   ô µ d· Increasing (Pw (Pw $¼‰t‰4)) (Pw (Pw $¼‰t‰4)) (SemanticFunctor d)
=TEX

\ignore{
=SML
set_goal([], ¬µd· Increasing (Pw (Pw $¼‰t‰4)) (Pw (Pw $¼‰t‰4)) (SemanticFunctor d)®);
a (strip_tac THEN LEMMA_T
	¬SemanticFunctor d = (Ìr s m· r s (Param_š m)) o (Ì$‰v· EvalForm (EvalCf_tf4, $¼‰t‰4, (d, $‰v)))®
	rewrite_thm_tac
	THEN1 rewrite_tac [get_spec ¬SemanticFunctor®]);
a (bc_tac [increasing_funcomp_thm]);
a (¶_tac ¬Pw (Pw $¼‰t‰4)® THEN strip_tac);
(* *** Goal "1" *** *)
a (rewrite_tac [get_spec ¬Increasing®]);
a (REPEAT strip_tac);
a (asm_tac ¼‰t‰4_crpou_thm);
a (asm_tac evalcf_tf4_increasing_lemma);
a (ALL_FC_T (MAP_EVERY (fn t => fc_tac [(rewrite_rule
	[get_spec ¬Increasing®, get_spec ¬RvO®] t)])) [evalform_increasing_thm]);
a (POP_ASM_T (asm_tac o (rewrite_rule [get_spec ¬Pw®])));
a (asm_rewrite_tac [get_spec ¬Pw®]);
(* *** Goal "2" *** *)
a (rewrite_tac [get_spec ¬Increasing®, get_spec ¬Pw®, get_spec ¬Param_š®]
	THEN REPEAT strip_tac
	THEN asm_rewrite_tac[]);
val semanticfunctor_increasing_thm = save_pop_thm "semanticfunctor_increasing_thm";
=TEX
}%ignore

\subsection{Properties of Fixed Points}

The first property of interest concerns the conditions under which a fixed point of the semantic functor yields an extensional model of set theory.

I suppose we might start by saying what a fixed point is:

¹HOLCONST
Ü ÛSFFixpİ : GS SET ­ (GS, FTV)BR ­ BOOL
÷üüüüüüüüüüü
Ü µd r· SFFixp d r ¤ SemanticFunctor d r = r
°

I am interested in interpretations of classical two-valued set theory and therefore will consider only fixed points which are total over the domain.

¹HOLCONST
Ü ÛTotalOverİ : 'a SET ­ ('a, FTV)BR ­ BOOL
÷üüüüüüüüüüü
Ü µ V r· TotalOver V r ¤ µx y·
Ü	if x  V ± y  V
Ü	then r x y = fTrue ² r x y = fFalse
Ü	else r x y = fB
°

If a relationship is total over some domain we can convert it to a boolean relation, without loss of information (provided we remember the domain).

¹HOLCONST
Ü ÛBoolRelİ : ('a, FTV)BR ­ ('a, BOOL)BR
÷üüüüüüüüüüü
Ü µ r:('a, FTV)BR· BoolRel r = Ìx y· fTrue ¼‰t‰4 r x y
°


¹HOLCONST
Ü ÛEqRelİ : 'a SET ­ ('a, FTV)BR ­ ('a, FTV)BR
÷üüüüüüüüüüü
Ü µ V r· EqRel V r = Ìx y·
Ü	if x  V ± y = x then fTrue
Ü	else	if µz· z  V ´ r x z = r y z ± (r x z = fTrue ² r x z = fFalse)
Ü		then fTrue
Ü		else	if ¶z· z  V ± {r x z; r y z} = {fTrue; fFalse}
Ü			then fFalse
Ü			else fB
°


=GFT
eqrel_refl_lemma =
	ô µ V pr x· x  V ´ fTrue ¼‰t‰4 EqRel V pr x x
=TEX

\ignore{
=IGN
set_goal ([], ¬µV pr x· x  V ´ fTrue ¼‰t‰4 EqRel V pr x x®);
a (rewrite_tac [get_spec ¬EqRel®, let_def] THEN REPEAT strip_tac
	THEN_TRY asm_rewrite_tac[]);
val eqrel_refl_lemma = pop_thm ();

set_goal([], ¬µV r· TotalOver V r ± PreExtensional V r ´ Equiv (V, BoolRel r)®);
a (PC_T1 "hol1" rewrite_tac [get_spec ¬TotalOver®, get_spec ¬BoolRel®, get_spec ¬Equiv®, get_spec ¬PreExtensional®]
	THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a (rewrite_tac [get_spec ¬Refl®, eqrel_refl_lemma] THEN REPEAT strip_tac);
(* *** Goal "2" *** *)
a (rewrite_tac [get_spec ¬Sym®] THEN REPEAT strip_tac);
a (POP_ASM_T ante_tac);
a (ALL_FC_T rewrite_tac [eqrel_sym_lemma]);
(* *** Goal "3" *** *)
a (rewrite_tac [get_spec ¬Trans®] THEN REPEAT strip_tac);
a (all_asm_fc_tac [eqrel_trans_lemma]);
val eqrel_equiv_lemma = pop_thm ();






I am only looking for extensional theories.
The notation for sets we are using here is not canonical so each set has multiple representatives and we do not have extensionality.
However, we can hope to be able to obtain an extensional interpretation by taking a quotient relative to extensional equality.
The following condition suffices for this to be possible.

What this says is that whenever two sets are not the members of all the same sets then there is something which is a member of one but not the other.

¹HOLCONST
Ü ÛPreExtensionalİ : GS SET ­ (GS, FTV)BR ­ BOOL
÷üüüüüüüüüüü
Ü µd r· PreExtensional d r ¤ µx y· x  d ± y  d
				´ (¶z· z  d ± IsLub $¼‰t‰4 {r z x; r z y} fT)
Ü				´ (¶z· z  d ± IsLub $¼‰t‰4 {r x z; r y z} fT)
°

If a membership relation is total and pre-extensional over some domain, then we can obtain from it an extensional boolean membership structure whose domain is equivalence classes under co-extensionality of the original domain.

I will be looking to establish reasonable conditions under which the fixed points of the semantic functor will be {\it PreExtensional}, but first I need to establish that {\it PreExtensional}ity suffices for a fixedpoint of the semantic functor to yield and extensional interpretation of first order set theory.


{\let\Section\section
\newcounter{ThyNum}
\def\section#1{\Section{#1}
\addtocounter{ThyNum}{1}\label{Theory\arabic{ThyNum}}}
\include{ifos.th}
\include{sfp.th}
}  %\let

\twocolumn[\section{INDEX}\label{index}]
{\small\printindex}

\end{document}
