=IGN
$Id: t028.doc,v 1.3 2009/06/02 19:15:30 rbj Exp $
=TEX
\documentclass[11pt,a4paper]{article}
\usepackage{latexsym}
\usepackage{ProofPower}
\usepackage{amsfonts}
\ftlinepenalty=9999
\usepackage{A4}

% the following two modal operators come from the amsfonts package
\def\PrKI{\Diamond}	%Modify printing for ®
\def\PrKJ{\Box}		%Modify printing for ©

\def\ExpName{\mbox{{\sf exp}}}
\def\Exp#1{\ExpName(#1)}

\tabstop=0.4in
\newcommand{\ignore}[1]{}

\title{Aristotle's Logic and Metaphysics - some formal analysis}
\makeindex
\usepackage[unicode,pdftex]{hyperref}
\hypersetup{pdfauthor={Roger Bishop Jones}, pdffitwindow=false}
\hypersetup{colorlinks=true, urlcolor=red, citecolor=blue, filecolor=blue, linkcolor=blue}
\author{Roger Bishop Jones}
\date{\ }

\begin{document}
\begin{titlepage}
\maketitle
\begin{abstract}
Formalisation in higher order logic of parts of Aristotle's logic and metaphysics.
\end{abstract}
\vfill

\begin{centering}
{\footnotesize

Created 2009/05/21

Last Change $ $Date: 2009/06/02 19:15:30 $ $

\href{http://www.rbjones.com/rbjpub/pp/doc/t028.pdf}
{http://www.rbjones.com/rbjpub/pp/doc/t028.pdf}

$ $Id: t028.doc,v 1.3 2009/06/02 19:15:30 rbj Exp $ $

\copyright\ Roger Bishop Jones; Licenced under Gnu LGPL

}%footnotesize
\end{centering}

\thispagestyle{empty}
\end{titlepage}

\newpage
\addtocounter{page}{1}
{\parskip=0pt\tableofcontents}

\newpage
\section{INTRODUCTION}

My original purpose in preparing this document was to analyse certain semi-formal statements, relating to the philosophy of Aristotle, which were posted to the \href{http://hist-analytic.org}{\it hist-analytic} mailing list (\href{http://rbjones.com/pipermail/hist-analytic_rbjones.com/2009q2/000258.html}{see message in archive}).

This has now been overtaken by various other philosophical motivations.

Of these the most important for me at present lie in the perceived relevance of Aristotle's metaphysics to what I am trying elsewhere to write about {\it Metaphysical Positivism}.
One tentative idea in this exposition involves three comparisons intended to illuminate the tension between essentialism and nominalism and inform the search for a middle ground.
These three are between Plato and Aristotle, between Hume and Kant, and between Carnap and one or more twentieth century metaphysicians.

For this purpose I seek some kind of understanding of Arstotle's essentialism, and it is for me a natural to use formal modelling as one way of realising that understanding.

Since my own backround in formal modelling comes from Computer Science and Information Systems Engineering, my own preferred languages, methods and tools, which I believe can be effectively applied to some kinds of philosophical problems, are probably alien to most if not all philosophers, and it is therefore a secondary purpose of this material to try to make this kind of modelling intelligible to some philosophers.
This is not a presentation of established methods with proven philosophical benefits.
It is an exploration and adaptation of methods from other domains to philosophy, and the benefits, are to be discovered, not merely displayed.

The present state of the document is rather rough and ready.
Formal modelling takes time, but presenting such material takes longer, and while I am hot on the trail of better, more illuminating models, the presentation will not be polished and transparent.

So far we have two of a series of three expected models of syllogistic logic, and a first model of the Grice/Code/Speranza presentation of the Metaphysics.
Once the third (modal) model of syllogisms is in place I will then look for a combined model, covering modal syllogisms with the crucial distinction between essential and accidental predication ({\it izzing} and {\it hazzing}, in Grices colourful terminology).
Then the emphasis will shift to pulling out the philosophical implications.

Further discussion of what might become of this document in the future may be found in my postscript (Section \ref{POSTSCRIPT}).

In this document, phrases in coloured text are hyperlinks, like on a web page, which will usually get you to another part of this document (the blue parts, the contents list, page numbers in the Index) but sometimes take you (the red bits) somewhere altogether different (if you happen to be online) like \href{http://rbjones.com/pipermail/hist-analytic_rbjones.com}{the hist-analytic archives}.

\section{LANGUAGES, METHODS AND TOOLS} \label{LMT}

This document is probably only of interest to philosophers, among whom few are likely to be familiar with the methods, languages and tools which I have used in it.
In this section I hope to supply enough on these topics to make it possibly for as many philosophers as possible to get something out of the formal models which follow.

For the moment this is brief and its coverage rather random.
I hope this will be filled out as work progresses.

I appeal for feedback on what parts of the document are most difficult to understand.

\subsection{Languages}

Two formal languages are used in this document.
One is a language, called HOL for Higher Order Logic, with a deductive system sufficient for the formal development of mathematics, or for other applications susceptible of formalisations.

The other is a metalanguage known as SML, which stands for Standard Meta-Language.
This is used for giving exective instructions to software which provides support for use of the HOL language and for the contruction and verification of formal proofs in the HOL logic.

\subsubsection{HOL}

The principle language used here (apart from English) is a language (and logic) called HOL.
HOL is an acronym for Higher Order Logic, of which there are many different varieties, and is also widely used for a specific variant of higher order logic which has been implemented in several computer programs providing support for formal specification and proof.

For full details of this language you would need to refer to the documentation which comes with these tools \cite{ds/fmu/ied/spc001} or some of the papers published about them.
See below (Section \ref{ProofPower}) for information relating to the tool used for producing this document, \ProductHOL.

The language HOL is a direct descendent of Russell's {\it Theory of Types}\cite{russell1908}, the logic which he and Whitehead used in {\it Principia Mathematica}\cite{russell1913}.
To get from Russell's {\it Theory of Types} to HOL you do the following (names in brackets give credit to the person who thought of the step):

\begin{itemize}
\item discard the ramifications (Ramsey \cite{ramsey25})
\item simplify by basing on typed lambda-calculus (Church \cite{church40})
\item add polymorphism (Gordon/Milner \cite{gordon87,milner78})
\end{itemize}

To do serious work you need a proof tool, see (Section \ref{ProofPower}).

The following are the most important features of this language/logic which distinguish it from those typically considered by philosophers.

\begin{itemize}
\item It is a foundation system, i.e. it suffices for the development of mathematics by conservative extension (definitions) alone.
\item It has a type system, and allows new types to be defined.
\item It is supported by computer software which checks specifications, assists in constructing proofs and rigorously checks proofs.
\end{itemize}

\subsection{Methods}

The principle technique used here is a method which has some of the theoretical merits of a metatheoretic treatment, but is less arduous and provides better support for reasoning in the object language.

We imagine ourself devising a formal language in which to talk about Aristotle's metaphysics, and in which to formalise the kind of metaphysical arguments which are found in Aristotle.
To do this rigorously, we need to deal first with the semantics of the language, and establish a deductive system which is sound with respect to that semantics.

A standard formal treatment of this material would involve a specification of the syntax of an appropriate language, the development of semantics, probably as some kind of model theory, the specification of a deductive system for the language and a proof of soundness of that system (this would be a version of Aristotle's Syllogistic logic).
This is feasible with the languages and tools we are using, but arduous.
The results would be good for metatheory, but not necessarly convenient for conducting proofs in the language thus defined, i.e. for reasoning in the new object language.

There is another manner of proceeding which better suits our present purposes.
This consists in extending our already available language, using the definitional facilities and the flexibility in its syntax (e.g. fixity declarations) to create a language extension which looks something like and behaves exactly like the intended object language.

We begin with something like model theory, defining new data types which model the kinds of thingd that the new language is to be about.
The constructs in the language are then given definitions in terms of these new data tupes.
By deduction within HOL we are then able to prove results which correspond to results in the intended object language.

There ia a technical term for this kind of treatment of languages in HOL, they are called {\it shallow semantic embeddings}, and this term indicates that the expressions of the target language are represented by expressions in HOL which are syntactically similar (though perhaps not identical) to those of the intended object language, and which do have the same meaning as the target language expressions.
For a fuller description of this kind of method (used in theoretical computer science) see \cite{gordon88}.

If you have not come across this kind of thing before this probably does not make much sense at this point, but I hope that eventually the material which follows will provide an intelligible example of this method.

\subsubsection{Schemas and Higher Order Quantification}

Much of the semi-formal material which we are trying to fully formalise involves general talk about the kinds of things which are found in categories.
Possibly the formulae are intended as schemas in a first order predicate calculus.
This is not the way we will treat them, so a few words explaining why not are in order here.

We are working here in a higher-order logic.
In a first-order logic, it is not possible for quantify over anything but individuals.
In first order set theory we get around that restriction by having ``individuals'' which are surrogates for all kinds of higher order objects.
In set theory we can, by quantifying over the individuals encompass objects which represent properties of functions of every conceivable type.
Some pragmatic issues remain which we need not go into here.

When a first-order formalisation is attempted without benefit of the machinery of set theory, it often proves necessary to use schemata, which are a syntactic surrogate for quantification over higher types.
A well known example is the theory PA, a first order version of Peano's axioms for arithmetic.
Peano himself formulated his axioms for arithmetic before first order logic was invented, before indeed the foundational problems which provoked the development of type theories.
His axiom of induction involved quantification over properties along the following lines:

=GFT
	Ù µp∑ p(0) ± (µx∑ p(x) ¥ p(x + 1)) ¥ µx∑ p(x)
=TEX

Which we may paraphrase:
\begin{quote}
for all properties {\it p}, if {\it p} holds for 0 and, whenever {\it p} is true of some natural number, it is true also of its successor, then {\it p} will be true of all natural numbers
\end{quote}

In the first order formalisation of Peano Arithmetic, known as PA, we cannot quantify over properties, so we use instead an axiom schemata, which lifts the quantification into the metalanguage and changes from quantifying over numbers to quantifying over formulae.
Thus we have instead something like:

=GFT
	Ù P(0) ± (µx∑ P(x) ¥ P(x + 1)) ¥ µx∑ P(x)
=TEX

Where $P$ is not a predicate in the object language, but a syntactic function in the metalanguage which yields formula.
This first order axiom schema describes an infinite set of properly first order axioms obtained by substituting arbitrary formulae (in which $0$ occurs) for $P(0)$, and corresponding formulae for $P(x)$ and $P(x+1)$ in which $x$ and $x+1$ respectively replace occurences of $0$ in the original formula.

\subsubsection{Features of The Language}

The following features of the language are methodologically significant:

[to be supplied]

\subsection{Tools}

\subsection{ProofPower}\label{ProofPower}

The tool used for preparation of this document, for checking the syntax and type correctness of the formal specifications, for assisting in the construction of formal proofs, and for checking the resulting proofs in detail is \Product.

This document is a {\it literate script}.
This means that it is a {\it script} intended for processing by machine, which is also intended to be humanly intelligible (i.e. literate).

The source for the document is machine processed in two distinct ways.
The formal content is extracted and processed by the proof tool \Product, which understands two main languages, the first, HOL, a kind of higher order logic suitable for the formal development of mathematics and for applications of formalised logic and/or mathematics.
The second is a functional programming language called SML, in which instructions may be given to \Product on how to process the formal specifications.
This includes instructions on how to construct and check formal proofs of conjectures in HOL.

\Product come with a library of already defined mathematical concepts and of theorems proven in the context of these definitions, which are organised into a hierarchy of theories in which a theory may make use of the definitions made and theorems proven in any of its ancestors.
As \Product processes a document it aguments the theory hierarchy with the new material.
Listings of the theories can be obtained for inclusion at the end of the document.

The other way of processing the source is for the purpose of obtaining a humanly readable document, typically in PDF format, of which this is an example.
While the document is being written, the author enters into an interactive dialogue with the proof tool in which new definitions or modifications to existing definitions are checked for grammatical correctness and type-correctness.
Proofs of conjecture are developed interactively in such a session using a ``goal package'' which permits the user to work backwards from the goal he is attempting to prove.
The end result of such proof development is a script in the metalanguage SML which provides to \Product a prescription for constructing a proof, which is checked for correctness on-the-fly.
This will be rerun when the complete document is later processed in batch.

Document preparation uses the \LaTeX package augmented by facilities provided by \Product, various aspects such as the formatting of formal text, the creation of contents lists, indexes and bibliographies being thereby facilitated.

\section{THE ORGANON}

\href{http://texts.rbjones.com/rbjpub/philos/classics/aristotl/oi.htm}{The Organon} is a collection of 6 books by Aristotle which form the main part of his work on Logic.
The first of these is \href{http://texts.rbjones.com/rbjpub/philos/classics/aristotl/o11i.htm}{the Categories} \cite{aristotleL325}, on which Aristotle's Metaphyics depends.
The Metaphysics, at least the parts involved in the Grice/Codd analysis, is concerned with predication, which is also central to the formal core of Aristotle's logic, the theory of the syllogism, presented in the \href{http://texts.rbjones.com/rbjpub/philos/classics/aristotl/o31i.htm}{Prior Analytic, Book 1} \cite{aristotleL325}.

Aristotle's account of syllogistic logic covers modal reasoning.
In attempting to understand Aristotelian essentialism, one of the key problems is to establish the relationship between the two distinctions between necessary and contingent proposition, and between essential and accidental predication.

Though Code \cite{code88} does not conceive of himself as engaged in formalising Aristotle in a modern predicate logic, his presentation seems much closer to predicate logic than to syllogistic logic.
I would like to understand the metaphysics if possible in terms of the kind of logic which Aristotle had at his disposal.
To explore the extent to which this might be possible, some models of syllogistic logic might be helpful.
.
When we look at the syllogism with particular concern for the notion of predication involved, we find that the Grice's ``izz/hazz'' distinction (in Aristotle ``said of'' and ``in'') is not relevant.
In this respect predication is simpler in the syllogism, but instead we have an orthogonal distinction into four kinds of predication according to whether the subject is universal or particular, and whether the predication is affirmative or negative, over which are later added the modal operators.

In the basic case the semantics of the syllogism is very simple and I therefore begin with that simple case.
One factor which complicates the semantics is the proscription, implicit in Aristotle and sometimes called ``the existential fallacy'', of predicates whose extension is empty.
Without the existential fallacy the models are simpler, so I have begun with this.

It may be helpful to give a full treatment in the following stages:
\begin{itemize}
\item pure syllogism without existential fallacy (Section \ref{SWEF})
\item full syllogism incorporating existential fallacy (Section \ref{SYLL})
\item modal syllogisms  (Section \ref{MODSYLL})
\end{itemize}

\subsection{The Syllogism without The Existential Fallacy}\label{SWEF}

The theory here is very simple, the presentation is complicated by the fact that the proofs have been completely automated by scripts in the metalanguage.
These can be completely ignored by anyone who is willing to trust that \Product checks proofs correctly.
In any case, the theorems proven are just the statements of the 15 valid forms of syllogism which do not exhibit the ``existential fallacy''.
For the most concise statement of the results of the exercise, the reader should refer directly to the theory listing in Appendix \ref{syllog1} below.

=SML
open_theory "misc2";
force_new_theory "syllog1";
=TEX

\ignore{
=SML
force_new_pc €"'syllog1"›;
merge_pcs ["'savedthm_cs_∂_proof"] "'syllog1";
set_merge_pcs ["misc2", "'syllog1"];
=TEX
}%ignore

\subsubsection{The Subject Matter}

Aristotle's syllogistic logic is concern with inferences between judgements considered as predications.
A predication in Aristotle affirms a {\it predicate} of some {\it subject}, but by contrast with more recent notions of predication the subject need not be an individual, the kinds of things which appear as predicates may also appear as subjects, and the relationship expressed seems closer to a modern eye to set inclusion than to what we now regard as predication.
Since subject and predicate are for present purposes the same kind of thing, it is useful to have a name for that kind of thing, and I will use the name {\it property}.

There are four kinds of predication which we have here to account for, which we will do by offering definitions which provide a good model for syllogistic logic, i.e. one for which the syllogisms held to be true by Aristotle are in fact true.
Before providing these definitions we must decide what kind of thing are the properties which are related by Aristotelian predication.
 
In HOL the most natural answer to this is ``boolean valued functions'' which are objects of type $î'a ≠ BOOLÆ$ for some type of individuals which we can leave open by using the type variable $î'aÆ$.
This provides a simple model of Aristotle's syllogistic reasoning, except for those cases which involve the ``existential fallacy''.
Four of the syllogisms which Aristotle considered valid fail under this conception of predicate, because among the objects of type $î'a ≠ BOOLÆ$ is the function $¨Ãx:'a∑ FÆ$ which corresponds to a predicate with empty extension and does not admit inference from the universal to the existential.

The following ``type abbreviation'' allows us to use {\it PROP} as an abbreviation for $î'a ≠ BOOLÆ$.

=SML
declare_type_abbrev("PROP", [], î'a ≠ BOOLÆ);
=TEX

\subsubsection{Predication}

There are four forms of predication which are normally presented as infix operators over predicates using the vowels ``a'', ``e'', ``i'', ``o''.
``o'' is already in use so I'll use ``u'' instead.

These are to be construed as follows:

\begin{center}
\begin{tabular}[]{ | l | l |}
\hline
HOL term & Meaning\\
\hline
¨A a BÆ & All A are B\\
¨A e BÆ & All A are not B\\
¨A i BÆ & An A is B\\
¨A o BÆ & An A is not B\\
\hline
\end{tabular}
\end{center}

``o'' is already in use for functional composition, so we will use ``u'' instead and then use an alias to permit us to write this as ``o'' (type inference will usually resolve any ambiguity).

To render these in HOL we first declare the relevant leters as infix operators:

=SML
declare_infix (300, "a");
declare_infix (300, "e");
declare_infix (300, "i");
declare_infix (300, "u");
=TEX

They predication operators are defined as follows:

πHOLCONST
‹ $€a› : PROP ≠ PROP ≠ BOOL
˜¸¸¸¸¸¸
‹ µA B∑ A a B § µx∑ A x ¥ B x
∞

πHOLCONST
‹ $€e› : PROP ≠ PROP ≠ BOOL
˜¸¸¸¸¸¸
‹ µA B∑ A e B § µx∑ A x ¥ ≥ B x
∞

πHOLCONST
‹ $€i› : PROP ≠ PROP ≠ BOOL
˜¸¸¸¸¸¸
‹ µA B∑ A i B § ∂x∑ A x ± B x
∞

πHOLCONST
‹ $€u› : PROP ≠ PROP ≠ BOOL
˜¸¸¸¸¸¸
‹ µA B∑ A u B § ∂x∑ A x ± ≥ B x
∞

=SML
declare_alias("o", ¨$uÆ);
=TEX

Note that as defined above these come in complementary pairs, $a$ being the negation of $o$ and $e$ of $i$.
If we had negation we could manage with just two predication operators.

\subsubsection{The Valid Syllogisms}\label{ValidSyllogisms}

The fifteen valid syllogisms which do not exhibit the existential fallacy are true under this semantics and can be proven formally with ease.

In this section we describe informally this subset of the valid syllogisms, in the next we provide scripts in our metalanguage which automates the construction and proof of the relevant syllogisms.
This presentation is based on \href{http://en.wikipedia.org/wiki/Syllogism}{the one at wikipedia}.

Syllogisms come in four figures, according to the configuration of variables in the premises:

\begin{quote}
\begin{itemize}
\item[Figure 1] M-P, S-M $Ù$ S-P
\item[Figure 2] P-M, S-M $Ù$ S-P
\item[Figure 3] M-P, M-S $Ù$ S-P
\item[Figure 4] P-M, M-S $Ù$ S-P
\end{itemize}
\end{quote}

These four figures are then repeated for each combination of the four types of premise in each of the premises and the conclusion.
This gives $4 ∏ 4 ∏ 4 ∏ 4 = 256$ possibilities, of which 19 were held to be valid by Aristotle, four exhibiting the so-called ``existential fallacy'' of inferring from a universal to an existential.

The use of vowels for the predicators allows the valid cases to be named using names in which the vowels tell you the form of the syllogism (if you also know the figure).
The first vowel tells you the kind of syllogism in the first premise, the second vowel that in the second premise, and the third vowel that in the conclusion.

In the following table the bracketted names are for syllogisms which exhibit on the existential fallacy.

\begin{center}
\begin{tabular}[]{| l | l | l | l |}
\hline
Figure 1 &	Figure 2	&	Figure 3 &	Figure 4\\
\hline 
Barbara &	Cesare 	&	[Darapti] &	[Bramantip]\\
Celarent &	Camestres &	Disamis 	&	Camenes\\
Darii 	&	Festino 	&	Datisi 	&	Dimaris\\
Ferio 	&	Baroco 	&	[Felapton] &	[Fesapo]\\
  	&	  	&	Bocardo 	&	Fresison\\
  	&	  	&	Ferison 	&	 \\
\hline
\end{tabular}
\end{center}

\subsubsection{Generating Syllogisms}

This section is mainly given over to short programs in our metalanguage the end effect of which is to secure the proof of the 15 forms of syllogism which do not exhibit the existential fallacy.
The results are visible in the ``theorems'' section of the theory listing in Appendix \ref{syllog1}, and this section can be safely skipped by anyone whose interest is purely philosophical.
Normally this kind of material would be hidden, it is shown here to give an impression of the size of script necessary to automate this kind of task.

Where S, P and M are the subject, predicate and middle term respectively. 

The following function generates a list of four quadruples of HOL variables which correspond to the four figures of syllogisms.
It is parameterised by the HOL type used for predicates to that it can be re-used when we change the representation type.

=SML
fun €figures› pt = 
	let val M = mk_var ("M", pt)
	    and P = mk_var ("P", pt)
	    and S = mk_var ("ø", pt)
	in [(M,P,S,M), (P,M,S,M), (M,P,M,S), (P,M,M,S)]
	end;
=TEX

The following functions take a string which is the name of a syllogism extract the vowels which occur in it and convert them into the corresponding predication operator to give a triple of operators.
=SML
fun €op_from_char› ot c = mk_const (if c = "o" then "u" else c, ot);

fun €vowels_from_string› s = filter (fn x => x mem (explode "aeiou")) (explode s);

fun €vartrip_from_text› ot s =
	let val [a,b,c] = (map (op_from_char ot) o vowels_from_string) s;
	in (a,b,c)
	end;
=TEX

The following functions contruct a syllogism.

=SML
fun €mk_pred› q s p = mk_app(mk_app (q, s), p);

fun €mk_syll› vt (a,b,c,d) (q1, q2, q3) =
	([mk_pred q1 a b, mk_pred q2 c d],
		mk_pred q3 (mk_var("ø", vt)) (mk_var("P", vt)));

fun mk_relt t = mk_ctype ("≠", [t, mk_ctype ("≠", [t, îBOOLÆ])]);

fun €mk_syllp› vt (s, n) =
	mk_syll vt (nth (n-1) (figures vt)) (vartrip_from_text (mk_relt vt) s);
=TEX



=SML
val mk_syllp1 = mk_syllp îPROPÆ;
=TEX

We now define a data structure from which the valid syllogisms can be generated.
With the model we are using only the 15 syllogisms which do not exhibit the ``existential fallacy'' are provable.
They are shown in the following data structure.

=SML
val €syllogism_data1› = 
	[("Barbara", 1),
	("Celarent", 1),
	("Darii", 1),
	("Ferio", 1),
	("Cesare", 2),
	("Camestres", 2),
	("Festino", 2),
	("Baroco", 2),
	("Disamis", 3),
	("Datisi", 3),
	("Bocardo", 3),
	("Ferison", 3),
	("Camenes", 4),
	("Dimaris", 4),
	("Fresison", 4)];
=IGN
map mk_syllp1 syllogism_data1;
=TEX

The following code generates the goals for proving the above syllogisms from the data structure, generates and checks formal proofs and saves the resulting theorems in the current theory (see end of document for theory listing). 

=SML
fun €syll_prove_and_store› msp tac (a,n) =
	let val thm = save_thm (a, tac_proof (msp (a,n), tac)) handle _ => t_thm
	in (a, thm)
	end;

val sps1 = syll_prove_and_store mk_syllp1;
=TEX

\subsubsection{Proving the Syllogisms}

We have now only to devise a tactic for proof and apply this tactic to the goals corresponding to allegedly valid syllogisms.

The following tactic is very elementary.
Basically it says: expand the goal by applying the definitions of the operators and then prove automatically the resulting conjecture in the predicate calculus.

=SML
val €syll_tac› =	asm_prove_tac (map get_spec [¨$aÆ, ¨$eÆ, ¨$iÆ, ¨$uÆ]);
=TEX

We now apply this to the complete set of syllogisms which are valid and do not exhibit the existential fallacy,
saving the results in the theory as well as binding them to (naming them as) the metalanguage value {\it valid\_sylls}.

=SML
val €valid_sylls› = map (sps1 syll_tac) syllogism_data1;
=TEX

This is the resulting value.
=GFT
val valid_sylls = [
	("Barbara", M a P, ø a M Ù ø a P),
	("Celarent", M e P, ø a M Ù ø e P),
	("Darii", M a P, ø i M Ù ø i P),
	("Ferio", M e P, ø i M Ù ø o P),
	("Cesare", P e M, ø a M Ù ø e P),
	("Camestres", P a M, ø e M Ù ø e P),
	("Festino", P e M, ø i M Ù ø o P),
	("Baroco", P a M, ø o M Ù ø o P),
	("Disamis", M i P, M a ø Ù ø i P),
	("Datisi", M a P, M i ø Ù ø i P),
	("Bocardo", M o P, M a ø Ù ø o P),
	("Ferison", M e P, M i ø Ù ø o P),
	("Camenes", P a M, M e ø Ù ø e P),
	("Dimaris", P i M, M a ø Ù ø i P),
	("Fresison", P e M, M i ø Ù ø o P)
] : (string * THM) list
=TEX

The theorems are also displayed in the theory listing in Appendix \ref{syllog1}

\subsection{The Syllogism with The Existential Fallacy}\label{SYLL}

We now make the model more faithful to Aristotle by excluding predicates with empty extension.

We can then prove all 19 valid forms of syllogism.

For the most concise statement of the results of the exercise, the reader should refer directly to the theory listing in Appendix \ref{syllog2} below.

=SML
open_theory "misc2";
force_new_theory "syllog2";
=TEX

\ignore{
=SML
force_new_pc €"'syllog2"›;
merge_pcs ["'savedthm_cs_∂_proof"] "'syllog2";
set_merge_pcs ["misc2", "'syllog2"];
=TEX
}%ignore

\subsubsection{The Subject Matter}

The key to getting the existential fallacies into the model is the adoption of a type for the variables in the syllogisms which does not include empty predicates.
We could do this by defining a new type which is a sub-type of the propositional functions, but it is simpler to use another type-abbreviation as follows.

Instead of using a propositional function, which might be unsatisfiable, we use an ordered pair.
The pair consists of one value, a value for which the predicate is true, and a propositional function.
The predicate $(v, pf)$ is then to be considered true of some value $x$ {\it either} if $x$ is $v$ {\it or} if $pf$ is true of $x$. 

This is the type abbreviation:

=SML
declare_type_abbrev("PROP2", [], î'a ∏ ('a ≠ BOOL)Æ);
=TEX

\subsubsection{Predication}

To work with this new type for the predicates we define a function which will convert this kind of predicate into the old kind, as follows:

πHOLCONST
‹ €p› : PROP2 ≠ ('a ≠ BOOL)
˜¸¸¸¸¸¸
‹ µA∑ p A = Ãx∑ let (v,f) = A in x = v ≤ f x 
∞

The resulting values have the same type as the old, but they will never have empty extension.

The following principle can be proven (proof omitted):

\ignore{
=SML
set_goal([], ¨µA∑ ∂¡∑ (p A) ¡Æ);
a (strip_tac);
a (∂_tac ¨Fst AÆ THEN rewrite_tac [get_spec ¨pÆ, let_def]);
val p_∂_lemma = save_pop_thm "p_∂_lemma";
=TEX
}%ignore

=GFT
p_∂_lemma =
	Ù µ A∑ ∂ ¡∑ p A ¡
=TEX

This principle is what we need to prove the four syllogisms which exhibit the existential fallacy.

We then proceed in a similar manner to the first model, using the function $p$ to convert the new kind of predicate into the old.

We have a new theory which is not a child of the first theory, so we must redeclare the fixity of the predication operators:

=SML
declare_infix (300, "a");
declare_infix (300, "e");
declare_infix (300, "i");
declare_infix (300, "u");
=TEX

They predication operators are then defined.
Note that the differences are small and uniform.
The type $îPROPÆ$ is changed to $îPROP2Æ$ and the function $p$ is invoked before applying a predicate.

πHOLCONST
‹ $€a› : PROP2 ≠ PROP2 ≠ BOOL
˜¸¸¸¸¸¸
‹ µA B∑ A a B § µx∑ p A x ¥ p B x
∞

πHOLCONST
‹ $€e› : PROP2 ≠ PROP2 ≠ BOOL
˜¸¸¸¸¸¸
‹ µA B∑ A e B § µx∑ p A x ¥ ≥ p B x
∞

πHOLCONST
‹ $€i› : PROP2 ≠ PROP2 ≠ BOOL
˜¸¸¸¸¸¸
‹ µA B∑ A i B § ∂x∑ p A x ± p B x
∞

πHOLCONST
‹ $€u› : PROP2 ≠ PROP2 ≠ BOOL
˜¸¸¸¸¸¸
‹ µA B∑ A u B § ∂x∑ p A x ± ≥ p B x
∞

=SML
declare_alias("o", ¨$uÆ);
=TEX

\subsubsection{The Valid Syllogisms}

The valid syllogisms have been described in Section \ref{ValidSyllogisms}.

The following valid syllogisms exhibit the existential fallacy and were not provable in the previous model.

=SML
val syllogism_data2 = 
	[("Darapti", 3),	
	("Felapton", 3),
	("Bramantip", 4),
	("Fesapo", 4)];
=TEX

All nineteen syllogisms supposed valid by Aristotle are true under this semantics and have been proven.
The actual theorems are shown in the theory listing in Appendix \ref{syllog2}.

The metalanguage scripts prepared for the first model are mostly reusable for this model, with some different parameters which reflect the differences between the models.

The main requirement is to supply the type of the propositional functions in this model which is done as follows:

=SML
val €mk_syllp2› = mk_syllp îPROP2Æ;
=TEX

This defines the fucntion {\it mk\_syllp2} whose type is shown:

=GFT
val mk_syllp2 = fn : string * int -> TERM list * TERM
=TEX

{\it mk\_syllp2} takes a pair consisting of a string which is the name of a syllogism and a number which is the number of the figure, and constructs the syllogism as a goal for proof.

An example of its use is:

=SML
mk_syllp2 ("Barbara", 1);
=TEX

which yields:

=GFT
val it = ([¨M a PÆ, ¨ø a MÆ], ¨ø a PÆ) : TERM list * TERM
=TEX

\subsubsection{Proving the Syllogisms}

The same tactic used for proof of the syllogisms in the previous model still works with this model, but does not prove the four syllogisms which exhibit the existential fallacy.

To obtain proofs of these other four syllogisms we need to make use of the lemma we proved about $p$, {\it p\_∂\_lemma}.
This we do by instantiating it for each of the variables which appear in the syllogisms and supplying these for use in the proof.

=SML
val €syll_tac2› =
	(MAP_EVERY (fn x => strip_asm_tac (µ_elim x p_∂_lemma))
		[¨M:PROP2Æ, ¨P:PROP2Æ, ¨ø:PROP2Æ])
	THEN syll_tac;
=TEX

We now apply this to the complete set of syllogisms which are valid and do not exhibit the existential fallacy,
saving the results in the theory as well as binding them to (naming them as) the metalanguage value {\it valid\_sylls}.

=SML
val €sps2› = syll_prove_and_store mk_syllp2;
val €valid_sylls2› = map (sps2 syll_tac2) (syllogism_data1 @ syllogism_data2);
=TEX

This is the resulting value.
=GFT
val valid_sylls = [("Barbara", M a P, ø a M Ù ø a P), ("Celarent", M e P, ø a M Ù ø e P),
      ("Darii", M a P, ø i M Ù ø i P), ("Ferio", M e P, ø i M Ù ø u P),
      ("Cesare", P e M, ø a M Ù ø e P), ("Camestres", P a M, ø e M Ù ø e P),
      ("Festino", P e M, ø i M Ù ø u P), ("Baroco", P a M, ø u M Ù ø u P),
      ("Disamis", M i P, M a ø Ù ø i P), ("Datisi", M a P, M i ø Ù ø i P),
      ("Bocardo", M u P, M a ø Ù ø u P), ("Ferison", M e P, M i ø Ù ø u P),
      ("Camenes", P a M, M e ø Ù ø e P), ("Dimaris", P i M, M a ø Ù ø i P),
      ("Fresison", P e M, M i ø Ù ø u P)] : (string * THM) list
=TEX

The theorems have aso been stored in the theory and are also displayed in the theory listing in Appendix \ref{syllog2}

\subsection{Modal Syllogisms}\label{MODSYLL}

The language of syllogistic logic does not have operators over propositions.
The only operators are the ones which apply predicates to subjects.

The modalities are perhaps therefore better thought of as kinds of judgements rather than as operations on propositions.
This would give us three kinds of judgement, which assert a predication contingently, necessarily or possibly.

It is natural to consider the modal aspects in terms of possible worlds, and I will model it first in those terms (not knowing whether this will provide a good model of Aristotle's conception of modality).
The propositional functions could then be modelled as functions from possible worlds to non-empty propositional functions.

One respect in which the treatment of the syllogism so far looks odd to the modern eye is the lack of consideration of constants.

We have a language which only has variables, even though Aristotle does use syllogistic reasoning with concrete predicates and subjects.
This lack bevomes more significant when modalities are introduced, for we expect necessities to flow from contraints on the extension of constants which are fixed across the possible worlds (i.e. the meanings of concepts are to be held fixed, even though their extensions may vary across possible worlds).

So I proposed in modelling modal syllogisms to bring the semantics closer to a modern model theory by allowing for constants.
This will be reflected in the definition of ``possible world'' which will include an assignment of values to constants.

\subsection{Discussion}

\section{METAPHYSICS (I)}

In this section we consider some material on Aristotle's Metaphysics \cite{aristotleMetap} which originated in work of Grice and Code \cite{code88} and came to me from a \href{http://rbjones.com/pipermail/hist-analytic_rbjones.com/2009q2/000258.html}{posting of J.L. Speranza} on the hist-analytic mailing list.
Code's paper is also partially available at \href{http://books.google.co.uk/books?id=sHWK4Lz37sAC&printsec=frontcover#PPA411,M1}{Google Books}.

What Speranza posted was the list of formulae which are named below as c01 through c31 (though not exactly as given, I have massaged them to be acceptable to HOL and also have quantified over all free variables).

The analysis in this section is independent of the preceding analysis of Aristotle's syllogism, and considers predication from a rather different point of view, which hangs around the distinction between essential and accidental predication.
In the next section I will produce another model in which essence and accident are combined with a full treatment of modal syllogism so that some conclusions might be drawn about the relationship between essence and necessity in Aristotlean philosophy.

A new theory is needed which I will call ``ariscat'' which is created here:

=SML
open_theory "misc2";
force_new_theory "ariscat";
=TEX

\ignore{
=SML
force_new_pc €"'ariscat"›;
merge_pcs ["'savedthm_cs_∂_proof"] "'ariscat";
set_merge_pcs ["misc2", "'ariscat"];
=TEX
}%ignore

\subsection{The Grice/Code/Speranza Formulae}

This work began with an attempt to analyse using \Product a set of formulae posted by J.L. Speranza to the \href{http://www.hist-analytic.org/}{hist-analytic mailing list}.
These were a Speranzan transcript of formulae published in a paper by Code \cite{code88}, the work presented in that paper having begun with some joint work with H.P.~Grice.

The following material labelled ``Code/Speranza'' began as a transcription from Speranza's email, and was later updated when Speranza pointed me to the partial availability of the Code paper on Google Books.
I then put back some of the detail missed in the Speranza version, enclosed in square brackets, and enclosed in curly braces some of the material which Speranza had added to Code's.

The terminology used is Grice's.
Code uses ``Is'' and ``Has'' instead of ``izz'' and ``hazz'' (which were coined by Grice and used by Speranza).
Aristotle's original's have been translated as ``SAID OF'' and ``IN'', according to Cohen (\href{http://faculty.washington.edu/smcohen/433/GriceCode.pdf}{Grice and Code on IZZing and HAZZing}).

The material is interspersed with a formalisation in \ProductHOL.
I have adopted some of Code's headings for sections.

\subsection{Formal Principles}

We begin with ``Formal Principles'' which we take as implicit definitions of two kinds of Aristotelian predication.

=GFT Code/Speranza
[(A) Formal Principles]

[FP1] 1. A izz A.
[FP2] 2. (A izz B & B izz C) --> A izz C.
[FP3] 3. A hazz B -> -(A izz B).
[FP4] 4. A hazz B iff A hazz Some-Thing [something] that izz B.
=TEX

The modelling in \ProductHOL will be entirely conservative, so we provide explicit definitions for ``izz'' and ``hazz'' and prove that they satisfy these principles and suffice also for the definitions and theorems which follow.

If the formal development is complete the definitions will have been shown to be sufficient.
In order to test whether the principles suffice I will attempt to procede on these alone, though I suspect that will not be possible.
Failing that I will offer informal arguments to the contrary (a formal argument would require ascent to a metatheory which would involve too much work).

In order to define these concepts we have to decide what they are about, and this is not straightforward.

\subsubsection{Categories}

Aristotle has a system of categories, and these seem central to the topic.
Much hang on what these are, and to get a nice structure to our theory it seems advisable to do a bit of ``category theory'' first.
Of course this is not at all the same thing as the branch of mathematics which now goes by that name, but the choice of name for the mathematics was not entirely quixotic and at some point it might be interesting to think about the relationship between the two kinds of category theory.

Among these categories that of substances plays a special role.
Substances can be particular in which case they correspond to some individual, or not, in which case they are sets of individuals.
The particulars of the other categories are attributes, and the non-individuals are sets of attributes.
I don't think you can have sigleton sets, so we can model all these categories as sets of sets in which the singleton sets are the individuals.
Attributes can also be considered as sets of individual substances and so there is a type difference between the category of substances and the other categories.

The following introduce new types and type abbreviations for modelling Aristotle's categories.

\begin{description}
\item ACAT is a type of attribute categories
\item ISUB is a type of individual substances
\item CATM is the type of the things which are in categories.

This is a `disjoint union', which means that there are two kinds of thing which one finds in categories, either a set of individual substances (using singleton sets to represent individual substances), or a set of properties of individual substances tagged with an attribute category.

\item CAT is a type abbreviation for a notion of category which is either an attribute category or some other category (which will stand for the category of substances).

\end{description}

There are some oversimplifications here which I am hoping will not be too serious for a useful first cut.

\begin{description}
\item[Modal Operators]
The main one is that this general approach will not permit the definition of modal operators, which are used by Code.
Whether there is real need for them seems to me doubtful, but if necessary a modal model could be provided.
\item[Empty Sets]
The second is that I have not excluded empty sets, and hence that there can be no predicates with null extensions.
This is in fact consistent with Code's ``principles'', but we find that his definitions are written as if there were no empty predicates, even though this is not entailed by the principles.
I where Code's definitions presume non-emptyness of predicates I have chosen another definition which does not.
Some of the theorems are then unprovable.
\item[Extensionality]
Intracategorial equality will be extensional.
That appears to be what is required, so it probably isn't a problem!
\item[Predicability]
Aristotle says defines particulars in terms of predicabilty, they are the impredicables.
Its not clear how to deal with this, and it appears to be in terminological confilct with Codc, who appears to use use ``predicable'' to mean ``truly predicable''.
Code has the general principle ``A izz A'' which implicitly asserts that everthing is truly predicable of itself.
\end{description}

=SML
new_type(€"ACAT"›, 0);
new_type(€"ISUB"›, 0);
declare_type_abbrev (€"CATM"›, [], îISUB  + (ACAT ∏ (ISUB ≠ BOOL))Æ);
declare_type_abbrev (€"CAT"›, [], îONE + ACATÆ);
=TEX

We name the category of substances.

πHOLCONST
‹ €CatSubs› : CAT
˜¸¸¸¸¸¸
‹ CatSubs = InL One
∞

Now we define various operators over categories and their constituents which suffice for the development of an appropriate theory, in the context of which rest of the Aristotelian terminology will we hope prove definable.

First ``projection'' functions which yield the constituents of $MCAT$s.

πHOLCONST
‹ €Cat› : CATM ≠ CAT
˜¸¸¸¸¸¸
‹ µx∑ Cat x = if IsL x then CatSubs else InR(Fst (OutR x))
∞

πHOLCONST
‹ €IndvSet› : CATM ≠ ISUB 
˜¸¸¸¸¸¸
‹ µx∑ IndvSet x = OutL x
∞

πHOLCONST
‹ €AttrSet› : CATM ≠ (ISUB ≠ BOOL)
˜¸¸¸¸¸¸
‹ µx∑ AttrSet x = Snd(OutR x)
∞

This one turns out handy.

πHOLCONST
‹ €CatSet› : CATM ≠ (ISUB + (ISUB ≠ BOOL))
˜¸¸¸¸¸¸
‹ µx∑ CatSet x =
‹	if Cat x = CatSubs
‹	then {y | ∂z∑ z ç IndvSet x ± y = InL z}
‹	else {y | ∂z∑ z ç AttrSet x ± y = InR z}
∞

With these definitions in place we get a useful characterisation of identity for elements of $CATM$.

=GFT
catm_eq_lemma =
	Ù µ A B∑ A = B § Cat A = Cat B ± CatSet A = CatSet B
=TEX

\ignore{
=SML
set_goal([], ¨µA B∑ A = B § Cat A =  Cat B ± CatSet A = CatSet BÆ);
a (REPEAT µ_tac THEN rewrite_tac [get_spec ¨CatÆ, get_spec ¨CatSetÆ]);
a (strip_asm_tac (µ_elim ¨AÆ sum_cases_thm) THEN asm_rewrite_tac[]
	THEN REPEAT_N 3 (TRY strip_tac)
	THEN_TRY asm_rewrite_tac[]);
(* *** Goal "1" *** *)
a (POP_ASM_T (asm_tac o eq_sym_rule)
	THEN asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a (lemma_tac ¨IsL BÆ);
(* *** Goal "2.1" *** *)
a (swap_nth_asm_concl_tac 2
	THEN asm_rewrite_tac[get_spec ¨CatSubsÆ]);
(* *** Goal "2.2" *** *)
a (swap_nth_asm_concl_tac 2
	THEN rewrite_tac[asm_rule ¨IsL BÆ, sets_ext_clauses, get_spec ¨IndvSetÆ]);
a (strip_tac);
a (lemma_tac ¨≥ y = OutL BÆ);
(* *** Goal "2.2.1" *** *)
a (swap_nth_asm_concl_tac 1 THEN asm_rewrite_tac[get_spec ¨InLÆ]);
a (GET_ASM_T ¨IsL BÆ (rewrite_thm_tac o (rewrite_rule [sum_clauses])));
(* *** Goal "2.2.2" *** *)
a (swap_nth_asm_concl_tac 1 THEN rewrite_tac[sets_ext_clauses]);
a (swap_nth_asm_concl_tac 1);
(* *** Goal "2.2.2.1" *** *)
a (strip_tac THEN ∂_tac ¨InL xÆ THEN asm_rewrite_tac[]);
a (contr_tac THEN asm_fc_tac[] THEN_TRY all_var_elim_asm_tac);
a (spec_nth_asm_tac 2 ¨xÆ);
(* *** Goal "2.2.2.2" *** *)
a (strip_tac THEN ∂_tac ¨InL xÆ THEN asm_rewrite_tac[]);
a (contr_tac THEN asm_fc_tac[] THEN_TRY all_var_elim_asm_tac);
a (spec_nth_asm_tac 1 ¨xÆ);
(* *** Goal "3" *** *)
a (POP_ASM_T (asm_tac o eq_sym_rule) THEN asm_rewrite_tac[]);
(* *** Goal "4" *** *)
a (lemma_tac ¨≥ IsL BÆ);
(* *** Goal "4.1" *** *)
a (swap_nth_asm_concl_tac 2
	THEN asm_rewrite_tac[get_spec ¨CatSubsÆ]);
(* *** Goal "4.2" *** *)
a (swap_nth_asm_concl_tac 2
	THEN rewrite_tac[asm_rule ¨≥ IsL BÆ, sets_ext_clauses, get_spec ¨IndvSetÆ]);
a (strip_tac);
a (lemma_tac ¨≥ z = OutR BÆ);
(* *** Goal "4.2.1" *** *)
a (swap_nth_asm_concl_tac 1 THEN asm_rewrite_tac[get_spec ¨InRÆ]);
a (LEMMA_T ¨IsR BÆ (rewrite_thm_tac o (rewrite_rule [sum_clauses])));
a (DROP_ASM_T ¨≥ IsL BÆ ante_tac
	THEN strip_asm_tac (µ_elim ¨BÆ sum_cases_thm)
	THEN asm_rewrite_tac[]);
(* *** Goal "4.2.2" *** *)
a (asm_rewrite_tac[get_spec ¨CatSubsÆ, get_spec ¨AttrSetÆ]);
a (lemma_tac ¨≥ Snd z = Snd(OutR B)Æ
	THEN1 swap_asm_concl_tac ¨≥ z = OutR BÆ);
(* *** Goal "4.2.2.1" *** *)
a (LEMMA_T ¨z = (Fst z, Snd z)Æ pure_once_rewrite_thm_tac THEN1 prove_tac[]);
a (pure_asm_rewrite_tac[]);
a (LEMMA_T ¨Fst z = Fst (OutR B)Æ rewrite_thm_tac);
a (swap_asm_concl_tac ¨InR (Fst z) = (if IsL B then CatSubs else InR (Fst (OutR B)))Æ);
a (asm_rewrite_tac[]);
a (swap_nth_asm_concl_tac 1);
a (rewrite_tac [sets_ext_clauses]);
a (swap_nth_asm_concl_tac 1);
a (strip_tac THEN ∂_tac ¨InR xÆ THEN asm_rewrite_tac[]);
a (REPEAT strip_tac THEN_TRY all_var_elim_asm_tac);
a (spec_nth_asm_tac 1 ¨xÆ);
a (spec_nth_asm_tac 1 ¨z'Æ);
(* *** Goal "4.2.2.2.2" *** *)
a (strip_tac THEN ∂_tac ¨InR xÆ THEN asm_rewrite_tac[]);
a (REPEAT strip_tac THEN_TRY all_var_elim_asm_tac);
(* *** Goal "4.2.2.2.2.1" *** *)
a (∂_tac ¨xÆ);
a (asm_rewrite_tac []);
(* *** Goal "4.2.2.2.2.2" *** *)
a (∂_tac ¨z'Æ);
a (asm_rewrite_tac []);
val catm_eq_lemma = save_pop_thm "catm_eq_lemma";
=TEX
}%ignore

\subsubsection{Predication}

Now we can define predication.
We do this in terms of Grice's $izz$ and $hazz$.

=SML
declare_infix (300, "izz");
declare_infix (300, "hazz");
=TEX

πHOLCONST
‹ $€izz› : CATM ≠ CATM ≠ BOOL
˜¸¸¸¸¸¸
‹ µA B∑ A izz B § Cat A = Cat B ± CatSet A Ä CatSet B
∞

πHOLCONST
‹ $€hazz› : CATM ≠ CATM ≠ BOOL
˜¸¸¸¸¸¸
‹ µA B∑ A hazz B § Cat A = CatSubs ± ≥ Cat B = CatSubs
‹	± ∂a∑ a ç AttrSet B ± µs∑ s ç IndvSet A ¥ a s
∞

That was reasonably neat, but the definition of $izz$ isn't terribly convenient for proving things.
Lets have some $izz$ lemmas:

=GFT
izz_lemma1 =
    Ù µ A B∑ Cat A = CatSubs ¥ (A izz B § Cat B = CatSubs ± IndvSet A Ä IndvSet B)

izz_lemma2 =
    Ù µ A B∑ Cat B = CatSubs ¥ (A izz B § Cat A = CatSubs ± IndvSet A Ä IndvSet B)

izz_lemma3 =
    Ù µ A B∑ ≥ Cat A = CatSubs ¥ (A izz B § Cat B = Cat A ± AttrSet A Ä AttrSet B)

izz_lemma4 =
    Ù µ A B∑ ≥ Cat B = CatSubs ¥ (A izz B § Cat B = Cat A ± AttrSet A Ä AttrSet B)
=TEX

\ignore{
=SML
set_goal([], ¨µA B∑ Cat A = CatSubs ¥ (A izz B § Cat B = CatSubs ± IndvSet A Ä IndvSet B)Æ);
a (REPEAT µ_tac THEN rewrite_tac[get_spec ¨$izzÆ, get_spec ¨CatSetÆ]); 
a (strip_tac THEN_TRY asm_rewrite_tac[] THEN REPEAT strip_tac THEN_TRY asm_rewrite_tac[]);
(* *** Goal "1" *** *)
a (POP_ASM_T ante_tac THEN asm_rewrite_tac[sets_ext_clauses] THEN REPEAT strip_tac);
a (spec_nth_asm_tac 2 ¨(InL x):ISUB + (ISUB ≠ BOOL)Æ);
(* *** Goal "1.1" *** *)
a (spec_nth_asm_tac 1 ¨xÆ);
(* *** Goal "1.2" *** *)
a (asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a (POP_ASM_T ante_tac THEN asm_rewrite_tac[sets_ext_clauses] THEN REPEAT strip_tac);
a (∂_tac ¨zÆ THEN asm_rewrite_tac[]);
a (all_asm_fc_tac[]);
val izz_lemma1 = save_pop_thm "izz_lemma1";

set_goal([], ¨µA B∑ Cat B = CatSubs ¥ (A izz B § Cat A = CatSubs ± IndvSet A Ä IndvSet B)Æ);
a (REPEAT µ_tac THEN rewrite_tac[get_spec ¨$izzÆ, get_spec ¨CatSetÆ]); 
a (strip_tac THEN_TRY asm_rewrite_tac[] THEN REPEAT strip_tac THEN_TRY asm_rewrite_tac[]);
(* *** Goal "1" *** *)
a (POP_ASM_T ante_tac THEN asm_rewrite_tac[sets_ext_clauses] THEN REPEAT strip_tac);
a (spec_nth_asm_tac 2 ¨(InL x):ISUB + (ISUB ≠ BOOL)Æ);
(* *** Goal "1.1" *** *)
a (spec_nth_asm_tac 1 ¨xÆ);
(* *** Goal "1.2" *** *)
a (asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a (POP_ASM_T ante_tac THEN asm_rewrite_tac[sets_ext_clauses] THEN REPEAT strip_tac);
a (∂_tac ¨zÆ THEN asm_rewrite_tac[]);
a (all_asm_fc_tac[]);
val izz_lemma2 = save_pop_thm "izz_lemma2";

set_goal([], ¨µA B∑ ≥ Cat A = CatSubs ¥ (A izz B § Cat B = Cat A ± AttrSet A Ä AttrSet B)Æ);
a (REPEAT µ_tac THEN rewrite_tac[get_spec ¨$izzÆ, get_spec ¨CatSetÆ]); 
a (strip_tac THEN_TRY asm_rewrite_tac[] THEN REPEAT strip_tac THEN_TRY asm_rewrite_tac[]);
(* *** Goal "1" *** *)
a (POP_ASM_T ante_tac THEN asm_rewrite_tac[sets_ext_clauses]);
a (DROP_NTH_ASM_T 2 ante_tac THEN asm_rewrite_tac[] THEN strip_tac THEN asm_rewrite_tac[] THEN REPEAT strip_tac);
a (spec_nth_asm_tac 2 ¨(InR x):ISUB + (ISUB ≠ BOOL)Æ);
(* *** Goal "1.1" *** *)
a (spec_nth_asm_tac 1 ¨xÆ);
(* *** Goal "1.2" *** *)
a (asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a (POP_ASM_T ante_tac THEN asm_rewrite_tac[sets_ext_clauses] THEN REPEAT strip_tac);
a (∂_tac ¨zÆ THEN asm_rewrite_tac[]);
a (all_asm_fc_tac[]);
val izz_lemma3 = save_pop_thm "izz_lemma3";

set_goal([], ¨µA B∑ ≥ Cat B = CatSubs ¥ (A izz B § Cat B = Cat A ± AttrSet A Ä AttrSet B)Æ);
a (REPEAT µ_tac THEN rewrite_tac[get_spec ¨$izzÆ, get_spec ¨CatSetÆ]); 
a (strip_tac THEN_TRY asm_rewrite_tac[] THEN REPEAT strip_tac THEN_TRY asm_rewrite_tac[]);
(* *** Goal "1" *** *)
a (POP_ASM_T ante_tac THEN asm_rewrite_tac[sets_ext_clauses] THEN REPEAT strip_tac);
a (spec_nth_asm_tac 2 ¨(InR x):ISUB + (ISUB ≠ BOOL)Æ);
(* *** Goal "1.1" *** *)
a (spec_nth_asm_tac 1 ¨xÆ);
(* *** Goal "1.2" *** *)
a (asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a (POP_ASM_T ante_tac 
	THEN SYM_ASMS_T rewrite_tac
	THEN asm_rewrite_tac[sets_ext_clauses]
	THEN REPEAT strip_tac);
a (∂_tac ¨zÆ THEN asm_rewrite_tac[]);
a (all_asm_fc_tac[]);
val izz_lemma4 = save_pop_thm "izz_lemma4";
=TEX
}%ignore

\subsubsection{The Principles in HOL}

Here are the HOL versions of the Code ``Principles''.

The following is a bit of program in a programming language called SML, which stands for "Standard Meta Language"!
It names various terms in HOL, the name on the left `c01' (short for `conjecture 1'), the term on the right quoted in ``Quine corners''.
\footnote{``Quine corners'' are a notation originally used by Quine for Godel numbers, i.e., in Quine's use `¨43Æ' is a friendly way of writing doen the Godel number of the numeral `43'.
In ProofPower HOL these corners are used to refer to HOL terms in the metalanguage SML.
In HOL, a formula is a term of type îBOOLÆ (the opening î is used when quoting a type rather than a term).}

=SML
val c01 = ¨µA∑ A izz AÆ;
val c02 = ¨µA B C∑ A izz B ± B izz C ¥ A izz CÆ;
val c03 = ¨µA B∑ A hazz B ¥ ≥ A izz BÆ;
val c04 = ¨µA B∑ A hazz B § ∂C∑ A hazz C ± C izz BÆ;
=TEX

One would expect this set of principles to be sufficient to characterise {\it izz} and {\it hazz} (i.e. sufficient to derive any other true facts about them) but this seems doubtful.

Here are some supplementary conjectures.

=SML
val c01b = ¨µA∑ ≥ A hazz AÆ;
val c03b = ¨µA B∑ A izz B ¥ ≥ A hazz BÆ;
val c03c = ¨µA B∑ A hazz B ¥ ≥ A = BÆ;
val c04a = ¨µA B C∑ A hazz B ± B izz C ¥ A hazz CÆ;
val c04b = ¨µA B C∑ A izz B ± B hazz C ¥ A hazz CÆ;
=TEX

Of the supplementaries:

\begin{itemize}
\item c01b is derivable from c03 and c01.
\item c03b is the contrapositive of c03.
\item c03c would be derivable for Code once he has defined equality, it is provable for us now because we have a primitive equality.
\item c04a is a preferable formulation of the right-left implication in c04, and we have used it to prove c04.
\item c04b is an obvious further transitivity-like property, which does not look like it's provable from the stipulated principles.
\end{itemize}

\ignore{
=SML
set_goal([], c01);
a (REPEAT µ_tac THEN_TRY rewrite_tac [get_spec ¨$izzÆ]);
val l01 = save_pop_thm "l01";

set_goal([], c01b);
a (REPEAT µ_tac THEN_TRY rewrite_tac [get_spec ¨$hazzÆ] THEN contr_tac);
val l01b = save_pop_thm "l01b";

set_goal([], c02);
a (REPEAT µ_tac THEN_TRY rewrite_tac [get_spec ¨$izzÆ]
	THEN REPEAT strip_tac
	THEN_TRY asm_rewrite_tac[]
	THEN all_asm_fc_tac[Ä_trans_thm]);
val l02 = save_pop_thm "l02";

set_goal([], c03);
a (REPEAT µ_tac THEN_TRY rewrite_tac [get_spec ¨$izzÆ, get_spec ¨$hazzÆ] THEN contr_tac);
a (DROP_NTH_ASM_T 5 ante_tac
	THEN DROP_NTH_ASM_T 5 ante_tac
	THEN asm_rewrite_tac[]);
val l03 = save_pop_thm "l03";

set_goal([], c03b);
a (REPEAT µ_tac THEN_TRY rewrite_tac [get_spec ¨$izzÆ, get_spec ¨$hazzÆ] THEN REPEAT strip_tac);
a (asm_rewrite_tac[]);
val l03b = save_pop_thm "l03b";

set_goal([], c03c);
a (REPEAT µ_tac THEN_TRY rewrite_tac [get_spec ¨$izzÆ, get_spec ¨$hazzÆ] THEN contr_tac);
a (all_var_elim_asm_tac);
val l03c = save_pop_thm "l03c";

set_goal([], c04a);
a (REPEAT µ_tac THEN rewrite_tac [get_spec ¨$hazzÆ, get_spec ¨CatSetÆ]
	THEN contr_tac);
(* *** Goal "1" *** *)
a (all_fc_tac [izz_lemma2]);
(* *** Goal "2" *** *)
a (all_asm_fc_tac[]);
a (all_fc_tac [list_µ_elim [¨BÆ] izz_lemma3]);
a (POP_ASM_T ante_tac THEN rewrite_tac [sets_ext_clauses]
	THEN REPEAT strip_tac
	THEN asm_fc_tac[]);
a (∂_tac ¨aÆ THEN contr_tac);
val l04a = save_pop_thm "l04a";

set_goal([], c04);
a (REPEAT strip_tac);
(* *** Goal "1" *** *)
a (∂_tac ¨BÆ THEN asm_rewrite_tac[l01]);
(* *** Goal "2" *** *)
a (all_fc_tac [list_µ_elim [¨AÆ, ¨CÆ] l04a]);
val l04 = save_pop_thm "l04";

set_goal([], c04b);
a (REPEAT µ_tac THEN rewrite_tac [get_spec ¨$hazzÆ, get_spec ¨CatSetÆ]
	THEN contr_tac);
(* *** Goal "1" *** *)
a (all_fc_tac [izz_lemma2]);
(* *** Goal "2" *** *)
a (spec_nth_asm_tac 1 ¨aÆ);
a (FC_T (MAP_EVERY ante_tac) [get_spec ¨$izzÆ]);
a (strip_tac THEN asm_rewrite_tac [get_spec ¨CatSetÆ, sets_ext_clauses]
	THEN strip_tac);
a (∂_tac ¨InL sÆ THEN REPEAT strip_tac);
(* *** Goal "2.1" *** *)
a (∂_tac ¨sÆ THEN REPEAT strip_tac);
(* *** Goal "2.2" *** *)
a (contr_tac THEN asm_fc_tac[]);
a (all_var_elim_asm_tac);
val l04b = save_pop_thm "l04b";
=TEX
}%ignore

=GFT Proven Theorems
l01	= Ù µ A∑ A izz A
l01b 	= Ù µ A∑ ≥ A hazz A
l02	= Ù µ A B C∑ A izz B ± B izz C ¥ A izz C
l03	= Ù µ A B∑ A hazz B ¥ ≥ A izz B
l03b 	= Ù µ A B∑ A izz B ¥ ≥ A hazz B
l03c 	= Ù µ A B∑ A hazz B ¥ ≥ A = B
l04a	= Ù µ A B C∑ A hazz B ± B izz C ¥ A hazz C
l04	= Ù µ A B∑ A hazz B § (∂ C∑ A hazz C ± C izz B) 
l04b 	= Ù µ A B C∑ A izz B ± B hazz C ¥ A hazz C
=TEX

\subsection{Total Definitions}

=GFT Code/Speranza
[(B) Total Definitions]

{6. (A hazz B & A is a particular) -> there is a C such that (C =/= A) & (A izz B).}

[D1] 7. A is predicable of B iff ((B izz A) ≤ (B hazz Something that izz A).
[D2] 8. A is essentially predicable [L-predicable] of B iff B izz A.
[D3] 9. A is accidentally predicable [H-predicable] of B iff B hazz something that izz A.
[D4] 10. A = B iff A izz B & B izz A.
[D5] 11. A is an individual iff (Nec)(For all B) B izz A -> A izz B
[D6] 12. A is a particular iff (Nec)(For all B) A is predicable of B -> (A izz B & B izz A)
[D7] 13. A is a universal iff
		(Poss) (There is a B) A is predicable of A[B] & -(A izz B & B izz A)
=TEX

There is a certain amount of duplication of terminology here, since essential and accidental predication seem to be just $izz$ and $hazz$ backwards.
I'm not so happy with the ``ables'' here, for what is clearly meant is ``truly predicable'', which is not quite the same thing.
Better names would be simply ``is\_essentially'' and ``is\_accidentally'', lacking the ambiguity of ``able'' (but then they would have to be the other way round, exactly the same as $izz$ and $hazz$).

Anyway here are the definitions (keeping the names (more or less) as they were for the present):

=SML
declare_infix (300, "predicable_of");
declare_infix (300, "essentially_predicable_of");
declare_infix (300, "accidentally_predicable_of");
=TEX

πHOLCONST
‹ $€essentially_predicable_of› : CATM ≠ CATM ≠ BOOL
˜¸¸¸¸¸¸
‹ µA B∑ A essentially_predicable_of B § B izz A
∞

πHOLCONST
‹ $€accidentally_predicable_of› : CATM ≠ CATM ≠ BOOL
˜¸¸¸¸¸¸
‹ µA B∑ A accidentally_predicable_of B § B hazz A
∞

Aristotelian predication is then:

πHOLCONST
‹ $€predicable_of› : CATM ≠ CATM ≠ BOOL
˜¸¸¸¸¸¸
‹ µA B∑ A predicable_of B § A essentially_predicable_of B ≤ A accidentally_predicable_of B
∞

Because we have not precluded empty predicates Code's definition will not do, and we have to make ``individual'' primitive, insisting on an individual being a singleton.

πHOLCONST
‹ €individual› : CATM ≠ BOOL
˜¸¸¸¸¸¸
‹ µA∑ individual A § ∂a∑ CatSet A = {a}
∞

According to Code's definition a particular is a substantial individual, we also have to use a more direct statemant of that principle.

πHOLCONST
‹ €particular› : CATM ≠ BOOL
˜¸¸¸¸¸¸
‹ µA∑ particular A § individual A ± Cat A = CatSubs
∞

Again we have a problem with Code's definition and therefore define a universal as a non-particular.

πHOLCONST
‹ €universal› : CATM ≠ BOOL
˜¸¸¸¸¸¸
‹ µA∑ universal A § ≥ particular A
∞

=SML
val c06 = ¨µA B∑ A hazz B ± particular A ¥ ∂C∑ C Ω A ± A izz BÆ; 
val c06n = ¨≥ µA B∑ A hazz B ± particular A ¥ ∂C∑ C Ω A ± A izz BÆ; 
val c07 = ¨µA B∑ A predicable_of B § (B izz A) ≤ ∂C∑ B hazz C ± C izz AÆ;
val c08 = ¨µA∑ A essentially_predicable_of B § B izz AÆ;
val c09 = ¨µA∑ A accidentally_predicable_of B § ∂C∑ B hazz C ± C izz AÆ;
val c10 = ¨µA B∑ A = B § A izz B ± B izz AÆ;
val c11 = ¨µA B∑ individual A § ©(µB∑ B izz A ¥ A izz B)Æ;
val c12 = ¨µA∑ particular A § ©(µB∑ A predicable_of B ¥ A izz B ± B izz A)Æ;
val c13 = ¨µA∑ universal A § ®(∂B∑ (A predicable_of B ± ≥(A izz B ± B izz A)))Æ;
=TEX

\ignore{
=SML
set_goal([], c06n);
a (strip_tac);
a (∂_tac ¨InL {≈i:ISUB∑T}Æ);
a (strip_tac);
a (∂_tac ¨InR ((≈c:ACAT∑T), {Ãi∑T})Æ);
a (rewrite_tac[get_spec ¨$hazzÆ, get_spec ¨CatÆ, get_spec ¨CatSubsÆ,
	get_spec ¨$izzÆ, get_spec ¨AttrSetÆ, get_spec ¨particularÆ, get_spec ¨individualÆ,
	get_spec ¨CatSetÆ, get_spec ¨IndvSetÆ]);
a (REPEAT strip_tac);
(* *** Goal "1" *** *)
a (∂_tac ¨Ã i∑ TÆ THEN rewrite_tac[]);
(* *** Goal "2" *** *)
a (∂_tac ¨InL (≈ i∑ T)Æ THEN rewrite_tac[sets_ext_clauses]);
a (REPEAT strip_tac THEN_TRY asm_rewrite_tac[]);
a (∂_tac ¨≈ i∑ TÆ THEN rewrite_tac[]);
val l06n = save_pop_thm "l06n";

set_goal([], c07);
a (REPEAT µ_tac);
a (rewrite_tac [get_spec ¨$predicable_ofÆ, get_spec ¨$essentially_predicable_ofÆ,
		get_spec ¨$accidentally_predicable_ofÆ]);
a (rewrite_tac [list_µ_elim [¨BÆ, ¨AÆ] l04]);
val l07 = save_pop_thm "l07";

set_goal([], c08);
a (rewrite_tac [get_spec ¨$essentially_predicable_ofÆ]);
val l08 = save_pop_thm "l08";

set_goal([], c09);
a (REPEAT µ_tac);
a (rewrite_tac [get_spec ¨$accidentally_predicable_ofÆ, list_µ_elim [¨BÆ, ¨AÆ] l04]);
val l09 = save_pop_thm "l09";

set_goal([], c10);
a (REPEAT µ_tac THEN rewrite_tac [get_spec ¨$izzÆ, catm_eq_lemma]);
a (REPEAT strip_tac THEN_TRY asm_rewrite_tac[]);
a (all_fc_tac [pc_rule1 "hol1" prove_rule [] ¨µa b∑ a Ä b ± b Ä a ¥ a = bÆ]);
val l10 = save_pop_thm "l10";
=TEX
}%ignore

=GFT
l05 	= Ù µ x∑ form x ¥ universal x
l06n 	= Ù ≥ (µ A B∑ A hazz B ± particular A ¥ (∂ C∑ C Ω A ± A izz B))
l07 	= Ù µ A B∑ A predicable_of B § B izz A ≤ (∂ C∑ B hazz C ± C izz A)
l08 	= Ù µ A∑ A essentially_predicable_of B § B izz A
l09 	= Ù µ A∑ A accidentally_predicable_of B § (∂ C∑ B hazz C ± C izz A)
l10	= Ù µ A B∑ A = B § A izz B ± B izz A
=TEX

c06 is false (see l06n), probably a typo.
However, I couldn't work out what was intended.

c11-13 are not provable in our model because of the existence of empty predicates (and the lack of modal operators).

\subsection{Partial Definitions}

=GFT Code/Speranza
[(C) Partial Definitions]

[D8] 14. If A is Some Thing [a this somewhat], A is an  individual.
[D9] 15. If A is a [(seperable) Platonic] Form,
		A is Some Thing [a this somewhat] and Universal.
=TEX

\ignore{
=SML
set_goal ([],¨∂SomeThing∑ µx∑ SomeThing x ¥ individual xÆ);
a (∂_tac ¨individualÆ THEN rewrite_tac[]);
save_cs_∂_thm(pop_thm());
=TEX
}%ignore

This is D8/c14.

πHOLCONST
‹ €SomeThing› : CATM ≠ BOOL
˜¸¸¸¸¸¸
‹ µx∑ SomeThing x ¥ individual x
∞

A form is a non-substantial individual.

\ignore{
=SML
set_goal ([],¨∂form∑ µx∑ form x ¥ SomeThing x ± universal xÆ);
a (∂_tac ¨Ãx∑ SomeThing x ± universal xÆ THEN rewrite_tac[]);
save_cs_∂_thm(pop_thm());
=TEX
}%ignore

This is D9/c15

πHOLCONST
‹ €form› : CATM ≠ BOOL
˜¸¸¸¸¸¸
‹ µx∑ form x ¥ SomeThing x ± universal x
∞

\subsection{Ontological Theorems}

=GFT Code/Speranza
[(D) Ontological Theorems]

[T1] 16. A is predicable of B iff (B izz A) v (B hazz Some Thing that Izz A).
[T2] 17. A is essentially predicable [L-predicable] of A.
[T3] 18. A is accidentally predicable [H-predicable] of B ->  A =/= B
[T4] A is not accidentally predicable [H-predicable] of A
{19. - (A is accidentally predicable of B) -> A =/= B.}
[T5] 20. A is a particular -> A is an individual.
	[Note that the converse of T5 is not a theorem]
[T6] 21. A is a particular -> No Thing [nothing] that is Not Identical with A izz A.
[T7] 22. No Thing is both particular & a [(separable) Platonic] Form.
[T8] 23. A is a (seperable Platonic) Form -> nothing that is not identical with A izz A.
[T9] 24. A is a particular -> there is no (seperable Platonic) form B such that A izz B.
[T10] 25. A is a (seperable Platonic) form
		-> ((A is predicable of B & A =/= B) -> B hazz A)
[T11] 26. (A is a (seperable Platonic) form & B is a particular)
		-> (A is predicable of B iff B hazz A).
=TEX

We need to define inequality:

=SML
declare_infix (300, "Ω");
=TEX

πHOLCONST
‹ $€Ω› : 'a ≠ 'a ≠ BOOL
˜¸¸¸¸¸¸
‹ µx y∑ x Ω y § ≥ x = y
∞

=SML
val c05 = ¨µx∑ universal x ¥ form xÆ;
val c05b = ¨µx∑ form x ¥ universal xÆ;
val c16 = ¨µA B∑ A predicable_of B § (B izz A) ≤ ∂C∑ (B hazz C ± C izz A)Æ;
val c17 = ¨µA∑ A essentially_predicable_of AÆ;
val c18 = ¨µA∑ A accidentally_predicable_of B ¥ A Ω BÆ;
val c19 = ¨µA∑ ≥ A accidentally_predicable_of AÆ;
val c20 = ¨µA∑ particular A ¥ individual AÆ;
val c21 = ¨µA∑ particular A ¥ ≥ ∂C∑ C Ω A ± C izz AÆ;
val c22 = ¨≥ ∂A∑ particular A ± form AÆ;
val c23 = ¨µA∑ form A ¥ ≥ ∂C∑ C Ω A ± C izz AÆ;
val c23b = ¨µA∑ form A ¥ individual AÆ;
val c24a = ¨µ A B∑ particular A ± individual B ± A izz B ¥ particular BÆ;
val c24 = ¨µA∑ particular A ¥ ≥ ∂B∑ form B ± A izz BÆ;
val c24b = ¨µA∑ particular A ¥ ≥ form AÆ;
val c25 = ¨µA B∑ form A ¥ A predicable_of B ± A Ω B ¥ B hazz AÆ;
val c26 = ¨µA B∑ form A ± particular B ¥ (A predicable_of B § B hazz A)Æ;
=TEX

\ignore{
=SML
=IGN
set_goal([], c06n);
a (strip_tac);
a (∂_tac ¨InL{≈x:ISUB∑T}:CATMÆ THEN strip_tac);
a (∂_tac ¨InR((≈x:ACAT∑T), {Ãx:ISUB∑T}):CATMÆ THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a (rewrite_tac (map get_spec [¨$hazzÆ, ¨CatÆ, ¨CatSubsÆ]));
a (∂_tac ¨Ãx:ISUB∑TÆ);
a (rewrite_tac (map get_spec [¨AttrSetÆ]));
(* *** Goal "2" *** *)
a (rewrite_tac (map get_spec [¨particularÆ, ¨individualÆ]) THEN strip_tac);
(* *** Goal "2.1" *** *)
a (∂_tac ¨InL(≈ x:ISUB∑ T):ISUB + (ISUB ≠ BOOL)Æ);
a (rewrite_tac [get_spec ¨CatSetÆ, get_spec ¨CatÆ, get_spec ¨IndvSetÆ, sets_ext_clauses]);
a (REPEAT strip_tac THEN_TRY asm_rewrite_tac[]);
a (∂_tac ¨≈ x:ISUB∑ TÆ);
a (rewrite_tac[]);
(* *** Goal "2.2" *** *)
a (rewrite_tac [get_spec ¨CatÆ]);
(* *** Goal "3" *** *)
a (swap_nth_asm_concl_tac 1);
a (rewrite_tac[get_spec ¨$izzÆ, get_spec ¨CatÆ, get_spec ¨CatSubsÆ]);
val l06n = save_pop_thm "l06n";
=SML

set_goal([], c16);
a (rewrite_tac [map_eq_sym_rule l04]);
a (REPEAT µ_tac THEN rewrite_tac [get_spec ¨$predicable_ofÆ,
	get_spec ¨$essentially_predicable_ofÆ, get_spec ¨$accidentally_predicable_ofÆ]);
val l16 = save_pop_thm "l16";

set_goal([], c17);
a (REPEAT µ_tac THEN rewrite_tac [get_spec ¨$essentially_predicable_ofÆ, l01]);
val l17 = save_pop_thm "l17";

set_goal([], c18);
a (REPEAT µ_tac THEN rewrite_tac [get_spec ¨$accidentally_predicable_ofÆ, get_spec ¨$ΩÆ]);
a (strip_tac THEN fc_tac [l03c]);
a (swap_nth_asm_concl_tac 1 THEN asm_rewrite_tac[]);
val l18 = save_pop_thm "l18";

set_goal([], c19);
a (rewrite_tac [get_spec ¨$accidentally_predicable_ofÆ, l01b]);
val l19 = save_pop_thm "l19";

set_goal([], c20);
a (REPEAT µ_tac THEN rewrite_tac [get_spec ¨$particularÆ]
	THEN contr_tac);
val l20 = save_pop_thm "l20";

=IGN
set_goal([], c21);
a (REPEAT µ_tac THEN rewrite_tac [get_spec ¨$particularÆ]
	THEN contr_tac);
val l21 = save_pop_thm "l21";
=SML

set_goal([], c22);
a (contr_tac);
a (fc_tac [get_spec ¨formÆ]);
a (fc_tac [get_spec ¨universalÆ]);
val l22 = save_pop_thm "l22";

set_goal([], c23b);
a (REPEAT strip_tac THEN fc_tac [get_spec ¨formÆ]);
a (fc_tac [get_spec ¨SomeThingÆ, get_spec ¨universalÆ]);
val l23b = save_pop_thm "l23b";

set_goal([], c24a);
a (REPEAT µ_tac THEN rewrite_tac [get_spec ¨particularÆ, get_spec ¨individualÆ,
		get_spec ¨$izzÆ]
	THEN strip_tac THEN strip_tac);
(* *** Goal "1" *** *)
a (∂_tac ¨a'Æ THEN asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a (SYM_ASMS_T rewrite_tac);
val l24a = save_pop_thm "l24a";

set_goal([], c24);
a (contr_tac THEN fc_tac [get_spec ¨formÆ]);
a (fc_tac [get_spec ¨SomeThingÆ, get_spec ¨universalÆ, get_spec ¨particularÆ, get_spec ¨individualÆ]);
a (all_fc_tac [l24a]);
val l24 = save_pop_thm "l24";

=IGN
set_goal([], c25b);
a (REPEAT µ_tac THEN rewrite_tac [get_spec ¨$predicable_ofÆ, get_spec ¨$accidentally_predicable_ofÆ,
	get_spec ¨$essentially_predicable_ofÆ, get_spec ¨$izzÆ] THEN strip_tac
	THEN fc_tac [get_spec ¨formÆ]);
a (fc_tac [get_spec ¨SomeThingÆ, get_spec ¨universalÆ]);
a (DROP_ASM_T ¨≥ particular AÆ (strip_asm_tac o (rewrite_rule [get_spec ¨particularÆ])));
a (REPEAT strip_tac);
a (rewrite_tac[get_spec ¨$hazzÆ] );

a (rewrite_tac [get_spec ¨$predicable_ofÆ, get_spec ¨$accidentally_predicable_ofÆ, get_spec ¨$essentially_predicable_ofÆ,
	get_spec ¨$izzÆ]
	THEN contr_tac);
a (DROP_ASM_T ¨Cat B = CatSubsÆ ante_tac);
a (asm_rewrite_tac[]);
val l25 = save_pop_thm "l25";
=SML

set_goal([], c26);
a (REPEAT µ_tac THEN rewrite_tac [get_spec ¨particularÆ] THEN strip_tac
	THEN fc_tac [get_spec ¨formÆ, get_spec ¨SomeThingÆ]);
a (fc_tac [get_spec ¨SomeThingÆ, get_spec ¨universalÆ]);
a (DROP_ASM_T ¨≥ particular AÆ (strip_asm_tac o (rewrite_rule [get_spec ¨particularÆ])));
a (rewrite_tac [get_spec ¨$predicable_ofÆ, get_spec ¨$accidentally_predicable_ofÆ, get_spec ¨$essentially_predicable_ofÆ,
	get_spec ¨$izzÆ]
	THEN contr_tac);
a (DROP_ASM_T ¨Cat B = CatSubsÆ ante_tac);
a (asm_rewrite_tac[]);
val l26 = save_pop_thm "l26";
=TEX
}%ignore

These are the ones I have proved.

=GFT
l16 	= Ù µ A B∑ A predicable_of B § B izz A ≤ (∂ C∑ B hazz C ± C izz A)
l17 	= Ù µ A∑ A essentially_predicable_of A
l19 	= Ù µ A∑ ≥ A accidentally_predicable_of A
l20 	= Ù µ A∑ individual A ¥ particular A
l22 	= Ù ≥ (∂ A∑ particular A ± form A)
l23b 	= Ù µ A∑ form A ¥ individual A
l24a 	= Ù µ A B∑ particular A ± individual B ± A izz B ¥ particular B
l24 	= Ù µ A∑ particular A ¥ ≥ (∂ B∑ form B ± A izz B)
l26 	= Ù µ A B∑ form A ± particular B ¥ (A predicable_of B § B hazz A)
=TEX

T6/c21, T8/c23, T10/c25 are all unprovable because of the existence of empty predicates.

\subsection{Platonic Principles and Theorems}

This section is a bit of a mess.
I have not yet worked out what is going on here.

=GFT Code/Speranza
[(E) Platonic Principle]

[PP1] 5. Each universal is a (seperable Platonic) form.
[PP2] 27. (A is particular & B is a universal & predicable of A)
	-> there is a C such that (A =/= C  & C is essentially predicable of A)
=TEX

=SML
val c05 = ¨µx∑ universal x ¥ form xÆ;
val c05b = ¨µx∑ form x ¥ universal xÆ;
val c27 = ¨µA B∑ particular A ± universal B ± B predicable_of A
		¥ ∂C∑ (A Ω C ± C essentially_predicable_of A)Æ;
=TEX

\ignore{
=SML
set_goal([], c05b);
a (REPEAT strip_tac THEN fc_tac [get_spec ¨formÆ]);
val l05b = save_pop_thm "l05b";

=IGN
set_goal([], c27);
a (REPEAT strip_tac THEN fc_tac [get_spec ¨formÆ]);
val l05b = save_pop_thm "l05b";
=TEX
}%ignore

c05 is not provable, its converse c05b is.
c27 is not provable, since it would require that there be more than one particular and we have no reason to believe that to be the case.

=GFT
l05b 	= Ù µ x∑ form x ¥ universal x
=TEX

=GFT Code/Speranza
[(F) Platonic Theorem]

{28. If there are particulars, of which universals are predicable,
	not every universal is Some Thing.}
[PP1] 29. Each universal is Some Thing [a this somewhat].
[PP2] 30. If A is a particular, there is no B such that
	(A =/= B &  B is essentially predicable of A).
[PP3] 31. (A is predicable of B & A =/= B) -> A is accidentally predicable of B.
=TEX

=SML
val c28 = ¨(∂P∑ particular P ± ∂U∑ universal U ± U predicable_of P)
		¥ ≥ (µU∑ universal U ¥ thing U)Æ;
val c29 = ¨µU∑ universal U ¥ thing UÆ;
val c30 = ¨µA∑ particular A ¥ ≥ ∂B∑ (A Ω B ± B essentially_predicable_of A)Æ;
val c31 = ¨µA B∑ A predicable_of B ± A Ω B ¥ A accidentally_predicable_of BÆ;
=TEX

\ignore{
=SML

=IGN
set_goal([], c06n);
a (strip_tac);
a (∂_tac ¨InL{≈x:ISUB∑T}:CATMÆ THEN strip_tac);
a (∂_tac ¨InR((≈x:ACAT∑T), {Ãx:ISUB∑T}):CATMÆ THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a (rewrite_tac (map get_spec [¨$hazzÆ, ¨CatÆ, ¨CatSubsÆ]));
a (∂_tac ¨Ãx:ISUB∑TÆ);
a (rewrite_tac (map get_spec [¨AttrSetÆ]));
(* *** Goal "2" *** *)
a (rewrite_tac (map get_spec [¨particularÆ, ¨individualÆ]) THEN strip_tac);
(* *** Goal "2.1" *** *)
a (∂_tac ¨InL(≈ x:ISUB∑ T):ISUB + (ISUB ≠ BOOL)Æ);
a (rewrite_tac [get_spec ¨CatSetÆ, get_spec ¨CatÆ, get_spec ¨IndvSetÆ, sets_ext_clauses]);
a (REPEAT strip_tac THEN_TRY asm_rewrite_tac[]);
a (∂_tac ¨≈ x:ISUB∑ TÆ);
a (rewrite_tac[]);
(* *** Goal "2.2" *** *)
a (rewrite_tac [get_spec ¨CatÆ]);
(* *** Goal "3" *** *)
a (swap_nth_asm_concl_tac 1);
a (rewrite_tac[get_spec ¨$izzÆ, get_spec ¨CatÆ, get_spec ¨CatSubsÆ]);
val l06n = save_pop_thm "l06n";
=TEX
}%ignore

These are the ones I have proved.

=GFT
l06n =	Ù ≥ (µ A B∑ A hazz B ± particular A ¥ (∂ C∑ C Ω A ± A izz B))
=TEX

\subsection{Some Comments on The Conjectures}

The main problem with the conjectures is that as a group they are inconsistent.
Consequently, one cannot find definitions which are consistent with all the conjectures.

So first I will expose some of the most obvious contradications which flow from the conjectures.

\begin{enumerate}
\item From 5 and 15 we conclude that form and universal are coextensive.
I think it may be that this is part of the Platonic view but not of the Aristotelian one.

\end{enumerate}

Here are some observations on specific conjectures (now out of date).

\begin{description}

\item[c01]
Note here that this is quantified over everything, and hence over individuals, whereas Aristotle describes individuals as thing of which one may predicate, but which are not themselves predicable.
Perhaps this inderdiction applies to $hazz$ but not to $izz$, to accidental but not essential predication.
(We should add the rule ¨≥ A hazz AÆ which is easy to prove.)
I don't know any more detail about Aristotle's attitude towards predication by individuals.
If one cannot, where do we stand when we do, as in ``Socrates is Socrates'' and ``Socrates is Aristotle''.
Anyway, if these were to have a truth value (which surely they do) then the truth value will be as in this rule.

\item[c02]
Behind the scenes this is transitivity of set inclusion.

\item[c03]
This is because {\it izz} is intracategorial and {\it hazz} is intercategorial.
An obvious but useful corrolary is that they are not equal (c03b).

\item[c04]
This, and most of the other theorems involving existential quantification, is rather odd.
Its proof depends on the conjecture $c04a$, which we have proven, and which involves no existential quantification, but its content is not significantly greater than that rule.
From right to left $l04$ is $l04b$ (you just pull out the existential and it turns into a universal).
Frin left to right $l04$ is trivial, since $B$ serves as a witness for the existential.

Ideally we would be working with claims which are expressible syllogistically, i.e. without benefit of quantifiers.
We can make an exception for universals on the left, since these are interconvertible with the conjecture with free variables instead which we can think of as schemata.
Where an existential quatifier appears in a negative context it will turn universal if pulled out to the top level and can therefore be dispensed with.
Elsewhere its worth asking whether the content is significant (including, as here, one half of the content implicit in putting an existential under an equivalence).

$co4b$ is an obvious similar result to $c04a$.

\item[c05]
According to my definition this is the wrong way round.

\item[c06]
As it stands this is provably false since we have $¨A hazz BÆ$ on the left, which entails that $A$ and $B$ are not of the same category, and $¨A izz BÆ$ in the right, which entails that they are of the same category.

\item[c07]
This, at the expense of using an existential, nevertheless tells us nothing that is not immediate from the definitions.

\item[c08]
Is just our definition.

\item[c09]
This turns into $c04$ (apart from the variable names) once you expand the definition of {\it accidentally\_predicable\_of}.

\item[c10]
Behind the scenes, {\it izz} is set inclusion, so this is obvious.

\item[c11-13]
These contain modal operators which cannot be defined using this model.

\item[c14-c15]
I've not worked out what a ``thing'' is.
Not even sure that I should have rendered Speranza's version using that term.
However, I do think I know that {\it particular} and {\it universal} are opposites (contradictories), and hence I could conclude from these two conjectures that there can be no {\it forms} since they entail that a form is both individual and universal.
Sounds like I have the wrong end of some stick or other.

\item[c16]
I don't know enough about ``thing''s to prove this one.

\item[c17]
This is $c01$ in other words.

\item[c018]
This is $c03b$ in other words.

\item[c19]

This is the contrapositive of the claim that {\it accidentally\_predicable\_of} is reflexive, which is false.
Would be true for {\it essentially\_predicable\_of}, but we already have that stated directly as c17.

\item[c20]
Immediate from my definitions.

\item[c21]
This turns out to be false under my definitions, because I have not excluded the possibility of an empty predicate.
However, one wonders why this should be excluded.

If I go over to a model adquate for modal operators then it will be easy to exclude this possibility.

\item[c21]
Fails for same reason as c20, though I could fix this by making the definition of {\it universal} insist on more than one member.

\item[c23]
I don't know why this should be true.
Any particular which partakes of a form contradicts it.

\item[c24]
This is not true in the present model, because we might have only one particular, and hence no non-trivial forms.

\item[c25-c26]
These two tell me that forms are not substance, but attributes, which contradicts c24 which tells us that there are subtantial forms (if particulars are substances). 

\item[c27]
I don't see why this should be true.

\item[c28-c29]
These two together entail that no universal is predicable of any particular.

\item[c30]
This says that nothing is essentially predicable of a particular except itself.

\item[c31]
This is a stronger version of c30 which says that, even if something isn't particular, nothing but itself is essentially predicable of it.

\end{description}

\section{POSTSCRIPT}\label{POSTSCRIPT}

These are the kinds of thing which {\it might} happen in future issues of this document:

\begin{itemize}
\item If I get constructive feedback (pointing out errors counts, telling me its a waste of time doesn't, explaining bits of Aristotle I'm getting wrong would be great) then I will probably do something about it.

\item There is a good chance I will get to know something about what Aristotle really said and make improvements arising from this.
In that case I would like to put some hyperlinks into my online hypertext of Aristotle's relevant works, connecting the specific features of the model with the passages in Aristotle which they reflect.

\item I think it would not be much harder to do a model in which modal operators are definable, and I would like to know whether I am right, so there is a good chance I will produce a modal version (with most of the same defects in other respects).
I may or may not then discard the non-modal version.

\item If I were to continue then I am inclined to think that some formalisation of Aristotle's syllogistic logic should intervene between the categories and the metaphysics (first cut is now there).

\item I think I need to incorporate the ``existential fallacy''.

\item I am interested in the methods, and I may spend more time trying to describe them in a way which might be intelligible to philosophers.

\item If this ever becomes a good approximation to Aristotle's position there would then be some philosophical analysis of the metaphysics (by contrast with a purely logical analysis), and somewhere there are points to be made about the kind of analysis which I am aiming for.
\end{itemize}

I'm inclined now to try a further model which combines the two above, adds modality and the existential fallacy, and is expressed as syllogistically as possible.

\appendix

{
\let\Section\section
\def\section#1{\Section{#1}\label{syllog1}}
\include{syllog1.th}
\def\section#1{\Section{#1}\label{syllog2}}
\include{syllog2.th}
\def\section#1{\Section{#1}\label{ariscat}}
\include{ariscat.th}
}  %\let

\pagebreak
\section*{BIBLIOGRAPHY}\label{BIBLIOGRAPHY}
\addcontentsline{toc}{section}{BIBLIOGRAPHY}

{
\def\section*#1{\ignore{#1}}
\raggedright
\bibliographystyle{fmu}
\bibliography{rbj,fmu}
} %\raggedright


{\twocolumn[\section*{INDEX}\label{index}]
\addcontentsline{toc}{section}{INDEX}

{\small\printindex}}

\end{document}
