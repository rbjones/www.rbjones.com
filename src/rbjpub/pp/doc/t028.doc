=IGN
val _ =
	let open ReaderWriterSupport.PrettyNames;
	in add_new_symbols [ (["identeq"], Value "\233", Simple) ]
end;
=TEX

\def\rbjidtACIdoc{$$Id: t028.doc,v 1.22 2010/12/09 15:02:33 rbj Exp $$}
\tiny[\rbjidtACIdoc]

My purpose here is to use formal models to aid in understanding the philosophies of Plato\index{Plato} and Aristotle\index{Aristotle|bf}, both in relation to their contribution generally to the areas of interest, philosophical logic, semantics and metaphysics. and also more specifically in relation to the extent to which these philosophers laid the ground for the distinction which was later expressed in Hume's fork.

In doing this I began with some enquiries into Aristotle's metaphysics published by Code\index{Code} \cite{code88} and produced from this a preliminary model (Section \ref{METAPHYSICSI}).
In these the single most important defect is that the model does not support the u-p syllogisms on which Code's analysis depends more heavily than one might have expected, and also does not allow for modal operators, which not only enter into Code's material but are also important for the kinds of comparison with later philosophers which I had hoped to undertake.

I then went back from the Metaphysics to the Organon\index{Aristotle!organon} and used formal models to come to a better understanding of Aristotle's formal syllogistic logic (Section \ref{ORGANON}).
In this three models of increasing sophistication were produced and formed the basis for undertaking a further model of the metaphysics which incorporated the u-p syllogisms and modal operators (Section \ref{METAPHYSICSII}).

\subsection{Preliminary Formalities}

In the document several different formal models are presented.
By and large they are independent, but a some features are common and are therefore presented here for use in all the models.

=SML
open_theory "misc2";
force_new_theory "aristotle";
=TEX

\ignore{
=IGN
force_new_pc Û"'ariscat"Ý;
merge_pcs ["'savedthm_cs_¶_proof"] "'ariscat";
set_merge_pcs ["misc2", "'ariscat"];
=SML
set_pc "misc2";
=TEX
}%ignore

We define inequality:

=SML
declare_infix (300, "½");
=TEX

¹HOLCONST
Ü $Û½Ý : 'a ­ 'a ­ BOOL
÷üüüüüü
Ü µx y· x ½ y ¤ ³ x = y
°

\section{Metaphysics (I)}\label{METAPHYSICSI}

In this section we consider some material on Aristotle's Metaphysics \cite{aristotleMetap} which originated in work of Grice and Code \cite{code88} and came to me from a \href{http://rbjones.com/pipermail/hist-analytic_rbjones.com/2009q2/000258.html}{posting of J.L. Speranza} on the hist-analytic mailing list.
Code's paper is also partially available at \href{http://books.google.co.uk/books?id=sHWK4Lz37sAC&printsec=frontcover#PPA411,M1}{Google Books}.

What Speranza posted was the list of formulae which are named below as c01 through c31 (though not exactly as given, I have massaged them to be acceptable to HOL and also have quantified over all free variables).

The analysis in this section is independent of the preceding analysis of Aristotle's syllogism, and considers predication from a rather different point of view, which hangs around the distinction between essential and accidental predication.
In the next section I will produce another model in which essence and accident are combined with a full treatment of modal syllogism so that some conclusions might be drawn about the relationship between essence and necessity in Aristotelean philosophy.

A new theory is needed which I will call ``ariscat'' which is created here:

=SML
open_theory "aristotle";
force_new_theory "ariscat";
=TEX

\ignore{
=SML
force_new_pc Û"'ariscat"Ý;
merge_pcs ["'savedthm_cs_¶_proof"] "'ariscat";
set_merge_pcs ["misc2", "'ariscat"];
=TEX
}%ignore

\subsection{The Grice/Code/Speranza Formulae}

This work began with an attempt to analyse using {\Product} a set of formulae posted by J.L. Speranza to the \href{http://www.hist-analytic.org/}{hist-analytic mailing list}.
These were a Speranzan transcript of formulae published in a paper by Code \cite{code88}, the work presented in that paper having begun with some joint work with H.P.~Grice \cite{grice88}.

The following material labelled ``Code/Speranza'' began as a transcription from Speranza's email, and was later updated when Speranza pointed me to the partial availability of the Code paper on Google Books.
I then put back some of the detail missed in the Speranza version, enclosed in square brackets, and enclosed in curly braces some of the material which Speranza had added to Code's.

The terminology used is Grice's.
Code uses ``Is'' and ``Has'' instead of ``izz'' and ``hazz'' (which were coined by Grice and used by Speranza).
Aristotle's originals have been translated as ``SAID OF'' and ``IN'', according to Cohen (\href{http://faculty.washington.edu/smcohen/433/GriceCode.pdf}{Grice and Code on IZZing and HAZZing}).

The material is interspersed with a formalisation in \ProductHOL.
I have adopted some of Code's headings for sections.

\subsection{Aristotelian References}

These are gathered together temporarily and will later be distributed as footnotes.

\begin{description}
\item[$Cat.\ 1^a$, 12--15]
	\href{http://texts.rbjones.com/rbjpub/philos/classics/aristotl/o1101i.htm}{Equivocally, Univocally and Derivatively.}
\item[$Cat.\ 2^a$, 19--34]
	\href{http://texts.rbjones.com/rbjpub/philos/classics/aristotl/o1102i.htm}{Presence and Predication.}
\item[$Cat.\ 3^a$, 15--20]
	\href{http://texts.rbjones.com/rbjpub/philos/classics/aristotl/o1103i.htm}{Subclasses and Predicability.}
\item[$Cat.\ 10^a$, 27ff.]
	\href{http://texts.rbjones.com/rbjpub/philos/classics/aristotl/o1110i.htm}{Opposite, Contrary, Privative, Positive.}
\item[$De.\ Int.$ 7, $17^a$9--40]
	\href{http://texts.rbjones.com/rbjpub/philos/classics/aristotl/o2107i.htm}{Universal and Individual Subjects.}
\item[$Post.\ An.\ A4,\ 73^a$34--$^b5$]
	\href{http://texts.rbjones.com/rbjpub/philos/classics/aristotl/o4104i.htm}{What are the premisses of demonstration.}
	Distinguishing essential and accidental predication.
\item[$Metap.\ I1,\ 1059^a10-14$]
	\href{http://texts.rbjones.com/rbjpub/philos/classics/aristotl/m11001i.htm}{The One.}
\item[$Metap.\ „9,\ 1018^a1-4$]
	\href{http://texts.rbjones.com/rbjpub/philos/classics/aristotl/m1509i.htm}{Same and Different.}
	'Socrates' and 'musical Socrates' are thought to be the same; but 'Socrates' is not predicable of more than one subject, and 		therefore we do not say 'every Socrates' as we say 'every man'.
\item[$Metap.\ „18,\ 1022^a25-27$]
	\href{http://texts.rbjones.com/rbjpub/philos/classics/aristotl/m1518i.htm}{In Virtue Of.}
	Admissibility of self-predication of particulars.
\item[$Metap.\ Z5$]
	\href{http://texts.rbjones.com/rbjpub/philos/classics/aristotl/m1705i.htm}{Only substance is definable.}
\item[$Metap.\ Z6, 1032^a4-6$]
	\href{http://texts.rbjones.com/rbjpub/philos/classics/aristotl/m1706i.htm}{Each thing and its essence are one and the same.}
\item[$Metap.\ Z11, 1037^a33-^b4$]
	\href{http://texts.rbjones.com/rbjpub/philos/classics/aristotl/m1711i.htm}{Formulae, Parts, Substance and Essence.}
\end{description}


\subsection{Formal Principles}

We begin with ``Formal Principles'' which we take as implicit definitions of two kinds of Aristotelian predication.

=GFT Code/Speranza
[(A) Formal Principles]

[FP1] 1. A izz A.
[FP2] 2. (A izz B & B izz C) --> A izz C.
[FP3] 3. A hazz B -> -(A izz B).
[FP4] 4. A hazz B iff A hazz Some-Thing [something] that izz B.
=TEX

The modelling in \ProductHOL will be entirely conservative, so we provide explicit definitions for ``izz'' and ``hazz'' and prove that they satisfy these principles and suffice also for the definitions and theorems which follow.

If the formal development is complete the definitions will have been shown to be sufficient.
In order to test whether the principles suffice I will attempt to proceed on these alone, though I suspect that will not be possible.
Failing that I will offer informal arguments to the contrary (a formal argument would require ascent to a metatheory which would involve too much work).

In order to define these concepts we have to decide what they are about, and this is not straightforward.

\subsubsection{Categories}

Aristotle has a system of categories, and these seem central to the topic.
Much hang on what these are, and to get a nice structure to our theory it seems advisable to do a bit of ``category theory'' first.
Of course this is not at all the same thing as the branch of mathematics which now goes by that name, but the choice of name for the mathematics was not entirely quixotic and at some point it might be interesting to think about the relationship between the two kinds of category theory.

Among these categories that of substances plays a special role.
Substances can be particular in which case they correspond to some individual, or not, in which case they are sets of individuals.
The particulars of the other categories are attributes, and the non-individuals are sets of attributes.
I don't think you can have singleton sets, so we can model all these categories as sets of sets in which the singleton sets are the individuals.
Attributes can also be considered as sets of individual substances and so there is a type difference between the category of substances and the other categories.

The following introduce new types and type abbreviations for modelling Aristotle's categories.

\begin{description}
\item ACAT is a type of attribute categories
\item ISUB is a type of individual substances
\item CATM is the type of the things which are in categories.

This is a `disjoint union', which means that there are two kinds of thing which one finds in categories, either a set of individual substances (using singleton sets to represent individual substances), or a set of properties of individual substances tagged with an attribute category.

\item CAT is a type abbreviation for a notion of category which is either an attribute category or some other category (which will stand for the category of substances).

\end{description}

There are some oversimplifications here which I am hoping will not be too serious for a useful first cut.

\begin{description}
\item[Modal Operators]
The main one is that this general approach will not permit the definition of modal operators, which are used by Code.
Whether there is real need for them seems to me doubtful, but if necessary a modal model could be provided.
\item[Empty Sets]
The second is that I have not excluded empty sets, and hence that there can be predicates with null extensions.
This is in fact consistent with Code's ``principles'', but we find that his definitions are written as if there were no empty predicates, even though this is not entailed by the principles.
I where Code's definitions presume non-emptiness of predicates I have chosen another definition which does not.
Some of the theorems are then unprovable.
\item[Extensionality]
Intracategorial equality will be extensional.
That appears to be what is required, so it probably isn't a problem!
\item[Predicability]
Aristotle defines particulars in terms of Predicability, they are the impredicables.
Its not clear how to deal with this, and it appears to be in terminological conflict with Code, who appears to use use ``predicable'' to mean ``truly predicable''.
Code has the general principle ``A izz A'' which implicitly asserts that everything is truly predicable of itself.
\end{description}

=SML
new_type(Û"ACAT"Ý, 0);
new_type(Û"ISUB"Ý, 0);
declare_type_abbrev (Û"CATM"Ý, [], ”ISUB ð + (ACAT ¸ (ISUB ­ BOOL)ð)®);
declare_type_abbrev (Û"CAT"Ý, [], ”ONE + ACAT®);
=TEX

We name the category of substances.

¹HOLCONST
Ü ÛCatSubsÝ : CAT
÷üüüüüü
Ü CatSubs = InL One
°

Now we define various operators over categories and their constituents which suffice for the development of an appropriate theory, in the context of which rest of the Aristotelian terminology will we hope prove definable.

First ``projection'' functions which yield the constituents of $MCAT$s.

¹HOLCONST
Ü ÛCatÝ : CATM ­ CAT
÷üüüüüü
Ü µx· Cat x = if IsL x then CatSubs else InR(Fst (OutR x))
°

¹HOLCONST
Ü ÛIndvSetÝ : CATM ­ ISUB ð
÷üüüüüü
Ü µx· IndvSet x = OutL x
°

¹HOLCONST
Ü ÛAttrSetÝ : CATM ­ (ISUB ­ BOOL)ð
÷üüüüüü
Ü µx· AttrSet x = Snd(OutR x)
°

This one turns out handy.

¹HOLCONST
Ü ÛCatSetÝ : CATM ­ (ISUB + (ISUB ­ BOOL))ð
÷üüüüüü
Ü µx· CatSet x =
Ü	if Cat x = CatSubs
Ü	then {y | ¶z· z  IndvSet x ± y = InL z}
Ü	else {y | ¶z· z  AttrSet x ± y = InR z}
°

With these definitions in place we get a useful characterisation of identity for elements of $CATM$.

=GFT
catm_eq_lemma =
	ô µ A B· A = B ¤ Cat A = Cat B ± CatSet A = CatSet B
=TEX

\ignore{
=SML
set_goal([], ¬µA B· A = B ¤ Cat A =  Cat B ± CatSet A = CatSet B®);
a (REPEAT µ_tac THEN rewrite_tac [get_spec ¬Cat®, get_spec ¬CatSet®]);
a (strip_asm_tac (µ_elim ¬A® sum_cases_thm) THEN asm_rewrite_tac[]
	THEN REPEAT_N 3 (TRY strip_tac)
	THEN_TRY asm_rewrite_tac[]);
(* *** Goal "1" *** *)
a (POP_ASM_T (asm_tac o eq_sym_rule)
	THEN asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a (lemma_tac ¬IsL B®);
(* *** Goal "2.1" *** *)
a (swap_nth_asm_concl_tac 2
	THEN asm_rewrite_tac[get_spec ¬CatSubs®]);
(* *** Goal "2.2" *** *)
a (swap_nth_asm_concl_tac 2
	THEN rewrite_tac[asm_rule ¬IsL B®, sets_ext_clauses, get_spec ¬IndvSet®]);
a (strip_tac);
a (lemma_tac ¬³ y = OutL B®);
(* *** Goal "2.2.1" *** *)
a (swap_nth_asm_concl_tac 1 THEN asm_rewrite_tac[get_spec ¬InL®]);
a (GET_ASM_T ¬IsL B® (rewrite_thm_tac o (rewrite_rule [sum_clauses])));
(* *** Goal "2.2.2" *** *)
a (swap_nth_asm_concl_tac 1 THEN rewrite_tac[sets_ext_clauses]);
a (swap_nth_asm_concl_tac 1);
(* *** Goal "2.2.2.1" *** *)
a (strip_tac THEN ¶_tac ¬InL x® THEN asm_rewrite_tac[]);
a (contr_tac THEN asm_fc_tac[] THEN_TRY all_var_elim_asm_tac);
a (spec_nth_asm_tac 2 ¬x®);
(* *** Goal "2.2.2.2" *** *)
a (strip_tac THEN ¶_tac ¬InL x® THEN asm_rewrite_tac[]);
a (contr_tac THEN asm_fc_tac[] THEN_TRY all_var_elim_asm_tac);
a (spec_nth_asm_tac 1 ¬x®);
(* *** Goal "3" *** *)
a (POP_ASM_T (asm_tac o eq_sym_rule) THEN asm_rewrite_tac[]);
(* *** Goal "4" *** *)
a (lemma_tac ¬³ IsL B®);
(* *** Goal "4.1" *** *)
a (swap_nth_asm_concl_tac 2
	THEN asm_rewrite_tac[get_spec ¬CatSubs®]);
(* *** Goal "4.2" *** *)
a (swap_nth_asm_concl_tac 2
	THEN rewrite_tac[asm_rule ¬³ IsL B®, sets_ext_clauses, get_spec ¬IndvSet®]);
a (strip_tac);
a (lemma_tac ¬³ z = OutR B®);
(* *** Goal "4.2.1" *** *)
a (swap_nth_asm_concl_tac 1 THEN asm_rewrite_tac[get_spec ¬InR®]);
a (LEMMA_T ¬IsR B® (rewrite_thm_tac o (rewrite_rule [sum_clauses])));
a (DROP_ASM_T ¬³ IsL B® ante_tac
	THEN strip_asm_tac (µ_elim ¬B® sum_cases_thm)
	THEN asm_rewrite_tac[]);
(* *** Goal "4.2.2" *** *)
a (asm_rewrite_tac[get_spec ¬CatSubs®, get_spec ¬AttrSet®]);
a (lemma_tac ¬³ Snd z = Snd(OutR B)®
	THEN1 swap_asm_concl_tac ¬³ z = OutR B®);
(* *** Goal "4.2.2.1" *** *)
a (LEMMA_T ¬z = (Fst z, Snd z)® pure_once_rewrite_thm_tac THEN1 prove_tac[]);
a (pure_asm_rewrite_tac[]);
a (LEMMA_T ¬Fst z = Fst (OutR B)® rewrite_thm_tac);
a (swap_asm_concl_tac ¬InR (Fst z) = (if IsL B then CatSubs else InR (Fst (OutR B)))®);
a (asm_rewrite_tac[]);
a (swap_nth_asm_concl_tac 1);
a (rewrite_tac [sets_ext_clauses]);
a (swap_nth_asm_concl_tac 1);
a (strip_tac THEN ¶_tac ¬InR x® THEN asm_rewrite_tac[]);
a (REPEAT strip_tac THEN_TRY all_var_elim_asm_tac);
a (spec_nth_asm_tac 1 ¬x®);
a (spec_nth_asm_tac 1 ¬z'®);
(* *** Goal "4.2.2.2.2" *** *)
a (strip_tac THEN ¶_tac ¬InR x® THEN asm_rewrite_tac[]);
a (REPEAT strip_tac THEN_TRY all_var_elim_asm_tac);
(* *** Goal "4.2.2.2.2.1" *** *)
a (¶_tac ¬x®);
a (asm_rewrite_tac []);
(* *** Goal "4.2.2.2.2.2" *** *)
a (¶_tac ¬z'®);
a (asm_rewrite_tac []);
val catm_eq_lemma = save_pop_thm "catm_eq_lemma";
=TEX
}%ignore

\subsubsection{Predication}

Now we can define predication.
We do this in terms of Grice's $izz$ and $hazz$.

=SML
declare_infix (300, "izz");
declare_infix (300, "hazz");
=TEX

¹HOLCONST
Ü $ÛizzÝ : CATM ­ CATM ­ BOOL
÷üüüüüü
Ü µA B· A izz B ¤ Cat A = Cat B ± CatSet A € CatSet B
°

¹HOLCONST
Ü $ÛhazzÝ : CATM ­ CATM ­ BOOL
÷üüüüüü
Ü µA B· A hazz B ¤ Cat A = CatSubs ± ³ Cat B = CatSubs
Ü	± ¶a· a  AttrSet B ± µs· s  IndvSet A ´ a s
°

That was reasonably neat, but the definition of $izz$ isn't terribly convenient for proving things.
Lets have some $izz$ lemmas:

=GFT
izz_lemma1 =
    ô µ A B· Cat A = CatSubs ´ (A izz B ¤ Cat B = CatSubs ± IndvSet A € IndvSet B)

izz_lemma2 =
    ô µ A B· Cat B = CatSubs ´ (A izz B ¤ Cat A = CatSubs ± IndvSet A € IndvSet B)

izz_lemma3 =
    ô µ A B· ³ Cat A = CatSubs ´ (A izz B ¤ Cat B = Cat A ± AttrSet A € AttrSet B)

izz_lemma4 =
    ô µ A B· ³ Cat B = CatSubs ´ (A izz B ¤ Cat B = Cat A ± AttrSet A € AttrSet B)
=TEX

\ignore{
=SML
set_goal([], ¬µA B· Cat A = CatSubs ´ (A izz B ¤ Cat B = CatSubs ± IndvSet A € IndvSet B)®);
a (REPEAT µ_tac THEN rewrite_tac[get_spec ¬$izz®, get_spec ¬CatSet®]); 
a (strip_tac THEN_TRY asm_rewrite_tac[] THEN REPEAT strip_tac THEN_TRY asm_rewrite_tac[]);
(* *** Goal "1" *** *)
a (POP_ASM_T ante_tac THEN asm_rewrite_tac[sets_ext_clauses] THEN REPEAT strip_tac);
a (spec_nth_asm_tac 2 ¬(InL x):ISUB + (ISUB ­ BOOL)®);
(* *** Goal "1.1" *** *)
a (spec_nth_asm_tac 1 ¬x®);
(* *** Goal "1.2" *** *)
a (asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a (POP_ASM_T ante_tac THEN asm_rewrite_tac[sets_ext_clauses] THEN REPEAT strip_tac);
a (¶_tac ¬z® THEN asm_rewrite_tac[]);
a (all_asm_fc_tac[]);
val izz_lemma1 = save_pop_thm "izz_lemma1";

set_goal([], ¬µA B· Cat B = CatSubs ´ (A izz B ¤ Cat A = CatSubs ± IndvSet A € IndvSet B)®);
a (REPEAT µ_tac THEN rewrite_tac[get_spec ¬$izz®, get_spec ¬CatSet®]); 
a (strip_tac THEN_TRY asm_rewrite_tac[] THEN REPEAT strip_tac THEN_TRY asm_rewrite_tac[]);
(* *** Goal "1" *** *)
a (POP_ASM_T ante_tac THEN asm_rewrite_tac[sets_ext_clauses] THEN REPEAT strip_tac);
a (spec_nth_asm_tac 2 ¬(InL x):ISUB + (ISUB ­ BOOL)®);
(* *** Goal "1.1" *** *)
a (spec_nth_asm_tac 1 ¬x®);
(* *** Goal "1.2" *** *)
a (asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a (POP_ASM_T ante_tac THEN asm_rewrite_tac[sets_ext_clauses] THEN REPEAT strip_tac);
a (¶_tac ¬z® THEN asm_rewrite_tac[]);
a (all_asm_fc_tac[]);
val izz_lemma2 = save_pop_thm "izz_lemma2";

set_goal([], ¬µA B· ³ Cat A = CatSubs ´ (A izz B ¤ Cat B = Cat A ± AttrSet A € AttrSet B)®);
a (REPEAT µ_tac THEN rewrite_tac[get_spec ¬$izz®, get_spec ¬CatSet®]); 
a (strip_tac THEN_TRY asm_rewrite_tac[] THEN REPEAT strip_tac THEN_TRY asm_rewrite_tac[]);
(* *** Goal "1" *** *)
a (POP_ASM_T ante_tac THEN asm_rewrite_tac[sets_ext_clauses]);
a (DROP_NTH_ASM_T 2 ante_tac THEN asm_rewrite_tac[] THEN strip_tac THEN asm_rewrite_tac[] THEN REPEAT strip_tac);
a (spec_nth_asm_tac 2 ¬(InR x):ISUB + (ISUB ­ BOOL)®);
(* *** Goal "1.1" *** *)
a (spec_nth_asm_tac 1 ¬x®);
(* *** Goal "1.2" *** *)
a (asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a (POP_ASM_T ante_tac THEN asm_rewrite_tac[sets_ext_clauses] THEN REPEAT strip_tac);
a (¶_tac ¬z® THEN asm_rewrite_tac[]);
a (all_asm_fc_tac[]);
val izz_lemma3 = save_pop_thm "izz_lemma3";

set_goal([], ¬µA B· ³ Cat B = CatSubs ´ (A izz B ¤ Cat B = Cat A ± AttrSet A € AttrSet B)®);
a (REPEAT µ_tac THEN rewrite_tac[get_spec ¬$izz®, get_spec ¬CatSet®]); 
a (strip_tac THEN_TRY asm_rewrite_tac[] THEN REPEAT strip_tac THEN_TRY asm_rewrite_tac[]);
(* *** Goal "1" *** *)
a (POP_ASM_T ante_tac THEN asm_rewrite_tac[sets_ext_clauses] THEN REPEAT strip_tac);
a (spec_nth_asm_tac 2 ¬(InR x):ISUB + (ISUB ­ BOOL)®);
(* *** Goal "1.1" *** *)
a (spec_nth_asm_tac 1 ¬x®);
(* *** Goal "1.2" *** *)
a (asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a (POP_ASM_T ante_tac 
	THEN SYM_ASMS_T rewrite_tac
	THEN asm_rewrite_tac[sets_ext_clauses]
	THEN REPEAT strip_tac);
a (¶_tac ¬z® THEN asm_rewrite_tac[]);
a (all_asm_fc_tac[]);
val izz_lemma4 = save_pop_thm "izz_lemma4";
=TEX
}%ignore

\subsubsection{The Principles in HOL}

Here are the HOL versions of the Code ``Principles''.

The following is a bit of program in a programming language called SML, which stands for ``Standard Meta Language''!
It names various terms in HOL, the name on the left `c01' (short for `conjecture 1'), the term on the right quoted in ``Quine corners''.
\footnote{``Quine corners'' are a notation originally used by Quine for Godel numbers, i.e., in Quine's use `¬43®' is a friendly way of writing doen the Godel number of the numeral `43'.
In ProofPower HOL these corners are used to refer to HOL terms in the metalanguage SML.
In HOL, a formula is a term of type ”BOOL® (the opening ” is used when quoting a type rather than a term).}

=SML
val c01 = ¬µA· A izz A®;
val c02 = ¬µA B C· A izz B ± B izz C ´ A izz C®;
val c03 = ¬µA B· A hazz B ´ ³ A izz B®;
val c04 = ¬µA B· A hazz B ¤ ¶C· A hazz C ± C izz B®;
=TEX

One would expect this set of principles to be sufficient to characterise {\it izz} and {\it hazz} (i.e. sufficient to derive any other true facts about them) but this seems doubtful.

Here are some supplementary conjectures.

=SML
val c01b = ¬µA· ³ A hazz A®;
val c03b = ¬µA B· A izz B ´ ³ A hazz B®;
val c03c = ¬µA B· A hazz B ´ ³ A = B®;
val c04a = ¬µA B C· A hazz B ± B izz C ´ A hazz C®;
val c04b = ¬µA B C· A izz B ± B hazz C ´ A hazz C®;
=TEX

Of the supplementaries:

\begin{itemize}
\item c01b is derivable from c03 and c01.
\item c03b is the contrapositive of c03.
\item c03c would be derivable for Code once he has defined equality, it is provable for us now because we have a primitive equality.
\item c04a is a preferable formulation of the right-left implication in c04, and we have used it to prove c04.
\item c04b is an obvious further transitivity-like property, which does not look like it's provable from the stipulated principles.
\end{itemize}

\ignore{
=SML
set_goal([], c01);
a (REPEAT µ_tac THEN_TRY rewrite_tac [get_spec ¬$izz®]);
val l01 = save_pop_thm "l01";

set_goal([], c01b);
a (REPEAT µ_tac THEN_TRY rewrite_tac [get_spec ¬$hazz®] THEN contr_tac);
val l01b = save_pop_thm "l01b";

set_goal([], c02);
a (REPEAT µ_tac THEN_TRY rewrite_tac [get_spec ¬$izz®]
	THEN REPEAT strip_tac
	THEN_TRY asm_rewrite_tac[]
	THEN all_asm_fc_tac[€_trans_thm]);
val l02 = save_pop_thm "l02";

set_goal([], c03);
a (REPEAT µ_tac THEN_TRY rewrite_tac [get_spec ¬$izz®, get_spec ¬$hazz®] THEN contr_tac);
a (DROP_NTH_ASM_T 5 ante_tac
	THEN DROP_NTH_ASM_T 5 ante_tac
	THEN asm_rewrite_tac[]);
val l03 = save_pop_thm "l03";

set_goal([], c03b);
a (REPEAT µ_tac THEN_TRY rewrite_tac [get_spec ¬$izz®, get_spec ¬$hazz®] THEN REPEAT strip_tac);
a (asm_rewrite_tac[]);
val l03b = save_pop_thm "l03b";

set_goal([], c03c);
a (REPEAT µ_tac THEN_TRY rewrite_tac [get_spec ¬$izz®, get_spec ¬$hazz®] THEN contr_tac);
a (all_var_elim_asm_tac);
val l03c = save_pop_thm "l03c";

set_goal([], c04a);
a (REPEAT µ_tac THEN rewrite_tac [get_spec ¬$hazz®, get_spec ¬CatSet®]
	THEN contr_tac);
(* *** Goal "1" *** *)
a (all_fc_tac [izz_lemma2]);
(* *** Goal "2" *** *)
a (all_asm_fc_tac[]);
a (all_fc_tac [list_µ_elim [¬B®] izz_lemma3]);
a (POP_ASM_T ante_tac THEN rewrite_tac [sets_ext_clauses]
	THEN REPEAT strip_tac
	THEN asm_fc_tac[]);
a (¶_tac ¬a® THEN contr_tac);
val l04a = save_pop_thm "l04a";

set_goal([], c04);
a (REPEAT strip_tac);
(* *** Goal "1" *** *)
a (¶_tac ¬B® THEN asm_rewrite_tac[l01]);
(* *** Goal "2" *** *)
a (all_fc_tac [list_µ_elim [¬A®, ¬C®] l04a]);
val l04 = save_pop_thm "l04";

set_goal([], c04b);
a (REPEAT µ_tac THEN rewrite_tac [get_spec ¬$hazz®, get_spec ¬CatSet®]
	THEN contr_tac);
(* *** Goal "1" *** *)
a (all_fc_tac [izz_lemma2]);
(* *** Goal "2" *** *)
a (spec_nth_asm_tac 1 ¬a®);
a (FC_T (MAP_EVERY ante_tac) [get_spec ¬$izz®]);
a (strip_tac THEN asm_rewrite_tac [get_spec ¬CatSet®, sets_ext_clauses]
	THEN strip_tac);
a (¶_tac ¬InL s® THEN REPEAT strip_tac);
(* *** Goal "2.1" *** *)
a (¶_tac ¬s® THEN REPEAT strip_tac);
(* *** Goal "2.2" *** *)
a (contr_tac THEN asm_fc_tac[]);
a (all_var_elim_asm_tac);
val l04b = save_pop_thm "l04b";
=TEX
}%ignore

=GFT Proven Theorems
l01	= ô µ A· A izz A
l01b 	= ô µ A· ³ A hazz A
l02	= ô µ A B C· A izz B ± B izz C ´ A izz C
l03	= ô µ A B· A hazz B ´ ³ A izz B
l03b 	= ô µ A B· A izz B ´ ³ A hazz B
l03c 	= ô µ A B· A hazz B ´ ³ A = B
l04a	= ô µ A B C· A hazz B ± B izz C ´ A hazz C
l04	= ô µ A B· A hazz B ¤ (¶ C· A hazz C ± C izz B) 
l04b 	= ô µ A B C· A izz B ± B hazz C ´ A hazz C
=TEX

\subsection{Total Definitions}

=GFT Code/Speranza
[(B) Total Definitions]

{6. (A hazz B & A is a particular) -> there is a C such that (C =/= A) & (A izz B).}

[D1] 7. A is predicable of B iff ((B izz A) ² (B hazz Something that izz A).
[D2] 8. A is essentially predicable [L-predicable] of B iff B izz A.
[D3] 9. A is accidentally predicable [H-predicable] of B iff B hazz something that izz A.
[D4] 10. A = B iff A izz B & B izz A.
[D5] 11. A is an individual iff (Nec)(For all B) B izz A -> A izz B
[D6] 12. A is a particular iff (Nec)(For all B) A is predicable of B -> (A izz B & B izz A)
[D7] 13. A is a universal iff
		(Poss) (There is a B) A is predicable of A[B] & -(A izz B & B izz A)
=TEX

There is a certain amount of duplication of terminology here, since essential and accidental predication seem to be just $izz$ and $hazz$ backwards.
I'm not so happy with the ``ables'' here, for what is clearly meant is ``truly predicable'', which is not quite the same thing.
Better names would be simply ``is\_essentially'' and ``is\_accidentally'', lacking the ambiguity of ``able'' (but then they would have to be the other way round, exactly the same as $izz$ and $hazz$).

Anyway here are the definitions (keeping the names (more or less) as they were for the present):

=SML
declare_infix (300, "predicable_of");
declare_infix (300, "essentially_predicable_of");
declare_infix (300, "accidentally_predicable_of");
=TEX

¹HOLCONST
Ü $Ûessentially_predicable_ofÝ : CATM ­ CATM ­ BOOL
÷üüüüüü
Ü µA B· A essentially_predicable_of B ¤ B izz A
°

¹HOLCONST
Ü $Ûaccidentally_predicable_ofÝ : CATM ­ CATM ­ BOOL
÷üüüüüü
Ü µA B· A accidentally_predicable_of B ¤ B hazz A
°

Aristotelian predication is then:

¹HOLCONST
Ü $Ûpredicable_ofÝ : CATM ­ CATM ­ BOOL
÷üüüüüü
Ü µA B· A predicable_of B ¤ A essentially_predicable_of B ² A accidentally_predicable_of B
°

Because we have not precluded empty predicates Code's definition will not do, and we have to make ``individual'' primitive, insisting on an individual being a singleton.

¹HOLCONST
Ü ÛindividualÝ : CATM ­ BOOL
÷üüüüüü
Ü µA· individual A ¤ ¶a· CatSet A = {a}
°

According to Code's definition a particular is a substantial individual, we also have to use a more direct statemant of that principle.

¹HOLCONST
Ü ÛparticularÝ : CATM ­ BOOL
÷üüüüüü
Ü µA· particular A ¤ individual A ± Cat A = CatSubs
°

Again we have a problem with Code's definition and therefore define a universal as a non-particular.

¹HOLCONST
Ü ÛuniversalÝ : CATM ­ BOOL
÷üüüüüü
Ü µA· universal A ¤ ³ particular A
°

=SML
val c06 = ¬µA B· A hazz B ± particular A ´ ¶C· C ½ A ± A izz B®; 
val c06n = ¬³ µA B· A hazz B ± particular A ´ ¶C· C ½ A ± A izz B®; 
val c07 = ¬µA B· A predicable_of B ¤ (B izz A) ² ¶C· B hazz C ± C izz A®;
val c08 = ¬µA· A essentially_predicable_of B ¤ B izz A®;
val c09 = ¬µA· A accidentally_predicable_of B ¤ ¶C· B hazz C ± C izz A®;
val c10 = ¬µA B· A = B ¤ A izz B ± B izz A®;
val c11 = ¬µA B· individual A ¤ ©(µB· B izz A ´ A izz B)®;
val c12 = ¬µA· particular A ¤ ©(µB· A predicable_of B ´ A izz B ± B izz A)®;
val c13 = ¬µA· universal A ¤ ¨(¶B· (A predicable_of B ± ³(A izz B ± B izz A)))®;
=TEX

\ignore{
=SML
set_goal([], c06n);
a (strip_tac);
a (¶_tac ¬InL {Åi:ISUB·T}®);
a (strip_tac);
a (¶_tac ¬InR ((Åc:ACAT·T), {Ìi·T})®);
a (rewrite_tac[get_spec ¬$hazz®, get_spec ¬Cat®, get_spec ¬CatSubs®,
	get_spec ¬$izz®, get_spec ¬AttrSet®, get_spec ¬particular®, get_spec ¬individual®,
	get_spec ¬CatSet®, get_spec ¬IndvSet®]);
a (REPEAT strip_tac);
(* *** Goal "1" *** *)
a (¶_tac ¬Ì i· T® THEN rewrite_tac[]);
(* *** Goal "2" *** *)
a (¶_tac ¬InL (Å i· T)® THEN rewrite_tac[sets_ext_clauses]);
a (REPEAT strip_tac THEN_TRY asm_rewrite_tac[]);
a (¶_tac ¬Å i· T® THEN rewrite_tac[]);
val l06n = save_pop_thm "l06n";

set_goal([], c07);
a (REPEAT µ_tac);
a (rewrite_tac [get_spec ¬$predicable_of®, get_spec ¬$essentially_predicable_of®,
		get_spec ¬$accidentally_predicable_of®]);
a (rewrite_tac [list_µ_elim [¬B®, ¬A®] l04]);
val l07 = save_pop_thm "l07";

set_goal([], c08);
a (rewrite_tac [get_spec ¬$essentially_predicable_of®]);
val l08 = save_pop_thm "l08";

set_goal([], c09);
a (REPEAT µ_tac);
a (rewrite_tac [get_spec ¬$accidentally_predicable_of®, list_µ_elim [¬B®, ¬A®] l04]);
val l09 = save_pop_thm "l09";

set_goal([], c10);
a (REPEAT µ_tac THEN rewrite_tac [get_spec ¬$izz®, catm_eq_lemma]);
a (REPEAT strip_tac THEN_TRY asm_rewrite_tac[]);
a (all_fc_tac [pc_rule1 "hol1" prove_rule [] ¬µa b· a € b ± b € a ´ a = b®]);
val l10 = save_pop_thm "l10";
=TEX
}%ignore

=GFT
l05 	= ô µ x· form x ´ universal x
l06n 	= ô ³ (µ A B· A hazz B ± particular A ´ (¶ C· C ½ A ± A izz B))
l07 	= ô µ A B· A predicable_of B ¤ B izz A ² (¶ C· B hazz C ± C izz A)
l08 	= ô µ A· A essentially_predicable_of B ¤ B izz A
l09 	= ô µ A· A accidentally_predicable_of B ¤ (¶ C· B hazz C ± C izz A)
l10	= ô µ A B· A = B ¤ A izz B ± B izz A
=TEX

c06 is false (see l06n), probably a typo.
However, I couldn't work out what was intended.

c11-13 are not provable in our model because of the existence of empty predicates (and the lack of modal operators).

\subsection{Partial Definitions}

=GFT Code/Speranza
[(C) Partial Definitions]

[D8] 14. If A is Some Thing [a this somewhat], A is an  individual.
[D9] 15. If A is a [(seperable) Platonic] Form,
		A is Some Thing [a this somewhat] and Universal.
=TEX

\ignore{
=SML
set_goal ([],¬¶SomeThing· µx· SomeThing x ´ individual x®);
a (¶_tac ¬individual® THEN rewrite_tac[]);
save_cs_¶_thm(pop_thm());
=TEX
}%ignore

This is D8/c14.

¹HOLCONST
Ü ÛSomeThingÝ : CATM ­ BOOL
÷üüüüüü
Ü µx· SomeThing x ´ individual x
°

A form is a non-substantial individual.

\ignore{
=SML
set_goal ([],¬¶form· µx· form x ´ SomeThing x ± universal x®);
a (¶_tac ¬Ìx· SomeThing x ± universal x® THEN rewrite_tac[]);
save_cs_¶_thm(pop_thm());
=TEX
}%ignore

This is D9/c15

¹HOLCONST
Ü ÛformÝ : CATM ­ BOOL
÷üüüüüü
Ü µx· form x ´ SomeThing x ± universal x
°

\subsection{Ontological Theorems}

=GFT Code/Speranza
[(D) Ontological Theorems]

[T1] 16. A is predicable of B iff (B izz A) v (B hazz Some Thing that Izz A).
[T2] 17. A is essentially predicable [L-predicable] of A.
[T3] 18. A is accidentally predicable [H-predicable] of B ->  A =/= B
[T4] A is not accidentally predicable [H-predicable] of A
{19. - (A is accidentally predicable of B) -> A =/= B.}
[T5] 20. A is a particular -> A is an individual.
	[Note that the converse of T5 is not a theorem]
[T6] 21. A is a particular -> No Thing [nothing] that is Not Identical with A izz A.
[T7] 22. No Thing is both particular & a [(separable) Platonic] Form.
[T8] 23. A is a (seperable Platonic) Form -> nothing that is not identical with A izz A.
[T9] 24. A is a particular -> there is no (seperable Platonic) form B such that A izz B.
[T10] 25. A is a (seperable Platonic) form
		-> ((A is predicable of B & A =/= B) -> B hazz A)
[T11] 26. (A is a (seperable Platonic) form & B is a particular)
		-> (A is predicable of B iff B hazz A).
=TEX

=SML
val c05 = ¬µx· universal x ´ form x®;
val c05b = ¬µx· form x ´ universal x®;
val c16 = ¬µA B· A predicable_of B ¤ (B izz A) ² ¶C· (B hazz C ± C izz A)®;
val c17 = ¬µA· A essentially_predicable_of A®;
val c18 = ¬µA· A accidentally_predicable_of B ´ A ½ B®;
val c19 = ¬µA· ³ A accidentally_predicable_of A®;
val c20 = ¬µA· particular A ´ individual A®;
val c21 = ¬µA· particular A ´ ³ ¶C· C ½ A ± C izz A®;
val c22 = ¬³ ¶A· particular A ± form A®;
val c23 = ¬µA· form A ´ ³ ¶C· C ½ A ± C izz A®;
val c23b = ¬µA· form A ´ individual A®;
val c24a = ¬µ A B· particular A ± individual B ± A izz B ´ particular B®;
val c24 = ¬µA· particular A ´ ³ ¶B· form B ± A izz B®;
val c24b = ¬µA· particular A ´ ³ form A®;
val c25 = ¬µA B· form A ´ A predicable_of B ± A ½ B ´ B hazz A®;
val c26 = ¬µA B· form A ± particular B ´ (A predicable_of B ¤ B hazz A)®;
=TEX

\ignore{
=SML
=IGN
set_goal([], c06n);
a (strip_tac);
a (¶_tac ¬InL{Åx:ISUB·T}:CATM® THEN strip_tac);
a (¶_tac ¬InR((Åx:ACAT·T), {Ìx:ISUB·T}):CATM® THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a (rewrite_tac (map get_spec [¬$hazz®, ¬Cat®, ¬CatSubs®]));
a (¶_tac ¬Ìx:ISUB·T®);
a (rewrite_tac (map get_spec [¬AttrSet®]));
(* *** Goal "2" *** *)
a (rewrite_tac (map get_spec [¬particular®, ¬individual®]) THEN strip_tac);
(* *** Goal "2.1" *** *)
a (¶_tac ¬InL(Å x:ISUB· T):ISUB + (ISUB ­ BOOL)®);
a (rewrite_tac [get_spec ¬CatSet®, get_spec ¬Cat®, get_spec ¬IndvSet®, sets_ext_clauses]);
a (REPEAT strip_tac THEN_TRY asm_rewrite_tac[]);
a (¶_tac ¬Å x:ISUB· T®);
a (rewrite_tac[]);
(* *** Goal "2.2" *** *)
a (rewrite_tac [get_spec ¬Cat®]);
(* *** Goal "3" *** *)
a (swap_nth_asm_concl_tac 1);
a (rewrite_tac[get_spec ¬$izz®, get_spec ¬Cat®, get_spec ¬CatSubs®]);
val l06n = save_pop_thm "l06n";
=SML

set_goal([], c16);
a (rewrite_tac [map_eq_sym_rule l04]);
a (REPEAT µ_tac THEN rewrite_tac [get_spec ¬$predicable_of®,
	get_spec ¬$essentially_predicable_of®, get_spec ¬$accidentally_predicable_of®]);
val l16 = save_pop_thm "l16";

set_goal([], c17);
a (REPEAT µ_tac THEN rewrite_tac [get_spec ¬$essentially_predicable_of®, l01]);
val l17 = save_pop_thm "l17";

set_goal([], c18);
a (REPEAT µ_tac THEN rewrite_tac [get_spec ¬$accidentally_predicable_of®, get_spec ¬$½®]);
a (strip_tac THEN fc_tac [l03c]);
a (swap_nth_asm_concl_tac 1 THEN asm_rewrite_tac[]);
val l18 = save_pop_thm "l18";

set_goal([], c19);
a (rewrite_tac [get_spec ¬$accidentally_predicable_of®, l01b]);
val l19 = save_pop_thm "l19";

set_goal([], c20);
a (REPEAT µ_tac THEN rewrite_tac [get_spec ¬$particular®]
	THEN contr_tac);
val l20 = save_pop_thm "l20";

=IGN
set_goal([], c21);
a (REPEAT µ_tac THEN rewrite_tac [get_spec ¬$particular®]
	THEN contr_tac);
val l21 = save_pop_thm "l21";
=SML

set_goal([], c22);
a (contr_tac);
a (fc_tac [get_spec ¬form®]);
a (fc_tac [get_spec ¬universal®]);
val l22 = save_pop_thm "l22";

set_goal([], c23b);
a (REPEAT strip_tac THEN fc_tac [get_spec ¬form®]);
a (fc_tac [get_spec ¬SomeThing®, get_spec ¬universal®]);
val l23b = save_pop_thm "l23b";

set_goal([], c24a);
a (REPEAT µ_tac THEN rewrite_tac [get_spec ¬particular®, get_spec ¬individual®,
		get_spec ¬$izz®]
	THEN strip_tac THEN strip_tac);
(* *** Goal "1" *** *)
a (¶_tac ¬a'® THEN asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a (SYM_ASMS_T rewrite_tac);
val l24a = save_pop_thm "l24a";

set_goal([], c24);
a (contr_tac THEN fc_tac [get_spec ¬form®]);
a (fc_tac [get_spec ¬SomeThing®, get_spec ¬universal®, get_spec ¬particular®, get_spec ¬individual®]);
a (all_fc_tac [l24a]);
val l24 = save_pop_thm "l24";

=IGN
set_goal([], c25b);
a (REPEAT µ_tac THEN rewrite_tac [get_spec ¬$predicable_of®, get_spec ¬$accidentally_predicable_of®,
	get_spec ¬$essentially_predicable_of®, get_spec ¬$izz®] THEN strip_tac
	THEN fc_tac [get_spec ¬form®]);
a (fc_tac [get_spec ¬SomeThing®, get_spec ¬universal®]);
a (DROP_ASM_T ¬³ particular A® (strip_asm_tac o (rewrite_rule [get_spec ¬particular®])));
a (REPEAT strip_tac);
a (rewrite_tac[get_spec ¬$hazz®] );

a (rewrite_tac [get_spec ¬$predicable_of®, get_spec ¬$accidentally_predicable_of®, get_spec ¬$essentially_predicable_of®,
	get_spec ¬$izz®]
	THEN contr_tac);
a (DROP_ASM_T ¬Cat B = CatSubs® ante_tac);
a (asm_rewrite_tac[]);
val l25 = save_pop_thm "l25";
=SML

set_goal([], c26);
a (REPEAT µ_tac THEN rewrite_tac [get_spec ¬particular®] THEN strip_tac
	THEN fc_tac [get_spec ¬form®, get_spec ¬SomeThing®]);
a (fc_tac [get_spec ¬SomeThing®, get_spec ¬universal®]);
a (DROP_ASM_T ¬³ particular A® (strip_asm_tac o (rewrite_rule [get_spec ¬particular®])));
a (rewrite_tac [get_spec ¬$predicable_of®, get_spec ¬$accidentally_predicable_of®, get_spec ¬$essentially_predicable_of®,
	get_spec ¬$izz®]
	THEN contr_tac);
a (DROP_ASM_T ¬Cat B = CatSubs® ante_tac);
a (asm_rewrite_tac[]);
val l26 = save_pop_thm "l26";
=TEX
}%ignore

These are the ones I have proved.

=GFT
l16 	= ô µ A B· A predicable_of B ¤ B izz A ² (¶ C· B hazz C ± C izz A)
l17 	= ô µ A· A essentially_predicable_of A
l19 	= ô µ A· ³ A accidentally_predicable_of A
l20 	= ô µ A· individual A ´ particular A
l22 	= ô ³ (¶ A· particular A ± form A)
l23b 	= ô µ A· form A ´ individual A
l24a 	= ô µ A B· particular A ± individual B ± A izz B ´ particular B
l24 	= ô µ A· particular A ´ ³ (¶ B· form B ± A izz B)
l26 	= ô µ A B· form A ± particular B ´ (A predicable_of B ¤ B hazz A)
=TEX

T6/c21, T8/c23, T10/c25 are all unprovable because of the existence of empty predicates.

\subsection{Platonic Principles and Theorems}

This section is a bit of a mess.
I now see that the reason for this is that Code is now presenting a different theory here, which is Aristotle's conception of Plato's metaphysics.
This explains why these principles at least augment (and possibly contradict) concepts which have already been defined.
In our method, which involves, for the sake of ensuring consistency, the use of only conservative extensions, this cannot be done simply by adding new principles.
We have to develop two systems in separate theories in which the differences of conception between Aristotle and Aristotle's conception of Plato are investigated in distinct contexts (though we could place in a single parent theory the elements which are common to both).

This will be considered later.


=GFT Code/Speranza
[(E) Platonic Principle]

[PP1] 5. Each universal is a (seperable Platonic) form.
[PP2] 27. (A is particular & B is a universal & predicable of A)
	-> there is a C such that (A =/= C  & C is essentially predicable of A)
=TEX

=SML
val c05 = ¬µx· universal x ´ form x®;
val c05b = ¬µx· form x ´ universal x®;
val c27 = ¬µA B· particular A ± universal B ± B predicable_of A
		´ ¶C· (A ½ C ± C essentially_predicable_of A)®;
=TEX

\ignore{
=SML
set_goal([], c05b);
a (REPEAT strip_tac THEN fc_tac [get_spec ¬form®]);
val l05b = save_pop_thm "l05b";

=IGN
set_goal([], c27);
a (REPEAT strip_tac THEN fc_tac [get_spec ¬form®]);
val l05b = save_pop_thm "l05b";
=TEX
}%ignore

c05 is not provable, its converse c05b is.
c27 is not provable, since it would require that there be more than one particular and we have no reason to believe that to be the case.

=GFT
l05b 	= ô µ x· form x ´ universal x
=TEX

=GFT Code/Speranza
[(F) Platonic Theorem]

{28. If there are particulars, of which universals are predicable,
	not every universal is Some Thing.}
[PT1] 29. Each universal is Some Thing [a this somewhat].
[PT2] 30. If A is a particular, there is no B such that
	(A =/= B &  B is essentially predicable of A).
[PT3] 31. (A is predicable of B & A =/= B) -> A is accidentally predicable of B.
=TEX

=SML
val c28 = ¬(¶P· particular P ± ¶U· universal U ± U predicable_of P)
		´ ³ (µU· universal U ´ thing U)®;
val c29 = ¬µU· universal U ´ thing U®;
val c30 = ¬µA· particular A ´ ³ ¶B· (A ½ B ± B essentially_predicable_of A)®;
val c31 = ¬µA B· A predicable_of B ± A ½ B ´ A accidentally_predicable_of B®;
=TEX

\ignore{
=SML

=IGN
set_goal([], c06n);
a (strip_tac);
a (¶_tac ¬InL{Åx:ISUB·T}:CATM® THEN strip_tac);
a (¶_tac ¬InR((Åx:ACAT·T), {Ìx:ISUB·T}):CATM® THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a (rewrite_tac (map get_spec [¬$hazz®, ¬Cat®, ¬CatSubs®]));
a (¶_tac ¬Ìx:ISUB·T®);
a (rewrite_tac (map get_spec [¬AttrSet®]));
(* *** Goal "2" *** *)
a (rewrite_tac (map get_spec [¬particular®, ¬individual®]) THEN strip_tac);
(* *** Goal "2.1" *** *)
a (¶_tac ¬InL(Å x:ISUB· T):ISUB + (ISUB ­ BOOL)®);
a (rewrite_tac [get_spec ¬CatSet®, get_spec ¬Cat®, get_spec ¬IndvSet®, sets_ext_clauses]);
a (REPEAT strip_tac THEN_TRY asm_rewrite_tac[]);
a (¶_tac ¬Å x:ISUB· T®);
a (rewrite_tac[]);
(* *** Goal "2.2" *** *)
a (rewrite_tac [get_spec ¬Cat®]);
(* *** Goal "3" *** *)
a (swap_nth_asm_concl_tac 1);
a (rewrite_tac[get_spec ¬$izz®, get_spec ¬Cat®, get_spec ¬CatSubs®]);
val l06n = save_pop_thm "l06n";
=TEX
}%ignore

These are the ones I have proved.

=GFT
l06n =	ô ³ (µ A B· A hazz B ± particular A ´ (¶ C· C ½ A ± A izz B))
=TEX

\subsection{Some Comments on The Conjectures}

The main problem with the conjectures is that as a group they are inconsistent.
Consequently, one cannot find definitions which are consistent with all the conjectures.

So first I will expose some of the most obvious contradications which flow from the conjectures.

\begin{enumerate}
\item From 5 and 15 we conclude that form and universal are coextensive.
I think it may be that this is part of the Platonic view but not of the Aristotelian one.

\end{enumerate}

Here are some observations on specific conjectures (now out of date).

\begin{description}

\item[c01]
Note here that this is quantified over everything, and hence over individuals, whereas Aristotle describes individuals as thing of which one may predicate, but which are not themselves predicable.
Perhaps this inderdiction applies to $hazz$ but not to $izz$, to accidental but not essential predication.
(We should add the rule ¬³ A hazz A® which is easy to prove.)
I don't know any more detail about Aristotle's attitude towards predication by individuals.
If one cannot, where do we stand when we do, as in ``Socrates is Socrates'' and ``Socrates is Aristotle''.
Anyway, if these were to have a truth value (which surely they do) then the truth value will be as in this rule.

\item[c02]
Behind the scenes this is transitivity of set inclusion.

\item[c03]
This is because {\it izz} is intracategorial and {\it hazz} is intercategorial.
An obvious but useful corrolary is that they are not equal (c03b).

\item[c04]
This, and most of the other theorems involving existential quantification, is rather odd.
Its proof depends on the conjecture $c04a$, which we have proven, and which involves no existential quantification, but its content is not significantly greater than that rule.
From right to left $l04$ is $l04b$ (you just pull out the existential and it turns into a universal).
From left to right $l04$ is trivial, since $B$ serves as a witness for the existential.

Ideally we would be working with claims which are expressible syllogistically, i.e. without benefit of quantifiers.
We can make an exception for universals on the left, since these are interconvertible with the conjecture with free variables instead which we can think of as schemata.
Where an existential quantifier appears in a negative context it will turn universal if pulled out to the top level and can therefore be dispensed with.
Elsewhere its worth asking whether the content is significant (including, as here, one half of the content implicit in putting an existential under an equivalence).

$co4b$ is an obvious similar result to $c04a$.

\item[c05]
According to my definition this is the wrong way round.

\item[c06]
As it stands this is provably false since we have $¬A hazz B®$ on the left, which entails that $A$ and $B$ are not of the same category, and $¬A izz B®$ in the right, which entails that they are of the same category.

\item[c07]
This, at the expense of using an existential, nevertheless tells us nothing that is not immediate from the definitions.

\item[c08]
Is just our definition.

\item[c09]
This turns into $c04$ (apart from the variable names) once you expand the definition of {\it accidentally\_predicable\_of}.

\item[c10]
Behind the scenes, {\it izz} is set inclusion, so this is obvious.

\item[c11-13]
These contain modal operators which cannot be defined using this model.

\item[c14-c15]
I've not worked out what a ``thing'' is.
Not even sure that I should have rendered Speranza's version using that term.
However, I do think I know that {\it particular} and {\it universal} are opposites (contradictories), and hence I could conclude from these two conjectures that there can be no {\it forms} since they entail that a form is both individual and universal.
Sounds like I have the wrong end of some stick or other.

\item[c16]
I don't know enough about ``thing''s to prove this one.

\item[c17]
This is $c01$ in other words.

\item[c018]
This is $c03b$ in other words.

\item[c19]

This is the contrapositive of the claim that {\it accidentally\_predicable\_of} is reflexive, which is false.
Would be true for {\it essentially\_predicable\_of}, but we already have that stated directly as c17.

\item[c20]
Immediate from my definitions.

\item[c21]
This turns out to be false under my definitions, because I have not excluded the possibility of an empty predicate.
However, one wonders why this should be excluded.

If I go over to a model adquate for modal operators then it will be easy to exclude this possibility.

\item[c21]
Fails for same reason as c20, though I could fix this by making the definition of {\it universal} insist on more than one member.

\item[c23]
I don't know why this should be true.
Any particular which partakes of a form contradicts it.

\item[c24]
This is not true in the present model, because we might have only one particular, and hence no non-trivial forms.

\item[c25-c26]
These two tell me that forms are not substance, but attributes, which contradicts c24 which tells us that there are subtantial forms (if particulars are substances). 

\item[c27]
I don't see why this should be true.

\item[c28-c29]
These two together entail that no universal is predicable of any particular.

\item[c30]
This says that nothing is essentially predicable of a particular except itself.

\item[c31]
This is a stronger version of c30 which says that, even if something isn't particular, nothing but itself is essentially predicable of it.

\end{description}

\section{The Organon}\label{ORGANON}

\href{http://texts.rbjones.com/rbjpub/philos/classics/aristotl/oi.htm}{The Organon} is a collection of 6 books by Aristotle which form the main part of his work on Logic.
The first of these is \href{http://texts.rbjones.com/rbjpub/philos/classics/aristotl/o11i.htm}{the Categories} \cite{aristotleL325}, on which Aristotle's Metaphyics depends.
The Metaphysics, at least the parts involved in the Grice/Code analysis \cite{grice88,code88}, is concerned with predication, which is also central to the formal core of Aristotle's logic, the theory of the syllogism, presented in the \href{http://texts.rbjones.com/rbjpub/philos/classics/aristotl/o31i.htm}{Prior Analytic, Book 1} \cite{aristotleL325}.

Aristotle's account of syllogistic logic covers modal reasoning.
In attempting to understand Aristotelian essentialism, one of the key problems is to establish the relationship between the two distinctions between necessary and contingent proposition, and between essential and accidental predication.

Though Code \cite{code88} does not conceive of himself as engaged in formalising Aristotle in a modern predicate logic, his presentation seems much closer to predicate logic than to syllogistic logic.
I would like to understand the metaphysics if possible in terms of the kind of logic which Aristotle had at his disposal.
To explore the extent to which this might be possible, some models of syllogistic logic might be helpful.

When we look at the syllogism with particular concern for the notion of predication involved, we find that the Grice's ``izz/hazz'' distinction (in Aristotle ``said of'' and ``in'') is not relevant.
In this respect predication is simpler in the syllogism, but instead we have an orthogonal distinction into four kinds of predication according to whether the subject is universal or particular, and whether the predication is affirmative or negative, over which are later added the modal operators.

The semantics of the syllogism remains a matter of controversy in some respects.
The majority of the syllogisms held to be valid by Aristotle would be valid if universal and particular propositions were translated as universal and existential quantification in a modern predicate logic.
Four of the syllogisms held to be valid by Aristotle would not be sound under such an interpretation.
These four are distinguished by having universal premises but a particular conclusion.
I propose to call these the \emph{universal-particular}\cite{universal-particular} syllogisms, which I may abbreviate \emph{u-p}.

There are three most common approaches to the u-p syllogisms:

\begin{enumerate}
\item Consider them to be fallacious (possibly admitting the implicature).
\item Consider Aristotle's formal logic to be concerned exclusively with non-empty terms.
\item Consider universal propositions to be, in effect, the conjunction of a universal and an existential quantification.
\end{enumerate}

Of these the last is perhaps the one most favoured today.
However, the treatment here considers as yet only the first two, in the following stages:

\begin{itemize}
\item pure syllogism without u-p syllogisms (Section \ref{SWEF})
\item full syllogism allowing u-p syllogisms (Section \ref{SYLL})
\item modal syllogisms  (Section \ref{MODSYLL})
\end{itemize}

To this I have recently added a discussion of mappings of the syllogisms to set theory and propositional logic as a part of a discussion about whether syllogisms can be said to be tautological. 

The present treatment was based firstly on the wikipedia account of \href{http://en.wikipedia.org/wiki/Syllogism}{Aristotle's Logic}, secondly on Strawson \cite{strawson52} from whom I first obtained the syllogisms not in Aristotle and began incorporation of direct inference, and then from Spade\cite{spade2002} I obtained the names for the extra syllogisms and a fuller account of how the syllogisms can be derived which is not yet reflected in the following.

The main interest at present is the sequence of models which contributes to the formulation of an integrated model for the syllogism and the metaphysics in Section \ref{METAPHYSICSII}.
It suffices perhaps in this context to know in which models the various syllogisms are provable, without delving into the details of proof, which are at present, sheer hackery.

\subsection{Non U-P Syllogisms}\label{SWEF}

The theory here is very simple, the presentation is complicated by the fact that the proofs have been completely automated by scripts in the metalanguage.
These can be completely ignored by anyone who is willing to trust that \Product checks proofs correctly.
In any case, the theorems proven are just the statements of the 15 valid forms of non-u-p syllogism.
For the most concise statement of the results of the exercise, the reader should refer directly to the theory listing in \thyref{syllog1}.

=SML
open_theory "aristotle";
force_new_theory "syllog1";
=TEX

\ignore{
=SML
force_new_pc Û"'syllog1"Ý;
merge_pcs ["'savedthm_cs_¶_proof"] "'syllog1";
set_merge_pcs ["misc2", "'syllog1"];
=TEX
}%ignore

\subsubsection{The Subject Matter}

Aristotle's syllogistic logic is concerned with inferences between judgements considered as predications.
A predication in Aristotle affirms a {\it predicate} of some {\it subject}, but by contrast with more recent notions of predication the subject need not be an individual, the kinds of things which appear as predicates may also appear as subjects, and the relationship expressed seems closer to a modern eye to set inclusion than to what we now regard as predication.
Since subject and predicate are for present purposes the same kind of thing, it is useful to have a name for that kind of thing, and I will use the name {\it property}.

There are four kinds of predication which we have here to account for, which we will do by offering definitions which provide a good model for syllogistic logic, i.e. one in which the syllogisms held to be true by Aristotle are in fact true.
Before providing these definitions we must decide what kind of thing are the terms which are related by Aristotelian predication.
 
In HOL the most natural answer to this is ``boolean valued functions'' which are objects of type $”'a ­ BOOL®$ for some type of individuals which we can leave open by using the type variable $”'a®$.
This provides a simple model of Aristotle's non-u-p syllogistic reasoning.
Four of the syllogisms which Aristotle considered valid fail under this conception of predicate, because among the objects of type $”'a ­ BOOL®$ is the function $¬Ìx:'a· F®$ which corresponds to a predicate with empty extension and does not admit inference from the universal to the existential (unless the universal is interpreted specially).

The following ``type abbreviation'' allows us to use {\it TERM} as an abbreviation for $”'a ­ BOOL®$.

=SML
declare_type_abbrev("TERM", [], ”'a ­ BOOL®);
=TEX

\subsubsection{Predication}

There are four forms of predication which are normally presented as infix operators over predicates using the vowels ``a'', ``e'', ``i'', ``o''.
``o'' is already in use so I'll use ``u'' instead.

These are to be construed as follows:

\begin{center}
\begin{tabular}[]{ | l | l |}
\hline
HOL term & Meaning\\
\hline
¬A a B® & All A are B\\
¬A e B® & All A are not B\\
¬A i B® & An A is B\\
¬A o B® & An A is not B\\
\hline
\end{tabular}
\end{center}

``o'' is already in use for functional composition, so we will use ``u'' instead and then use an alias to permit us to write this as ``o'' (type inference will usually resolve any ambiguity).

To render these in HOL we first declare the relevant letters as infix operators:

=SML
declare_infix (300, "a");
declare_infix (300, "e");
declare_infix (300, "i");
declare_infix (300, "u");
=TEX

They predication operators are defined as follows:

¹HOLCONST
Ü $ÛaÝ : TERM ­ TERM ­ BOOL
÷üüüüüü
Ü µA B· A a B ¤ µx· A x ´ B x
°

¹HOLCONST
Ü $ÛeÝ : TERM ­ TERM ­ BOOL
÷üüüüüü
Ü µA B· A e B ¤ µx· A x ´ ³ B x
°

¹HOLCONST
Ü $ÛiÝ : TERM ­ TERM ­ BOOL
÷üüüüüü
Ü µA B· A i B ¤ ¶x· A x ± B x
°

¹HOLCONST
Ü $ÛuÝ : TERM ­ TERM ­ BOOL
÷üüüüüü
Ü µA B· A u B ¤ ¶x· A x ± ³ B x
°

=SML
declare_alias("o", ¬$u®);
=TEX

Note that as defined above these come in complementary pairs, $a$ being the negation of $o$ and $e$ of $i$.
If we had negation we could manage with just two predication operators.

\subsubsection{The Laws of Immediate Inference}

Though in the source of this kind of ``literate script'' are to be found the scripts for generating and checking the proofs of all the theorems presente, it will not be my practice to expose these scripts in the printed version of the document.
These scripts are not usually intelligible other than in that intimate man-machine dialogue which they mediate, and sufficient knowledge for most purposes of the structure of the proof will be found in the detailed lemmas proven (since the level of proof automation is modest).

However, I will begin by exposing some of the scripts used for obtaining proofs of syllogisms in this model, to give the reader an impession of the level of complexity and kind of obscurity involved in this kind of formal work,
I will not attempt sufficient explanation to make these scripts intelligible, they are best understood in the interactive environment, all the scripts are available for readers who want to run them.

Most readers are expected to skip over the gory details, the philosophical points at stake do no depend on the details of the proofs.

Before addressing the laws of immediate inference
\footnote{in which I followed Strawson \cite{strawson52}, though I can now cite \href{file:///home/rbj/rbj/share/rbjones/www/rbjpub/philos/classics/aristotl/o3102c.htm}{Aristotle, Prior Analytic, Book 1, Part 2.}
\cite{aristotleL325}}
I devise a tactic for automating simple proofs in this domain.

The following elementary tactic expands the goal by applying the definitions of the operators and then invokes a general tactic for the predicate calculus.
A rule is also defined using that tactic for direct rather than interactive proof.

=SML
val Ûsyll_tacÝ =	asm_prove_tac (map get_spec [¬$a®, ¬$e®, ¬$i®, ¬$u®]);
fun Ûsyll_ruleÝ g = tac_proof (g, syll_tac);	
=TEX

\paragraph{Simple Conversion}

Using the above tactic thus:
=SML
val e_conv_thm = save_thm ("e_conv_thm", syll_rule([¬A e B®], ¬B e A®));
val i_conv_thm = save_thm ("i_conv_thm", syll_rule([¬A i B®], ¬B i A®));
=TEX


The following two theorems are obtained.
=GFT
val e_conv_thm = A e B ô B e A : THM
val i_conv_thm = A i B ô B i A : THM
=TEX

The following two theorems show that the other obvious conversions are false.

\ignore{
=SML
set_goal([], ¬¶A B· A a B ± ³ B a A®);
a (¶_tac ¬Ìx·F® THEN ¶_tac ¬Ìx·T® THEN syll_tac);
val a_not_conv_thm = save_pop_thm "a_not_conv_thm";

set_goal([], ¬¶A B:TERM· A o B ± ³ B o A®);
a (¶_tac ¬Ìx·T® THEN ¶_tac ¬Ìx·F® THEN syll_tac);
val o_not_conv_thm = save_pop_thm "o_not_conv_thm";
=TEX
}%ignore

=GFT
a_not_conv_thm = ô ¶ A B· A a B ± ³ B a A
o_not_conv_thm = ô ¶ A B· A o B ± ³ B o A
=TEX

\paragraph{Conversion Per Accidens}

These don't work here because they rely upon the u-p syllogisms.

\paragraph{Obversion}

For these we need to define an operation of complementation on predicates.

¹HOLCONST
Ü ÛComplementÝ : TERM ­ TERM
÷üüüüüü
Ü µA Á· (Complement A) Á ¤ ³ (A Á) 
°

We will use ``$~$'' as a shorthand for ``complement''.

=SML
declare_alias ("~", ¬Complement®);
=TEX

\ignore{
=SML
add_pc_thms "'syllog1" [get_spec ¬Complement®];
set_merge_pcs ["misc2", "'syllog1"];
=TEX
}%ignore

\ignore{
=SML
val ae_obv_thm = save_thm ("ae_obv_thm", syll_rule([¬A a B®], ¬A e ~B®));
val ea_obv_thm = save_thm ("ea_obv_thm", syll_rule([¬A e B®], ¬A a ~B®));

set_goal([¬A i B®], ¬A u ~B®);
a (syll_tac);
a (¶_tac ¬x® THEN asm_rewrite_tac[]);
val io_obv_thm = save_pop_thm "io_obv_thm";

set_goal([¬A u B®], ¬A i ~B®);
a (syll_tac);
a (¶_tac ¬x® THEN asm_rewrite_tac[]);
val oi_obv_thm = save_pop_thm "oi_obv_thm";
=TEX
}%ignore

=GFT
ae_obv_thm = 	A a B ô A e ~ B
ea_obv_thm = 	A e B ô A a ~ B
io_obv_thm = 	A i B ô A o ~ B
oi_obv_thm = 	A o B ô A i ~ B
=TEX

\paragraph{Contraposition and Inversion}


\paragraph{The Square of Opposition}


\subsubsection{The Valid Syllogisms}\label{ValidSyllogisms}

The fifteen valid non-u-p syllogisms are true under this semantics and can be proven formally with ease.

In this section we describe informally this subset of the valid syllogisms, in the next we provide scripts in our metalanguage which automates the construction and proof of the relevant syllogisms.
This presentation is based on \href{http://en.wikipedia.org/wiki/Syllogism}{the one at wikipedia}.

Syllogisms come in four figures, according to the configuration of variables in the premises:

\begin{quote}
\begin{itemize}
\item[Figure 1] M-P, S-M $ô$ S-P
\item[Figure 2] P-M, S-M $ô$ S-P
\item[Figure 3] M-P, M-S $ô$ S-P
\item[Figure 4] P-M, M-S $ô$ S-P
\end{itemize}
\end{quote}

Where S, P and M are the subject, predicate and middle term respectively. 

These four figures are then repeated for each combination of the four types of premise in each of the premises and the conclusion.
This gives $4 ¸ 4 ¸ 4 ¸ 4 = 256$ possibilities, of which 19 were held to be valid by Aristotle, four of them u-p syllogisms.

The use of vowels for the predicators allows the valid cases to be named using names in which the vowels tell you the form of the syllogism (if you also know the figure).
The first vowel tells you the kind of syllogism in the first premise, the second vowel that in the second premise, and the third vowel that in the conclusion.

In the following table the names in square brackets are for u-p syllogisms.
The names followed by exclamation marks are ``subalternate mood'', they do not appear in aristotle but are valid in the models here for which the u-p syllogisms hold
\footnote{This I got from Spade \cite{spade2002}.}.

\begin{center}
\begin{tabular}[]{| l | l | l | l |}
\hline
Figure 1 &	Figure 2	&	Figure 3 &	Figure 4\\
\hline 
Barbara &	Cesare 	&	[Darapti] &	[Bramantip]\\
Celarent &	Camestres &	Disamis 	&	Camenes\\
Darii 	&	Festino 	&	Datisi 	&	Dimaris\\
Ferio 	&	Baroco 	&	[Felapton] &	[Fesapo]\\
Barbari!	&	Cesaro!  	&	Bocardo 	&	Fresison\\
Celaront!	&	Camestrop! 	&	Ferison 	&	Camenop! \\
\hline
\end{tabular}
\end{center}

\subsubsection{Generating Syllogisms}

This section is mainly given over to short programs in our metalanguage the end effect of which is to secure the proof of the 15 forms of non-u-p syllogism.
The results are visible in the ``theorems'' section of the theory listing in \thyref{syllog1}, and this section can be safely skipped by anyone whose interest is purely philosophical.
Normally this kind of material would be hidden, it is shown here to give an impression of the size of script necessary to automate this kind of task.

The following function generates a list of four quadruples of HOL variables which correspond to the four figures of syllogisms.
It is parameterised by the HOL type used for predicates to that it can be re-used when we change the representation type.

=SML
fun ÛfiguresÝ pt = 
	let val M = mk_var ("M", pt)
	    and P = mk_var ("P", pt)
	    and S = mk_var ("¿", pt)
	in [(M,P,S,M), (P,M,S,M), (M,P,M,S), (P,M,M,S)]
	end;
=TEX

The following functions take a string which is the name of a syllogism extract the vowels which occur in it and convert them into the corresponding predication operator to give a triple of operators.

=SML
fun Ûop_from_charÝ ot c = mk_const (if c = "o" then "u" else c, ot);

fun Ûvowels_from_stringÝ s = filter (fn x => x mem (explode "aeiou")) (explode s);

fun Ûoptrip_from_textÝ ot s =
	let val [a, b, c] = (map (op_from_char ot) o vowels_from_string) s;
	in (a, b, c)
	end;
=TEX

The following functions construct a syllogism.

=SML
fun Ûmk_predÝ q s p = mk_app(mk_app (q, s), p);

fun Ûmk_syllÝ vt (a,b,c,d) (q1, q2, q3) =
	([mk_pred q1 a b, mk_pred q2 c d],
		mk_pred q3 (mk_var("¿", vt)) (mk_var("P", vt)));

fun Ûmk_reltÝ t = mk_ctype ("­", [t, mk_ctype ("­", [t, ”BOOL®])]);

fun Ûmk_syllpÝ vt (s, n) =
	mk_syll vt (nth (n-1) (figures vt)) (optrip_from_text (mk_relt vt) s);
=TEX

=SML
val Ûmk_syllp1Ý = mk_syllp ”TERM®;
=TEX

We now define a data structure from which the valid syllogisms can be generated.
With the model we are using only the 15 non-u-p syllogisms.
They are shown in the following data structure.

=SML
val Ûsyllogism_data1Ý = 
	[("Barbara", 1),
	("Celarent", 1),
	("Darii", 1),
	("Ferio", 1),
	("Cesare", 2),
	("Camestres", 2),
	("Festino", 2),
	("Baroco", 2),
	("Disamis", 3),
	("Datisi", 3),
	("Bocardo", 3),
	("Ferison", 3),
	("Camenes", 4),
	("Dimaris", 4),
	("Fresison", 4)];
=IGN
map mk_syllp1 syllogism_data1;
=TEX

The following four u-p syllogisms held to be valid by Aristotle are less straighforward to construe as sound.
One way is to restrict the syllogism to non-empty terms and this is the only one we will consider here, though there are other ways of dealing with this problem.

=SML
val Ûsyllogism_data2Ý = 
	[("Darapti", 3),	
	("Felapton", 3),
	("Bramantip", 4),
	("Fesapo", 4)];
=TEX

Under the assumption that terms are non-empty the following five further syllogisms are also sound, though not noted as such by Aristotle.

=SML
val Ûsyllogism_data3Ý = 
	[("Barbari", 1),
	("Celaront", 1),
	("Cesaro", 2),
	("Camestrop", 2),
	("Camenop", 4)];
=TEX

The following code generates the goals for proving syllogisms from the data structures, generates and checks formal proofs and saves the resulting theorems in the current theory (see end of document for theory listing). 

=SML
fun Ûsyll_proveÝ msp suff tac (a,n) =
	let val thm = tac_proof (msp (a,n), tac) handle _ => t_thm
	in (concat [a, suff], thm)
	end;

fun Ûsyll_prove_and_storeÝ msp suff tac (a,n) =
	let val res = syll_prove msp suff tac (a,n);
	    val _ = save_thm res
	in res 
	end;

val Ûsps1Ý = syll_prove_and_store mk_syllp1 "";
=TEX

\subsubsection{Proving the Syllogisms}

We now apply this to the complete set of non-u-p syllogisms,
saving the results in the theory as well as binding them to (naming them as) the metalanguage value {\it valid\_sylls}.

=SML
val Ûvalid_syllsÝ = map (sps1 syll_tac) syllogism_data1;
=TEX

This is the resulting value.
=GFT
val valid_sylls = [
	("Barbara", M a P, ¿ a M ô ¿ a P),
	("Celarent", M e P, ¿ a M ô ¿ e P),
	("Darii", M a P, ¿ i M ô ¿ i P),
	("Ferio", M e P, ¿ i M ô ¿ o P),
	("Cesare", P e M, ¿ a M ô ¿ e P),
	("Camestres", P a M, ¿ e M ô ¿ e P),
	("Festino", P e M, ¿ i M ô ¿ o P),
	("Baroco", P a M, ¿ o M ô ¿ o P),
	("Disamis", M i P, M a ¿ ô ¿ i P),
	("Datisi", M a P, M i ¿ ô ¿ i P),
	("Bocardo", M o P, M a ¿ ô ¿ o P),
	("Ferison", M e P, M i ¿ ô ¿ o P),
	("Camenes", P a M, M e ¿ ô ¿ e P),
	("Dimaris", P i M, M a ¿ ô ¿ i P),
	("Fresison", P e M, M i ¿ ô ¿ o P)
] : (string * THM) list
=TEX

The theorems are also displayed in the theory listing in \thyref{syllog1}


\subsection{Reductions of the Syllogism}\label{RSPL}

P.V. Spade, in a thumbnail history of logic \cite{spade2002} remarks that some later peripatetics attempted to show that stoic propositional logic was simply the syllogism in other clothes, and others that the two are in some sense equivalent.

A partial reduction to propositional logic via set theory is exhibited in this section.
The reduction to set theory is semantically more plausible than the second step to proposional logic, and provides an account of the u-p syllogisms, which are not accounted for by the propositional reduction.

We obtain kind of reduction of the decision problem for the non-u-a syllogisms to the decision problem for truth functional tautologies, but only in a very informal sense, since there are only a small finite set of valid syllogisms (though schemata) and so the decision problem is trivial.
For this reason syllogistic logic cannot be as expressive as a modern propositional logic, but conceivably might be closer to Stoic propositional logic.

The first step, to set theory is illustrated in the Wikpedia article on the syllogism, which gives Venn diagrams for all 24 ``valid'' syllogisms.

Though it is convenient to think of this as a two stage reduction, in the following implementation the two different reducations are generated independently.

=SML
open_theory "aristotle";
force_new_theory "syllog1p";
=TEX

\ignore{
=SML
force_new_pc Û"'syllog1p"Ý;
merge_pcs ["'savedthm_cs_¶_proof"] "'syllog1p";
set_merge_pcs ["misc2", "'syllog1p"];
=TEX
}%ignore

Under the proposed mapping terms of the syllogism are mapped to propositions.
The term ``Mortal'' may be thought of as being mapped to the proposition ``x is Mortal''.

Thus the Barbara syllogism:

\begin{itemize}
\item All As are Bs
\item All Bs are Cs	
\item =========
\item All As are Cs
\end{itemize}

might be rendered set theoretically as:

=INLINEFT
(A € B ± B € C) ´ (A € C)
=TEX

where A, B and C are subsets of some universal set,
or in the propositional calculus as:

=INLINEFT
(A ´ B ± B ´ C) ´ (A ´ C)
=TEX

where A, B and C are boolean values or propositions.

However, since we are working here in a sequent calculus we can render the theorems closely to the original as:


=GFT
   [A € B,
    B € C]
  ô A € C
=TEX

or

=GFT
   [A ´ B,
    B ´ C]
  ô A ´ C
=TEX

A set theoretic presentation of the u-p syllogisms can be obtained by assuming that the sets are not empty, but no similarly plausible account of these syllogisms is available in propositional logic.

The following two definitions provide names for the types of the variables in the two cases.

=SML
declare_type_abbrev("STERM", [], ”'a SET®);
declare_type_abbrev("PTERM", [], ”BOOL®);
=TEX

Here is a table describing the proposed mappings:

\begin{center}
\begin{tabular}[]{ | l | l | c | c |}
\hline
Aristotle & Meaning & Set Theory & Propositional Analogue\\
\hline
A a B & All A are B & A € B & A ´ B \\
A e B & All A are not B & 
=INLINEFT
A€~B
=TEX
 & A ´ ³B \\
A i B & An A is B & 
=INLINEFT
³(A€~B)
=TEX
 & ³(A ´ ³B)  \\
A o B & An A is not B & ³(A € B) & ³(A ´ B) \\
\hline
\end{tabular}
\end{center}


\subsubsection{Generating The Propositions}

This section is mainly given over to short programs in our metalanguage the end effect of which is to secure the proof of the 15 theorems of set theory and 15 propositional tautologies which are obtained from non-u-p syllogisms by this naive transformation.

The results are visible in the ``theorems'' section of the theory listing in \thyref{syllog1p}, and this section can be safely skipped by anyone whose interest is purely philosophical.

Mostly this uses functionality devised in the previous section to achieve two slightly different sets of theorems.

The following functions take a string which is the name of a syllogism, extract the vowels which occur in it and convert them into the corresponding propositional formula to give a triple of propositions.

The first translates letters into functions which construct formalae.

First the set theory version:

=SML
fun Ûsop_from_charÝ c =
	let fun a x y = ¬‘x® € ‘y®®;
	    fun e x y = ¬‘x® € ~‘y®®;
	    fun i x y = ¬³ ‘e x y®®;
	    fun u x y = ¬³ ‘a x y®®
	in case c of "a" => a | "e" => e | "i" => i | "o" => u
	end;
=TEX

Then the propositional logic:

=SML
fun Ûbop_from_charÝ c =
	let fun a x y = ¬‘x® ´ ‘y®®;
	    fun e x y = ¬‘x® ´ ³ ‘y®®;
	    fun i x y = ¬³ ‘e x y®®;
	    fun u x y = ¬³ ‘a x y®®
	in case c of "a" => a | "e" => e | "i" => i | "o" => u
	end;
=TEX

The second maps this over a list of three vowels extracted from the name of a single syllogism.

=SML
fun Ûsoptrip_from_textÝ s =
	let val [a, b, c] = (map sop_from_char o vowels_from_string) s;
	in (a, b, c)
	end;

fun Ûboptrip_from_textÝ s =
	let val [a, b, c] = (map bop_from_char o vowels_from_string) s;
	in (a, b, c)
	end;
=TEX

The following functions constructs a ``goal'' (something to prove) corresponding to a syllogism.
A goal is a list of assumptions and a conclusion, the list of assumptions contains the premises of the syllogism.

=SML
fun Ûmk_ssyllÝ (a,b,c,d) (q1, q2, q3) =
	([q1 a b, q2 c d], q3 (mk_var("¿", ”STERM®)) (mk_var("P", ”STERM®)));

fun Ûmk_ssyllpÝ (s, n) =
	mk_ssyll (nth (n-1) (figures ”STERM®)) (soptrip_from_text s);

fun Ûmk_bsyllÝ (a,b,c,d) (q1, q2, q3) =
	([q1 a b, q2 c d], q3 (mk_var("¿", ”PTERM®)) (mk_var("P", ”PTERM®)));

fun Ûmk_bsyllpÝ (s, n) =
	mk_bsyll (nth (n-1) (figures ”PTERM®)) (boptrip_from_text s);
=TEX

which can then be mapped over the list of valid non-u-p syllogisms thus:

=GFT SML
map mk_ssyllp syllogism_data1;
=TEX

giving the following list of ``goals'':

=GFT
val it =
   [  ([¬M € P®, ¬¿ € M®], ¬¿ € P®),
      ([¬M € ~ P®, ¬¿ € M®], ¬¿ € ~ P®),
      ([¬M € P®, ¬³ ¿ € ~ M®], ¬³ ¿ € ~ P®),
      ([¬M € ~ P®, ¬³ ¿ € ~ M®], ¬³ ¿ € P®),
      ([¬P € ~ M®, ¬¿ € M®], ¬¿ € ~ P®),
      ([¬P € M®, ¬¿ € ~ M®], ¬¿ € ~ P®),
      ([¬P € ~ M®, ¬³ ¿ € ~ M®], ¬³ ¿ € P®),
      ([¬P € M®, ¬³ ¿ € M®], ¬³ ¿ € P®),
      ([¬³ M € ~ P®, ¬M € ¿®], ¬³ ¿ € ~ P®),
      ([¬M € P®, ¬³ M € ~ ¿®], ¬³ ¿ € ~ P®),
      ([¬³ M € P®, ¬M € ¿®], ¬³ ¿ € P®),
      ([¬M € ~ P®, ¬³ M € ~ ¿®], ¬³ ¿ € P®),
      ([¬P € M®, ¬M € ~ ¿®], ¬¿ € ~ P®),
      ([¬³ P € ~ M®, ¬M € ¿®], ¬³ ¿ € ~ P®),
=TEX

=GFT SML
map mk_bsyllp syllogism_data1;
=TEX

giving the following list of ``goals'':

=GFT
val it =
   [([¬M ´ P®, ¬¿ ´ M®], ¬¿ ´ P®),
      ([¬M ´ ³ P®, ¬¿ ´ M®], ¬¿ ´ ³ P®),
      ([¬M ´ P®, ¬³ (¿ ´ ³ M)®], ¬³ (¿ ´ ³ P)®),
      ([¬M ´ ³ P®, ¬³ (¿ ´ ³ M)®], ¬³ (¿ ´ P)®),
      ([¬P ´ ³ M®, ¬¿ ´ M®], ¬¿ ´ ³ P®),
      ([¬P ´ M®, ¬¿ ´ ³ M®], ¬¿ ´ ³ P®),
      ([¬P ´ ³ M®, ¬³ (¿ ´ ³ M)®], ¬³ (¿ ´ P)®),
      ([¬P ´ M®, ¬³ (¿ ´ M)®], ¬³ (¿ ´ P)®),
      ([¬³ (M ´ ³ P)®, ¬M ´ ¿®], ¬³ (¿ ´ ³ P)®),
      ([¬M ´ P®, ¬³ (M ´ ³ ¿)®], ¬³ (¿ ´ ³ P)®),
      ([¬³ (M ´ P)®, ¬M ´ ¿®], ¬³ (¿ ´ P)®),
      ([¬M ´ ³ P®, ¬³ (M ´ ³ ¿)®], ¬³ (¿ ´ P)®),
      ([¬P ´ M®, ¬M ´ ³ ¿®], ¬¿ ´ ³ P®),
      ([¬³ (P ´ ³ M)®, ¬M ´ ¿®], ¬³ (¿ ´ ³ P)®),
      ([¬P ´ ³ M®, ¬³ (M ´ ³ ¿)®], ¬³ (¿ ´ P)®)] : (TERM list * TERM) list
=TEX

The following code generates the goals for proving the above syllogisms from the previously defined data structure desribing the valid syllogisms, generates and checks formal proofs and saves the resulting theorems in the current theory (see end of document for theory listing). 

=SML
val Ûssps1Ý = syll_prove_and_store mk_ssyllp "_s";
val Ûbsps1Ý = syll_prove_and_store mk_bsyllp "_p";
=TEX

\subsubsection{Proving the Syllogisms}

We now apply this to the complete set of non-u-p syllogisms,
saving the results in the theory as well as binding them to (naming them as) the metalanguage value {\it valid\_sylls}.

=SML
val Ûvalid_ssyllsÝ =
	map (ssps1
		(REPEAT (POP_ASM_T ante_tac)
		THEN PC_T1 "hol1" rewrite_tac [] THEN prove_tac[]))
	syllogism_data1;

val Ûvalid_bsyllsÝ =
	map (bsps1
		(REPEAT (POP_ASM_T ante_tac)
		THEN REPEAT strip_tac))
	syllogism_data1;
=TEX

This is the resulting value.
=GFT
val valid_bsylls =
   [("Barbara", M ´ P, ¿ ´ M ô ¿ ´ P),
      ("Celarent", M ´ ³ P, ¿ ´ M ô ¿ ´ ³ P),
      ("Darii", M ´ P, ³ (¿ ´ ³ M) ô ³ (¿ ´ ³ P)),
      ("Ferio", M ´ ³ P, ³ (¿ ´ ³ M) ô ³ (¿ ´ P)),
      ("Cesare", P ´ ³ M, ¿ ´ M ô ¿ ´ ³ P),
      ("Camestres", P ´ M, ¿ ´ ³ M ô ¿ ´ ³ P),
      ("Festino", P ´ ³ M, ³ (¿ ´ ³ M) ô ³ (¿ ´ P)),
      ("Baroco", P ´ M, ³ (¿ ´ M) ô ³ (¿ ´ P)),
      ("Disamis", ³ (M ´ ³ P), M ´ ¿ ô ³ (¿ ´ ³ P)),
      ("Datisi", M ´ P, ³ (M ´ ³ ¿) ô ³ (¿ ´ ³ P)),
      ("Bocardo", ³ (M ´ P), M ´ ¿ ô ³ (¿ ´ P)),
      ("Ferison", M ´ ³ P, ³ (M ´ ³ ¿) ô ³ (¿ ´ P)),
      ("Camenes", P ´ M, M ´ ³ ¿ ô ¿ ´ ³ P),
      ("Dimaris", ³ (P ´ ³ M), M ´ ¿ ô ³ (¿ ´ ³ P)),
      ("Fresison", P ´ ³ M, ³ (M ´ ³ ¿) ô ³ (¿ ´ P))] : (string * THM) list
=TEX

.. which is a list of name/theorem pairs of the tautologies corresponding to each syllogism.

The theorems are also displayed in the theory listing in \thyref{syllog1p}

We now adjust the set theoretic reduction to deliver u-p syllogisms by including a non-emptyness assumption and obtain proofs of the nine syllogisms valid u-p syllogisms.

=SML
fun Ûmk_xssyllÝ (a,b,c,d) (q1, q2, q3) =
	([¬³ ({}:'a SET)  {M; ¿; P}®, q1 a b, q2 c d], q3 (mk_var("¿", ”STERM®)) (mk_var("P", ”STERM®)));

fun Ûmk_xssyllpÝ (s, n) =
	mk_xssyll (nth (n-1) (figures ”STERM®)) (soptrip_from_text s);
=TEX

which can then be mapped over the rest of the syllogisms thus:

=GFT SML
map mk_xssyllp (syllogism_data2 @ syllogism_data3);
=TEX

giving the following list of ``goals'':

=GFT
val it =
   [  ([¬³ {}  {M; ¿; P}®, ¬M € P®, ¬M € ¿®], ¬³ ¿ € ~ P®),
      ([¬³ {}  {M; ¿; P}®, ¬M € ~ P®, ¬M € ¿®], ¬³ ¿ € P®),
      ([¬³ {}  {M; ¿; P}®, ¬P € M®, ¬M € ¿®], ¬³ ¿ € ~ P®),
      ([¬³ {}  {M; ¿; P}®, ¬P € ~ M®, ¬M € ¿®], ¬³ ¿ € P®),
      ([¬³ {}  {M; ¿; P}®, ¬M € P®, ¬¿ € M®], ¬³ ¿ € ~ P®),
      ([¬³ {}  {M; ¿; P}®, ¬M € ~ P®, ¬¿ € M®], ¬³ ¿ € P®),
      ([¬³ {}  {M; ¿; P}®, ¬P € ~ M®, ¬¿ € M®], ¬³ ¿ € P®),
      ([¬³ {}  {M; ¿; P}®, ¬P € M®, ¬¿ € ~ M®], ¬³ ¿ € P®),
      ([¬³ {}  {M; ¿; P}®, ¬P € M®, ¬M € ~ ¿®], ¬³ ¿ € P®)]
: (TERM list * TERM) list
=TEX

The following code generates the goals for proving the above syllogisms from the previously defined data structure desribing the valid syllogisms, generates and checks formal proofs and saves the resulting theorems in the current theory (see end of document for theory listing). 

=SML
val Ûxssps1Ý = syll_prove_and_store mk_xssyllp "_s";
=TEX

\subsubsection{Proving the Syllogisms}

We now apply this to the complete set of non-u-p syllogisms,
saving the results in the theory as well as binding them to (naming them as) the metalanguage value {\it valid\_sylls}.

=SML
val Ûvalid_xssyllsÝ =
	map (xssps1
		(REPEAT (POP_ASM_T ante_tac)
		THEN PC_T1 "hol1" rewrite_tac [] THEN prove_tac[]))
	(syllogism_data2 @ syllogism_data3);
=IGN
set_goal ([¬³ ({}:'a SET)  {M; ¿; P}®, ¬M € (P:'a SET)®, ¬M € (¿:'a SET)®], ¬³ ¿ € ~ (P:'a SET)®);
a (REPEAT(POP_ASM_T ante_tac));
a (PC_T1 "hol1" rewrite_tac[]);
a (prove_tac[]);
=TEX

Some words about the very limited signficance of this little exercise would be appropriate here!

\subsection{The Complete Syllogism}\label{SYLL}

There is more than one way in which the semantics of the syllogism can be modified to make the inference from ``All As are Bs'' to ``Some As are Bs'' sound.
One way would be to change the meaning of ``All''.
This would interfere with the square of opposition by making opposites no longer contradictories.
From this I tentatively infer that the exclusion of empty predicates is a better approach.
\footnote{This seems to be endorsed by Robin Smith in the \href{http://plato.stanford.edu/entries/aristotle-logic/}{Stanford Encyclopaedia of Philosophy}.}

We can then prove valid 24 forms of syllogism.

For the most concise statement of the results of the exercise, the reader should refer directly to the theory listing in \thyref{syllog2}.

=SML
open_theory "aristotle";
force_new_theory "syllog2";
=TEX

\ignore{
=SML
force_new_pc Û"'syllog2"Ý;
merge_pcs ["'savedthm_cs_¶_proof"] "'syllog2";
set_merge_pcs ["misc2", "'syllog2"];
=TEX
}%ignore

\subsubsection{The Subject Matter}

The key to getting the u-p syllogisms into the model is the adoption of a type for the variables in the syllogisms which does not include empty predicates.
We could do this by defining a new type which is a sub-type of the propositional functions, but it is simpler to use another type-abbreviation as follows.

Instead of using a propositional function, which might be unsatisfiable, we use an ordered pair.
The pair consists of one value, a value for which the predicate is true, and a propositional function.
The predicate $(v, pf)$ is then to be considered true of some value $x$ {\it either} if $x$ is $v$ {\it or} if $pf$ is true of $x$. 

This is the type abbreviation:

=SML
declare_type_abbrev("TERM2", [], ”'a ¸ ('a ­ BOOL)®);
=TEX

\subsubsection{Predication}

To work with this new type for the predicates we define a function which will convert this kind of predicate into the old kind, as follows:

¹HOLCONST
Ü ÛpÝ : TERM2 ­ ('a ­ BOOL)
÷üüüüüü
Ü µA· p A = Ìx· let (v,f) = A in x = v ² f x 
°

The resulting values have the same type as the old, but they will never have empty extension.

The following principle can be proven (proof omitted):

\ignore{
=SML
set_goal([], ¬µA· ¶v· (p A) v®);
a (strip_tac);
a (¶_tac ¬Fst A® THEN rewrite_tac [get_spec ¬p®, let_def]);
val p_¶_lemma = save_pop_thm "p_¶_lemma";
=TEX
}%ignore

=GFT
p_¶_lemma =
	ô µ A· ¶v· p A v
=TEX

This principle is what we need to prove the u-p syllogisms.

We then proceed in a similar manner to the first model, using the function $p$ to convert the new kind of predicate into the old.

We have a new theory which is not a child of the first theory, so we must redeclare the fixity of the predication operators:

=SML
declare_infix (300, "a");
declare_infix (300, "e");
declare_infix (300, "i");
declare_infix (300, "u");
=TEX

They predication operators are then defined.
Note that the differences are small and uniform.
The type $”PROP®$ is changed to $”TERM2®$ and the function $p$ is invoked before applying a predicate.

¹HOLCONST
Ü $ÛaÝ : TERM2 ­ TERM2 ­ BOOL
÷üüüüüü
Ü µA B· A a B ¤ µx· p A x ´ p B x
°

¹HOLCONST
Ü $ÛeÝ : TERM2 ­ TERM2 ­ BOOL
÷üüüüüü
Ü µA B· A e B ¤ µx· p A x ´ ³ p B x
°

¹HOLCONST
Ü $ÛiÝ : TERM2 ­ TERM2 ­ BOOL
÷üüüüüü
Ü µA B· A i B ¤ ¶x· p A x ± p B x
°

¹HOLCONST
Ü $ÛuÝ : TERM2 ­ TERM2 ­ BOOL
÷üüüüüü
Ü µA B· A u B ¤ ¶x· p A x ± ³ p B x
°

=SML
declare_alias("o", ¬$u®);
=TEX

\subsubsection{Laws of Immediate Inference}

The same tactic used for proof of the syllogisms in the previous model still works with this model (with the new definitions), but does not prove the u-p syllogisms.

To obtain proofs of these other syllogisms we need to make use of the lemma we proved about $p$, {\it p\_¶\_lemma}.
This we do by instantiating it for each of the variables which appear in the syllogisms and supplying these for use in the proof.

=SML
val Ûsyll_tac2Ý =
	(MAP_EVERY (fn x => strip_asm_tac (µ_elim x p_¶_lemma))
		[¬M:TERM2®, ¬P:TERM2®, ¬¿:TERM2®, ¬A:TERM2®, ¬B:TERM2®])
	THEN asm_prove_tac (map get_spec [¬$a®, ¬$e®, ¬$i®, ¬$u®]);

fun Ûsyll_rule2Ý g = tac_proof(g, syll_tac2);
=TEX

\paragraph{Simple Conversion}

=SML
val e_conv_thm = save_thm ("e_conv_thm", syll_rule2([¬A e B®], ¬B e A®));
val i_conv_thm = save_thm ("i_conv_thm", syll_rule2([¬A i B®], ¬B i A®));
=TEX

=GFT
val e_conv_thm = A e B ô B e A : THM
val i_conv_thm = A i B ô B i A : THM
=TEX

In this version of the semantics, ``a'' and ``o'' conversion is neither provable nor refutable.
In the previous version, since the universe is a HOL type there is at least one individual, and contradictory predicates are allowed, we can use these two to disprove the two conversions.
With this semantics there is no empty predicate, and we cannot know that there are two distinct predicates.

\paragraph{Conversion Per Accidens}

=SML
val ai_conv_thm = save_thm ("ai_conv_thm", syll_rule2([¬A a B®], ¬B i A®));
val eo_conv_thm = save_thm ("eo_conv_thm", syll_rule2([¬A e B®], ¬B u A®));
=TEX

=GFT
val ai_conv_thm = A a B ô B i A : THM
val eo_conv_thm = A e B ô B o A : THM
=TEX

\subsubsection{The Valid Syllogisms}

The valid syllogisms have been described in Section \ref{ValidSyllogisms}.

All twnety four syllogisms are true under this semantics and have been proven.
The actual theorems are shown in the theory listing in \thyref{syllog2}.

The metalanguage scripts prepared for the first model are mostly reusable for this model, with some different parameters which reflect the differences between the models.

The main requirement is to supply the type of the propositional functions in this model which is done as follows:

=SML
val Ûmk_syllp2Ý = mk_syllp ”TERM2®;
=TEX

This defines the fucntion {\it mk\_syllp2} whose type is shown:

=GFT
val mk_syllp2 = fn : string * int -> TERM list * TERM
=TEX

{\it mk\_syllp2} takes a pair consisting of a string which is the name of a syllogism and a number which is the number of the figure, and constructs the syllogism as a goal for proof.

An example of its use is:

=SML
mk_syllp2 ("Barbara", 1);
=TEX

which yields:

=GFT
val it = ([¬M a P®, ¬¿ a M®], ¬¿ a P®) : TERM list * TERM
=TEX

\subsubsection{Proving the Syllogisms}

We now apply this to the complete set of u-p syllogisms,
saving the results in the theory as well as binding them to (naming them as) the metalanguage value {\it valid\_sylls}.

=SML
val Ûsps2Ý = syll_prove_and_store mk_syllp2 "";
val Ûvalid_sylls2Ý = map (sps2 syll_tac2)
	(syllogism_data1 @ syllogism_data2 @ syllogism_data3);
=TEX

This is the resulting value.
=GFT
val valid_sylls2 =
   [("Barbara", M a P, ¿ a M ô ¿ a P), ("Celarent", M e P, ¿ a M ô ¿ e P),
      ("Darii", M a P, ¿ i M ô ¿ i P), ("Ferio", M e P, ¿ i M ô ¿ o P),
      ("Cesare", P e M, ¿ a M ô ¿ e P), ("Camestres", P a M, ¿ e M ô ¿ e P),
      ("Festino", P e M, ¿ i M ô ¿ o P), ("Baroco", P a M, ¿ o M ô ¿ o P),
      ("Disamis", M i P, M a ¿ ô ¿ i P), ("Datisi", M a P, M i ¿ ô ¿ i P),
      ("Bocardo", M o P, M a ¿ ô ¿ o P), ("Ferison", M e P, M i ¿ ô ¿ o P),
      ("Camenes", P a M, M e ¿ ô ¿ e P), ("Dimaris", P i M, M a ¿ ô ¿ i P),
      ("Fresison", P e M, M i ¿ ô ¿ o P), ("Darapti", M a P, M a ¿ ô ¿ i P),
      ("Felapton", M e P, M a ¿ ô ¿ o P),
      ("Bramantip", P a M, M a ¿ ô ¿ i P), ("Fesapo", P e M, M a ¿ ô ¿ o P),
      ("Barbari", M a P, ¿ a M ô ¿ i P), ("Celaront", M e P, ¿ a M ô ¿ o P),
      ("Cesaro", M e P, ¿ a M ô ¿ o P), ("Camestrop", P a M, ¿ e M ô ¿ o P),
      ("Camenop", P a M, M e ¿ ô ¿ o P)] : (string * THM) list
=TEX

The theorems have aso been stored in the theory and are also displayed in the theory listing in \thyref{syllog2}

\subsection{Modal Syllogisms}\label{MODSYLL}

The language of syllogistic logic does not have operators over propositions.
The only operators are the ones which apply predicates to subjects.

The modalities are perhaps therefore better thought of as kinds of judgements rather than as operations on propositions.
This would give us three kinds of judgement, which assert a predication contingently, necessarily or possibly.

It is natural to consider the modal aspects in terms of possible worlds, and I will model it first in those terms (not knowing whether this will provide a good model of Aristotle's conception of modality).
The propositional functions could then be modelled as functions from possible worlds to non-empty propositional functions.

\ignore{
One respect in which the treatment of the syllogism so far looks odd to the modern eye is the lack of consideration of constants.

We have a language which only has variables, even though Aristotle does use syllogistic reasoning with concrete predicates and subjects.
This lack bevomes more significant when modalities are introduced, for we expect necessities to flow from contraints on the extension of constants which are fixed across the possible worlds (i.e. the meanings of concepts are to be held fixed, even though their extensions may vary across possible worlds).

So I proposed in modelling modal syllogisms to bring the semantics closer to a modern model theory by allowing for constants.
This will be reflected in the definition of ``possible world'' which will include an assignment of values to constants.
}%ignore

I adapt the treatment of u-p syllogisms by treating predicates as parameterised by a possible world.

Rather than using a type variable (which is what I did for the two preceding treatments) I will use two new type constants for individual aubstances and possible worlds.

It may suffice for the reader to refer directly to the theory listing in \thyref{modsyllog}.

=SML
open_theory "aristotle";
force_new_theory "modsyllog";
=TEX

\ignore{
=SML
force_new_pc Û"'modsyllog"Ý;
merge_pcs ["'savedthm_cs_¶_proof"] "'modsyllog";
set_merge_pcs ["misc2", "'modsyllog"];
=TEX
}%ignore

\subsubsection{The Subject Matter}

The complexity required in the semantics of modal operators depends upon other features of the language in which they occur.
Because the language of the syllogism is very simple, having neither propositional operators nor variables for individuals a very simple semantics may suffice.
When we come to consider the metaphyics there will be some increase in the complexity of the other features of the language, and also a greater premium on getting the semantics to correspond intuitively with the content of the metaphysics, but at this stage we will adopt the simplest semantic model which seems likely to secure the results expressible in our restrictied language.

So are now talking about predicates parameterised by possible worlds.
Furthermore, we will model this with a fixed set to individuals, independent of the possible world.
Possible worlds differ only in the extension of predicates.

First some new types, ``I'' for individual substances, ``W'' for possible worlds:

=SML
new_type (Û"I"Ý,0);
new_type (Û"W"Ý,0);
=TEX

Then a type abbreviation for the predicates:

=SML
declare_type_abbrev("MPROP", [], ”W ­ I ¸ (I ­ BOOL)®);
=TEX

\subsubsection{Predication}

To work with this new type for the predicates we define a function which will convert this kind of predicate into the old kind, as follows:

¹HOLCONST
Ü ÛpÝ : MPROP ­ (W ­ I ­ BOOL)
÷üüüüüü
Ü µA· p A = Ìw x· let (v,f) = A w in x = v ² f x
°

The following principle can be proven (proof omitted):

\ignore{
=SML
set_goal([], ¬µA w· ¶v· (p A) w v®);
a (REPEAT µ_tac);
a (¶_tac ¬Fst (A w)® THEN rewrite_tac [get_spec ¬p®, let_def]);
val p_¶_lemma = save_pop_thm "p_¶_lemma";
=TEX
}%ignore

=GFT
p_¶_lemma =
	ô µ A w· ¶ v· p A w v
=TEX

This principle is what we need to prove the u-p syllogisms.

We then proceed in a similar manner to the other models, using the function $p$ to convert the new kind of predicate into the old.

We have a new theory which is not a child of the first theory, so we must redeclare the fixity of the predication operators:

=SML
declare_infix (300, "a");
declare_infix (300, "e");
declare_infix (300, "i");
declare_infix (300, "u");
=TEX

They predication operators are then defined.
Note that the differences are small and uniform.
The type $”TERM2®$ is changed to $”MPROP®$ and the function $p$ is invoked before applying a predicate.

Now we think of a predication as being a set of possible worlds, or BOOLean valued function over possible worlds.

¹HOLCONST
Ü $ÛaÝ : MPROP ­ MPROP ­ W ­ BOOL
÷üüüüüü
Ü µA B w· (A a B) w ¤ µx· p A w x ´ p B w x
°

¹HOLCONST
Ü $ÛeÝ : MPROP ­ MPROP ­ W ­ BOOL
÷üüüüüü
Ü µA B w· (A e B) w ¤ µx· p A w x ´ ³ p B w x
°

¹HOLCONST
Ü $ÛiÝ : MPROP ­ MPROP ­ W ­ BOOL
÷üüüüüü
Ü µA B w· (A i B) w ¤ ¶x· p A w x ± p B w x
°

¹HOLCONST
Ü $ÛuÝ : MPROP ­ MPROP ­ W ­ BOOL
÷üüüüüü
Ü µA B w· (A u B) w ¤ ¶x· p A w x ± ³ p B w x
°

=SML
declare_alias("o", ¬$u®);
=TEX

We now have to define some additional constants for the forms of judgement, which will assert the predications either of the actual world or of some or all possible worlds.

First I define a constant (rather loosely) to be the actual world:

¹HOLCONST
Ü Ûactual_worldÝ : W
÷üüüüüü
Ü T
°

Then the two modal judgement forms:

¹HOLCONST
Ü Û¨Ý : (W ­ BOOL) ­ BOOL
÷üüüüüü
Ü µs· ¨ s ¤ ¶w· s w
°

¹HOLCONST
Ü Û©Ý : (W ­ BOOL) ­ BOOL
÷üüüüüü
Ü µs· © s ¤ µw· s w
°

Finally the non-modal judgements also need a judgement forming constant.

¹HOLCONST
Ü Û˜Ý : (W ­ BOOL) ­ BOOL
÷üüüüüü
Ü µs· ˜ s ¤ s actual_world
°

\subsubsection{Laws of Immediate Inference}

Before looking at the conversions there are some general rules which may be helpful for us though these probably are not in Aristotle.

\ignore{
=SML
set_goal([¬©X®], ¬¨X®);
a (POP_ASM_T ante_tac THEN rewrite_tac [get_spec ¬©®, get_spec ¬¨®, get_spec ¬˜®]
	THEN REPEAT strip_tac THEN_TRY asm_rewrite_tac[]);
val ©¨_thm = save_pop_thm "©¨_thm";

set_goal([¬©X®], ¬˜X®);
a (POP_ASM_T ante_tac THEN rewrite_tac [get_spec ¬©®, get_spec ¬¨®, get_spec ¬˜®]
	THEN REPEAT strip_tac THEN_TRY asm_rewrite_tac[]);
val ©˜_thm = save_pop_thm "©˜_thm";

set_goal([¬˜X®], ¬¨X®);
a (POP_ASM_T ante_tac THEN rewrite_tac [get_spec ¬©®, get_spec ¬¨®, get_spec ¬˜®]
	THEN REPEAT strip_tac THEN_TRY asm_rewrite_tac[]);
a (¶_tac ¬actual_world® THEN strip_tac);
val ˜¨_thm_thm = save_pop_thm "˜¨_thm_thm";
=TEX
}%ignore

=GFT
©¨_thm = 		© X ô ¨ X
©˜_thm = 	© X ô ˜ X
˜¨_thm = 	˜ X ô ¨ X
=TEX

\paragraph{Simple Conversion}

\ignore{
=SML
set_goal([¬˜ (A e B)®], ¬˜(B e A)®);
a (POP_ASM_T ante_tac THEN rewrite_tac (map get_spec [¬˜®, ¬$e®])
	THEN contr_tac);
a (asm_fc_tac[]);
val e_conv_thm = save_pop_thm "e_conv_thm";

set_goal([¬˜ (A i B)®], ¬˜(B i A)®);
a (POP_ASM_T ante_tac THEN rewrite_tac (map get_spec [¬˜®, ¬$i®])
	THEN contr_tac);
a (asm_fc_tac[]);
val i_conv_thm = save_pop_thm "i_conv_thm";

set_goal([¬© (A e B)®], ¬©(B e A)®);
a (POP_ASM_T ante_tac THEN rewrite_tac (map get_spec [¬©®, ¬$e®])
	THEN contr_tac);
a (asm_fc_tac[]);
val ©e_conv_thm = save_pop_thm "©e_conv_thm";

set_goal([¬© (A i B)®], ¬©(B i A)®);
a (POP_ASM_T ante_tac THEN rewrite_tac (map get_spec [¬©®, ¬$i®])
	THEN contr_tac);
a (asm_fc_tac[]);
a (spec_nth_asm_tac 2 ¬w®);
a (asm_fc_tac[]);
val ©i_conv_thm = save_pop_thm "©i_conv_thm";

set_goal([¬¨ (A e B)®], ¬¨(B e A)®);
a (POP_ASM_T ante_tac THEN rewrite_tac (map get_spec [¬¨®, ¬$e®])
	THEN contr_tac);
a (spec_nth_asm_tac 1 ¬w®);
a (asm_fc_tac[]);
val ¨e_conv_thm = save_pop_thm "¨e_conv_thm";

set_goal([¬¨ (A i B)®], ¬¨(B i A)®);
a (POP_ASM_T ante_tac THEN rewrite_tac (map get_spec [¬¨®, ¬$i®])
	THEN contr_tac);
a (spec_nth_asm_tac 1 ¬w®);
a (asm_fc_tac[]);
val ¨i_conv_thm = save_pop_thm "¨i_conv_thm";

set_goal([¬© (A e B)®], ¬¨(B e A)®);
a (POP_ASM_T ante_tac THEN rewrite_tac (map get_spec [¬¨®, ¬©®, ¬$e®])
	THEN contr_tac);
a (spec_nth_asm_tac 1 ¬w:W®);
a (asm_fc_tac[]);
val ©¨e_conv_thm = save_pop_thm "©¨e_conv_thm";

set_goal([¬© (A e B)®], ¬˜(B e A)®);
a (POP_ASM_T ante_tac THEN rewrite_tac (map get_spec [¬˜®, ¬©®, ¬$e®])
	THEN contr_tac);
a (asm_fc_tac[]);
val ©˜e_conv_thm = save_pop_thm "©˜e_conv_thm";
=TEX
}%ignore

=GFT
e_conv_thm = ˜ (A e B) ô ˜ (B e A)
i_conv_thm = ˜ (A i B) ô ˜ (B i A)
©e_conv_thm = © (A e B) ô © (B e A)
©i_conv_thm = © (A i B) ô © (B i A)
¨e_conv_thm = ¨ (A e B) ô ¨ (B e A)
¨i_conv_thm = ¨ (A i B) ô ¨ (B i A)
©¨e_conv_thm = © (A e B) ô ¨ (B e A)
©˜e_conv_thm = © (A e B) ô ˜ (B e A)
=TEX

In this version of the semantics, ``a'' and ``o'' conversion is neither provable nor refutable.
In the previous version (the one not admitting the u-p syllogisms), since the universe is a HOL type there is at least one individual, and contradictory predicates are allowed, we can use these two to disprove the two conversions.
With this semantics there is no empty predicate, and we cannot know that there are two distinct predicates.

\paragraph{Conversion Per Accidens}

\ignore{
=SML
set_goal([¬˜ (A a B)®], ¬˜ (B i A)®);
a (REPEAT (POP_ASM_T ante_tac) THEN rewrite_tac (map get_spec [¬¨®, ¬©®, ¬˜®, ¬$a®, ¬$e®, ¬$i®, ¬$u®])
	THEN contr_tac THEN asm_fc_tac[]);
a (strip_asm_tac (list_µ_elim [¬A®, ¬actual_world®] p_¶_lemma));
a (asm_fc_tac[]);
val ˜ai_conv_thm = save_pop_thm "˜ai_conv_thm";

set_goal([¬˜ (A e B)®], ¬˜ (B u A)®);
a (REPEAT (POP_ASM_T ante_tac) THEN rewrite_tac (map get_spec [¬¨®, ¬©®, ¬˜®, ¬$a®, ¬$e®, ¬$i®, ¬$u®])
	THEN contr_tac THEN asm_fc_tac[]);
a (strip_asm_tac (list_µ_elim [¬B®, ¬actual_world®] p_¶_lemma));
a (spec_nth_asm_tac 2 ¬v®);
a (asm_fc_tac[]);
val ˜eo_conv_thm = save_pop_thm "˜eo_conv_thm";

set_goal([¬© (A a B)®], ¬¨ (B i A)®);
a (REPEAT (POP_ASM_T ante_tac) THEN rewrite_tac (map get_spec [¬¨®, ¬©®, ¬˜®, ¬$a®, ¬$e®, ¬$i®, ¬$u®])
	THEN contr_tac THEN asm_fc_tac[]);
a (strip_asm_tac (list_µ_elim [¬A®, ¬actual_world®] p_¶_lemma));
a (asm_fc_tac[]);
val ©¨ai_conv_thm = save_pop_thm "©¨ai_conv_thm";

set_goal([¬© (A e B)®], ¬¨ (B u A)®);
a (REPEAT (POP_ASM_T ante_tac) THEN rewrite_tac (map get_spec [¬¨®, ¬©®, ¬˜®, ¬$a®, ¬$e®, ¬$i®, ¬$u®])
	THEN contr_tac THEN asm_fc_tac[]);
a (strip_asm_tac (list_µ_elim [¬B®, ¬actual_world®] p_¶_lemma));
a (spec_nth_asm_tac 2 ¬actual_world®);
a (spec_nth_asm_tac 1 ¬v®);
a (asm_fc_tac[]);
val ©¨eo_conv_thm = save_pop_thm "©¨eo_conv_thm";
=TEX
}%ignore

=GFT
˜ai_conv_thm = 	˜ (A a B) ô ˜ (B i A)
˜eo_conv_thm = 	˜ (A e B) ô ˜ (B o A)
©¨ai_conv_thm = 	© (A a B) ô ¨ (B i A)
©¨eo_conv_thm = 	© (A e B) ô ¨ (B o A)
=TEX

\subsubsection{The Valid Modal Syllogisms}

The valid syllogisms have been described in Section \ref{ValidSyllogisms}.

All nineteen syllogisms supposed valid by Aristotle are true under this semantics and have been proven.
A further five\footnote{Which I got from Strawson \cite{strawson52}.} have also been proven, giving a total of 24.
When combinations of modal operators are added to this the number gets quite large, so, rather than proving all the valid cases I will prove sufficient to enable the rest to be automatically proven.

This will involve some theorems which are not strictly syllogistic.

The actual theorems proved are shown in the theory listing in \thyref{modsyllog}.

Because of the modal operators the generation of the syllogisms is more complicated.
The generation functions are adapted to allow a single modal operator to be applied to each of the premises and the conclusion.

=SML
fun Ûmap_goalÝ f (st, t) = (map f st, f t);

fun Ûmk_modtÝ vt = mk_ctype ("­", [vt,
	mk_ctype ("­", [vt, (mk_ctype ("­", [”W®, ”BOOL®]))])]);

fun Ûmk_modsyllÝ vt (s, n) =
	mk_syll vt (nth (n-1) (figures vt)) (optrip_from_text (mk_modt vt) s);

fun ÛmodgoalÝ (mo1, mo2, mo3) ([p1,p2], c) =
	([mk_app (mo1, p1), mk_app (mo2, p2)], mk_app (mo3, c));

fun Ûmk_modsyllpÝ mot p = modgoal mot (mk_modsyll ”MPROP® p);
=TEX

This defines the function {\it mk\_modsyllp} whose type is shown:

=GFT
val mk_modsyllp = fn: TERM * TERM * TERM -> string * int -> TERM list * TERM
=TEX

in which the {\it TERM} parameters are modal operators the next argument is a pair consisting of a string which is the name of a syllogism and a number which is the number of the figure.
The result is a goal for proof.

An example of its use is:

=SML
mk_modsyllp (¬©®,¬˜®,¬¨®) ("Barbara", 1);
=TEX

which yields:

=GFT
val it = ([¬© (M a P)®, ¬© (¿ a M)®], ¬© (¿ a P)®) : TERM list * TERM
=TEX

\subsubsection{General Results}

The logic of the modal operators is completely independent of the logic of the syllogism.
The relevant results can be stated and proven in HOL concisely, but these statements are not in the language of the syllogism.

There are in effect just seven modal truths, each of which appears in 24 forms, one for each of the valid non-modal syllogisms.

Rather than proving all 192 theorems (counting the non-modal truths in this modal model), I prove the eight proformas expressed in HOL.
From these eight all 192 theorems can be obtained by proving (a special form of) one of the valid syllogisms and instantiating one of the general modal rules using it.

I omit the details of the metalanguage scripts which automate all this.

\ignore{
To get the required general results we define a new kind of pseudo-judgement `G' (for general).

=SML
val G = ¬(Ìx:W ­ BOOL· x w)®;
val GS = ¬µw:W· ‘G® FP ± ‘G® SP ´ ‘G® CS®;
fun modal_generalisation (a,b,c) =
	¬µFP SP CS· ‘GS® ´ (‘a® FP) ± (‘b® SP) ´ (‘c® CS)®;
=TEX

=SML
mk_modsyllp (G,G,G) ("Barbara", 1);
val general_syllogs = map ((map_goal (snd o dest_eq o concl o rewrite_conv[]))
			o (mk_modsyllp (G,G,G)))
	(syllogism_data1 @ syllogism_data2 @ syllogism_data3);
=TEX


=SML
fun AW_COND_T tac (asms, conc) =
	if snd (dest_app conc) = ¬actual_world®
	then tac ¬actual_world® (asms, conc)
	else tac ¬w:W® (asms, conc);

val mod_gen_tac = REPEAT µ_tac
	THEN rewrite_tac (map get_spec [¬¨®, ¬©®, ¬˜®])
	THEN REPEAT strip_tac
	THEN (AW_COND_T (fn x => REPEAT
		(((SPEC_NTH_ASM_T 1 x ante_tac) ORELSE_T (GET_NTH_ASM_T 1 ante_tac))
			THEN POP_ASM_T discard_tac)))
	THEN REPEAT strip_tac
	THEN_TRY ¶_tac ¬w:W®
	THEN REPEAT strip_tac;

fun mod_gen_rule t = tac_proof(([],t), mod_gen_tac);
=TEX
}%ignore

The following lists the valid modal forms.
In each tuple the three entries give the modalities of the first and second premise and the conclusion respectively.
Taking any valid syllogism and applying modal operators using one of the patterns in this table will give a valid modal syllogism.

=SML
val mod_gen_params =
	[(¬©®, ¬©®, ¬©®),
	(¬©®, ¬©®, ¬¨®),
	(¬©®, ¬©®, ¬˜®),
	(¬¨®, ¬©®, ¬¨®),
	(¬©®, ¬¨®, ¬¨®),
	(¬©®, ¬˜®, ¬˜®),
	(¬˜®, ¬©®, ¬˜®),
	(¬˜®, ¬˜®, ¬˜®)];
=TEX

\ignore{
=SML
val mod_gen_terms = map modal_generalisation mod_gen_params;

val mod_gens = map mod_gen_rule mod_gen_terms;

fun mod_gen_name (x,y,z) = concat
	(["mod_gen_"] @ [fst (dest_const x), fst (dest_const y), fst (dest_const z)]);

val mod_gen_thms = map
	(save_thm o (fn x => (mod_gen_name x, rewrite_rule [] (mod_gen_rule (modal_generalisation x)))))
	mod_gen_params;
=TEX
}%ignore

The set of general HOL theorems which facilitate the proofs of these modal syllogisms is as follows:

=GFT ProofPower Theorems
val mod_gen_thms =
   [ô µ FP SP CS· (µ w· FP w ± SP w ´ CS w) ´ © FP ± © SP ´ © CS,
      ô µ FP SP CS· (µ w· FP w ± SP w ´ CS w) ´ © FP ± © SP ´ ¨ CS,
      ô µ FP SP CS· (µ w· FP w ± SP w ´ CS w) ´ © FP ± © SP ´ ˜ CS,
      ô µ FP SP CS· (µ w· FP w ± SP w ´ CS w) ´ ¨ FP ± © SP ´ ¨ CS,
      ô µ FP SP CS· (µ w· FP w ± SP w ´ CS w) ´ © FP ± ¨ SP ´ ¨ CS,
      ô µ FP SP CS· (µ w· FP w ± SP w ´ CS w) ´ © FP ± ˜ SP ´ ˜ CS,
      ô µ FP SP CS· (µ w· FP w ± SP w ´ CS w) ´ ˜ FP ± © SP ´ ˜ CS,
      ô µ FP SP CS· (µ w· FP w ± SP w ´ CS w) ´ ˜ FP ± ˜ SP ´ ˜ CS]
: THM list
=TEX

In the above theorems the variables {\it FP}, {\it SP}, {\it CS}, stand respectively for {\it first premise}, {\it second premise}, {\it conclusion of syllogism} and range over modal propositions (which have type ”W ­ BOOL®).

\subsubsection{Proving the Syllogisms}

I then prove the 24 non-modal syllogisms in the required form and infer forward using the above 8 theorems to obtain a total of 192 theorems true in this model of the modal syllogism.

Details of scripts omitted.

\ignore{
=SML
fun ÛmodspsÝ mods = syll_prove (mk_modsyllp mods);
fun Ûvalid_modsyllsÝ mods suff tac = map (modsps mods suff tac)
	(syllogism_data1 @ syllogism_data2 @ syllogism_data3);
=TEX

The same tactic used for proof of the syllogisms in the previous model still works with this model (with the new definitions), but does not prove the u-p syllogisms.

To obtain proofs of these other syllogisms we need to make use of the lemma we proved about $p$, {\it p\_¶\_lemma}.
This we do by instantiating it for each of the variables which appear in the syllogisms and supplying these for use in the proof.


=SML
val Ûmodsyll_G_tacÝ =
	(MAP_EVERY strip_asm_tac
		(map (fn x => (list_µ_elim [x, ¬w:W®] p_¶_lemma))
		[¬M:MPROP®, ¬P:MPROP®, ¬¿:MPROP®])
	THEN (asm_prove_tac (map get_spec [¬$a®, ¬$e®, ¬$i®, ¬$u®])));

fun Ûmodsyll_G_ruleÝ g = tac_proof(g, modsyll_G_tac);
=TEX

I just run this over a few combinations of modal operators to see which it will prove.

=SML
val valid_G_modsylls1 = valid_modsylls (G,G,G) "" modsyll_G_tac;
val valid_G_modsylls2 = map
	((µ_intro ¬w:W®)
		o (rewrite_rule [prove_rule [] ¬µA B C· (A ´ B ´ C) ¤ (A ± B ´ C)®])
		o (rewrite_rule [])
		o all_´_intro
		o snd)
	valid_G_modsylls1;

val valid_G_modsylls = map (undisch_rule
		o undisch_rule
		o (rewrite_rule [prove_rule [] ¬µA B C· (A ± B ´ C) ¤ (A ´ B ´ C)®])
		o all_µ_elim)
	(fc_rule mod_gen_thms valid_G_modsylls2);
=TEX
}%ignore

The automated proof the yields the expected 192 modal syllogisms, of which we display only the first few (and do not save them in the theory):

=GFT
val valid_G_modsylls =
   [˜ (P a M), ˜ (M e ¿) ô ˜ (¿ o P), ˜ (P a M), © (M e ¿) ô ˜ (¿ o P),
      © (P a M), ˜ (M e ¿) ô ˜ (¿ o P), © (P a M), ¨ (M e ¿) ô ¨ (¿ o P),
      ¨ (P a M), © (M e ¿) ô ¨ (¿ o P), © (P a M), © (M e ¿) ô ˜ (¿ o P),
      © (P a M), © (M e ¿) ô ¨ (¿ o P), © (P a M), © (M e ¿) ô © (¿ o P),
      ˜ (P a M), ˜ (¿ e M) ô ˜ (¿ o P), ˜ (P a M), © (¿ e M) ô ˜ (¿ o P),
      © (P a M), ˜ (¿ e M) ô ˜ (¿ o P), © (P a M), ¨ (¿ e M) ô ¨ (¿ o P),
      ¨ (P a M), © (¿ e M) ô ¨ (¿ o P), © (P a M), © (¿ e M) ô ˜ (¿ o P),
      © (P a M), © (¿ e M) ô ¨ (¿ o P), © (P a M), © (¿ e M) ô © (¿ o P),
      ˜ (P e M), ˜ (¿ a M) ô ˜ (¿ o P), ˜ (P e M), © (¿ a M) ô ˜ (¿ o P),
      © (P e M), ˜ (¿ a M) ô ˜ (¿ o P), © (P e M), ¨ (¿ a M) ô ¨ (¿ o P),
...
=TEX

=SML
length valid_G_modsylls;
=GFT
val it = 192 : int
=TEX
=TEX

\subsection{Demonstrative Truth}

An important part of Aristotle's philosophy is his concept of demonstrative science.

A proof is demonstrative if it proceeds from first principles and is deductively sound.
Truths established in this way is necessary because the first principles must be essential and hence necessary and sound deduction preserves necessity.

If we understand Hume's ``intuitively certain'' as a reference to the criteria for Aristotle's first principles, and understand Hume as using the term `demonstrative' in the same sense as Aristotle, then it is plausible that Hume's ``truths of reason'' are the same as Aristotle's truths of demonstrative science.

It is tempting to use the word demonstrative for these though in Aristotle and Hume the first principles do not count as demonstrable.
It is tempting also to identify these concepts with the concept of analyticity.
This last point is aided by the connection in Aristotle between essential truth (which must be posessed by the first principles) and definition, which seems close, and which distinguishes his accidental predications from essential predications.

However, we now expect deductive systems to be incomplete, and hence that not all analytic propositions are provable.
However, the incompleteness may arise from adopting a fixed set of first principles, rather from incompleteness of deduction.
In this case, the availability of an open set of first principles makes completeness in principle possible.
To sustain this principle in relation to set theory, for example, we would have to regard ourselves as having some definition of the concept of set relative to which the present axioms (say those of ZFC) are essential, and relative to which extensions as necessary to prove progressively more difficult results can also be seen to be essential.
This is not entirely implausible.
This is close to the rationale for large cardinal axioms.
The informal description of the cumulative hierarchy as the domain of set theory involves the idea that the construction of well-founded sets from other well-founded sets of lesser rank proceeds indefinitely, and hence any axiom which states that a set of a certain rank exists must be true.

Does formal modelling contribute anything to this discussion?

The above discussion involves ideas which belong to Aristotle's metaphysics rather than his logic.
So a fuller formal analysis of these ideas will have to wait until we get to the Metaphysics.

However some aspects may be considered here.
For example, we need to know that from necessary premises only necessary premises are derivable by syllogisms.

\section{Metaphysics (II)}\label{METAPHYSICSII}

In this section I offer a single model integrating Modal Syllogisms with the distinction between essential and accidental predication.

My interest is primarily in the extent to which may be found in Aristotle's philosophy a precursor of Hume's fork or the modern distinctions between analytic and synthetic or necessary and contingent propositions.
I see three Aristotelian ideas which have some relevance.

\begin{itemize}
\item the distinction between necessary and contingent propositions
\item the distinction between essential and accidental predication
\item the notion of demonstrability
\end{itemize}

It is only when we combine the syllogism with the metaphyics that we can explore the relationship between these various concepts.

I will give higher priority in this model to good structure while remaining faithful to Aristotle.
It is not the purpose of this model to further investigate the position in relation to Aristotle of Grice, Codd or Speranza.

I have constructed this model to give a good correspondence between necessary truth and essential predication.
If the model is successful in that respect it remains to consider whether it is consistent with the philosophy of Aristotle.
I do not know whether Aristotle talked about the relationship between essence and necessity.

I also hope that the model may help to explore the question of whether demonstrable truth, or rather the truths which are either ``intuitively or demonstrably certain'' to use Hume's words, coincides with necessary truth.

=SML
open_theory "aristotle";
force_new_theory "syllmetap";
=TEX

\ignore{
=SML
force_new_pc Û"'syllmetap"Ý;
merge_pcs ["'savedthm_cs_¶_proof"] "'syllmetap";
set_merge_pcs ["misc2", "'syllmetap"];
=TEX
}%ignore

\subsection{The Subject Matter}

In my first metaphysical model the main question in relations to subject matter was ``what are subjects and predicates'', to which a model of Aristotelian categories gives an answer.
The introduction of modality makes it necessary to consider something like possible worlds.
These were left uninterpreted in the modal treatment of the syllogism, but now that we expose the distinction between essential and accidental predication is it desirable to identify possible worlds with that which is accidental.

What is accidental is the extension of individual attributes, and this gives our concept of possible world.

It is convenient at this point to consider the question of extensionality.
According to Grice/Codd/Speranza, essential predicates are extensional (%
=INLINEFT
A izz B ± B izz A ´ A = B
=TEX
), but I know no reason to suppose that accidental predication is, and it seems counter-intuitive that it should be.
Consequently the modelling of an accidental predicate using a BOOLean valued function in HOL (in which functions are extensional) is inappropriate.
So I will separate out the extension from the individual attribute.

Individuals belong to categories, and are collected together in groups which determine the nature of essential predication within that category.
The simplest way of getting the right structure is to use some type of tags to differentiate individuals within a category, using the same collection of tags in each category (with the unintended effect of ensuring that each category has the same number of individuals, which I hope will have a significant effect on the resulting theory).
The individuals are then represented by an ordered pair consisting of a category and a tag.

For most purposes the number of categories is not important, though we must have a category of substances, so a completely undifferentiated new type might have sufficed.
However, it turns out that some things don't work, and its useful to have at least one non-substantial category in order to prove that they don't work.
So I introduce a new type of non-substantial (attribute) categories (so we get at least one) and then make the type of categories by adding one more.

=SML
new_type ("ACAT", 0);
new_type ("TAG", 0);
=TEX

=SML
declare_type_abbrev("CAT", [], ”ONE+ACAT®);
=TEX

One of the categories will be the category of substance, it doesn't matter which one but we might as well use the odd One on the left of the sum (so you can test for substance using {\it IsL}).

¹HOLCONST
Ü ÛCategory_of_SubstanceÝ : CAT
÷üüüüüü
Ü Category_of_Substance = InL One
°

An individual will therefore be modelled as an ordered pair consisting of a tag and a category.
This is captured by the following type abbreviation.

=SML
declare_type_abbrev ("I", [], ”CAT ¸ TAG®);
=TEX

A possible world is then an assignment of extensions to individual attributes, where an extension is a set of particulars.
Since we only want individual attributes, we do not use type {\it I} for the domain.
Particulars always belong to the category of substance, so we only need a set of tags in the result, the category is implicit.

=SML
declare_type_abbrev ("W", [], ”ACAT ¸ TAG ­ TAG SET®);
=TEX

This does include an assignement of extensions to particulars, but this plays no role, only intefering with the identity criteria for possible worlds, which do not feature in the theory.

I need to distinguish one possible world which is the actual world:

¹HOLCONST
Ü Ûactual_worldÝ : W
÷üüüüüü
Ü T
°

Since the individuals are pairs it might be handy to have appropriately named projection funtions which extract the two components:

¹HOLCONST
Ü ÛcategoryÝ : I ­ CAT;
Ü ÛtagÝ : I ­ TAG
÷üüüüüü
Ü µct·	category ct = Fst ct
Ü   ±	tag ct = Snd ct 
°

Finally the question of what subjects and predicates are can be determined.
I will call them {\it TERM}s and they are either a set of particulars or a set of attributes.
To allow for complementation I add a boolean component, which if true indicates a complement.

The sets in this case must be non-empty if we are to retain the u-p syllogisms (in default of a different universal).
The method used in my model of the modal syllogism in Section \ref{MODSYLL} will not do here, because (at least according to Code) we need an extensionality result, so I have instead introduced
\footnote{The definition has been placed in a separte document, \cite{rbjt006}.}
 for this purpose a new type ({\it NESET}) of non-empty sets which will give us both the u-p syllogisms and extensionality (for essential predication, not for accidental predication).

A term is therefore modelled as either a non-empty set of individual substances or a non-empty set of individual attributes.

=SML
declare_type_abbrev (Û"TERM"Ý, [], ”(CAT ¸ TAG NESET)®);
=TEX

¹HOLCONST
Ü Ûmk_SubsTermÝ : TAG ð ­ TERM
÷üüüüüü
Ü µs· mk_SubsTerm s = (Category_of_Substance, NeSet s)
°

¹HOLCONST
Ü Ûmk_AttrTermÝ : CAT ¸ TAG ð ­ TERM
÷üüüüüü
Ü µs· mk_AttrTerm s = (Fst s, NeSet (Snd s))
°

It may be useful to have a name for the predicate encompassing all substance.

¹HOLCONST
Ü ÛSubstanceÝ : TERM
÷üüüüüü
Ü Substance = mk_SubsTerm Universe
°

\subsection{Predication}

The syllogism comes with four kinds of predication (a, e, i, o), and the metaphysics with three (izz, hazz and izz or hazz).
Combining these would give twelve combinations.

To simplify a bit I will separate out the quantifier but defining {\it All} and {\it Some} appropriately, and provide a postfix negator for izz an hazz.

I will then treat the modal operators as operators over propositions, and introduce the syllogism as a kind of judgement.

The type of the primitive copulas is:

=SML
declare_type_abbrev("COPULA", [], ”I ­ TERM ­ (W ­ BOOL)®);
=TEX

The first parameter is an individual substance or attribute rather than a TERM, the quantifying operator will arrange for each of the relevant individuals or attributes to be supplied.

\paragraph{Propositions}

=SML
declare_type_abbrev ("MPROP", [], ”W ­ BOOL®);
=TEX

\paragraph{Complementation}

The distinction between affirmative and negative is achieved by a postfix negation so we can say ``izz not'', ``hazz not'' or ``are not''.

=SML
declare_postfix (100, "not");
=TEX

¹HOLCONST
Ü $ÛnotÝ : COPULA ­ COPULA
÷üüüüüü
Ü µpred· pred not = Ìpa t w· ³ pred pa t w 
°

\paragraph{Quantifiers}

The following function is used by both quantifiers to check if something is in the range of quantification.

Think of a TERM as denoting a set of individuals, this is a test for membership of that set.
The complications are because substances and attributes have different types in this model.

=SML
declare_infix(300, "InTERM");
=TEX

¹HOLCONST
Ü $ÛInTERMÝ : I ­ TERM ­ BOOL
÷üüüüüü
Ü µ c1t c2ts · c1t InTERM c2ts ¤ Fst c1t = Fst c2ts ± Snd c1t  PeSet (Snd c2ts)
°

=GFT
interm_¶_lemma =
	ô µ t· ¶ i· i InTERM t
=TEX

\ignore{
=SML
set_goal([], ¬µt· ¶i· i InTERM t®);
a (strip_tac);
a (¶_tac ¬(Fst t, MemOf (Snd t))® THEN rewrite_tac[get_spec ¬$InTERM®]);
val interm_¶_lemma = save_pop_thm "interm_¶_lemma";
=TEX
}%ignore

We then use that membership test in defining the quantifiers.
The quantifiers expect to be supplied with a copula and a term.
The quantifier then predicates using the copula the term of everything or something in the domain of quantification (which is the subject term).
The copulas are defined below.

=IGN
declare_prefix(400, "All");
declare_prefix(400, "Some");
=TEX

¹HOLCONST
Ü ÛAllÝ : TERM ­ (I ­ TERM ­ MPROP) ­ TERM ­ MPROP
÷üüüüüü
Ü µ s r p· All s r p = Ìw· µz· z InTERM s ´ r z p w
°

¹HOLCONST
Ü ÛSomeÝ : TERM ­ (I ­ TERM ­ MPROP) ­ TERM ­ MPROP
÷üüüüüü
Ü µ s r p· Some s r p = Ìw· ¶z· z InTERM s ± r z p w
°

\paragraph{Predicators}

For essential predication it is necessary that the individual and the predicate are both of the same category and then reduces under our model to set membership.
In effect. since the non-substantial individuals are tagged with their category, we need only deal separately with the distinction between substantial and non-substantial and the set inclusion will ensure a match in the non-substantial categories.

¹HOLCONST
Ü ÛizzÝ : I ­ TERM ­ MPROP
÷üüüüüü
Ü µ i t· izz i t = Ìw· i InTERM t
°

For accidental predication the subject term must be substantial and the predicate may not be.
We then need some member of the predicate to be attributable to the substance.

¹HOLCONST
Ü ÛhazzÝ : I ­ TERM ­ MPROP
÷üüüüüü
Ü µ c1t c2ts· hazz c1t c2ts = Ìw·
Ü	Fst c1t = Category_of_Substance
Ü ± 	³ Fst c2ts = Category_of_Substance
Ü ±	(¶a· a  PeSet (Snd c2ts) ± (Snd c1t)  w (OutR(Fst c2ts), a))
°

=GFT
not_izz_and_hazz_lemma1 =
	ô µ pa t w· ³ (izz pa t w ± hazz pa t w)
=TEX

\ignore{
=SML
set_goal([], ¬µpa t w· ³ (izz pa t w ± hazz pa t w)®);
a (rewrite_tac [get_spec ¬$izz®, get_spec ¬$hazz®, get_spec ¬$InTERM®]);
a (contr_tac);
a (DROP_NTH_ASM_T 4 ante_tac THEN asm_rewrite_tac[]);
val not_izz_and_hazz_lemma1 = save_pop_thm "not_izz_and_hazz_lemma1";
=TEX
}%ignore

¹HOLCONST
Ü ÛareÝ : I ­ TERM ­ MPROP
÷üüüüüü
Ü µ pa t· are pa t = Ìw· izz pa t w ² hazz pa t w	
°

=GFT
Ûare_izz_neq_hazz_lemmaÝ =
	ô µ pa t w· are pa t w ¤ ³ (izz pa t w ¤ hazz pa t w)

ÛAll_are_izz_or_hazz_lemmaÝ =
	ô µ A B w· All A are B w ¤ All A izz B w ² All A hazz B w

ÛSome_are_izz_or_hazz_lemmaÝ =
	ô µ A B w· Some A are B w ¤ Some A izz B w ² Some A hazz B w

ÛAll_are_not_lemmaÝ =
	ô µ A B w · All A (are not) B w ¤ All A (izz not) B w ± All A (hazz not) B w
=TEX

\ignore{
=SML
set_goal([], ¬µpa t w· are pa t w ¤ ³ (izz pa t w ¤ hazz pa t w)®);
a (rewrite_tac [get_spec ¬$are®]);
a (REPEAT µ_tac);
a (cond_cases_tac ¬izz pa t w® THEN contr_tac);
a (asm_tac not_izz_and_hazz_lemma1 THEN asm_fc_tac[]);
val are_izz_neq_hazz_lemma = save_pop_thm "are_izz_neq_hazz_lemma";
=TEX
}%ignore

\ignore{
=SML
set_goal([], ¬µA B w · (All A are B) w ¤ (All A izz B w ² (All A hazz B) w)®);
a (REPEAT µ_tac);
a (rewrite_tac [get_spec ¬are®, get_spec ¬All®, get_spec ¬$InTERM®, ext_thm]);
a (contr_tac THEN_TRY asm_rewrite_tac[] THEN_TRY all_asm_fc_tac[]);
a (POP_ASM_T (strip_asm_tac o (rewrite_rule [get_spec ¬$hazz®])));
a (spec_nth_asm_tac 11 ¬z'®);
a (POP_ASM_T (strip_asm_tac o (rewrite_rule [get_spec ¬$izz®])));
a (POP_ASM_T (strip_asm_tac o (rewrite_rule [get_spec ¬$InTERM®])));
a (lemma_tac ¬Fst B = Fst A® THEN1 SYM_ASMS_T rewrite_tac);
a (lemma_tac ¬Fst B = Category_of_Substance® THEN1 SYM_ASMS_T rewrite_tac);
a (REPEAT_N 9 (POP_ASM_T discard_tac) THEN asm_rewrite_tac[]);
val All_are_izz_or_hazz_lemma = save_pop_thm "All_are_izz_or_hazz_lemma";

set_goal([], ¬µA B w · (Some A are B) w ¤ (Some A izz B w ² (Some A hazz B) w)®);
a (REPEAT µ_tac);
a (rewrite_tac [get_spec ¬are®, get_spec ¬Some®, get_spec ¬$InTERM®, ext_thm]);
a (contr_tac THEN_TRY asm_rewrite_tac[] THEN_TRY all_asm_fc_tac[]);
val Some_are_izz_or_hazz_lemma = save_pop_thm "Some_are_izz_or_hazz_lemma";

set_goal([], ¬µA B w · (All A (are not) B) w ¤ (All A (izz not) B w ± (All A (hazz not) B) w)®);
a (REPEAT µ_tac);
a (rewrite_tac [get_spec ¬are®, get_spec ¬All®, get_spec ¬$InTERM®, get_spec ¬$not®, ext_thm]);
a (contr_tac THEN_TRY asm_rewrite_tac[] THEN_TRY all_asm_fc_tac[]);
val All_are_not_lemma = save_pop_thm "All_are_not_lemma";
=TEX
}%ignore

\paragraph{Modal Operators}

In this model the model operators are operators over propositions.

¹HOLCONST
Ü Û¨Ý : MPROP ­ MPROP
÷üüüüüü
Ü µp· ¨ p = Ìw· ¶w'· p w' 
°

¹HOLCONST
Ü Û©Ý : MPROP ­ MPROP
÷üüüüüü
Ü µp· © p = Ìw· µw'· p w' 
°

\subsection{Propositional Operators}

Though the truth functional propositional operators do not feature in the syllogism it is nevertheless useful to have them in giving a full account of Aristotle's logic and they are therefore here defined.

That these propositional operators are ``truth functional'', in a context in which propositions are not regarded as denoting truth values requires a little explanation perhaps.
Our propositions are families of truth values indexed by possible worlds, i.e. functions from possible worlds to truth values, or in the context of a two valued logic (which Aristotle's seems to be), sets of possible worlds.
In this context the usual truth functional operators can be expressed by mapping the usual operator over the set of possible worlds, i.e. the result in every possible world is the result of applying the truth functional operator to the values of the propositions in that possible world.
These also correspond to the obvious set theoretic operation if the propositions are thought of as sets of possible worlds, i.e. intersetion for conjunction, complementation for negation.

The symbols for the operators are already in use, so we define the operations using decorated variants of the symbols and use an alias to allow the undecorated symbol to be used.


¹HOLCONST
Ü Û³‰aÝ : MPROP ­ MPROP
÷üüüüüü
Ü µp· ³‰a p = Ìw· ³ (p w) 
°

=SML
declare_alias ("³", ¬³‰a®);
=TEX

=SML
declare_infix(220, "±‰a");
=TEX

¹HOLCONST
Ü $Û±‰aÝ : MPROP ­ MPROP ­ MPROP
÷üüüüüü
Ü µp q· (p ±‰a q) = Ìw· (p w) ± (q w) 
°

=SML
declare_alias ("±", ¬$±‰a®);
=TEX

=SML
declare_infix(210, "´‰a");
=TEX

¹HOLCONST
Ü $Û´‰aÝ : MPROP ­ MPROP ­ MPROP
÷üüüüüü
Ü µp q· (p ´‰a q) = Ìw· p w ´ q w 
°

=SML
declare_alias ("´", ¬$´‰a®);
=TEX

=SML
declare_infix(200, "¤‰a");
=TEX

¹HOLCONST
Ü $Û¤‰aÝ : MPROP ­ MPROP ­ MPROP
÷üüüüüü
Ü µp q· (p ¤‰a q) = Ìw· p w ¤ q w 
°

=SML
declare_alias ("¤", ¬$¤‰a®);
=TEX

\subsection{Quantification}

The Grice/Code analysis makes use of quantifiers, particularly existential quantification.
To verify the formulae in this context we therefore need to define modal version of the quantifiers. 

=SML
declare_binder "µ‰a";
=TEX

¹HOLCONST
Ü $Ûµ‰aÝ : (TERM ­ MPROP) ­ MPROP
÷üüüüüü
Ü µmpf· $µ‰a mpf = Ìw· µt· mpf t w
°
=SML
declare_alias ("µ", ¬$µ‰a®);
=TEX

=SML
declare_binder "¶‰a";
=TEX

¹HOLCONST
Ü $Û¶‰aÝ : (TERM ­ MPROP) ­ MPROP
÷üüüüüü
Ü µmpf· $¶‰a mpf = Ìw· ¶t· mpf t w
°
=SML
declare_alias ("¶", ¬$¶‰a®);
=TEX

\subsection{Judgements}

I'm not yet clear what to offer here, so for the present I will define two kinds of sequent, which will be displayed with the symbols $˜$ asnd $$. the former being a kind of contingent material implication and the latter a necessary implication.

Both form of judgement seem suitable for expressing the rules of the syllogism at first glance but which can also be used for conversions.

The first expresses a contingent entailment, that if some arbitrary finite (possibly empty) collection of premises are contingently true, then some conclusion will also be true.
Since the consequence is material, and the premisses might be contingent, the conclusion might also be contingent.
One might hope that if the rules of the syllogism are applied and the premises are necessary, then so will be the conclusions. 

=SML
declare_infix(100, "˜");
=TEX

¹HOLCONST
Ü $Û˜Ý : MPROP LIST ­ MPROP ­ BOOL
÷üüüüüü
Ü µlp c· lp ˜ c ¤ Fold (Ìp t· p actual_world ± t) lp T ´ c actual_world
°

This one says that in every possible world the premises entail the conclusion (still material).

=SML
declare_infix(100, "");
=TEX

¹HOLCONST
Ü $ÛÝ : MPROP LIST ­ MPROP ­ BOOL
÷üüüüüü
Ü µlp c· lp  c ¤ µw· Fold (Ìp t· p w ± t) lp T ´ c w
°

In the present context the choice between the two is probably immaterial, since we know no more about the actual world than any other, so anything that we can prove to be true contingently, we can also prove to be true necessarily.

\subsection{Conversions}

\paragraph{Premisses, their Modes and Conversions}

See: \href{http://texts.rbjones.com/rbjpub/philos/classics/aristotl/o3102c.htm#2}{Prior Analytics Book 1 Part 2 Paragraph 2}.

\begin{quote}
First then take a universal negative with the terms A and B.

If no B is A, neither can any A be B. For if some A (say C) were B, it would not be true that no B is A; for C is a B.

But if every B is A then some A is B. For if no A were B, then no B could be A. But we assumed that every B is A.

Similarly too, if the premiss is particular. For if some B is A, then some of the As must be B. For if none were, then no B would be A. But if some B is not A, there is no necessity that some of the As should not be B; e.g. let B stand for animal and A for man. Not every animal is a man; but every man is an animal.
\end{quote}

These work out fine for {\it izz}, so I will do those first, and then show that they fail for {\it hazz} and {\it is}.

The first and third conversions are most useful when expressed as an equation, since our proof system is based primarily on rewriting using equations.

=GFT
Ûizz_not_lemmaÝ =
	ô All B (izz not) A = All A (izz not) B
Ûsome_izz_lemmaÝ =
	ô Some B izz A = Some A izz B
=TEX

These we also supply as our Aristotelian judgements, together with the second which does not give an equation.
The second conversion embodies the u-p syllogisms.

=GFT
Ûizz_conv1Ý = ô
	[All B (izz not) A]  All A (izz not) B

Ûizz_conv2Ý = ô
	[All B izz A]  Some A izz B

Ûizz_conv3Ý = ô
	[Some B izz A]  Some A izz B
=TEX

\ignore{
=SML
set_goal([], ¬All B (izz not) A = All A (izz not) B®);
a (rewrite_tac [ext_thm]);
a (strip_tac THEN rewrite_tac [get_spec ¬All®]);
a (contr_tac);
(* *** Goal "1" *** *)
a (POP_ASM_T (strip_asm_tac o (rewrite_rule (map get_spec [¬izz®, ¬$not®]))));
a (asm_fc_tac[]);
a (POP_ASM_T (strip_asm_tac o (rewrite_rule (map get_spec [¬izz®, ¬$not®]))));
val izz_not_lemma = save_pop_thm "izz_not_lemma";

set_goal([], ¬Some B izz A = Some A izz B®);
a (rewrite_tac [ext_thm]);
a (strip_tac THEN rewrite_tac (map get_spec [¬Some®, ¬izz®]));
a (contr_tac);
a (spec_nth_asm_tac 1 ¬z®);
val some_izz_lemma = save_pop_thm "some_izz_lemma";

set_goal([], ¬[All B (izz not) A]  All A (izz not) B®);
a (rewrite_tac (map get_spec [¬$®, ¬$¤‰a®]));
a (strip_tac THEN rewrite_tac [get_spec ¬Fold®, get_spec ¬All®, izz_not_lemma]);
val izz_conv1 = save_pop_thm "izz_conv1";

set_goal([], ¬[All B izz A]   Some A izz B®);
a (rewrite_tac (map get_spec [¬$®]));
a (strip_tac THEN rewrite_tac [get_spec ¬Fold®, get_spec ¬All®, get_spec ¬Some®, get_spec ¬izz®, get_spec ¬$InTERM®]);
a (REPEAT strip_tac);
a (¶_tac ¬(Fst B, MemOf (Snd B))® THEN asm_rewrite_tac[]);
a (SPEC_NTH_ASM_T 1 ¬(Fst B, MemOf (Snd B))® (rewrite_thm_tac o (rewrite_rule[])));
val izz_conv2 = save_pop_thm "izz_conv2";

set_goal([], ¬[Some B izz A]   Some A izz B®);
a (rewrite_tac (map get_spec [¬$®]));
a (strip_tac THEN rewrite_tac [get_spec ¬Fold®, get_spec ¬Some®, get_spec ¬izz®, get_spec ¬$InTERM®]);
a (REPEAT strip_tac);
a (¶_tac ¬z® THEN asm_rewrite_tac[]);
a (SYM_ASMS_T rewrite_tac);
val izz_conv3 = save_pop_thm "izz_conv3";
=TEX
}%ignore

Now we look at {\it hazz}.

The following theorems state that the two equational conversions are both false for {\it hazz}.

=GFT
Ûnot_hazz_not_lemmaÝ =
	ô ³ (µ A B· All B (hazz not) A = All A (hazz not) B)

Ûnot_some_hazz_lemmaÝ =
	ô ³ (µ A B· Some B hazz A = Some A hazz B)
=TEX

Aristotle's second conversion also fails for {\it hazz}, because in incorporates an application of the third in effect.
If we simplify by removing the final flip we get:

=GFT
Ûhazz_conv2Ý =
	ô [All A hazz B]  Some A hazz B
=TEX

\ignore{
=SML
set_goal([], ¬³ µA B· All B (hazz not) A = All A (hazz not) B®);
a (strip_tac);
a (¶_tac ¬(Category_of_Substance, Ås:TAG NESET·T)® THEN strip_tac);
a (¶_tac ¬(InR (Ås:ACAT·T), Ås:TAG NESET·T)®);
a (rewrite_tac [ext_thm, get_spec ¬All®, get_spec ¬hazz®, get_spec ¬$not®, get_spec ¬$InTERM®]);
a (REPEAT strip_tac THEN_TRY asm_rewrite_tac[]);
a (¶_tac ¬Ìw:ACAT¸TAG· Universe® THEN rewrite_tac [] THEN REPEAT strip_tac THEN_TRY asm_rewrite_tac[]);
a (¶_tac ¬(Category_of_Substance, MemOf(Å s· T))® THEN rewrite_tac [] THEN REPEAT strip_tac THEN_TRY asm_rewrite_tac[]);
a (rewrite_tac [get_spec ¬Category_of_Substance®]);
val not_hazz_not_lemma = save_pop_thm "not_hazz_not_lemma";

set_goal([], ¬³ µA B· Some B hazz A = Some A hazz B®);
a (strip_tac);
a (¶_tac ¬(Category_of_Substance, Ås:TAG NESET·T)® THEN strip_tac);
a (¶_tac ¬(InR (Ås:ACAT·T), Ås:TAG NESET·T)®);
a (rewrite_tac [ext_thm, get_spec ¬Some®, get_spec ¬hazz®, get_spec ¬$InTERM®]);
a (REPEAT strip_tac THEN_TRY asm_rewrite_tac[]);
a (¶_tac ¬Ìw:ACAT¸TAG· Universe® THEN rewrite_tac [] THEN REPEAT strip_tac THEN_TRY asm_rewrite_tac[]);
a (¶_tac ¬(Category_of_Substance, MemOf(Å s· T))® THEN rewrite_tac [] THEN REPEAT strip_tac THEN_TRY asm_rewrite_tac[]);
a (rewrite_tac [get_spec ¬Category_of_Substance®]);
val not_some_hazz_lemma = save_pop_thm "not_some_hazz_lemma";

set_goal([], ¬[All A hazz B]   Some A hazz B®);
a (rewrite_tac (map get_spec [¬$®]));
a (strip_tac THEN rewrite_tac [get_spec ¬Fold®, get_spec ¬All®, get_spec ¬Some®, get_spec ¬hazz®, get_spec ¬$InTERM®]);
a (REPEAT strip_tac);
a (¶_tac ¬(Fst A, MemOf (Snd A))® THEN asm_rewrite_tac[]);
a (SPEC_NTH_ASM_T 1 ¬(Fst A, MemOf (Snd A))® (rewrite_thm_tac o (rewrite_rule[])));
val hazz_conv2 = save_pop_thm "hazz_conv2";
=TEX
}%ignore

Since {\it is} is the conjunction of {\it izz} and {\it hazz} it is likely that it would yeild similar results to {\it hazz}.

\subsection{Modal Conversions}

\paragraph{Prior Analytics Book 1 Part 3}

See: \href{http://texts.rbjones.com/rbjpub/philos/classics/aristotl/o3103c.htm}{Universal and Possible Premisses and their Conversions}.

These are the conversions in relation to necessity and possibility described by Aristotle:

\begin{enumerate}
\item If it is necessary that no B is A, it is necessary also that no A is B.
\item If all or some B is A of necessity, it is necessary also that some A is B.
\item If it is possible that all or some B is A, it will be possible that some A is B.
\item and so on
\end{enumerate}

So in this section Aristotle only offers variants of the previous conversions with either ``possible'' or ``necessary'' attached to both premiss and conclusion.

We can prove generally that modal operators can be introduced into a conversion:

=GFT
Û¨_convÝ =
	ô [P]  Q ´ [¨ P]  ¨ Q

Û©_convÝ =
	ô [P]  Q ´ [© P]  © Q
=TEX

\ignore{
=SML
set_goal([], ¬[P]  Q ´ [¨ P]  ¨ Q®);
a (rewrite_tac (map get_spec [¬$®, ¬Fold®, ¬¨®]));
a (REPEAT strip_tac);
a (¶_tac ¬w'® THEN asm_fc_tac[]);
val ¨_conv = save_pop_thm "¨_conv";

set_goal([], ¬[P]  Q ´ [© P]  © Q®);
a (rewrite_tac (map get_spec [¬$®, ¬Fold®, ¬©®]));
a (REPEAT strip_tac);
a (asm_ufc_tac[] THEN asm_rewrite_tac[]);
val ©_conv = save_pop_thm "©_conv";
=TEX
}%ignore

=GFT
Û©_izz_thmÝ = ô [© (All A izz B)] ˜ All A izz B
Û©_hazz_thmÝ = ô [© (All A hazz B)] ˜ All A izz B
Ûizz_©_thmÝ = ô [All A izz B] ˜ © (All A izz B)
Ûnot_©_hazz_thmÝ = ô [] ˜ (³ © (All A hazz B))

Û©_izz_thm2Ý = ô [© (All A izz B)]  All A izz B
Û©_hazz_thm2Ý = ô [© (All A hazz B)]  All A izz B
Ûizz_©_thm2Ý = ô [All A izz B]  © (All A izz B)
Ûnot_©_hazz_thm2Ý = ô []  (³ © (All A hazz B))
=TEX

$©\_hazz\_thm$ is a bit odd.
Really what I wanted to prove was that no accidental predication is necessary, but I have no negation in the syllogism, so I just proved that if an accidental predication were necessary then it would be essential.
Then I went back and defined negation so permitting a direct denial that any accidental predication is necessary.

There are many theorems which one would naturally prove at this point, to facilitate further proofs and proof automation, which are not expressible syllogistically.
Proof automation depends heavily on the demonstration of equations, so that proof may proceed by rewriting.
But syllogisms are not suitable for this.

The natural way to proceed in such a case is to continue in this theory doing things which support proofs of syllogisms without being restrained to syllogisms, and then to have a separate theory in which the syllogistic claims are presented.
Some reflection is desirable on what the philosophical objectives are and what course will best contribute to those purposes.

\ignore{
=SML
set_goal([], ¬[© (All A izz B)] ˜ All A izz B®);
a (rewrite_tac  (map get_spec [¬$˜®, ¬Fold®, ¬©®, ¬All®, ¬izz®])
	THEN REPEAT strip_tac);
val ©_izz_thm = save_pop_thm "©_izz_thm";

set_goal([], ¬[© (All A hazz B)] ˜ All A izz B®);
a (rewrite_tac  (map get_spec [¬$˜®, ¬Fold®])
	THEN REPEAT strip_tac);
a (swap_nth_asm_concl_tac 1);
a (rewrite_tac (map get_spec [¬©®, ¬All®, ¬hazz®])
	THEN strip_tac);
a (¶_tac ¬Ìw· {}® THEN rewrite_tac[get_spec ¬$InTERM®] THEN strip_tac);
a (lemma_tac ¬¶d· d  PeSet (Snd A)® THEN1 rewrite_tac[]);
a (¶_tac ¬(Fst A, d)® THEN asm_rewrite_tac[]);
val ©_hazz_thm = save_pop_thm "©_hazz_thm";

set_goal([], ¬[All A izz B] ˜ © (All  A izz B)®);
a (rewrite_tac  (map get_spec [¬$˜®, ¬Fold®, ¬©®, ¬All®, ¬izz®])
	THEN REPEAT strip_tac);
val izz_©_thm = save_pop_thm "izz_©_thm";

set_goal([], ¬[] ˜ ³ © (All A hazz B)®);
a (rewrite_tac  (map get_spec [¬$˜®, ¬Fold®, ¬©®, ¬All®, ¬izz®, ¬$³‰a®, ¬hazz®]));
a (REPEAT strip_tac);
a (¶_tac ¬Ìw· {}® THEN rewrite_tac[get_spec ¬$InTERM®] THEN strip_tac);
a (¶_tac ¬(Fst A, MemOf(Snd A))® THEN rewrite_tac[]);
val not_©_hazz_thm = save_pop_thm "not_©_hazz_thm";

set_goal([], ¬[© (All A izz B)]  All A izz B®);
a (rewrite_tac  (map get_spec [¬$®, ¬Fold®, ¬©®, ¬All®, ¬izz®])
	THEN REPEAT strip_tac);
val ©_izz_thm2 = save_pop_thm "©_izz_thm2";

set_goal([], ¬[© (All A hazz B)]  All A izz B®);
a (rewrite_tac  (map get_spec [¬$®, ¬Fold®])
	THEN REPEAT strip_tac);
a (swap_nth_asm_concl_tac 1);
a (rewrite_tac (map get_spec [¬©®, ¬All®, ¬hazz®])
	THEN strip_tac);
a (¶_tac ¬Ìw· {}® THEN rewrite_tac[get_spec ¬$InTERM®] THEN strip_tac);
a (lemma_tac ¬¶d· d  PeSet (Snd A)® THEN1 rewrite_tac[]);
a (¶_tac ¬(Fst A, d)® THEN asm_rewrite_tac[]);
val ©_hazz_thm2 = save_pop_thm "©_hazz_thm2";

set_goal([], ¬[All A izz B]  © (All  A izz B)®);
a (rewrite_tac  (map get_spec [¬$®, ¬Fold®, ¬©®, ¬All®, ¬izz®])
	THEN REPEAT strip_tac);
val izz_©_thm2 = save_pop_thm "izz_©_thm2";

set_goal([], ¬[]  ³ © (All A hazz B)®);
a (rewrite_tac  (map get_spec [¬$®, ¬Fold®, ¬©®, ¬All®, ¬izz®, ¬$³‰a®, ¬hazz®]));
a (REPEAT strip_tac);
a (¶_tac ¬Ìw· {}® THEN rewrite_tac[get_spec ¬$InTERM®] THEN strip_tac);
a (¶_tac ¬(Fst A, MemOf(Snd A))® THEN rewrite_tac[]);
val not_©_hazz_thm2 = save_pop_thm "not_©_hazz_thm2";
=TEX
}%ignore

Here are some general modal results which I have not noticed in Aristotle as yet.

=GFT
Û©_elim_thmÝ =
	ô [© P] ˜ P
Û¨_intro_thmÝ =
	ô [P] ˜ ¨ P
Û©_¨_thmÝ =
	ô [© P] ˜ ¨ P
=TEX

\ignore{
=SML
set_goal([], ¬[© P] ˜ P®);
a (rewrite_tac (map get_spec [¬$˜®, ¬Fold®, ¬$©®]) THEN REPEAT strip_tac THEN asm_rewrite_tac[]);
val ©_elim_thm = save_pop_thm "©_elim_thm";

set_goal([], ¬[P] ˜ ¨ P®);
a (rewrite_tac (map get_spec [¬$˜®, ¬Fold®, ¬$¨®]) THEN contr_tac THEN asm_fc_tac[]);
val ¨_intro_thm = save_pop_thm "©_intro_thm";

set_goal([], ¬[© P] ˜ ¨ P®);
a (rewrite_tac (map get_spec [¬$˜®, ¬Fold®, ¬$©®, ¬$¨®]) THEN REPEAT strip_tac THEN asm_rewrite_tac[]);
val ©_¨_thm = save_pop_thm "©_¨_thm";
=TEX
}%ignore

\subsection{Other Conversions}

The following conversions relate to the square of opposition, but I have not yet discovered where they appear in Aristotle.
They work for all the copulas, so I have used a free variable for the copulas.

=GFT
³_All_conv_thm =
	ô (³ All A cop B) = Some A (cop not) B
³_All_not_conv_thm2 =
	ô (³ All A (cop not) B) = Some A cop B
³_Some_conv_thm =
	ô (³ Some A cop B) = All A (cop not) B
³_Some_not_conv_thm =
	ô (³ Some A (cop not) B) = All A cop B
=TEX

They are contraries out of Aristotles square of opposition

\ignore{
=SML
set_goal([], ¬(³ All A cop B) = Some A (cop not) B®);
a (rewrite_tac (map get_spec [¬All®, ¬Some®, ¬$not®, ¬³‰a®]));
a (rewrite_tac[ext_thm] THEN contr_tac THEN asm_fc_tac[]);
val ³_All_conv_thm = save_pop_thm "³_All_conv_thm";

set_goal([], ¬(³ All A (cop not) B) = Some A cop B®);
a (rewrite_tac (map get_spec [¬All®, ¬Some®, ¬$not®, ¬³‰a®]));
a (rewrite_tac[ext_thm] THEN contr_tac THEN asm_fc_tac[]);
val ³_All_not_conv_thm2 = save_pop_thm "³_All_not_conv_thm2";

set_goal([], ¬(³ Some A cop B) = All A (cop not) B®);
a (rewrite_tac (map get_spec [¬All®, ¬Some®, ¬$not®, ¬³‰a®]));
a (rewrite_tac[ext_thm] THEN contr_tac THEN asm_fc_tac[]);
val ³_Some_conv_thm = save_pop_thm "³_Some_conv_thm";

set_goal([], ¬(³ Some A (cop not) B) = All A cop B®);
a (rewrite_tac (map get_spec [¬All®, ¬Some®, ¬$not®, ¬³‰a®]));
a (rewrite_tac[ext_thm] THEN contr_tac THEN asm_fc_tac[]);
val ³_Some_not_conv_thm = save_pop_thm "³_Some_not_conv_thm";
=TEX
}%ignore

Normally theorems like this would be proved closed, but it looks more Aristotelian without the quantifiers and we can imagine that they are schemata.
To use them it will usually be desirable to close them, which is easily done, e.g.:

=SML
all_µ_intro ³_Some_not_conv_thm;
=TEX

=GFT ProofPower output
val it = ô µ A cop B· (³ Some A (cop not) B) = All A cop B : THM
=TEX

\subsection{Syllogisms for Essential Predication}

Though the usual syllogisms are not valid for predication in general, the problems are confined to accidental predication.
We can, by methods similar to those used above obtain automatic proofs of the 24 valid syllogisms restricted to essential predication.

The details are omitted, but the 24 izz syllogisms have been proven and stored in the theory, see: \thyref{syllmetap}.

\ignore{
=SML
fun 	Ûopfun_from_charÝ cop "a" s p = ¬All ‘s® ‘cop® ‘p®®
|	opfun_from_char cop "e" s p = ¬All ‘s® (‘cop® not) ‘p®®
|	opfun_from_char cop "i" s p = ¬Some ‘s® ‘cop® ‘p®®
|	opfun_from_char cop "o" s p = ¬Some ‘s® (‘cop® not) ‘p®®;

fun Ûopfuntrip_from_textÝ cop s =
	let val [a, b, c] = (map (opfun_from_char cop) o vowels_from_string) s;
	in (a, b, c)
	end;

fun Ûopfuntrip_from_text_ccÝ (cop1,cop2) s =
	let val [v1, v2, v3] = vowels_from_string s;
	    val [a, b, c] = [opfun_from_char cop1 v1, opfun_from_char cop2 v2, opfun_from_char ¬hazz® v3];
	in (a, b, c)
	end;
=TEX

The following functions construct a syllogism.

=SML
fun Ûmk_izz_syllÝ vt (a, b, c, d) (f1, f2, f3) =
	¬[‘f1 a b®; ‘f2 c d®] 
		‘f3 (mk_var("¿", vt)) (mk_var("P", vt))®®;

fun Ûmk_cop_syllpÝ cop (s, n) =
	([], mk_izz_syll ”TERM® (nth (n-1) (figures ”TERM®)) (opfuntrip_from_text cop s));

fun Ûmk_cop_syllp_ccÝ cc (s, n) =
	([], mk_izz_syll ”TERM® (nth (n-1) (figures ”TERM®)) (opfuntrip_from_text_cc cc s));

fun Ûmk_izz_syllpÝ (s, n) = mk_cop_syllp ¬izz® (s, n);

fun Ûmk_izzhazz_syllpÝ (s, n) = mk_cop_syllp_cc (¬izz®, ¬hazz®) (s, n);
fun Ûmk_hazzizz_syllpÝ (s, n) = mk_cop_syllp_cc (¬hazz®, ¬izz®) (s, n);

val Ûsyll_izz_tac2Ý =
	(MAP_EVERY (fn x => strip_asm_tac (µ_elim x interm_¶_lemma))
		[¬M:TERM®, ¬P:TERM®, ¬¿:TERM®, ¬A:TERM®, ¬B:TERM®])
	THEN asm_prove_tac (map get_spec [¬$®, ¬All®, ¬Some®, ¬izz®, ¬$not®, ¬Fold®]);

val Ûsyll_izzhazz_tacÝ =
	(MAP_EVERY (fn x => strip_asm_tac (µ_elim x interm_¶_lemma))
		[¬M:TERM®, ¬P:TERM®, ¬¿:TERM®, ¬A:TERM®, ¬B:TERM®])
	THEN rewrite_tac (map get_spec [¬$®, ¬All®, ¬Some®, ¬izz®, ¬hazz®, ¬$not®, ¬Fold®])
	THEN contr_tac;

val Ûsyll_izzhazz_tac2Ý = 	syll_izzhazz_tac
	THEN (REPEAT_N 3 (asm_fc_tac[]));

fun Ûsyll_izz_rule2Ý g = tac_proof(g, syll_izz_tac2);

fun Ûsyll_izzhazz_rule2Ý g = tac_proof(g, syll_izzhazz_tac2);

val Ûsps_izz1Ý = syll_prove_and_store mk_izz_syllp "_izz";
val Ûsps_izzhazz1Ý = syll_prove_and_store mk_izzhazz_syllp "_ih";
val Ûsps_hazzizz1Ý = syll_prove_and_store mk_hazzizz_syllp "_hi";

val Ûvalid_izz_syllsÝ = map (sps_izz1 syll_izz_tac2)
	(syllogism_data1 @ syllogism_data2 @ syllogism_data3);
=IGN
(*
val Ûvalid_izzhazz_syllsÝ = map (sps_izzhazz1 syll_izzhazz_tac2)
	(syllogism_data1 @ syllogism_data2 @ syllogism_data3);
*)
val Ûvalid_hazzizz_syllsÝ = map (sps_hazzizz1 syll_izzhazz_tac2)
	(syllogism_data1 @ syllogism_data2 @ syllogism_data3);

set_goal(mk_izzhazz_syllp ("Barbara", 1));
a syll_izzhazz_tac;
(* *** Goal "1" *** *)
a (asm_fc_tac[]);
(* *** Goal "2" *** *)
a (asm_fc_tac[]);
a (DROP_NTH_ASM_T 12 (strip_asm_tac o (rewrite_rule [get_spec ¬$InTERM®])));


a (contr_tac THEN REPEAT_N 3 (asm_fc_tac[]));

=TEX

}%ignore

\subsection{Some Accidental Syllogisms}

\ignore{
=SML
=TEX
}%ignore

=GFT
=TEX

\subsection{Grice and Code}

I now review the Grice/Code analysis under the revised interpretation of {\it izz} and {\it hazz}.

On my first attempt I did not notice till rather late that the material covered both Aristotle's and Plato's metaphysics, which are not wholly compatible.
To do this using only conservative extension we have to use a different context for the parts of the treatment which might be incompatible.
Three new theories will therefore be introduced, respectively covering:

\begin{itemize}
\item[gccom] material common to Aristotle and Plato
\item[gcaris] material specific to Aristotle
\item[gcplato] material specific to Plato
\end{itemize}

All three theories are in the context of theory {\it syllmetap} which is an integrated model of both the modal syllogism and the metaphysics, incorporating the u-p syllogisms, which makes slightly more sense in the context of the metaphysics than otherwise.

\subsubsection{Common Material}

=SML
force_new_theory "gccon";
=TEX

The following results are now provable:

=GFT
ÛFP1Ý =	ô []  All A izz A 
ÛFP2Ý =	ô [All A izz B; All B izz C]  All A izz C
ÛFP3Ý =	ô [All A hazz B]  ³ (All A izz B)
ÛFP4aÝ =	ô [All A hazz B; All B izz C]  All A hazz C
ÛFP4Ý =	ô []  All A hazz B ¤ (¶‰a C· All A hazz C ± All C izz B)
=TEX

These are not very Aristotelian.
It would seem more Aristotelian to have:

=GFT
ÛFP3bÝ =
	ô [All A hazz B]  Some A (izz not) B
=TEX

\ignore{
=SML
set_goal([], ¬[]  All A izz A®);
a (syll_izz_tac2);
val FP1 = save_pop_thm "FP1";

set_goal([], ¬[All A izz B; All B izz C]  All A izz C®);
a (syll_izz_tac2);
val FP2 = save_pop_thm "FP2";

val Ûsyll_hizz_tacÝ =
	(MAP_EVERY (fn x => strip_asm_tac (µ_elim x interm_¶_lemma))
		[¬M:TERM®, ¬P:TERM®, ¬¿:TERM®, ¬A:TERM®, ¬B:TERM®])
	THEN asm_prove_tac (map get_spec [¬$®, ¬All®, ¬Some®, ¬izz®, ¬hazz®, ¬$not®, ¬$³‰a®, ¬Fold®]);


set_goal([], ¬[All A hazz B]  ³ All A izz B®);
a (syll_hizz_tac);
a (asm_fc_tac[]);
a (¶_tac ¬i'''® THEN asm_rewrite_tac[get_spec ¬$InTERM®]);
a (swap_nth_asm_concl_tac 2 THEN asm_rewrite_tac[]);
val FP3 = save_pop_thm "FP3";

val FP3b = save_thm("FP3b", rewrite_rule [all_µ_intro ³_All_conv_thm] FP3);

set_goal([], ¬[All A hazz B; All B izz C]  All A hazz C®);
a (rewrite_tac (map get_spec [¬$®, ¬Fold®, ¬All®, ¬izz®, ¬hazz®]) THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a (asm_fc_tac[]);
(* *** Goal "2" *** *)
a (DROP_NTH_ASM_T 2 (strip_asm_tac o (rewrite_rule [get_spec ¬$InTERM®])));
a (asm_fc_tac[]);
a (SPEC_NTH_ASM_T 5 ¬(Fst B, a)® (strip_asm_tac o (rewrite_rule[])));
a (swap_nth_asm_concl_tac 4 THEN asm_rewrite_tac[]);
(* *** Goal "3" *** *)
a (DROP_NTH_ASM_T 2 (strip_asm_tac o (rewrite_rule [get_spec ¬$InTERM®])));
a (asm_fc_tac[]);
a (SPEC_NTH_ASM_T 5 ¬(Fst B, a)® (strip_asm_tac o (rewrite_rule[])));
a (¶_tac ¬a® THEN (SYM_ASMS_T rewrite_tac));
val FP4a = save_pop_thm "FP4a";


set_goal([], ¬[]  (All A hazz B ¤ ¶ C· (All A hazz C) ± (All C izz B))®);
a (rewrite_tac (map get_spec [¬$®, ¬Fold®, ¬$¤‰a®, ¬$¶‰a®, ¬$±‰a®]) THEN REPEAT_N 3 strip_tac);
(* *** Goal "1" *** *)
a (strip_tac THEN ¶_tac ¬B® THEN asm_rewrite_tac[all_µ_intro (rewrite_rule (map get_spec [¬$®, ¬Fold®]) FP1)]);
(* *** Goal "2" *** *)
a (rewrite_tac (map get_spec [¬All®, ¬izz®, ¬hazz®]) THEN strip_tac);
a (POP_ASM_T (strip_asm_tac o (rewrite_rule [get_spec ¬$InTERM®])));
a (REPEAT strip_tac);
(* *** Goal "2.1" *** *)
a (asm_fc_tac[]);
(* *** Goal "2.2" *** *)
a (asm_fc_tac[]);
a (SPEC_NTH_ASM_T 6 ¬(Fst t, a)® (strip_asm_tac o (rewrite_rule[])));
a (swap_nth_asm_concl_tac 4 THEN asm_rewrite_tac[]);
(* *** Goal "2.3" *** *)
a (asm_fc_tac[]);
a (SPEC_NTH_ASM_T 6 ¬(Fst t, a)® (strip_asm_tac o (rewrite_rule[])));
a (¶_tac ¬a® THEN (SYM_ASMS_T rewrite_tac));
val FP4 = save_pop_thm "FP4";
=TEX
}%ignore

The above rendition of FP4 may not be true to the intention of Code.
I possibly he might have intended that C be an individual.

To prove that more interesting result I need to define ``individual''.

¹HOLCONST
Ü ÛindividualÝ : TERM ­ BOOL
÷üüüüüü
Ü µA· individual A ¤ ¶a· Snd A = NeSet{a}
°

Since the above is a regular predicate, we need something to convert an ordinary proposition into a modal proposition to use it in the context of modal syllogisms.

¹HOLCONST
Ü ÛMpÝ : BOOL ­ MPROP
÷üüüüüü
Ü µp· Mp p = Ìw· p
°

The revised principle is then:

=GFT
FP4b = ?ô []  (All A hazz B ¤ ¶ C· Mp(individual C) ± (All A hazz C) ± (All C izz B))
=TEX

However, this is false in our model, since there need be no single attribute which is posessed by every substance which izz A.
Consider the claim that all paints have colour.
This may be true even if there is no individual colour which every paint hazz.
However, if this stronger claim is not what Code intended, then what did he mean?
Surely not the theorem I actually proved as FP4, since that is too trivial to be worth mentioning.

If we require A to be an individual we get a result:

=GFT
ÛFP4cÝ =
   ô [Mp (individual A)]
        (All A hazz B
         ¤ (¶ C· Mp (individual C) ± All A hazz C ± All C izz B))
=TEX

\ignore{
=SML
set_goal([], ¬[Mp(individual A)]  (All A hazz B ¤ ¶ C· Mp(individual C) ± (All A hazz C) ± (All C izz B))®);
a (rewrite_tac (map get_spec [¬$®, ¬Fold®, ¬$¤‰a®, ¬$¶‰a®, ¬$±‰a®, ¬Mp®, ¬individual®, ¬hazz®, ¬izz®, ¬All®, ¬$InTERM®]) 
	THEN REPEAT_N 5 strip_tac);
(* *** Goal "1" *** *)
a (SPEC_NTH_ASM_T 1 ¬(Fst A, MemOf (Snd A))® (strip_asm_tac o (rewrite_rule[])));
a (¶_tac ¬(Fst B, NeSet {a'})® THEN asm_rewrite_tac[]);
a (strip_tac);
(* *** Goal "1.1" *** *)
a (¶_tac ¬a'® THEN rewrite_tac[]);
(* *** Goal "1.2" *** *)
a (REPEAT strip_tac);
(* *** Goal "1.2.1" *** *)
a (¶_tac ¬a'® THEN asm_rewrite_tac[]);
a (DROP_NTH_ASM_T 3 ante_tac THEN asm_rewrite_tac[]);
(* *** Goal "1.2.2" *** *)
a (asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a (REPEAT strip_tac THEN_TRY asm_rewrite_tac[]);
(* *** Goal "2.1" *** *)
a (ASM_FC_T (MAP_EVERY ante_tac) [] THEN asm_rewrite_tac[]
	THEN contr_tac);
(* *** Goal "2.2" *** *)
a (asm_fc_tac[]);
a (LEMMA_T ¬Fst(Fst t, a'') = Fst t® asm_tac THEN1 rewrite_tac[]);
a (LEMMA_T ¬Snd(Fst t, a'')  PeSet (Snd t)® asm_tac THEN1 rewrite_tac[asm_rule ¬a''  PeSet (Snd t)®]);
a (spec_nth_asm_tac 9 ¬(Fst t, a'')®);
a (REPEAT_N 2 (POP_ASM_T ante_tac)
	THEN rewrite_tac[]
	THEN strip_tac);
a (strip_tac THEN swap_nth_asm_concl_tac 6 THEN asm_rewrite_tac[]);
(* *** Goal "2.3" *** *)
a (asm_fc_tac[]);
a (LEMMA_T ¬Fst(Fst t, a'') = Fst t® asm_tac THEN1 rewrite_tac[]);
a (LEMMA_T ¬Snd(Fst t, a'')  PeSet (Snd t)® asm_tac THEN1 rewrite_tac[asm_rule ¬a''  PeSet (Snd t)®]);
a (spec_nth_asm_tac 9 ¬(Fst t, a'')®);
a (POP_ASM_T ante_tac THEN POP_ASM_T ante_tac THEN rewrite_tac[] THEN STRIP_T (asm_tac o eq_sym_rule)
	THEN strip_tac);
a (¶_tac ¬a''® THEN asm_rewrite_tac []);
val FP4c = save_pop_thm "FP4c";
=TEX
}%ignore

¹HOLCONST
Ü ÛIndividualÝ : TERM ­ MPROP
÷üüüüüü
Ü µA· Individual A = © µ‰a B· All B izz A ´‰a All A izz B
°

Now on the face of it, in the context of our present model, the modal operator in this definition is irrelevant.
This because all essential predication is necessary.

The following theorem confirms that intuition.

=GFT
individual_lemma1 =
	ô µ A· Individual A = (µ B· All B izz A ´ All A izz B)
=TEX

We can also show that the Code definition is equivalent to our own:

=GFT
individual_lemma2 =
	ô Individual A = Mp (individual A) 
=TEX

In addition to the apparently spurious invocation of necessity, the Code definition depends upon the u-p syllogisms.

Our own primitive definition is couched in terms of the underlying model, and so in terms of that model we would have to regard as a primitive rather than a defined concept (this may be the best way to think of it).


\ignore{
=SML
set_goal ([], ¬µA· Individual A = µ‰a B· All B izz A ´‰a All A izz B®);
a (rewrite_tac [get_spec ¬Individual®, get_spec ¬©®, ext_thm]);
a (REPEAT strip_tac THEN_TRY asm_rewrite_tac[] THEN POP_ASM_T ante_tac);
a (rewrite_tac (map get_spec [¬$´‰a®, ¬$µ‰a®, ¬All®, ¬izz®]));
val individual_lemma1 = save_pop_thm "individual_lemma1";

set_goal ([], ¬Individual A = Mp (individual A)®);
a (rewrite_tac [individual_lemma1]);
a (rewrite_tac (map get_spec [¬Mp ®, ¬individual®, ¬izz®, ¬$InTERM®, ¬$´‰a®, ¬$µ‰a®]));
a (rewrite_tac (map get_spec [¬Mp ®, ¬individual®, ¬All®, ¬izz®, ¬$InTERM®, ¬$´‰a®, ¬$µ‰a®]));
a (rewrite_tac [ext_thm] THEN contr_tac);
(* *** Goal "1" *** *)
a (lemma_tac ¬¶b c· ³ b = c ± b  PeSet(Snd A) ± c  PeSet(Snd A)®
	THEN1 (¶_tac ¬MemOf (Snd A)® THEN rewrite_tac[]));
(* *** Goal "1.1" *** *)
a (spec_nth_asm_tac 1 ¬MemOf (Snd A)®);
a (POP_ASM_T (strip_asm_tac o (rewrite_rule [NeSet_ext_thm])));
(* *** Goal "1.1.1" *** *)
a (¶_tac ¬z® THEN asm_rewrite_tac[]);
a (swap_nth_asm_concl_tac 1 THEN asm_rewrite_tac[]);
(* *** Goal "1.1.2" *** *)
a (POP_ASM_T ante_tac THEN asm_rewrite_tac[]);
(* *** Goal "1.2" *** *)
a (spec_nth_asm_tac 5 ¬(Fst A, NeSet{b})®);
(* *** Goal "1.2.1" *** *)
a (DROP_NTH_ASM_T 3 (strip_asm_tac o (rewrite_rule[])));
(* *** Goal "1.2.2" *** *)
a (DROP_NTH_ASM_T 2 ante_tac THEN rewrite_tac[]);
a (swap_nth_asm_concl_tac 1 THEN asm_rewrite_tac[]);
(* *** Goal "1.2.3" *** *)
a (lemma_tac ¬Fst (Fst A, c) = Fst A® THEN1 rewrite_tac[]);
a (lemma_tac ¬Snd (Fst A, c)  PeSet (Snd A)® THEN1 asm_rewrite_tac[]);
a (spec_nth_asm_tac 3 ¬(Fst A, c)®);
a (POP_ASM_T ante_tac THEN asm_rewrite_tac[]);
a (swap_nth_asm_concl_tac 7 THEN asm_rewrite_tac []);
 (* *** Goal "2" *** *)
a (SPEC_NTH_ASM_T 4 ¬(Fst t, MemOf(Snd t))® (strip_asm_tac o (rewrite_rule[])));
a (DROP_NTH_ASM_T 3 ante_tac THEN asm_rewrite_tac[]);
(* *** Goal "3" *** *)
a (DROP_ASM_T  ¬Snd z  PeSet (Snd A)® ante_tac THEN asm_rewrite_tac[]);
a (swap_nth_asm_concl_tac 1 THEN asm_rewrite_tac []);
a (SPEC_NTH_ASM_T 3 ¬(Fst t, MemOf(Snd t))® (strip_asm_tac o (rewrite_rule[])));
a (POP_ASM_T ante_tac THEN asm_rewrite_tac[]);
a (STRIP_T (rewrite_thm_tac o eq_sym_rule));
val individual_lemma2 = save_pop_thm "individual_lemma2";
=TEX
}%ignore

Now we come to the Code definition of particular:

¹HOLCONST
Ü ÛparticularÝ : TERM ­ MPROP
÷üüüüüü
Ü µA· particular A = © µ‰a B· All B are A ´‰a All A izz B ±‰a All B izz A
°

A particular is an individual substance and one would have thought that a definition closer to saying that directly might have been a good idea.
In this case in our model the modal operator is not redundant, because without it the definiens would be true if A were an individual attribute which contingently has an empty extension (i.e. is true of no substance), which is possible in this model.
However, this cannot be true of necessity unless A is substantial.

Code might have used a similar device to define substantial:

¹HOLCONST
Ü ÛsubstantialÝ : TERM ­ MPROP
÷üüüüüü
Ü µA· substantial A = © µ‰a B· All B are A ´‰a All B izz A
°

and then defined a particular as a substantial individual.
Alternatively substantial might be taken as primitive to avoid the use of a modal operator.
Again, Code's definition relies on the u-p syllogisms.

Code's definition of universal is:

¹HOLCONST
Ü ÛuniversalÝ : TERM ­ MPROP
÷üüüüüü
Ü µA· universal A = ¨ ¶‰a B· All B are A ±‰a ³‰a (All A izz B ±‰a All B izz A)
°

I think the intension is that a universal is anything except a particular, in which case that would be a better way to define it.
However, in this model, this definition will be true of any non-individual, unless the $¬¨®$ is changed to $¬©®$.

\paragraph{Ontological Theorems}

T1-T3 are essentially redundant definitions so I will omit them and not use the additional vocabulary on this pass.


\section{Conclusions}
