=IGN
$Id: t028.doc,v 1.6 2009/06/09 17:44:47 rbj Exp $
=TEX
\documentclass[11pt,a4paper]{article}
\usepackage{latexsym}
\usepackage{ProofPower}
\usepackage{amsfonts}
\ftlinepenalty=9999
\usepackage{A4}

% the following two modal operators come from the amsfonts package
\def\PrKI{\Diamond}	%Modify printing for ¨
\def\PrJI{\models}	%Modify printing for ˜
\def\PrKJ{\Box}		%Modify printing for ©

\def\ExpName{\mbox{{\sf exp}}}
\def\Exp#1{\ExpName(#1)}

=IGN
val _ =
	let open ReaderWriterSupport.PrettyNames;
	in add_new_symbols [ (["identeq"], Value "\233", Simple) ]
end;
=TEX

\tabstop=0.4in
\newcommand{\ignore}[1]{}

\title{Aristotle's Logic and Metaphysics - some formal models}
\makeindex
\usepackage[unicode,pdftex]{hyperref}
\hypersetup{pdfauthor={Roger Bishop Jones}, pdffitwindow=false}
\hypersetup{colorlinks=true, urlcolor=red, citecolor=blue, filecolor=blue, linkcolor=blue}
\author{Roger Bishop Jones}
\date{\ }

\begin{document}
\begin{titlepage}
\maketitle
\begin{abstract}
Formalisation in higher order logic of parts of Aristotle's logic and metaphysics.
\end{abstract}
\vfill

\begin{centering}
{\footnotesize

Created 2009/05/21

Last Change $ $Date: 2009/06/09 17:44:47 $ $

\href{http://www.rbjones.com/rbjpub/pp/doc/t028.pdf}
{http://www.rbjones.com/rbjpub/pp/doc/t028.pdf}

$ $Id: t028.doc,v 1.6 2009/06/09 17:44:47 rbj Exp $ $

\copyright\ Roger Bishop Jones; Licenced under Gnu LGPL

}%footnotesize
\end{centering}

\thispagestyle{empty}
\end{titlepage}

\newpage
\addtocounter{page}{1}
{\parskip=0pt\tableofcontents}

\newpage
\section{INTRODUCTION}

My original purpose in preparing this document was to analyse certain semi-formal statements, relating to the philosophy of Aristotle, which were posted to the \href{http://hist-analytic.org}{\it hist-analytic} mailing list (\href{http://rbjones.com/pipermail/hist-analytic_rbjones.com/2009q2/000258.html}{see message in archive}) originating primarily in joint work by Grice \cite{grice88} and Code \cite{code88}.

This has now been overtaken by various other philosophical motivations.

Of these the most important for me at present lie in the perceived relevance of Aristotle's metaphysics to what I am trying elsewhere to write about {\it Metaphysical Positivism}.
One tentative idea in this exposition involves three comparisons intended to illuminate the tension between essentialism and nominalism and inform the search for a middle ground.
These three are between Plato and Aristotle, between Hume and Kant, and between Carnap and one or more twentieth century metaphysicians.

For this purpose I seek some kind of understanding of Arstotle's essentialism, and it is for me a natural to use formal modelling as one way of realising that understanding.

Since my own backround in formal modelling comes from Computer Science and Information Systems Engineering, my own preferred languages, methods and tools, which I believe can be effectively applied to some kinds of philosophical problems, are probably alien to most if not all philosophers, and it is therefore a secondary purpose of this material to try to make this kind of modelling intelligible to some philosophers.
This is not a presentation of established methods with proven philosophical benefits.
It is an exploration and adaptation of methods from other domains to philosophy, and the benefits, are to be discovered, not merely displayed.

The present state of the document is rather rough and ready.
Formal modelling takes time, but presenting such material takes longer, and while I am hot on the trail of better, more illuminating models, the presentation will not be polished and transparent.

So far we have two of a series of three expected models of syllogistic logic, and a first model of the Grice/Code/Speranza presentation of the Metaphysics.
Once the third (modal) model of syllogisms is in place I will then look for a combined model, covering modal syllogisms with the crucial distinction between essential and accidental predication ({\it izzing} and {\it hazzing}, in Grices colourful terminology).
Then the emphasis will shift to pulling out the philosophical implications.

Further discussion of what might become of this document in the future may be found in my postscript (Section \ref{POSTSCRIPT}).

In this document, phrases in coloured text are hyperlinks, like on a web page, which will usually get you to another part of this document (the blue parts, the contents list, page numbers in the Index) but sometimes take you (the red bits) somewhere altogether different (if you happen to be online) like \href{http://rbjones.com/pipermail/hist-analytic_rbjones.com}{the hist-analytic archives}.

\subsection{Preliminary Formalities}

In the document several different formal models are presented.
By and large they are independent, but a some features are common and are therefore presented here for use in all the models.

=SML
open_theory "misc2";
force_new_theory "aristotle";
=TEX

\ignore{
=IGN
force_new_pc Û"'ariscat"Ý;
merge_pcs ["'savedthm_cs_¶_proof"] "'ariscat";
set_merge_pcs ["misc2", "'ariscat"];
=SML
set_pc "misc2";
=TEX
}%ignore

We define inequality:

=SML
declare_infix (300, "½");
=TEX

¹HOLCONST
Ü $Û½Ý : 'a ­ 'a ­ BOOL
÷üüüüüü
Ü µx y· x ½ y ¤ ³ x = y
°

\section{LANGUAGES, METHODS AND TOOLS} \label{LMT}

This document is probably only of interest to philosophers, among whom few are likely to be familiar with the methods, languages and tools which I have used in it.
In this section I hope to supply enough on these topics to make it possibly for as many philosophers as possible to get something out of the formal models which follow.

For the moment this is brief and its coverage rather random.
I hope this will be filled out as work progresses.

I appeal for feedback on what parts of the document are most difficult to understand.

\subsection{Languages}

Two formal languages are used in this document.
One is a language, called HOL for Higher Order Logic, with a deductive system sufficient for the formal development of mathematics, or for other applications susceptible of formalisations.

The other is a metalanguage known as SML, which stands for Standard Meta-Language.
This is used for giving exective instructions to software which provides support for use of the HOL language and for the contruction and verification of formal proofs in the HOL logic.

\subsubsection{HOL}

The principle language used here (apart from English) is a language (and logic) called HOL.
HOL is an acronym for Higher Order Logic, of which there are many different varieties, and is also widely used for a specific variant of higher order logic which has been implemented in several computer programs providing support for formal specification and proof.

For full details of this language you would need to refer to the documentation which comes with these tools \cite{ds/fmu/ied/spc001} or some of the papers published about them.
See below (Section \ref{ProofPower}) for information relating to the tool used for producing this document, \ProductHOL.

The language HOL is a direct descendent of Russell's {\it Theory of Types}\cite{russell1908}, the logic which he and Whitehead used in {\it Principia Mathematica}\cite{russell1913}.
To get from Russell's {\it Theory of Types} to HOL you do the following (names in brackets give credit to the person who thought of the step):

\begin{itemize}
\item discard the ramifications (Ramsey \cite{ramsey25})
\item simplify by basing on typed lambda-calculus (Church \cite{church40})
\item add polymorphism (Gordon/Milner \cite{gordon87,milner78})
\end{itemize}

To do serious work you need a proof tool, see (Section \ref{ProofPower}).

The following are the most important features of this language/logic which distinguish it from those typically considered by philosophers.

\begin{itemize}
\item It is a foundation system, i.e. it suffices for the development of mathematics by conservative extension (definitions) alone.
\item It has a type system, and allows new types to be defined.
\item It is supported by computer software which checks specifications, assists in constructing proofs and rigorously checks proofs.
\end{itemize}

\subsection{Methods}

The principle technique used here is a method which has some of the theoretical merits of a metatheoretic treatment, but is less arduous and provides better support for reasoning in the object language.

We imagine ourself devising a formal language in which to talk about Aristotle's metaphysics, and in which to formalise the kind of metaphysical arguments which are found in Aristotle.
To do this rigorously, we need to deal first with the semantics of the language, and establish a deductive system which is sound with respect to that semantics.

A standard formal treatment of this material would involve a specification of the syntax of an appropriate language, the development of semantics, probably as some kind of model theory, the specification of a deductive system for the language and a proof of soundness of that system (this would be a version of Aristotle's Syllogistic logic).
This is feasible with the languages and tools we are using, but arduous.
The results would be good for metatheory, but not necessarly convenient for conducting proofs in the language thus defined, i.e. for reasoning in the new object language.

There is another manner of proceeding which better suits our present purposes.
This consists in extending our already available language, using the definitional facilities and the flexibility in its syntax (e.g. fixity declarations) to create a language extension which looks something like and behaves exactly like the intended object language.

We begin with something like model theory, defining new data types which model the kinds of thingd that the new language is to be about.
The constructs in the language are then given definitions in terms of these new data tupes.
By deduction within HOL we are then able to prove results which correspond to results in the intended object language.

There ia a technical term for this kind of treatment of languages in HOL, they are called {\it shallow semantic embeddings}, and this term indicates that the expressions of the target language are represented by expressions in HOL which are syntactically similar (though perhaps not identical) to those of the intended object language, and which do have the same meaning as the target language expressions.
For a fuller description of this kind of method (used in theoretical computer science) see \cite{gordon88}.

If you have not come across this kind of thing before this probably does not make much sense at this point, but I hope that eventually the material which follows will provide an intelligible example of this method.

\subsubsection{Schemas and Higher Order Quantification}

Much of the semi-formal material which we are trying to fully formalise involves general talk about the kinds of things which are found in categories.
Possibly the formulae are intended as schemas in a first order predicate calculus.
This is not the way we will treat them, so a few words explaining why not are in order here.

We are working here in a higher-order logic.
In a first-order logic, it is not possible for quantify over anything but individuals.
In first order set theory we get around that restriction by having ``individuals'' which are surrogates for all kinds of higher order objects.
In set theory we can, by quantifying over the individuals encompass objects which represent properties of functions of every conceivable type.
Some pragmatic issues remain which we need not go into here.

When a first-order formalisation is attempted without benefit of the machinery of set theory, it often proves necessary to use schemata, which are a syntactic surrogate for quantification over higher types.
A well known example is the theory PA, a first order version of Peano's axioms for arithmetic.
Peano himself formulated his axioms for arithmetic before first order logic was invented, before indeed the foundational problems which provoked the development of type theories.
His axiom of induction involved quantification over properties along the following lines:

=GFT
	ô µp· p(0) ± (µx· p(x) ´ p(x + 1)) ´ µx· p(x)
=TEX

Which we may paraphrase:
\begin{quote}
for all properties {\it p}, if {\it p} holds for 0 and, whenever {\it p} is true of some natural number, it is true also of its successor, then {\it p} will be true of all natural numbers
\end{quote}

In the first order formalisation of Peano Arithmetic, known as PA, we cannot quantify over properties, so we use instead an axiom schemata, which lifts the quantification into the metalanguage and changes from quantifying over numbers to quantifying over formulae.
Thus we have instead something like:

=GFT
	ô P(0) ± (µx· P(x) ´ P(x + 1)) ´ µx· P(x)
=TEX

Where $P$ is not a predicate in the object language, but a syntactic function in the metalanguage which yields formula.
This first order axiom schema describes an infinite set of properly first order axioms obtained by substituting arbitrary formulae (in which $0$ occurs) for $P(0)$, and corresponding formulae for $P(x)$ and $P(x+1)$ in which $x$ and $x+1$ respectively replace occurences of $0$ in the original formula.

\subsubsection{Features of The Language}

The following features of the language are methodologically significant:

[to be supplied]

\subsection{Tools}

\subsection{ProofPower}\label{ProofPower}

The tool used for preparation of this document, for checking the syntax and type correctness of the formal specifications, for assisting in the construction of formal proofs, and for checking the resulting proofs in detail is \Product.

This document is a {\it literate script}.
This means that it is a {\it script} intended for processing by machine, which is also intended to be humanly intelligible (i.e. literate).

The source for the document is machine processed in two distinct ways.
The formal content is extracted and processed by the proof tool \Product, which understands two main languages, the first, HOL, a kind of higher order logic suitable for the formal development of mathematics and for applications of formalised logic and/or mathematics.
The second is a functional programming language called SML, in which instructions may be given to \Product on how to process the formal specifications.
This includes instructions on how to construct and check formal proofs of conjectures in HOL.

\Product come with a library of already defined mathematical concepts and of theorems proven in the context of these definitions, which are organised into a hierarchy of theories in which a theory may make use of the definitions made and theorems proven in any of its ancestors.
As \Product processes a document it aguments the theory hierarchy with the new material.
Listings of the theories can be obtained for inclusion at the end of the document.

The other way of processing the source is for the purpose of obtaining a humanly readable document, typically in PDF format, of which this is an example.
While the document is being written, the author enters into an interactive dialogue with the proof tool in which new definitions or modifications to existing definitions are checked for grammatical correctness and type-correctness.
Proofs of conjecture are developed interactively in such a session using a ``goal package'' which permits the user to work backwards from the goal he is attempting to prove.
The end result of such proof development is a script in the metalanguage SML which provides to \Product a prescription for constructing a proof, which is checked for correctness on-the-fly.
This will be rerun when the complete document is later processed in batch.

Document preparation uses the \LaTeX package augmented by facilities provided by \Product, various aspects such as the formatting of formal text, the creation of contents lists, indexes and bibliographies being thereby facilitated.

\section{THE ORGANON}

\href{http://texts.rbjones.com/rbjpub/philos/classics/aristotl/oi.htm}{The Organon} is a collection of 6 books by Aristotle which form the main part of his work on Logic.
The first of these is \href{http://texts.rbjones.com/rbjpub/philos/classics/aristotl/o11i.htm}{the Categories} \cite{aristotleL325}, on which Aristotle's Metaphyics depends.
The Metaphysics, at least the parts involved in the Grice/Code analysis \cite{grice88,code88}, is concerned with predication, which is also central to the formal core of Aristotle's logic, the theory of the syllogism, presented in the \href{http://texts.rbjones.com/rbjpub/philos/classics/aristotl/o31i.htm}{Prior Analytic, Book 1} \cite{aristotleL325}.

Aristotle's account of syllogistic logic covers modal reasoning.
In attempting to understand Aristotelian essentialism, one of the key problems is to establish the relationship between the two distinctions between necessary and contingent proposition, and between essential and accidental predication.

Though Code \cite{code88} does not conceive of himself as engaged in formalising Aristotle in a modern predicate logic, his presentation seems much closer to predicate logic than to syllogistic logic.
I would like to understand the metaphysics if possible in terms of the kind of logic which Aristotle had at his disposal.
To explore the extent to which this might be possible, some models of syllogistic logic might be helpful.

When we look at the syllogism with particular concern for the notion of predication involved, we find that the Grice's ``izz/hazz'' distinction (in Aristotle ``said of'' and ``in'') is not relevant.
In this respect predication is simpler in the syllogism, but instead we have an orthogonal distinction into four kinds of predication according to whether the subject is universal or particular, and whether the predication is affirmative or negative, over which are later added the modal operators.

In the basic case the semantics of the syllogism is very simple and I therefore begin with that simple case.
One factor which complicates the semantics is the proscription, implicit in Aristotle and sometimes called ``the existential fallacy'', of predicates whose extension is empty.
Without the existential fallacy the models are simpler, so I have begun with this.

It may be helpful to give a full treatment in the following stages:
\begin{itemize}
\item pure syllogism without existential fallacy (Section \ref{SWEF})
\item full syllogism incorporating existential fallacy (Section \ref{SYLL})
\item modal syllogisms  (Section \ref{MODSYLL})
\end{itemize}

The present treatment was based firstly on the wikipedia account of \href{http://en.wikipedia.org/wiki/Syllogism}{Aristotle's Logic}, secondly on Strawson \cite{strawson52} from whom I first obtained the syllogisms not in Aristotle and began incorporation of direct inference, and then from Spade\cite{spade2002} I obtained the names for the extra syllogisms and a fuller account of how the syllogisms can be derived which is not yet reflected in the following.

The main interest at present is the sequence of models which contributes to the formulation of an integrated model for the syllogicsm and the metaphysics in Section \ref{METAPHYSICSII}.
It suffices perhaps in this context to know in which models the various syllogisms are provable, without delving into the details of proof, which are at present, sheer hackery.

\subsection{The Syllogism without The Existential Fallacy}\label{SWEF}

The theory here is very simple, the presentation is complicated by the fact that the proofs have been completely automated by scripts in the metalanguage.
These can be completely ignored by anyone who is willing to trust that \Product checks proofs correctly.
In any case, the theorems proven are just the statements of the 15 valid forms of syllogism which do not exhibit the ``existential fallacy''.
For the most concise statement of the results of the exercise, the reader should refer directly to the theory listing in Appendix \ref{syllog1} below.

=SML
open_theory "aristotle";
force_new_theory "syllog1";
=TEX

\ignore{
=SML
force_new_pc Û"'syllog1"Ý;
merge_pcs ["'savedthm_cs_¶_proof"] "'syllog1";
set_merge_pcs ["misc2", "'syllog1"];
=TEX
}%ignore

\subsubsection{The Subject Matter}

Aristotle's syllogistic logic is concern with inferences between judgements considered as predications.
A predication in Aristotle affirms a {\it predicate} of some {\it subject}, but by contrast with more recent notions of predication the subject need not be an individual, the kinds of things which appear as predicates may also appear as subjects, and the relationship expressed seems closer to a modern eye to set inclusion than to what we now regard as predication.
Since subject and predicate are for present purposes the same kind of thing, it is useful to have a name for that kind of thing, and I will use the name {\it property}.

There are four kinds of predication which we have here to account for, which we will do by offering definitions which provide a good model for syllogistic logic, i.e. one for which the syllogisms held to be true by Aristotle are in fact true.
Before providing these definitions we must decide what kind of thing are the properties which are related by Aristotelian predication.
 
In HOL the most natural answer to this is ``boolean valued functions'' which are objects of type $”'a ­ BOOL®$ for some type of individuals which we can leave open by using the type variable $”'a®$.
This provides a simple model of Aristotle's syllogistic reasoning, except for those cases which involve the ``existential fallacy''.
Four of the syllogisms which Aristotle considered valid fail under this conception of predicate, because among the objects of type $”'a ­ BOOL®$ is the function $¬Ìx:'a· F®$ which corresponds to a predicate with empty extension and does not admit inference from the universal to the existential.

The following ``type abbreviation'' allows us to use {\it PROP} as an abbreviation for $”'a ­ BOOL®$.

=SML
declare_type_abbrev("PROP", [], ”'a ­ BOOL®);
=TEX

\subsubsection{Predication}

There are four forms of predication which are normally presented as infix operators over predicates using the vowels ``a'', ``e'', ``i'', ``o''.
``o'' is already in use so I'll use ``u'' instead.

These are to be construed as follows:

\begin{center}
\begin{tabular}[]{ | l | l |}
\hline
HOL term & Meaning\\
\hline
¬A a B® & All A are B\\
¬A e B® & All A are not B\\
¬A i B® & An A is B\\
¬A o B® & An A is not B\\
\hline
\end{tabular}
\end{center}

``o'' is already in use for functional composition, so we will use ``u'' instead and then use an alias to permit us to write this as ``o'' (type inference will usually resolve any ambiguity).

To render these in HOL we first declare the relevant leters as infix operators:

=SML
declare_infix (300, "a");
declare_infix (300, "e");
declare_infix (300, "i");
declare_infix (300, "u");
=TEX

They predication operators are defined as follows:

¹HOLCONST
Ü $ÛaÝ : PROP ­ PROP ­ BOOL
÷üüüüüü
Ü µA B· A a B ¤ µx· A x ´ B x
°

¹HOLCONST
Ü $ÛeÝ : PROP ­ PROP ­ BOOL
÷üüüüüü
Ü µA B· A e B ¤ µx· A x ´ ³ B x
°

¹HOLCONST
Ü $ÛiÝ : PROP ­ PROP ­ BOOL
÷üüüüüü
Ü µA B· A i B ¤ ¶x· A x ± B x
°

¹HOLCONST
Ü $ÛuÝ : PROP ­ PROP ­ BOOL
÷üüüüüü
Ü µA B· A u B ¤ ¶x· A x ± ³ B x
°

=SML
declare_alias("o", ¬$u®);
=TEX

Note that as defined above these come in complementary pairs, $a$ being the negation of $o$ and $e$ of $i$.
If we had negation we could manage with just two predication operators.

\subsubsection{The Laws of Immediate Inference}

Before addressing the laws of immediate inference
\footnote{in which I follow Strawson \cite{strawson52}.}
I devise a tactic for automating simple proofs in this domain.

The following elementary tactic expands the goal by applying the definitions of the operators and then invokes a general tactic for the predicate calculus.
A rule is also defined using that tactic for direct rather than interactive proof.

=SML
val Ûsyll_tacÝ =	asm_prove_tac (map get_spec [¬$a®, ¬$e®, ¬$i®, ¬$u®]);
fun Ûsyll_ruleÝ g = tac_proof (g, syll_tac);	
=TEX

\paragraph{Simple Conversion}

=SML
val e_conv_thm = save_thm ("e_conv_thm", syll_rule([¬A e B®], ¬B e A®));
val i_conv_thm = save_thm ("i_conv_thm", syll_rule([¬A i B®], ¬B i A®));
=TEX

=GFT
val e_conv_thm = A e B ô B e A : THM
val i_conv_thm = A i B ô B i A : THM
=TEX

\ignore{
=SML
set_goal([], ¬¶A B· A a B ± ³ B a A®);
a (¶_tac ¬Ìx·F® THEN ¶_tac ¬Ìx·T® THEN syll_tac);
val a_not_conv_thm = save_pop_thm "a_not_conv_thm";

set_goal([], ¬¶A B:PROP· A o B ± ³ B o A®);
a (¶_tac ¬Ìx·T® THEN ¶_tac ¬Ìx·F® THEN syll_tac);
val o_not_conv_thm = save_pop_thm "o_not_conv_thm";
=TEX
}%ignore

=GFT
a_not_conv_thm = ô ¶ A B· A a B ± ³ B a A
o_not_conv_thm = ô ¶ A B· A o B ± ³ B o A
=TEX

\paragraph{Conversion Per Accidens}

These don't work here because they rely upon the existential fallacy.

\paragraph{Obversion}

For these we need to define an operation of complementation on predicates.

¹HOLCONST
Ü ÛComplementÝ : PROP ­ PROP
÷üüüüüü
Ü µA Á· (Complement A) Á ¤ ³ (A Á) 
°

We will use ``$~$'' as a shorthand for ``complement''.

=SML
declare_alias ("~", ¬Complement®);
=TEX

\ignore{
=SML
add_pc_thms "'syllog1" [get_spec ¬Complement®];
set_merge_pcs ["misc2", "'syllog1"];
=TEX
}%ignore

\ignore{
=SML
val ae_obv_thm = save_thm ("ae_obv_thm", syll_rule([¬A a B®], ¬A e ~B®));
val ea_obv_thm = save_thm ("ea_obv_thm", syll_rule([¬A e B®], ¬A a ~B®));

set_goal([¬A i B®], ¬A u ~B®);
a (syll_tac);
a (¶_tac ¬x® THEN asm_rewrite_tac[]);
val io_obv_thm = save_pop_thm "io_obv_thm";

set_goal([¬A u B®], ¬A i ~B®);
a (syll_tac);
a (¶_tac ¬x® THEN asm_rewrite_tac[]);
val oi_obv_thm = save_pop_thm "oi_obv_thm";
=TEX
}%ignore

=GFT
ae_obv_thm = 	A a B ô A e ~ B
ea_obv_thm = 	A e B ô A a ~ B
io_obv_thm = 	A i B ô A o ~ B
oi_obv_thm = 	A o B ô A i ~ B
=TEX

\paragraph{Contraposition and Inversion}


\paragraph{The Square of Opposition}


\subsubsection{The Valid Syllogisms}\label{ValidSyllogisms}

The fifteen valid syllogisms which do not exhibit the existential fallacy are true under this semantics and can be proven formally with ease.

In this section we describe informally this subset of the valid syllogisms, in the next we provide scripts in our metalanguage which automates the construction and proof of the relevant syllogisms.
This presentation is based on \href{http://en.wikipedia.org/wiki/Syllogism}{the one at wikipedia}.

Syllogisms come in four figures, according to the configuration of variables in the premises:

\begin{quote}
\begin{itemize}
\item[Figure 1] M-P, S-M $ô$ S-P
\item[Figure 2] P-M, S-M $ô$ S-P
\item[Figure 3] M-P, M-S $ô$ S-P
\item[Figure 4] P-M, M-S $ô$ S-P
\end{itemize}
\end{quote}

Where S, P and M are the subject, predicate and middle term respectively. 

These four figures are then repeated for each combination of the four types of premise in each of the premises and the conclusion.
This gives $4 ¸ 4 ¸ 4 ¸ 4 = 256$ possibilities, of which 19 were held to be valid by Aristotle, four exhibiting the so-called ``existential fallacy'' of inferring from a universal to an existential.

The use of vowels for the predicators allows the valid cases to be named using names in which the vowels tell you the form of the syllogism (if you also know the figure).
The first vowel tells you the kind of syllogism in the first premise, the second vowel that in the second premise, and the third vowel that in the conclusion.

In the following table the names in square brackets are for syllogisms which exhibit the existential fallacy.
Then names followed by exclamation marks are ``subalternate mood'', they do not appear in aristotle but are valid in the models here for which the existential fallacy holds
\footnote{This I got from Spade \cite{spade2002}.}.

\begin{center}
\begin{tabular}[]{| l | l | l | l |}
\hline
Figure 1 &	Figure 2	&	Figure 3 &	Figure 4\\
\hline 
Barbara &	Cesare 	&	[Darapti] &	[Bramantip]\\
Celarent &	Camestres &	Disamis 	&	Camenes\\
Darii 	&	Festino 	&	Datisi 	&	Dimaris\\
Ferio 	&	Baroco 	&	[Felapton] &	[Fesapo]\\
Barbari!	&	Cesaro!  	&	Bocardo 	&	Fresison\\
Celaront!	&	Camestrop! 	&	Ferison 	&	Camenop! \\
\hline
\end{tabular}
\end{center}

\subsubsection{Generating Syllogisms}

This section is mainly given over to short programs in our metalanguage the end effect of which is to secure the proof of the 15 forms of syllogism which do not exhibit the existential fallacy.
The results are visible in the ``theorems'' section of the theory listing in Appendix \ref{syllog1}, and this section can be safely skipped by anyone whose interest is purely philosophical.
Normally this kind of material would be hidden, it is shown here to give an impression of the size of script necessary to automate this kind of task.

The following function generates a list of four quadruples of HOL variables which correspond to the four figures of syllogisms.
It is parameterised by the HOL type used for predicates to that it can be re-used when we change the representation type.

=SML
fun ÛfiguresÝ pt = 
	let val M = mk_var ("M", pt)
	    and P = mk_var ("P", pt)
	    and S = mk_var ("¿", pt)
	in [(M,P,S,M), (P,M,S,M), (M,P,M,S), (P,M,M,S)]
	end;
=TEX

The following functions take a string which is the name of a syllogism extract the vowels which occur in it and convert them into the corresponding predication operator to give a triple of operators.
=SML
fun Ûop_from_charÝ ot c = mk_const (if c = "o" then "u" else c, ot);

fun Ûvowels_from_stringÝ s = filter (fn x => x mem (explode "aeiou")) (explode s);

fun Ûoptrip_from_textÝ ot s =
	let val [a,b,c] = (map (op_from_char ot) o vowels_from_string) s;
	in (a,b,c)
	end;
=TEX

The following functions contruct a syllogism.

=SML
fun Ûmk_predÝ q s p = mk_app(mk_app (q, s), p);

fun Ûmk_syllÝ vt (a,b,c,d) (q1, q2, q3) =
	([mk_pred q1 a b, mk_pred q2 c d],
		mk_pred q3 (mk_var("¿", vt)) (mk_var("P", vt)));

fun Ûmk_reltÝ t = mk_ctype ("­", [t, mk_ctype ("­", [t, ”BOOL®])]);

fun Ûmk_syllpÝ vt (s, n) =
	mk_syll vt (nth (n-1) (figures vt)) (optrip_from_text (mk_relt vt) s);
=TEX

=SML
val Ûmk_syllp1Ý = mk_syllp ”PROP®;
=TEX

We now define a data structure from which the valid syllogisms can be generated.
With the model we are using only the 15 syllogisms which do not exhibit the ``existential fallacy'' are provable.
They are shown in the following data structure.

=SML
val Ûsyllogism_data1Ý = 
	[("Barbara", 1),
	("Celarent", 1),
	("Darii", 1),
	("Ferio", 1),
	("Cesare", 2),
	("Camestres", 2),
	("Festino", 2),
	("Baroco", 2),
	("Disamis", 3),
	("Datisi", 3),
	("Bocardo", 3),
	("Ferison", 3),
	("Camenes", 4),
	("Dimaris", 4),
	("Fresison", 4)];
=IGN
map mk_syllp1 syllogism_data1;
=TEX

The following code generates the goals for proving the above syllogisms from the data structure, generates and checks formal proofs and saves the resulting theorems in the current theory (see end of document for theory listing). 

=SML
fun Ûsyll_proveÝ msp suff tac (a,n) =
	let val thm = tac_proof (msp (a,n), tac) handle _ => t_thm
	in (concat [a, suff], thm)
	end;

fun Ûsyll_prove_and_storeÝ msp suff tac (a,n) =
	let val res = syll_prove msp suff tac (a,n);
	    val _ = save_thm res
	in res 
	end;

val Ûsps1Ý = syll_prove_and_store mk_syllp1 "";
=TEX

\subsubsection{Proving the Syllogisms}

We now apply this to the complete set of syllogisms which are valid and do not exhibit the existential fallacy,
saving the results in the theory as well as binding them to (naming them as) the metalanguage value {\it valid\_sylls}.

=SML
val Ûvalid_syllsÝ = map (sps1 syll_tac) syllogism_data1;
=TEX

This is the resulting value.
=GFT
val valid_sylls = [
	("Barbara", M a P, ¿ a M ô ¿ a P),
	("Celarent", M e P, ¿ a M ô ¿ e P),
	("Darii", M a P, ¿ i M ô ¿ i P),
	("Ferio", M e P, ¿ i M ô ¿ o P),
	("Cesare", P e M, ¿ a M ô ¿ e P),
	("Camestres", P a M, ¿ e M ô ¿ e P),
	("Festino", P e M, ¿ i M ô ¿ o P),
	("Baroco", P a M, ¿ o M ô ¿ o P),
	("Disamis", M i P, M a ¿ ô ¿ i P),
	("Datisi", M a P, M i ¿ ô ¿ i P),
	("Bocardo", M o P, M a ¿ ô ¿ o P),
	("Ferison", M e P, M i ¿ ô ¿ o P),
	("Camenes", P a M, M e ¿ ô ¿ e P),
	("Dimaris", P i M, M a ¿ ô ¿ i P),
	("Fresison", P e M, M i ¿ ô ¿ o P)
] : (string * THM) list
=TEX

The theorems are also displayed in the theory listing in Appendix \ref{syllog1}

\subsection{The Syllogism with The Existential Fallacy}\label{SYLL}

There is more than one way in which the semantics of the syllogism can be modified to make the inference from "All As are Bs" to "Some As are Bs" sound.
One way would be to change the meaning of "All".
This would interfere with the square of opposition by making opposites no longer contradictories.
From this I tentatively infer that the exclusion of empty predicates is a better approach.
\footnote{This seems to be endorsed by Robin Smith in the \href{http://plato.stanford.edu/entries/aristotle-logic/}{Stanford Encyclopaedia of Philosophy}.}

We can then prove valid 24 forms of syllogism.

For the most concise statement of the results of the exercise, the reader should refer directly to the theory listing in Appendix \ref{syllog2} below.

=SML
open_theory "aristotle";
force_new_theory "syllog2";
=TEX

\ignore{
=SML
force_new_pc Û"'syllog2"Ý;
merge_pcs ["'savedthm_cs_¶_proof"] "'syllog2";
set_merge_pcs ["misc2", "'syllog2"];
=TEX
}%ignore

\subsubsection{The Subject Matter}

The key to getting the existential fallacies into the model is the adoption of a type for the variables in the syllogisms which does not include empty predicates.
We could do this by defining a new type which is a sub-type of the propositional functions, but it is simpler to use another type-abbreviation as follows.

Instead of using a propositional function, which might be unsatisfiable, we use an ordered pair.
The pair consists of one value, a value for which the predicate is true, and a propositional function.
The predicate $(v, pf)$ is then to be considered true of some value $x$ {\it either} if $x$ is $v$ {\it or} if $pf$ is true of $x$. 

This is the type abbreviation:

=SML
declare_type_abbrev("PROP2", [], ”'a ¸ ('a ­ BOOL)®);
=TEX

\subsubsection{Predication}

To work with this new type for the predicates we define a function which will convert this kind of predicate into the old kind, as follows:

¹HOLCONST
Ü ÛpÝ : PROP2 ­ ('a ­ BOOL)
÷üüüüüü
Ü µA· p A = Ìx· let (v,f) = A in x = v ² f x 
°

The resulting values have the same type as the old, but they will never have empty extension.

The following principle can be proven (proof omitted):

\ignore{
=SML
set_goal([], ¬µA· ¶v· (p A) v®);
a (strip_tac);
a (¶_tac ¬Fst A® THEN rewrite_tac [get_spec ¬p®, let_def]);
val p_¶_lemma = save_pop_thm "p_¶_lemma";
=TEX
}%ignore

=GFT
p_¶_lemma =
	ô µ A· ¶v· p A v
=TEX

This principle is what we need to prove the four Aristotelian syllogisms which exhibit the existential fallacy, and the other five not known to Aristotle.

We then proceed in a similar manner to the first model, using the function $p$ to convert the new kind of predicate into the old.

We have a new theory which is not a child of the first theory, so we must redeclare the fixity of the predication operators:

=SML
declare_infix (300, "a");
declare_infix (300, "e");
declare_infix (300, "i");
declare_infix (300, "u");
=TEX

They predication operators are then defined.
Note that the differences are small and uniform.
The type $”PROP®$ is changed to $”PROP2®$ and the function $p$ is invoked before applying a predicate.

¹HOLCONST
Ü $ÛaÝ : PROP2 ­ PROP2 ­ BOOL
÷üüüüüü
Ü µA B· A a B ¤ µx· p A x ´ p B x
°

¹HOLCONST
Ü $ÛeÝ : PROP2 ­ PROP2 ­ BOOL
÷üüüüüü
Ü µA B· A e B ¤ µx· p A x ´ ³ p B x
°

¹HOLCONST
Ü $ÛiÝ : PROP2 ­ PROP2 ­ BOOL
÷üüüüüü
Ü µA B· A i B ¤ ¶x· p A x ± p B x
°

¹HOLCONST
Ü $ÛuÝ : PROP2 ­ PROP2 ­ BOOL
÷üüüüüü
Ü µA B· A u B ¤ ¶x· p A x ± ³ p B x
°

=SML
declare_alias("o", ¬$u®);
=TEX

\subsubsection{Laws of Immediate Inference}

The same tactic used for proof of the syllogisms in the previous model still works with this model (with the new definitions), but does not prove the syllogisms which exhibit the existential fallacy.

To obtain proofs of these other syllogisms we need to make use of the lemma we proved about $p$, {\it p\_¶\_lemma}.
This we do by instantiating it for each of the variables which appear in the syllogisms and supplying these for use in the proof.

=SML
val Ûsyll_tac2Ý =
	(MAP_EVERY (fn x => strip_asm_tac (µ_elim x p_¶_lemma))
		[¬M:PROP2®, ¬P:PROP2®, ¬¿:PROP2®, ¬A:PROP2®, ¬B:PROP2®])
	THEN asm_prove_tac (map get_spec [¬$a®, ¬$e®, ¬$i®, ¬$u®]);

fun Ûsyll_rule2Ý g = tac_proof(g, syll_tac2);
=TEX

\paragraph{Simple Conversion}

=SML
val e_conv_thm = save_thm ("e_conv_thm", syll_rule2([¬A e B®], ¬B e A®));
val i_conv_thm = save_thm ("i_conv_thm", syll_rule2([¬A i B®], ¬B i A®));
=TEX

=GFT
val e_conv_thm = A e B ô B e A : THM
val i_conv_thm = A i B ô B i A : THM
=TEX

In this version of the semantics, ``a'' and ``o'' conversion is neither provable nor refutable.
In the previous version, since the universe is a HOL type there is at least one individual, and contradictory predicates are allowed, we can use these two to disprove the two conversions.
With this semantics there is no empty predicate, and we cannot know that there are two distinct predicates.

\paragraph{Conversion Per Accidens}

=SML
val ai_conv_thm = save_thm ("ai_conv_thm", syll_rule2([¬A a B®], ¬B i A®));
val eo_conv_thm = save_thm ("eo_conv_thm", syll_rule2([¬A e B®], ¬B u A®));
=TEX

=GFT
val ai_conv_thm = A a B ô B i A : THM
val eo_conv_thm = A e B ô B o A : THM
=TEX

\subsubsection{The Valid Syllogisms}

The valid syllogisms have been described in Section \ref{ValidSyllogisms}.

The following valid syllogisms exhibit the existential fallacy and were not provable in the previous model.

=SML
val Ûsyllogism_data2Ý = 
	[("Darapti", 3),	
	("Felapton", 3),
	("Bramantip", 4),
	("Fesapo", 4)];

val Ûsyllogism_data3Ý = 
	[("Barbari", 1),
	("Celaront", 1),
	("Cesaro", 2),
	("Camestrop", 2),
	("Camenop", 4)];
=TEX

All nineteen syllogisms supposed valid by Aristotle are true under this semantics and have been provenThe actual theorems are shown in the theory listing in Appendix \ref{syllog2}.

The metalanguage scripts prepared for the first model are mostly reusable for this model, with some different parameters which reflect the differences between the models.

The main requirement is to supply the type of the propositional functions in this model which is done as follows:

=SML
val Ûmk_syllp2Ý = mk_syllp ”PROP2®;
=TEX

This defines the fucntion {\it mk\_syllp2} whose type is shown:

=GFT
val mk_syllp2 = fn : string * int -> TERM list * TERM
=TEX

{\it mk\_syllp2} takes a pair consisting of a string which is the name of a syllogism and a number which is the number of the figure, and constructs the syllogism as a goal for proof.

An example of its use is:

=SML
mk_syllp2 ("Barbara", 1);
=TEX

which yields:

=GFT
val it = ([¬M a P®, ¬¿ a M®], ¬¿ a P®) : TERM list * TERM
=TEX

\subsubsection{Proving the Syllogisms}

We now apply this to the complete set of syllogisms which are valid and do not exhibit the existential fallacy,
saving the results in the theory as well as binding them to (naming them as) the metalanguage value {\it valid\_sylls}.

=SML
val Ûsps2Ý = syll_prove_and_store mk_syllp2 "";
val Ûvalid_sylls2Ý = map (sps2 syll_tac2)
	(syllogism_data1 @ syllogism_data2 @ syllogism_data3);
=TEX

This is the resulting value.
=GFT
val valid_sylls2 =
   [("Barbara", M a P, ¿ a M ô ¿ a P), ("Celarent", M e P, ¿ a M ô ¿ e P),
      ("Darii", M a P, ¿ i M ô ¿ i P), ("Ferio", M e P, ¿ i M ô ¿ o P),
      ("Cesare", P e M, ¿ a M ô ¿ e P), ("Camestres", P a M, ¿ e M ô ¿ e P),
      ("Festino", P e M, ¿ i M ô ¿ o P), ("Baroco", P a M, ¿ o M ô ¿ o P),
      ("Disamis", M i P, M a ¿ ô ¿ i P), ("Datisi", M a P, M i ¿ ô ¿ i P),
      ("Bocardo", M o P, M a ¿ ô ¿ o P), ("Ferison", M e P, M i ¿ ô ¿ o P),
      ("Camenes", P a M, M e ¿ ô ¿ e P), ("Dimaris", P i M, M a ¿ ô ¿ i P),
      ("Fresison", P e M, M i ¿ ô ¿ o P), ("Darapti", M a P, M a ¿ ô ¿ i P),
      ("Felapton", M e P, M a ¿ ô ¿ o P),
      ("Bramantip", P a M, M a ¿ ô ¿ i P), ("Fesapo", P e M, M a ¿ ô ¿ o P),
      ("Barbari", M a P, ¿ a M ô ¿ i P), ("Celaront", M e P, ¿ a M ô ¿ o P),
      ("Cesaro", M e P, ¿ a M ô ¿ o P), ("Camestrop", P a M, ¿ e M ô ¿ o P),
      ("Camenop", P a M, M e ¿ ô ¿ o P)] : (string * THM) list
=TEX

The theorems have aso been stored in the theory and are also displayed in the theory listing in Appendix \ref{syllog2}

\subsection{Modal Syllogisms}\label{MODSYLL}

The language of syllogistic logic does not have operators over propositions.
The only operators are the ones which apply predicates to subjects.

The modalities are perhaps therefore better thought of as kinds of judgements rather than as operations on propositions.
This would give us three kinds of judgement, which assert a predication contingently, necessarily or possibly.

It is natural to consider the modal aspects in terms of possible worlds, and I will model it first in those terms (not knowing whether this will provide a good model of Aristotle's conception of modality).
The propositional functions could then be modelled as functions from possible worlds to non-empty propositional functions.

\ignore{
One respect in which the treatment of the syllogism so far looks odd to the modern eye is the lack of consideration of constants.

We have a language which only has variables, even though Aristotle does use syllogistic reasoning with concrete predicates and subjects.
This lack bevomes more significant when modalities are introduced, for we expect necessities to flow from contraints on the extension of constants which are fixed across the possible worlds (i.e. the meanings of concepts are to be held fixed, even though their extensions may vary across possible worlds).

So I proposed in modelling modal syllogisms to bring the semantics closer to a modern model theory by allowing for constants.
This will be reflected in the definition of ``possible world'' which will include an assignment of values to constants.
}%ignore

I adapt the treatment of syllogisms with the existential fallacy by treating predicates as parameterised by a possible world.

Rather than using a type variable (which is what I did for the two preceding treatments) I will use two new type constants for individual aubstances and possible worlds.

It may suffice for the reader to refer directly to the theory listing in Appendix \ref{modsyllog} below.

=SML
open_theory "aristotle";
force_new_theory "modsyllog";
=TEX

\ignore{
=SML
force_new_pc Û"'modsyllog"Ý;
merge_pcs ["'savedthm_cs_¶_proof"] "'modsyllog";
set_merge_pcs ["misc2", "'modsyllog"];
=TEX
}%ignore

\subsubsection{The Subject Matter}

The complexity required in the semantics of modal operators depends upon other features of the language in which they occur.
Because the language of the syllogism is very simple, having neither propositional operators nor variables for individuals a very simple semantics may suffice.
When we come to consider the metaphyics there will be some increase in the complexity of the other features of the language, and also a greater premium on getting the semantics to correspond intuitively with the content of the metaphysics, but at this stage we will adopt the simplest semantic model which seems likely to secure the results expressible in our restrictied language.

So are now talking about predicates parameterised by possible worlds.
Furthermore, we will model this with a fixed set to individuals, independent of the possible world.
Possible worlds differ only in the extension of predicates.

First some new types, ``I'' for individual substances, ``W'' for possible worlds:

=SML
new_type (Û"I"Ý,0);
new_type (Û"W"Ý,0);
=TEX

Then a type abbreviation for the predicates:

=SML
declare_type_abbrev("MPROP", [], ”W ­ I ¸ (I ­ BOOL)®);
=TEX

\subsubsection{Predication}

To work with this new type for the predicates we define a function which will convert this kind of predicate into the old kind, as follows:

¹HOLCONST
Ü ÛpÝ : MPROP ­ (W ­ I ­ BOOL)
÷üüüüüü
Ü µA· p A = Ìw x· let (v,f) = A w in x = v ² f x
°

The following principle can be proven (proof omitted):

\ignore{
=SML
set_goal([], ¬µA w· ¶v· (p A) w v®);
a (REPEAT µ_tac);
a (¶_tac ¬Fst (A w)® THEN rewrite_tac [get_spec ¬p®, let_def]);
val p_¶_lemma = save_pop_thm "p_¶_lemma";
=TEX
}%ignore

=GFT
p_¶_lemma =
	ô µ A w· ¶ v· p A w v
=TEX

This principle is what we need to prove the syllogisms which exhibit the existential fallacy.

We then proceed in a similar manner to the other models, using the function $p$ to convert the new kind of predicate into the old.

We have a new theory which is not a child of the first theory, so we must redeclare the fixity of the predication operators:

=SML
declare_infix (300, "a");
declare_infix (300, "e");
declare_infix (300, "i");
declare_infix (300, "u");
=TEX

They predication operators are then defined.
Note that the differences are small and uniform.
The type $”PROP2®$ is changed to $”MPROP®$ and the function $p$ is invoked before applying a predicate.

Now we think of a predication as being a set of possible worlds, or BOOLean valued function over possible worlds.

¹HOLCONST
Ü $ÛaÝ : MPROP ­ MPROP ­ W ­ BOOL
÷üüüüüü
Ü µA B w· (A a B) w ¤ µx· p A w x ´ p B w x
°

¹HOLCONST
Ü $ÛeÝ : MPROP ­ MPROP ­ W ­ BOOL
÷üüüüüü
Ü µA B w· (A e B) w ¤ µx· p A w x ´ ³ p B w x
°

¹HOLCONST
Ü $ÛiÝ : MPROP ­ MPROP ­ W ­ BOOL
÷üüüüüü
Ü µA B w· (A i B) w ¤ ¶x· p A w x ± p B w x
°

¹HOLCONST
Ü $ÛuÝ : MPROP ­ MPROP ­ W ­ BOOL
÷üüüüüü
Ü µA B w· (A u B) w ¤ ¶x· p A w x ± ³ p B w x
°

=SML
declare_alias("o", ¬$u®);
=TEX

We now have to define some additional constants for the forms of judgement, which will assert the predications either of the actual world or of some or all possible worlds.

First I define a constant (rather loosely) to be the actual world:

¹HOLCONST
Ü Ûactual_worldÝ : W
÷üüüüüü
Ü T
°

Then the two modal judgement forms:

¹HOLCONST
Ü Û¨Ý : (W ­ BOOL) ­ BOOL
÷üüüüüü
Ü µs· ¨ s ¤ ¶w· s w
°

¹HOLCONST
Ü Û©Ý : (W ­ BOOL) ­ BOOL
÷üüüüüü
Ü µs· © s ¤ µw· s w
°

Finally the non-modal judgements also need a judgement forming constant.

¹HOLCONST
Ü Û˜Ý : (W ­ BOOL) ­ BOOL
÷üüüüüü
Ü µs· ˜ s ¤ s actual_world
°

\subsubsection{Laws of Immediate Inference}

Before looking at the conversions there are some general rules which may be helpful for us though these probably are not in Aristotle.

\ignore{
=SML
set_goal([¬©X®], ¬¨X®);
a (POP_ASM_T ante_tac THEN rewrite_tac [get_spec ¬©®, get_spec ¬¨®, get_spec ¬˜®]
	THEN REPEAT strip_tac THEN_TRY asm_rewrite_tac[]);
val ©¨_thm = save_pop_thm "©¨_thm";

set_goal([¬©X®], ¬˜X®);
a (POP_ASM_T ante_tac THEN rewrite_tac [get_spec ¬©®, get_spec ¬¨®, get_spec ¬˜®]
	THEN REPEAT strip_tac THEN_TRY asm_rewrite_tac[]);
val ©˜_thm = save_pop_thm "©˜_thm";

set_goal([¬˜X®], ¬¨X®);
a (POP_ASM_T ante_tac THEN rewrite_tac [get_spec ¬©®, get_spec ¬¨®, get_spec ¬˜®]
	THEN REPEAT strip_tac THEN_TRY asm_rewrite_tac[]);
a (¶_tac ¬actual_world® THEN strip_tac);
val ˜¨_thm_thm = save_pop_thm "˜¨_thm_thm";
=TEX
}%ignore

=GFT
©¨_thm = 		© X ô ¨ X
©˜_thm = 	© X ô ˜ X
˜¨_thm = 	˜ X ô ¨ X
=TEX

\paragraph{Simple Conversion}

\ignore{
=SML
set_goal([¬˜ (A e B)®], ¬˜(B e A)®);
a (POP_ASM_T ante_tac THEN rewrite_tac (map get_spec [¬˜®, ¬$e®])
	THEN contr_tac);
a (asm_fc_tac[]);
val e_conv_thm = save_pop_thm "e_conv_thm";

set_goal([¬˜ (A i B)®], ¬˜(B i A)®);
a (POP_ASM_T ante_tac THEN rewrite_tac (map get_spec [¬˜®, ¬$i®])
	THEN contr_tac);
a (asm_fc_tac[]);
val i_conv_thm = save_pop_thm "i_conv_thm";

set_goal([¬© (A e B)®], ¬©(B e A)®);
a (POP_ASM_T ante_tac THEN rewrite_tac (map get_spec [¬©®, ¬$e®])
	THEN contr_tac);
a (asm_fc_tac[]);
val ©e_conv_thm = save_pop_thm "©e_conv_thm";

set_goal([¬© (A i B)®], ¬©(B i A)®);
a (POP_ASM_T ante_tac THEN rewrite_tac (map get_spec [¬©®, ¬$i®])
	THEN contr_tac);
a (asm_fc_tac[]);
a (spec_nth_asm_tac 2 ¬w®);
a (asm_fc_tac[]);
val ©i_conv_thm = save_pop_thm "©i_conv_thm";

set_goal([¬¨ (A e B)®], ¬¨(B e A)®);
a (POP_ASM_T ante_tac THEN rewrite_tac (map get_spec [¬¨®, ¬$e®])
	THEN contr_tac);
a (spec_nth_asm_tac 1 ¬w®);
a (asm_fc_tac[]);
val ¨e_conv_thm = save_pop_thm "¨e_conv_thm";

set_goal([¬¨ (A i B)®], ¬¨(B i A)®);
a (POP_ASM_T ante_tac THEN rewrite_tac (map get_spec [¬¨®, ¬$i®])
	THEN contr_tac);
a (spec_nth_asm_tac 1 ¬w®);
a (asm_fc_tac[]);
val ¨i_conv_thm = save_pop_thm "¨i_conv_thm";

set_goal([¬© (A e B)®], ¬¨(B e A)®);
a (POP_ASM_T ante_tac THEN rewrite_tac (map get_spec [¬¨®, ¬©®, ¬$e®])
	THEN contr_tac);
a (spec_nth_asm_tac 1 ¬w:W®);
a (asm_fc_tac[]);
val ©¨e_conv_thm = save_pop_thm "©¨e_conv_thm";

set_goal([¬© (A e B)®], ¬˜(B e A)®);
a (POP_ASM_T ante_tac THEN rewrite_tac (map get_spec [¬˜®, ¬©®, ¬$e®])
	THEN contr_tac);
a (asm_fc_tac[]);
val ©˜e_conv_thm = save_pop_thm "©˜e_conv_thm";
=TEX
}%ignore

=GFT
e_conv_thm = ˜ (A e B) ô ˜ (B e A)
i_conv_thm = ˜ (A i B) ô ˜ (B i A)
©e_conv_thm = © (A e B) ô © (B e A)
©i_conv_thm = © (A i B) ô © (B i A)
¨e_conv_thm = ¨ (A e B) ô ¨ (B e A)
¨i_conv_thm = ¨ (A i B) ô ¨ (B i A)
©¨e_conv_thm = © (A e B) ô ¨ (B e A)
©˜e_conv_thm = © (A e B) ô ˜ (B e A)
=TEX

In this version of the semantics, ``a'' and ``o'' conversion is neither provable nor refutable.
In the previous version (the one not admitting the existential fallacy), since the universe is a HOL type there is at least one individual, and contradictory predicates are allowed, we can use these two to disprove the two conversions.
With this semantics there is no empty predicate, and we cannot know that there are two distinct predicates.

\paragraph{Conversion Per Accidens}

\ignore{
=SML
set_goal([¬˜ (A a B)®], ¬˜ (B i A)®);
a (REPEAT (POP_ASM_T ante_tac) THEN rewrite_tac (map get_spec [¬¨®, ¬©®, ¬˜®, ¬$a®, ¬$e®, ¬$i®, ¬$u®])
	THEN contr_tac THEN asm_fc_tac[]);
a (strip_asm_tac (list_µ_elim [¬A®, ¬actual_world®] p_¶_lemma));
a (asm_fc_tac[]);
val ˜ai_conv_thm = save_pop_thm "˜ai_conv_thm";

set_goal([¬˜ (A e B)®], ¬˜ (B u A)®);
a (REPEAT (POP_ASM_T ante_tac) THEN rewrite_tac (map get_spec [¬¨®, ¬©®, ¬˜®, ¬$a®, ¬$e®, ¬$i®, ¬$u®])
	THEN contr_tac THEN asm_fc_tac[]);
a (strip_asm_tac (list_µ_elim [¬B®, ¬actual_world®] p_¶_lemma));
a (spec_nth_asm_tac 2 ¬v®);
a (asm_fc_tac[]);
val ˜eo_conv_thm = save_pop_thm "˜eo_conv_thm";

set_goal([¬© (A a B)®], ¬¨ (B i A)®);
a (REPEAT (POP_ASM_T ante_tac) THEN rewrite_tac (map get_spec [¬¨®, ¬©®, ¬˜®, ¬$a®, ¬$e®, ¬$i®, ¬$u®])
	THEN contr_tac THEN asm_fc_tac[]);
a (strip_asm_tac (list_µ_elim [¬A®, ¬actual_world®] p_¶_lemma));
a (asm_fc_tac[]);
val ©¨ai_conv_thm = save_pop_thm "©¨ai_conv_thm";

set_goal([¬© (A e B)®], ¬¨ (B u A)®);
a (REPEAT (POP_ASM_T ante_tac) THEN rewrite_tac (map get_spec [¬¨®, ¬©®, ¬˜®, ¬$a®, ¬$e®, ¬$i®, ¬$u®])
	THEN contr_tac THEN asm_fc_tac[]);
a (strip_asm_tac (list_µ_elim [¬B®, ¬actual_world®] p_¶_lemma));
a (spec_nth_asm_tac 2 ¬actual_world®);
a (spec_nth_asm_tac 1 ¬v®);
a (asm_fc_tac[]);
val ©¨eo_conv_thm = save_pop_thm "©¨eo_conv_thm";
=TEX
}%ignore

=GFT
˜ai_conv_thm = 	˜ (A a B) ô ˜ (B i A)
˜eo_conv_thm = 	˜ (A e B) ô ˜ (B o A)
©¨ai_conv_thm = 	© (A a B) ô ¨ (B i A)
©¨eo_conv_thm = 	© (A e B) ô ¨ (B o A)
=TEX

\subsubsection{The Valid Modal Syllogisms}

The valid syllogisms have been described in Section \ref{ValidSyllogisms}.

All nineteen syllogisms supposed valid by Aristotle are true under this semantics and have been proven.
A further five\footnote{Which I got from Strawson \cite{strawson52}.} have also been proven, giving a total of 24.
When combinations of modal operators are added to this the number gets quite large, so, rather than proving all the valid cases I will prove sufficient to enable the rest to be automatically proven.

This will involve some theorems which are not strictly syllogistic.

The actual theorems proved are shown in the theory listing in Appendix \ref{modsyllog}.

Because of the modal operators the generation of the syllogisms is more complicated.
The generation functions are adapted to allow a single modal operator to be applied to each of the premises and the conclusion.

=SML
fun Ûmap_goalÝ f (st, t) = (map f st, f t);

fun Ûmk_modtÝ vt = mk_ctype ("­", [vt,
	mk_ctype ("­", [vt, (mk_ctype ("­", [”W®, ”BOOL®]))])]);

fun Ûmk_modsyllÝ vt (s, n) =
	mk_syll vt (nth (n-1) (figures vt)) (optrip_from_text (mk_modt vt) s);

fun ÛmodgoalÝ (mo1, mo2, mo3) ([p1,p2], c) =
	([mk_app (mo1, p1), mk_app (mo2, p2)], mk_app (mo3, c));

fun Ûmk_modsyllpÝ mot p = modgoal mot (mk_modsyll ”MPROP® p);
=TEX

This defines the function {\it mk\_modsyllp} whose type is shown:

=GFT
val mk_modsyllp = fn: TERM * TERM * TERM -> string * int -> TERM list * TERM
=TEX

in which the {\it TERM} parameters are modal operators the next argument is a pair consisting of a string which is the name of a syllogism and a number which is the number of the figure.
The result is a goal for proof.

An example of its use is:

=SML
mk_modsyllp (¬©®,¬˜®,¬¨®) ("Barbara", 1);
=TEX

which yields:

=GFT
val it = ([¬© (M a P)®, ¬© (¿ a M)®], ¬© (¿ a P)®) : TERM list * TERM
=TEX

\subsubsection{General Results}

The logic of the modal operators is completely independent of the logic of the syllogism.
The relevant results can be stated and proven in HOL concisely, but these statements are not in the language of the syllogism.

There are in effect just seven modal truths, each of which appears in 24 forms, one for each of the valid non-modal syllogisms.

Rather than proving all 192 theorems (counting the non-modal truths in this modal model), I prove the eight proformas expressed in HOL.
From these eight all 192 theorems can be obtained by proving (a special form of) one of the valid syllogisms and instantiating one of the general modal rules using it.

I omit the details of the metalanguage scripts which automate all this.

\ignore{
To get the required general results we define a new kind of pseudo-judgement `G' (for general).

=SML
val G = ¬(Ìx:W ­ BOOL· x w)®;
val GS = ¬µw:W· ‘G® FP ± ‘G® SP ´ ‘G® CS®;
fun modal_generalisation (a,b,c) =
	¬µFP SP CS· ‘GS® ´ (‘a® FP) ± (‘b® SP) ´ (‘c® CS)®;
=TEX

=SML
mk_modsyllp (G,G,G) ("Barbara", 1);
val general_syllogs = map ((map_goal (snd o dest_eq o concl o rewrite_conv[]))
			o (mk_modsyllp (G,G,G)))
	(syllogism_data1 @ syllogism_data2 @ syllogism_data3);
=TEX


=SML
fun AW_COND_T tac (asms, conc) =
	if snd (dest_app conc) = ¬actual_world®
	then tac ¬actual_world® (asms, conc)
	else tac ¬w:W® (asms, conc);

val mod_gen_tac = REPEAT µ_tac
	THEN rewrite_tac (map get_spec [¬¨®, ¬©®, ¬˜®])
	THEN REPEAT strip_tac
	THEN (AW_COND_T (fn x => REPEAT
		(((SPEC_NTH_ASM_T 1 x ante_tac) ORELSE_T (GET_NTH_ASM_T 1 ante_tac))
			THEN POP_ASM_T discard_tac)))
	THEN REPEAT strip_tac
	THEN_TRY ¶_tac ¬w:W®
	THEN REPEAT strip_tac;

fun mod_gen_rule t = tac_proof(([],t), mod_gen_tac);
=TEX
}%ignore

The following lists the valid modal forms.
In each tuple the three entries give the modalities of the first and second premise and the conclusion respectively.
Taking any valid syllogism and applying modal operators using one of the patterns in this table will give a valid modal syllogism.

=SML
val mod_gen_params =
	[(¬©®, ¬©®, ¬©®),
	(¬©®, ¬©®, ¬¨®),
	(¬©®, ¬©®, ¬˜®),
	(¬¨®, ¬©®, ¬¨®),
	(¬©®, ¬¨®, ¬¨®),
	(¬©®, ¬˜®, ¬˜®),
	(¬˜®, ¬©®, ¬˜®),
	(¬˜®, ¬˜®, ¬˜®)];
=TEX

\ignore{
=SML
val mod_gen_terms = map modal_generalisation mod_gen_params;

val mod_gens = map mod_gen_rule mod_gen_terms;

fun mod_gen_name (x,y,z) = concat
	(["mod_gen_"] @ [fst (dest_const x), fst (dest_const y), fst (dest_const z)]);

val mod_gen_thms = map
	(save_thm o (fn x => (mod_gen_name x, rewrite_rule [] (mod_gen_rule (modal_generalisation x)))))
	mod_gen_params;
=TEX
}%ignore

The set of general HOL theorems which facilitate the proofs of these modal syllogisms is as follows:

=GFT ProofPower Theorems
val mod_gen_thms =
   [ô µ FP SP CS· (µ w· FP w ± SP w ´ CS w) ´ © FP ± © SP ´ © CS,
      ô µ FP SP CS· (µ w· FP w ± SP w ´ CS w) ´ © FP ± © SP ´ ¨ CS,
      ô µ FP SP CS· (µ w· FP w ± SP w ´ CS w) ´ © FP ± © SP ´ ˜ CS,
      ô µ FP SP CS· (µ w· FP w ± SP w ´ CS w) ´ ¨ FP ± © SP ´ ¨ CS,
      ô µ FP SP CS· (µ w· FP w ± SP w ´ CS w) ´ © FP ± ¨ SP ´ ¨ CS,
      ô µ FP SP CS· (µ w· FP w ± SP w ´ CS w) ´ © FP ± ˜ SP ´ ˜ CS,
      ô µ FP SP CS· (µ w· FP w ± SP w ´ CS w) ´ ˜ FP ± © SP ´ ˜ CS,
      ô µ FP SP CS· (µ w· FP w ± SP w ´ CS w) ´ ˜ FP ± ˜ SP ´ ˜ CS]
: THM list
=TEX

In the above theorems the variables {\it FP}, {\it SP}, {\it CS}, stand respectively for {\it first premise}, {\it second premise}, {\it conclusion of syllogism} and range over modal propositions (which have type ”W ­ BOOL®).

\subsubsection{Proving the Syllogisms}

I then prove the 24 non-modal syllogisms in the required form and infer forward using the above 8 theorems to obtain a total of 192 theorems true in this model of the modal syllogism.

Details of scripts omitted.

\ignore{
=SML
fun ÛmodspsÝ mods = syll_prove (mk_modsyllp mods);
fun Ûvalid_modsyllsÝ mods suff tac = map (modsps mods suff tac)
	(syllogism_data1 @ syllogism_data2 @ syllogism_data3);
=TEX

The same tactic used for proof of the syllogisms in the previous model still works with this model (with the new definitions), but does not prove the syllogisms which exhibit the existential fallacy.

To obtain proofs of these other syllogisms we need to make use of the lemma we proved about $p$, {\it p\_¶\_lemma}.
This we do by instantiating it for each of the variables which appear in the syllogisms and supplying these for use in the proof.


=SML
val Ûmodsyll_G_tacÝ =
	(MAP_EVERY strip_asm_tac
		(map (fn x => (list_µ_elim [x, ¬w:W®] p_¶_lemma))
		[¬M:MPROP®, ¬P:MPROP®, ¬¿:MPROP®])
	THEN (asm_prove_tac (map get_spec [¬$a®, ¬$e®, ¬$i®, ¬$u®])));

fun Ûmodsyll_G_ruleÝ g = tac_proof(g, modsyll_G_tac);
=TEX

I just run this over a few combinations of modal operators to see which it will prove.


=SML
val valid_G_modsylls1 = valid_modsylls (G,G,G) "" modsyll_G_tac;
val valid_G_modsylls2 = map
	((µ_intro ¬w:W®)
		o (rewrite_rule [prove_rule [] ¬µA B C· (A ´ B ´ C) ¤ (A ± B ´ C)®])
		o (rewrite_rule [])
		o all_´_intro
		o snd)
	valid_G_modsylls1;
undisch_rule;

val valid_G_modsylls = map (undisch_rule
		o undisch_rule
		o (rewrite_rule [prove_rule [] ¬µA B C· (A ± B ´ C) ¤ (A ´ B ´ C)®])
		o all_µ_elim)
	(fc_rule mod_gen_thms valid_G_modsylls2);
=TEX
}%ignore

The automated proof the yields the expected 192 modal syllogisms, of which we display only the first few (and do not save them in the theory):

=GFT
val valid_G_modsylls =
   [˜ (P a M), ˜ (M e ¿) ô ˜ (¿ o P), ˜ (P a M), © (M e ¿) ô ˜ (¿ o P),
      © (P a M), ˜ (M e ¿) ô ˜ (¿ o P), © (P a M), ¨ (M e ¿) ô ¨ (¿ o P),
      ¨ (P a M), © (M e ¿) ô ¨ (¿ o P), © (P a M), © (M e ¿) ô ˜ (¿ o P),
      © (P a M), © (M e ¿) ô ¨ (¿ o P), © (P a M), © (M e ¿) ô © (¿ o P),
      ˜ (P a M), ˜ (¿ e M) ô ˜ (¿ o P), ˜ (P a M), © (¿ e M) ô ˜ (¿ o P),
      © (P a M), ˜ (¿ e M) ô ˜ (¿ o P), © (P a M), ¨ (¿ e M) ô ¨ (¿ o P),
      ¨ (P a M), © (¿ e M) ô ¨ (¿ o P), © (P a M), © (¿ e M) ô ˜ (¿ o P),
      © (P a M), © (¿ e M) ô ¨ (¿ o P), © (P a M), © (¿ e M) ô © (¿ o P),
      ˜ (P e M), ˜ (¿ a M) ô ˜ (¿ o P), ˜ (P e M), © (¿ a M) ô ˜ (¿ o P),
      © (P e M), ˜ (¿ a M) ô ˜ (¿ o P), © (P e M), ¨ (¿ a M) ô ¨ (¿ o P),
...
=TEX

=SML
length valid_G_modsylls;
=GFT
val it = 192 : int
=TEX
=TEX

\subsection{Demonstrative Truth}

An important part of Aristotle's philosophy is his concept of demonstrative science.

A proof is demonstrative if it proceeds from first principles and is deductively sound.
Truths established in this way is necessary because the first principles must be essential and hence necessary and sound deduction preserves necessity.

If we understand Hume's ``intuitively certain'' as a reference to the criteria for Aristotle's first principles, and understand Hume as using the term `demonstrative' in the same sense as Aristotle, then it is plausible that Hume's ``truths of reason'' are the same as Aristotle's truths of demonstrative science.

It is tempting to use the word demonstrative for these though in Aristotle and Hume the first principles do not count as demonstrable.
It is tempting also to identify these concepts with the concept of analyticity.
This last point is aided by the connection in Aristotle between essential truth (which must be posessed by the first principles) and definition, which seems close, and which distinguishes his accidental predications from essential predications.

However, we now expect deductive systems to be incomplete, and hence that not all analytic propositions are provable.
However, the incompleteness may arise from adopting a fixed set of first principles, rather from incompleteness of deduction.
In this case, the availability of an open set of first principles makes completeness in principle possible.
To sustain this principle in relation to set theory, for example, we would have to regard ourselves as having some definition of the concept of set relative to which the present axioms (say those of ZFC) are essential, and relative to which extensions as necessary to prove progressively more difficult results can also be seen to be essential.
This is not entirely implausible.
This is close to the rationale for large cardinaly axioms.
The informal description of the cumulative hierarchy as the domain of set theory involves the idea that the construction of well-founded sets from other well-founded sets of lesser rank proceeds indefinitely, and hence any axiom which states that a set of a certain rank exists must be true.

Does formal modelling contribute anything to this discussion?

The above discussion involves ideas which belong to Aristotle's metaphysics rather than his logic.
So a fuller formal analysis of these ideas will have to wait until we get to the Metaphysics.

However some aspects may be considered here.
For example, we need to know that from necessary premises only necessary premises are derivable by syllogisms.

\section{METAPHYSICS (I)}\label{METAPHYSICSI}

In this section we consider some material on Aristotle's Metaphysics \cite{aristotleMetap} which originated in work of Grice and Code \cite{code88} and came to me from a \href{http://rbjones.com/pipermail/hist-analytic_rbjones.com/2009q2/000258.html}{posting of J.L. Speranza} on the hist-analytic mailing list.
Code's paper is also partially available at \href{http://books.google.co.uk/books?id=sHWK4Lz37sAC&printsec=frontcover#PPA411,M1}{Google Books}.

What Speranza posted was the list of formulae which are named below as c01 through c31 (though not exactly as given, I have massaged them to be acceptable to HOL and also have quantified over all free variables).

The analysis in this section is independent of the preceding analysis of Aristotle's syllogism, and considers predication from a rather different point of view, which hangs around the distinction between essential and accidental predication.
In the next section I will produce another model in which essence and accident are combined with a full treatment of modal syllogism so that some conclusions might be drawn about the relationship between essence and necessity in Aristotlean philosophy.

A new theory is needed which I will call ``ariscat'' which is created here:

=SML
open_theory "aristotle";
force_new_theory "ariscat";
=TEX

\ignore{
=SML
force_new_pc Û"'ariscat"Ý;
merge_pcs ["'savedthm_cs_¶_proof"] "'ariscat";
set_merge_pcs ["misc2", "'ariscat"];
=TEX
}%ignore

\subsection{The Grice/Code/Speranza Formulae}

This work began with an attempt to analyse using \Product a set of formulae posted by J.L. Speranza to the \href{http://www.hist-analytic.org/}{hist-analytic mailing list}.
These were a Speranzan transcript of formulae published in a paper by Code \cite{code88}, the work presented in that paper having begun with some joint work with H.P.~Grice \cite{grice88}.

The following material labelled ``Code/Speranza'' began as a transcription from Speranza's email, and was later updated when Speranza pointed me to the partial availability of the Code paper on Google Books.
I then put back some of the detail missed in the Speranza version, enclosed in square brackets, and enclosed in curly braces some of the material which Speranza had added to Code's.

The terminology used is Grice's.
Code uses ``Is'' and ``Has'' instead of ``izz'' and ``hazz'' (which were coined by Grice and used by Speranza).
Aristotle's original's have been translated as ``SAID OF'' and ``IN'', according to Cohen (\href{http://faculty.washington.edu/smcohen/433/GriceCode.pdf}{Grice and Code on IZZing and HAZZing}).

The material is interspersed with a formalisation in \ProductHOL.
I have adopted some of Code's headings for sections.

\subsection{Formal Principles}

We begin with ``Formal Principles'' which we take as implicit definitions of two kinds of Aristotelian predication.

=GFT Code/Speranza
[(A) Formal Principles]

[FP1] 1. A izz A.
[FP2] 2. (A izz B & B izz C) --> A izz C.
[FP3] 3. A hazz B -> -(A izz B).
[FP4] 4. A hazz B iff A hazz Some-Thing [something] that izz B.
=TEX

The modelling in \ProductHOL will be entirely conservative, so we provide explicit definitions for ``izz'' and ``hazz'' and prove that they satisfy these principles and suffice also for the definitions and theorems which follow.

If the formal development is complete the definitions will have been shown to be sufficient.
In order to test whether the principles suffice I will attempt to procede on these alone, though I suspect that will not be possible.
Failing that I will offer informal arguments to the contrary (a formal argument would require ascent to a metatheory which would involve too much work).

In order to define these concepts we have to decide what they are about, and this is not straightforward.

\subsubsection{Categories}

Aristotle has a system of categories, and these seem central to the topic.
Much hang on what these are, and to get a nice structure to our theory it seems advisable to do a bit of ``category theory'' first.
Of course this is not at all the same thing as the branch of mathematics which now goes by that name, but the choice of name for the mathematics was not entirely quixotic and at some point it might be interesting to think about the relationship between the two kinds of category theory.

Among these categories that of substances plays a special role.
Substances can be particular in which case they correspond to some individual, or not, in which case they are sets of individuals.
The particulars of the other categories are attributes, and the non-individuals are sets of attributes.
I don't think you can have sigleton sets, so we can model all these categories as sets of sets in which the singleton sets are the individuals.
Attributes can also be considered as sets of individual substances and so there is a type difference between the category of substances and the other categories.

The following introduce new types and type abbreviations for modelling Aristotle's categories.

\begin{description}
\item ACAT is a type of attribute categories
\item ISUB is a type of individual substances
\item CATM is the type of the things which are in categories.

This is a `disjoint union', which means that there are two kinds of thing which one finds in categories, either a set of individual substances (using singleton sets to represent individual substances), or a set of properties of individual substances tagged with an attribute category.

\item CAT is a type abbreviation for a notion of category which is either an attribute category or some other category (which will stand for the category of substances).

\end{description}

There are some oversimplifications here which I am hoping will not be too serious for a useful first cut.

\begin{description}
\item[Modal Operators]
The main one is that this general approach will not permit the definition of modal operators, which are used by Code.
Whether there is real need for them seems to me doubtful, but if necessary a modal model could be provided.
\item[Empty Sets]
The second is that I have not excluded empty sets, and hence that there can be no predicates with null extensions.
This is in fact consistent with Code's ``principles'', but we find that his definitions are written as if there were no empty predicates, even though this is not entailed by the principles.
I where Code's definitions presume non-emptyness of predicates I have chosen another definition which does not.
Some of the theorems are then unprovable.
\item[Extensionality]
Intracategorial equality will be extensional.
That appears to be what is required, so it probably isn't a problem!
\item[Predicability]
Aristotle says defines particulars in terms of predicabilty, they are the impredicables.
Its not clear how to deal with this, and it appears to be in terminological confilct with Codc, who appears to use use ``predicable'' to mean ``truly predicable''.
Code has the general principle ``A izz A'' which implicitly asserts that everthing is truly predicable of itself.
\end{description}

=SML
new_type(Û"ACAT"Ý, 0);
new_type(Û"ISUB"Ý, 0);
declare_type_abbrev (Û"CATM"Ý, [], ”ISUB ð + (ACAT ¸ (ISUB ­ BOOL)ð)®);
declare_type_abbrev (Û"CAT"Ý, [], ”ONE + ACAT®);
=TEX

We name the category of substances.

¹HOLCONST
Ü ÛCatSubsÝ : CAT
÷üüüüüü
Ü CatSubs = InL One
°

Now we define various operators over categories and their constituents which suffice for the development of an appropriate theory, in the context of which rest of the Aristotelian terminology will we hope prove definable.

First ``projection'' functions which yield the constituents of $MCAT$s.

¹HOLCONST
Ü ÛCatÝ : CATM ­ CAT
÷üüüüüü
Ü µx· Cat x = if IsL x then CatSubs else InR(Fst (OutR x))
°

¹HOLCONST
Ü ÛIndvSetÝ : CATM ­ ISUB ð
÷üüüüüü
Ü µx· IndvSet x = OutL x
°

¹HOLCONST
Ü ÛAttrSetÝ : CATM ­ (ISUB ­ BOOL)ð
÷üüüüüü
Ü µx· AttrSet x = Snd(OutR x)
°

This one turns out handy.

¹HOLCONST
Ü ÛCatSetÝ : CATM ­ (ISUB + (ISUB ­ BOOL))ð
÷üüüüüü
Ü µx· CatSet x =
Ü	if Cat x = CatSubs
Ü	then {y | ¶z· z  IndvSet x ± y = InL z}
Ü	else {y | ¶z· z  AttrSet x ± y = InR z}
°

With these definitions in place we get a useful characterisation of identity for elements of $CATM$.

=GFT
catm_eq_lemma =
	ô µ A B· A = B ¤ Cat A = Cat B ± CatSet A = CatSet B
=TEX

\ignore{
=SML
set_goal([], ¬µA B· A = B ¤ Cat A =  Cat B ± CatSet A = CatSet B®);
a (REPEAT µ_tac THEN rewrite_tac [get_spec ¬Cat®, get_spec ¬CatSet®]);
a (strip_asm_tac (µ_elim ¬A® sum_cases_thm) THEN asm_rewrite_tac[]
	THEN REPEAT_N 3 (TRY strip_tac)
	THEN_TRY asm_rewrite_tac[]);
(* *** Goal "1" *** *)
a (POP_ASM_T (asm_tac o eq_sym_rule)
	THEN asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a (lemma_tac ¬IsL B®);
(* *** Goal "2.1" *** *)
a (swap_nth_asm_concl_tac 2
	THEN asm_rewrite_tac[get_spec ¬CatSubs®]);
(* *** Goal "2.2" *** *)
a (swap_nth_asm_concl_tac 2
	THEN rewrite_tac[asm_rule ¬IsL B®, sets_ext_clauses, get_spec ¬IndvSet®]);
a (strip_tac);
a (lemma_tac ¬³ y = OutL B®);
(* *** Goal "2.2.1" *** *)
a (swap_nth_asm_concl_tac 1 THEN asm_rewrite_tac[get_spec ¬InL®]);
a (GET_ASM_T ¬IsL B® (rewrite_thm_tac o (rewrite_rule [sum_clauses])));
(* *** Goal "2.2.2" *** *)
a (swap_nth_asm_concl_tac 1 THEN rewrite_tac[sets_ext_clauses]);
a (swap_nth_asm_concl_tac 1);
(* *** Goal "2.2.2.1" *** *)
a (strip_tac THEN ¶_tac ¬InL x® THEN asm_rewrite_tac[]);
a (contr_tac THEN asm_fc_tac[] THEN_TRY all_var_elim_asm_tac);
a (spec_nth_asm_tac 2 ¬x®);
(* *** Goal "2.2.2.2" *** *)
a (strip_tac THEN ¶_tac ¬InL x® THEN asm_rewrite_tac[]);
a (contr_tac THEN asm_fc_tac[] THEN_TRY all_var_elim_asm_tac);
a (spec_nth_asm_tac 1 ¬x®);
(* *** Goal "3" *** *)
a (POP_ASM_T (asm_tac o eq_sym_rule) THEN asm_rewrite_tac[]);
(* *** Goal "4" *** *)
a (lemma_tac ¬³ IsL B®);
(* *** Goal "4.1" *** *)
a (swap_nth_asm_concl_tac 2
	THEN asm_rewrite_tac[get_spec ¬CatSubs®]);
(* *** Goal "4.2" *** *)
a (swap_nth_asm_concl_tac 2
	THEN rewrite_tac[asm_rule ¬³ IsL B®, sets_ext_clauses, get_spec ¬IndvSet®]);
a (strip_tac);
a (lemma_tac ¬³ z = OutR B®);
(* *** Goal "4.2.1" *** *)
a (swap_nth_asm_concl_tac 1 THEN asm_rewrite_tac[get_spec ¬InR®]);
a (LEMMA_T ¬IsR B® (rewrite_thm_tac o (rewrite_rule [sum_clauses])));
a (DROP_ASM_T ¬³ IsL B® ante_tac
	THEN strip_asm_tac (µ_elim ¬B® sum_cases_thm)
	THEN asm_rewrite_tac[]);
(* *** Goal "4.2.2" *** *)
a (asm_rewrite_tac[get_spec ¬CatSubs®, get_spec ¬AttrSet®]);
a (lemma_tac ¬³ Snd z = Snd(OutR B)®
	THEN1 swap_asm_concl_tac ¬³ z = OutR B®);
(* *** Goal "4.2.2.1" *** *)
a (LEMMA_T ¬z = (Fst z, Snd z)® pure_once_rewrite_thm_tac THEN1 prove_tac[]);
a (pure_asm_rewrite_tac[]);
a (LEMMA_T ¬Fst z = Fst (OutR B)® rewrite_thm_tac);
a (swap_asm_concl_tac ¬InR (Fst z) = (if IsL B then CatSubs else InR (Fst (OutR B)))®);
a (asm_rewrite_tac[]);
a (swap_nth_asm_concl_tac 1);
a (rewrite_tac [sets_ext_clauses]);
a (swap_nth_asm_concl_tac 1);
a (strip_tac THEN ¶_tac ¬InR x® THEN asm_rewrite_tac[]);
a (REPEAT strip_tac THEN_TRY all_var_elim_asm_tac);
a (spec_nth_asm_tac 1 ¬x®);
a (spec_nth_asm_tac 1 ¬z'®);
(* *** Goal "4.2.2.2.2" *** *)
a (strip_tac THEN ¶_tac ¬InR x® THEN asm_rewrite_tac[]);
a (REPEAT strip_tac THEN_TRY all_var_elim_asm_tac);
(* *** Goal "4.2.2.2.2.1" *** *)
a (¶_tac ¬x®);
a (asm_rewrite_tac []);
(* *** Goal "4.2.2.2.2.2" *** *)
a (¶_tac ¬z'®);
a (asm_rewrite_tac []);
val catm_eq_lemma = save_pop_thm "catm_eq_lemma";
=TEX
}%ignore

\subsubsection{Predication}

Now we can define predication.
We do this in terms of Grice's $izz$ and $hazz$.

=SML
declare_infix (300, "izz");
declare_infix (300, "hazz");
=TEX

¹HOLCONST
Ü $ÛizzÝ : CATM ­ CATM ­ BOOL
÷üüüüüü
Ü µA B· A izz B ¤ Cat A = Cat B ± CatSet A € CatSet B
°

¹HOLCONST
Ü $ÛhazzÝ : CATM ­ CATM ­ BOOL
÷üüüüüü
Ü µA B· A hazz B ¤ Cat A = CatSubs ± ³ Cat B = CatSubs
Ü	± ¶a· a  AttrSet B ± µs· s  IndvSet A ´ a s
°

That was reasonably neat, but the definition of $izz$ isn't terribly convenient for proving things.
Lets have some $izz$ lemmas:

=GFT
izz_lemma1 =
    ô µ A B· Cat A = CatSubs ´ (A izz B ¤ Cat B = CatSubs ± IndvSet A € IndvSet B)

izz_lemma2 =
    ô µ A B· Cat B = CatSubs ´ (A izz B ¤ Cat A = CatSubs ± IndvSet A € IndvSet B)

izz_lemma3 =
    ô µ A B· ³ Cat A = CatSubs ´ (A izz B ¤ Cat B = Cat A ± AttrSet A € AttrSet B)

izz_lemma4 =
    ô µ A B· ³ Cat B = CatSubs ´ (A izz B ¤ Cat B = Cat A ± AttrSet A € AttrSet B)
=TEX

\ignore{
=SML
set_goal([], ¬µA B· Cat A = CatSubs ´ (A izz B ¤ Cat B = CatSubs ± IndvSet A € IndvSet B)®);
a (REPEAT µ_tac THEN rewrite_tac[get_spec ¬$izz®, get_spec ¬CatSet®]); 
a (strip_tac THEN_TRY asm_rewrite_tac[] THEN REPEAT strip_tac THEN_TRY asm_rewrite_tac[]);
(* *** Goal "1" *** *)
a (POP_ASM_T ante_tac THEN asm_rewrite_tac[sets_ext_clauses] THEN REPEAT strip_tac);
a (spec_nth_asm_tac 2 ¬(InL x):ISUB + (ISUB ­ BOOL)®);
(* *** Goal "1.1" *** *)
a (spec_nth_asm_tac 1 ¬x®);
(* *** Goal "1.2" *** *)
a (asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a (POP_ASM_T ante_tac THEN asm_rewrite_tac[sets_ext_clauses] THEN REPEAT strip_tac);
a (¶_tac ¬z® THEN asm_rewrite_tac[]);
a (all_asm_fc_tac[]);
val izz_lemma1 = save_pop_thm "izz_lemma1";

set_goal([], ¬µA B· Cat B = CatSubs ´ (A izz B ¤ Cat A = CatSubs ± IndvSet A € IndvSet B)®);
a (REPEAT µ_tac THEN rewrite_tac[get_spec ¬$izz®, get_spec ¬CatSet®]); 
a (strip_tac THEN_TRY asm_rewrite_tac[] THEN REPEAT strip_tac THEN_TRY asm_rewrite_tac[]);
(* *** Goal "1" *** *)
a (POP_ASM_T ante_tac THEN asm_rewrite_tac[sets_ext_clauses] THEN REPEAT strip_tac);
a (spec_nth_asm_tac 2 ¬(InL x):ISUB + (ISUB ­ BOOL)®);
(* *** Goal "1.1" *** *)
a (spec_nth_asm_tac 1 ¬x®);
(* *** Goal "1.2" *** *)
a (asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a (POP_ASM_T ante_tac THEN asm_rewrite_tac[sets_ext_clauses] THEN REPEAT strip_tac);
a (¶_tac ¬z® THEN asm_rewrite_tac[]);
a (all_asm_fc_tac[]);
val izz_lemma2 = save_pop_thm "izz_lemma2";

set_goal([], ¬µA B· ³ Cat A = CatSubs ´ (A izz B ¤ Cat B = Cat A ± AttrSet A € AttrSet B)®);
a (REPEAT µ_tac THEN rewrite_tac[get_spec ¬$izz®, get_spec ¬CatSet®]); 
a (strip_tac THEN_TRY asm_rewrite_tac[] THEN REPEAT strip_tac THEN_TRY asm_rewrite_tac[]);
(* *** Goal "1" *** *)
a (POP_ASM_T ante_tac THEN asm_rewrite_tac[sets_ext_clauses]);
a (DROP_NTH_ASM_T 2 ante_tac THEN asm_rewrite_tac[] THEN strip_tac THEN asm_rewrite_tac[] THEN REPEAT strip_tac);
a (spec_nth_asm_tac 2 ¬(InR x):ISUB + (ISUB ­ BOOL)®);
(* *** Goal "1.1" *** *)
a (spec_nth_asm_tac 1 ¬x®);
(* *** Goal "1.2" *** *)
a (asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a (POP_ASM_T ante_tac THEN asm_rewrite_tac[sets_ext_clauses] THEN REPEAT strip_tac);
a (¶_tac ¬z® THEN asm_rewrite_tac[]);
a (all_asm_fc_tac[]);
val izz_lemma3 = save_pop_thm "izz_lemma3";

set_goal([], ¬µA B· ³ Cat B = CatSubs ´ (A izz B ¤ Cat B = Cat A ± AttrSet A € AttrSet B)®);
a (REPEAT µ_tac THEN rewrite_tac[get_spec ¬$izz®, get_spec ¬CatSet®]); 
a (strip_tac THEN_TRY asm_rewrite_tac[] THEN REPEAT strip_tac THEN_TRY asm_rewrite_tac[]);
(* *** Goal "1" *** *)
a (POP_ASM_T ante_tac THEN asm_rewrite_tac[sets_ext_clauses] THEN REPEAT strip_tac);
a (spec_nth_asm_tac 2 ¬(InR x):ISUB + (ISUB ­ BOOL)®);
(* *** Goal "1.1" *** *)
a (spec_nth_asm_tac 1 ¬x®);
(* *** Goal "1.2" *** *)
a (asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a (POP_ASM_T ante_tac 
	THEN SYM_ASMS_T rewrite_tac
	THEN asm_rewrite_tac[sets_ext_clauses]
	THEN REPEAT strip_tac);
a (¶_tac ¬z® THEN asm_rewrite_tac[]);
a (all_asm_fc_tac[]);
val izz_lemma4 = save_pop_thm "izz_lemma4";
=TEX
}%ignore

\subsubsection{The Principles in HOL}

Here are the HOL versions of the Code ``Principles''.

The following is a bit of program in a programming language called SML, which stands for "Standard Meta Language"!
It names various terms in HOL, the name on the left `c01' (short for `conjecture 1'), the term on the right quoted in ``Quine corners''.
\footnote{``Quine corners'' are a notation originally used by Quine for Godel numbers, i.e., in Quine's use `¬43®' is a friendly way of writing doen the Godel number of the numeral `43'.
In ProofPower HOL these corners are used to refer to HOL terms in the metalanguage SML.
In HOL, a formula is a term of type ”BOOL® (the opening ” is used when quoting a type rather than a term).}

=SML
val c01 = ¬µA· A izz A®;
val c02 = ¬µA B C· A izz B ± B izz C ´ A izz C®;
val c03 = ¬µA B· A hazz B ´ ³ A izz B®;
val c04 = ¬µA B· A hazz B ¤ ¶C· A hazz C ± C izz B®;
=TEX

One would expect this set of principles to be sufficient to characterise {\it izz} and {\it hazz} (i.e. sufficient to derive any other true facts about them) but this seems doubtful.

Here are some supplementary conjectures.

=SML
val c01b = ¬µA· ³ A hazz A®;
val c03b = ¬µA B· A izz B ´ ³ A hazz B®;
val c03c = ¬µA B· A hazz B ´ ³ A = B®;
val c04a = ¬µA B C· A hazz B ± B izz C ´ A hazz C®;
val c04b = ¬µA B C· A izz B ± B hazz C ´ A hazz C®;
=TEX

Of the supplementaries:

\begin{itemize}
\item c01b is derivable from c03 and c01.
\item c03b is the contrapositive of c03.
\item c03c would be derivable for Code once he has defined equality, it is provable for us now because we have a primitive equality.
\item c04a is a preferable formulation of the right-left implication in c04, and we have used it to prove c04.
\item c04b is an obvious further transitivity-like property, which does not look like it's provable from the stipulated principles.
\end{itemize}

\ignore{
=SML
set_goal([], c01);
a (REPEAT µ_tac THEN_TRY rewrite_tac [get_spec ¬$izz®]);
val l01 = save_pop_thm "l01";

set_goal([], c01b);
a (REPEAT µ_tac THEN_TRY rewrite_tac [get_spec ¬$hazz®] THEN contr_tac);
val l01b = save_pop_thm "l01b";

set_goal([], c02);
a (REPEAT µ_tac THEN_TRY rewrite_tac [get_spec ¬$izz®]
	THEN REPEAT strip_tac
	THEN_TRY asm_rewrite_tac[]
	THEN all_asm_fc_tac[€_trans_thm]);
val l02 = save_pop_thm "l02";

set_goal([], c03);
a (REPEAT µ_tac THEN_TRY rewrite_tac [get_spec ¬$izz®, get_spec ¬$hazz®] THEN contr_tac);
a (DROP_NTH_ASM_T 5 ante_tac
	THEN DROP_NTH_ASM_T 5 ante_tac
	THEN asm_rewrite_tac[]);
val l03 = save_pop_thm "l03";

set_goal([], c03b);
a (REPEAT µ_tac THEN_TRY rewrite_tac [get_spec ¬$izz®, get_spec ¬$hazz®] THEN REPEAT strip_tac);
a (asm_rewrite_tac[]);
val l03b = save_pop_thm "l03b";

set_goal([], c03c);
a (REPEAT µ_tac THEN_TRY rewrite_tac [get_spec ¬$izz®, get_spec ¬$hazz®] THEN contr_tac);
a (all_var_elim_asm_tac);
val l03c = save_pop_thm "l03c";

set_goal([], c04a);
a (REPEAT µ_tac THEN rewrite_tac [get_spec ¬$hazz®, get_spec ¬CatSet®]
	THEN contr_tac);
(* *** Goal "1" *** *)
a (all_fc_tac [izz_lemma2]);
(* *** Goal "2" *** *)
a (all_asm_fc_tac[]);
a (all_fc_tac [list_µ_elim [¬B®] izz_lemma3]);
a (POP_ASM_T ante_tac THEN rewrite_tac [sets_ext_clauses]
	THEN REPEAT strip_tac
	THEN asm_fc_tac[]);
a (¶_tac ¬a® THEN contr_tac);
val l04a = save_pop_thm "l04a";

set_goal([], c04);
a (REPEAT strip_tac);
(* *** Goal "1" *** *)
a (¶_tac ¬B® THEN asm_rewrite_tac[l01]);
(* *** Goal "2" *** *)
a (all_fc_tac [list_µ_elim [¬A®, ¬C®] l04a]);
val l04 = save_pop_thm "l04";

set_goal([], c04b);
a (REPEAT µ_tac THEN rewrite_tac [get_spec ¬$hazz®, get_spec ¬CatSet®]
	THEN contr_tac);
(* *** Goal "1" *** *)
a (all_fc_tac [izz_lemma2]);
(* *** Goal "2" *** *)
a (spec_nth_asm_tac 1 ¬a®);
a (FC_T (MAP_EVERY ante_tac) [get_spec ¬$izz®]);
a (strip_tac THEN asm_rewrite_tac [get_spec ¬CatSet®, sets_ext_clauses]
	THEN strip_tac);
a (¶_tac ¬InL s® THEN REPEAT strip_tac);
(* *** Goal "2.1" *** *)
a (¶_tac ¬s® THEN REPEAT strip_tac);
(* *** Goal "2.2" *** *)
a (contr_tac THEN asm_fc_tac[]);
a (all_var_elim_asm_tac);
val l04b = save_pop_thm "l04b";
=TEX
}%ignore

=GFT Proven Theorems
l01	= ô µ A· A izz A
l01b 	= ô µ A· ³ A hazz A
l02	= ô µ A B C· A izz B ± B izz C ´ A izz C
l03	= ô µ A B· A hazz B ´ ³ A izz B
l03b 	= ô µ A B· A izz B ´ ³ A hazz B
l03c 	= ô µ A B· A hazz B ´ ³ A = B
l04a	= ô µ A B C· A hazz B ± B izz C ´ A hazz C
l04	= ô µ A B· A hazz B ¤ (¶ C· A hazz C ± C izz B) 
l04b 	= ô µ A B C· A izz B ± B hazz C ´ A hazz C
=TEX

\subsection{Total Definitions}

=GFT Code/Speranza
[(B) Total Definitions]

{6. (A hazz B & A is a particular) -> there is a C such that (C =/= A) & (A izz B).}

[D1] 7. A is predicable of B iff ((B izz A) ² (B hazz Something that izz A).
[D2] 8. A is essentially predicable [L-predicable] of B iff B izz A.
[D3] 9. A is accidentally predicable [H-predicable] of B iff B hazz something that izz A.
[D4] 10. A = B iff A izz B & B izz A.
[D5] 11. A is an individual iff (Nec)(For all B) B izz A -> A izz B
[D6] 12. A is a particular iff (Nec)(For all B) A is predicable of B -> (A izz B & B izz A)
[D7] 13. A is a universal iff
		(Poss) (There is a B) A is predicable of A[B] & -(A izz B & B izz A)
=TEX

There is a certain amount of duplication of terminology here, since essential and accidental predication seem to be just $izz$ and $hazz$ backwards.
I'm not so happy with the ``ables'' here, for what is clearly meant is ``truly predicable'', which is not quite the same thing.
Better names would be simply ``is\_essentially'' and ``is\_accidentally'', lacking the ambiguity of ``able'' (but then they would have to be the other way round, exactly the same as $izz$ and $hazz$).

Anyway here are the definitions (keeping the names (more or less) as they were for the present):

=SML
declare_infix (300, "predicable_of");
declare_infix (300, "essentially_predicable_of");
declare_infix (300, "accidentally_predicable_of");
=TEX

¹HOLCONST
Ü $Ûessentially_predicable_ofÝ : CATM ­ CATM ­ BOOL
÷üüüüüü
Ü µA B· A essentially_predicable_of B ¤ B izz A
°

¹HOLCONST
Ü $Ûaccidentally_predicable_ofÝ : CATM ­ CATM ­ BOOL
÷üüüüüü
Ü µA B· A accidentally_predicable_of B ¤ B hazz A
°

Aristotelian predication is then:

¹HOLCONST
Ü $Ûpredicable_ofÝ : CATM ­ CATM ­ BOOL
÷üüüüüü
Ü µA B· A predicable_of B ¤ A essentially_predicable_of B ² A accidentally_predicable_of B
°

Because we have not precluded empty predicates Code's definition will not do, and we have to make ``individual'' primitive, insisting on an individual being a singleton.

¹HOLCONST
Ü ÛindividualÝ : CATM ­ BOOL
÷üüüüüü
Ü µA· individual A ¤ ¶a· CatSet A = {a}
°

According to Code's definition a particular is a substantial individual, we also have to use a more direct statemant of that principle.

¹HOLCONST
Ü ÛparticularÝ : CATM ­ BOOL
÷üüüüüü
Ü µA· particular A ¤ individual A ± Cat A = CatSubs
°

Again we have a problem with Code's definition and therefore define a universal as a non-particular.

¹HOLCONST
Ü ÛuniversalÝ : CATM ­ BOOL
÷üüüüüü
Ü µA· universal A ¤ ³ particular A
°

=SML
val c06 = ¬µA B· A hazz B ± particular A ´ ¶C· C ½ A ± A izz B®; 
val c06n = ¬³ µA B· A hazz B ± particular A ´ ¶C· C ½ A ± A izz B®; 
val c07 = ¬µA B· A predicable_of B ¤ (B izz A) ² ¶C· B hazz C ± C izz A®;
val c08 = ¬µA· A essentially_predicable_of B ¤ B izz A®;
val c09 = ¬µA· A accidentally_predicable_of B ¤ ¶C· B hazz C ± C izz A®;
val c10 = ¬µA B· A = B ¤ A izz B ± B izz A®;
val c11 = ¬µA B· individual A ¤ ©(µB· B izz A ´ A izz B)®;
val c12 = ¬µA· particular A ¤ ©(µB· A predicable_of B ´ A izz B ± B izz A)®;
val c13 = ¬µA· universal A ¤ ¨(¶B· (A predicable_of B ± ³(A izz B ± B izz A)))®;
=TEX

\ignore{
=SML
set_goal([], c06n);
a (strip_tac);
a (¶_tac ¬InL {Åi:ISUB·T}®);
a (strip_tac);
a (¶_tac ¬InR ((Åc:ACAT·T), {Ìi·T})®);
a (rewrite_tac[get_spec ¬$hazz®, get_spec ¬Cat®, get_spec ¬CatSubs®,
	get_spec ¬$izz®, get_spec ¬AttrSet®, get_spec ¬particular®, get_spec ¬individual®,
	get_spec ¬CatSet®, get_spec ¬IndvSet®]);
a (REPEAT strip_tac);
(* *** Goal "1" *** *)
a (¶_tac ¬Ì i· T® THEN rewrite_tac[]);
(* *** Goal "2" *** *)
a (¶_tac ¬InL (Å i· T)® THEN rewrite_tac[sets_ext_clauses]);
a (REPEAT strip_tac THEN_TRY asm_rewrite_tac[]);
a (¶_tac ¬Å i· T® THEN rewrite_tac[]);
val l06n = save_pop_thm "l06n";

set_goal([], c07);
a (REPEAT µ_tac);
a (rewrite_tac [get_spec ¬$predicable_of®, get_spec ¬$essentially_predicable_of®,
		get_spec ¬$accidentally_predicable_of®]);
a (rewrite_tac [list_µ_elim [¬B®, ¬A®] l04]);
val l07 = save_pop_thm "l07";

set_goal([], c08);
a (rewrite_tac [get_spec ¬$essentially_predicable_of®]);
val l08 = save_pop_thm "l08";

set_goal([], c09);
a (REPEAT µ_tac);
a (rewrite_tac [get_spec ¬$accidentally_predicable_of®, list_µ_elim [¬B®, ¬A®] l04]);
val l09 = save_pop_thm "l09";

set_goal([], c10);
a (REPEAT µ_tac THEN rewrite_tac [get_spec ¬$izz®, catm_eq_lemma]);
a (REPEAT strip_tac THEN_TRY asm_rewrite_tac[]);
a (all_fc_tac [pc_rule1 "hol1" prove_rule [] ¬µa b· a € b ± b € a ´ a = b®]);
val l10 = save_pop_thm "l10";
=TEX
}%ignore

=GFT
l05 	= ô µ x· form x ´ universal x
l06n 	= ô ³ (µ A B· A hazz B ± particular A ´ (¶ C· C ½ A ± A izz B))
l07 	= ô µ A B· A predicable_of B ¤ B izz A ² (¶ C· B hazz C ± C izz A)
l08 	= ô µ A· A essentially_predicable_of B ¤ B izz A
l09 	= ô µ A· A accidentally_predicable_of B ¤ (¶ C· B hazz C ± C izz A)
l10	= ô µ A B· A = B ¤ A izz B ± B izz A
=TEX

c06 is false (see l06n), probably a typo.
However, I couldn't work out what was intended.

c11-13 are not provable in our model because of the existence of empty predicates (and the lack of modal operators).

\subsection{Partial Definitions}

=GFT Code/Speranza
[(C) Partial Definitions]

[D8] 14. If A is Some Thing [a this somewhat], A is an  individual.
[D9] 15. If A is a [(seperable) Platonic] Form,
		A is Some Thing [a this somewhat] and Universal.
=TEX

\ignore{
=SML
set_goal ([],¬¶SomeThing· µx· SomeThing x ´ individual x®);
a (¶_tac ¬individual® THEN rewrite_tac[]);
save_cs_¶_thm(pop_thm());
=TEX
}%ignore

This is D8/c14.

¹HOLCONST
Ü ÛSomeThingÝ : CATM ­ BOOL
÷üüüüüü
Ü µx· SomeThing x ´ individual x
°

A form is a non-substantial individual.

\ignore{
=SML
set_goal ([],¬¶form· µx· form x ´ SomeThing x ± universal x®);
a (¶_tac ¬Ìx· SomeThing x ± universal x® THEN rewrite_tac[]);
save_cs_¶_thm(pop_thm());
=TEX
}%ignore

This is D9/c15

¹HOLCONST
Ü ÛformÝ : CATM ­ BOOL
÷üüüüüü
Ü µx· form x ´ SomeThing x ± universal x
°

\subsection{Ontological Theorems}

=GFT Code/Speranza
[(D) Ontological Theorems]

[T1] 16. A is predicable of B iff (B izz A) v (B hazz Some Thing that Izz A).
[T2] 17. A is essentially predicable [L-predicable] of A.
[T3] 18. A is accidentally predicable [H-predicable] of B ->  A =/= B
[T4] A is not accidentally predicable [H-predicable] of A
{19. - (A is accidentally predicable of B) -> A =/= B.}
[T5] 20. A is a particular -> A is an individual.
	[Note that the converse of T5 is not a theorem]
[T6] 21. A is a particular -> No Thing [nothing] that is Not Identical with A izz A.
[T7] 22. No Thing is both particular & a [(separable) Platonic] Form.
[T8] 23. A is a (seperable Platonic) Form -> nothing that is not identical with A izz A.
[T9] 24. A is a particular -> there is no (seperable Platonic) form B such that A izz B.
[T10] 25. A is a (seperable Platonic) form
		-> ((A is predicable of B & A =/= B) -> B hazz A)
[T11] 26. (A is a (seperable Platonic) form & B is a particular)
		-> (A is predicable of B iff B hazz A).
=TEX

=SML
val c05 = ¬µx· universal x ´ form x®;
val c05b = ¬µx· form x ´ universal x®;
val c16 = ¬µA B· A predicable_of B ¤ (B izz A) ² ¶C· (B hazz C ± C izz A)®;
val c17 = ¬µA· A essentially_predicable_of A®;
val c18 = ¬µA· A accidentally_predicable_of B ´ A ½ B®;
val c19 = ¬µA· ³ A accidentally_predicable_of A®;
val c20 = ¬µA· particular A ´ individual A®;
val c21 = ¬µA· particular A ´ ³ ¶C· C ½ A ± C izz A®;
val c22 = ¬³ ¶A· particular A ± form A®;
val c23 = ¬µA· form A ´ ³ ¶C· C ½ A ± C izz A®;
val c23b = ¬µA· form A ´ individual A®;
val c24a = ¬µ A B· particular A ± individual B ± A izz B ´ particular B®;
val c24 = ¬µA· particular A ´ ³ ¶B· form B ± A izz B®;
val c24b = ¬µA· particular A ´ ³ form A®;
val c25 = ¬µA B· form A ´ A predicable_of B ± A ½ B ´ B hazz A®;
val c26 = ¬µA B· form A ± particular B ´ (A predicable_of B ¤ B hazz A)®;
=TEX

\ignore{
=SML
=IGN
set_goal([], c06n);
a (strip_tac);
a (¶_tac ¬InL{Åx:ISUB·T}:CATM® THEN strip_tac);
a (¶_tac ¬InR((Åx:ACAT·T), {Ìx:ISUB·T}):CATM® THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a (rewrite_tac (map get_spec [¬$hazz®, ¬Cat®, ¬CatSubs®]));
a (¶_tac ¬Ìx:ISUB·T®);
a (rewrite_tac (map get_spec [¬AttrSet®]));
(* *** Goal "2" *** *)
a (rewrite_tac (map get_spec [¬particular®, ¬individual®]) THEN strip_tac);
(* *** Goal "2.1" *** *)
a (¶_tac ¬InL(Å x:ISUB· T):ISUB + (ISUB ­ BOOL)®);
a (rewrite_tac [get_spec ¬CatSet®, get_spec ¬Cat®, get_spec ¬IndvSet®, sets_ext_clauses]);
a (REPEAT strip_tac THEN_TRY asm_rewrite_tac[]);
a (¶_tac ¬Å x:ISUB· T®);
a (rewrite_tac[]);
(* *** Goal "2.2" *** *)
a (rewrite_tac [get_spec ¬Cat®]);
(* *** Goal "3" *** *)
a (swap_nth_asm_concl_tac 1);
a (rewrite_tac[get_spec ¬$izz®, get_spec ¬Cat®, get_spec ¬CatSubs®]);
val l06n = save_pop_thm "l06n";
=SML

set_goal([], c16);
a (rewrite_tac [map_eq_sym_rule l04]);
a (REPEAT µ_tac THEN rewrite_tac [get_spec ¬$predicable_of®,
	get_spec ¬$essentially_predicable_of®, get_spec ¬$accidentally_predicable_of®]);
val l16 = save_pop_thm "l16";

set_goal([], c17);
a (REPEAT µ_tac THEN rewrite_tac [get_spec ¬$essentially_predicable_of®, l01]);
val l17 = save_pop_thm "l17";

set_goal([], c18);
a (REPEAT µ_tac THEN rewrite_tac [get_spec ¬$accidentally_predicable_of®, get_spec ¬$½®]);
a (strip_tac THEN fc_tac [l03c]);
a (swap_nth_asm_concl_tac 1 THEN asm_rewrite_tac[]);
val l18 = save_pop_thm "l18";

set_goal([], c19);
a (rewrite_tac [get_spec ¬$accidentally_predicable_of®, l01b]);
val l19 = save_pop_thm "l19";

set_goal([], c20);
a (REPEAT µ_tac THEN rewrite_tac [get_spec ¬$particular®]
	THEN contr_tac);
val l20 = save_pop_thm "l20";

=IGN
set_goal([], c21);
a (REPEAT µ_tac THEN rewrite_tac [get_spec ¬$particular®]
	THEN contr_tac);
val l21 = save_pop_thm "l21";
=SML

set_goal([], c22);
a (contr_tac);
a (fc_tac [get_spec ¬form®]);
a (fc_tac [get_spec ¬universal®]);
val l22 = save_pop_thm "l22";

set_goal([], c23b);
a (REPEAT strip_tac THEN fc_tac [get_spec ¬form®]);
a (fc_tac [get_spec ¬SomeThing®, get_spec ¬universal®]);
val l23b = save_pop_thm "l23b";

set_goal([], c24a);
a (REPEAT µ_tac THEN rewrite_tac [get_spec ¬particular®, get_spec ¬individual®,
		get_spec ¬$izz®]
	THEN strip_tac THEN strip_tac);
(* *** Goal "1" *** *)
a (¶_tac ¬a'® THEN asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a (SYM_ASMS_T rewrite_tac);
val l24a = save_pop_thm "l24a";

set_goal([], c24);
a (contr_tac THEN fc_tac [get_spec ¬form®]);
a (fc_tac [get_spec ¬SomeThing®, get_spec ¬universal®, get_spec ¬particular®, get_spec ¬individual®]);
a (all_fc_tac [l24a]);
val l24 = save_pop_thm "l24";

=IGN
set_goal([], c25b);
a (REPEAT µ_tac THEN rewrite_tac [get_spec ¬$predicable_of®, get_spec ¬$accidentally_predicable_of®,
	get_spec ¬$essentially_predicable_of®, get_spec ¬$izz®] THEN strip_tac
	THEN fc_tac [get_spec ¬form®]);
a (fc_tac [get_spec ¬SomeThing®, get_spec ¬universal®]);
a (DROP_ASM_T ¬³ particular A® (strip_asm_tac o (rewrite_rule [get_spec ¬particular®])));
a (REPEAT strip_tac);
a (rewrite_tac[get_spec ¬$hazz®] );

a (rewrite_tac [get_spec ¬$predicable_of®, get_spec ¬$accidentally_predicable_of®, get_spec ¬$essentially_predicable_of®,
	get_spec ¬$izz®]
	THEN contr_tac);
a (DROP_ASM_T ¬Cat B = CatSubs® ante_tac);
a (asm_rewrite_tac[]);
val l25 = save_pop_thm "l25";
=SML

set_goal([], c26);
a (REPEAT µ_tac THEN rewrite_tac [get_spec ¬particular®] THEN strip_tac
	THEN fc_tac [get_spec ¬form®, get_spec ¬SomeThing®]);
a (fc_tac [get_spec ¬SomeThing®, get_spec ¬universal®]);
a (DROP_ASM_T ¬³ particular A® (strip_asm_tac o (rewrite_rule [get_spec ¬particular®])));
a (rewrite_tac [get_spec ¬$predicable_of®, get_spec ¬$accidentally_predicable_of®, get_spec ¬$essentially_predicable_of®,
	get_spec ¬$izz®]
	THEN contr_tac);
a (DROP_ASM_T ¬Cat B = CatSubs® ante_tac);
a (asm_rewrite_tac[]);
val l26 = save_pop_thm "l26";
=TEX
}%ignore

These are the ones I have proved.

=GFT
l16 	= ô µ A B· A predicable_of B ¤ B izz A ² (¶ C· B hazz C ± C izz A)
l17 	= ô µ A· A essentially_predicable_of A
l19 	= ô µ A· ³ A accidentally_predicable_of A
l20 	= ô µ A· individual A ´ particular A
l22 	= ô ³ (¶ A· particular A ± form A)
l23b 	= ô µ A· form A ´ individual A
l24a 	= ô µ A B· particular A ± individual B ± A izz B ´ particular B
l24 	= ô µ A· particular A ´ ³ (¶ B· form B ± A izz B)
l26 	= ô µ A B· form A ± particular B ´ (A predicable_of B ¤ B hazz A)
=TEX

T6/c21, T8/c23, T10/c25 are all unprovable because of the existence of empty predicates.

\subsection{Platonic Principles and Theorems}

This section is a bit of a mess.
I have not yet worked out what is going on here.

=GFT Code/Speranza
[(E) Platonic Principle]

[PP1] 5. Each universal is a (seperable Platonic) form.
[PP2] 27. (A is particular & B is a universal & predicable of A)
	-> there is a C such that (A =/= C  & C is essentially predicable of A)
=TEX

=SML
val c05 = ¬µx· universal x ´ form x®;
val c05b = ¬µx· form x ´ universal x®;
val c27 = ¬µA B· particular A ± universal B ± B predicable_of A
		´ ¶C· (A ½ C ± C essentially_predicable_of A)®;
=TEX

\ignore{
=SML
set_goal([], c05b);
a (REPEAT strip_tac THEN fc_tac [get_spec ¬form®]);
val l05b = save_pop_thm "l05b";

=IGN
set_goal([], c27);
a (REPEAT strip_tac THEN fc_tac [get_spec ¬form®]);
val l05b = save_pop_thm "l05b";
=TEX
}%ignore

c05 is not provable, its converse c05b is.
c27 is not provable, since it would require that there be more than one particular and we have no reason to believe that to be the case.

=GFT
l05b 	= ô µ x· form x ´ universal x
=TEX

=GFT Code/Speranza
[(F) Platonic Theorem]

{28. If there are particulars, of which universals are predicable,
	not every universal is Some Thing.}
[PP1] 29. Each universal is Some Thing [a this somewhat].
[PP2] 30. If A is a particular, there is no B such that
	(A =/= B &  B is essentially predicable of A).
[PP3] 31. (A is predicable of B & A =/= B) -> A is accidentally predicable of B.
=TEX

=SML
val c28 = ¬(¶P· particular P ± ¶U· universal U ± U predicable_of P)
		´ ³ (µU· universal U ´ thing U)®;
val c29 = ¬µU· universal U ´ thing U®;
val c30 = ¬µA· particular A ´ ³ ¶B· (A ½ B ± B essentially_predicable_of A)®;
val c31 = ¬µA B· A predicable_of B ± A ½ B ´ A accidentally_predicable_of B®;
=TEX

\ignore{
=SML

=IGN
set_goal([], c06n);
a (strip_tac);
a (¶_tac ¬InL{Åx:ISUB·T}:CATM® THEN strip_tac);
a (¶_tac ¬InR((Åx:ACAT·T), {Ìx:ISUB·T}):CATM® THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a (rewrite_tac (map get_spec [¬$hazz®, ¬Cat®, ¬CatSubs®]));
a (¶_tac ¬Ìx:ISUB·T®);
a (rewrite_tac (map get_spec [¬AttrSet®]));
(* *** Goal "2" *** *)
a (rewrite_tac (map get_spec [¬particular®, ¬individual®]) THEN strip_tac);
(* *** Goal "2.1" *** *)
a (¶_tac ¬InL(Å x:ISUB· T):ISUB + (ISUB ­ BOOL)®);
a (rewrite_tac [get_spec ¬CatSet®, get_spec ¬Cat®, get_spec ¬IndvSet®, sets_ext_clauses]);
a (REPEAT strip_tac THEN_TRY asm_rewrite_tac[]);
a (¶_tac ¬Å x:ISUB· T®);
a (rewrite_tac[]);
(* *** Goal "2.2" *** *)
a (rewrite_tac [get_spec ¬Cat®]);
(* *** Goal "3" *** *)
a (swap_nth_asm_concl_tac 1);
a (rewrite_tac[get_spec ¬$izz®, get_spec ¬Cat®, get_spec ¬CatSubs®]);
val l06n = save_pop_thm "l06n";
=TEX
}%ignore

These are the ones I have proved.

=GFT
l06n =	ô ³ (µ A B· A hazz B ± particular A ´ (¶ C· C ½ A ± A izz B))
=TEX

\subsection{Some Comments on The Conjectures}

The main problem with the conjectures is that as a group they are inconsistent.
Consequently, one cannot find definitions which are consistent with all the conjectures.

So first I will expose some of the most obvious contradications which flow from the conjectures.

\begin{enumerate}
\item From 5 and 15 we conclude that form and universal are coextensive.
I think it may be that this is part of the Platonic view but not of the Aristotelian one.

\end{enumerate}

Here are some observations on specific conjectures (now out of date).

\begin{description}

\item[c01]
Note here that this is quantified over everything, and hence over individuals, whereas Aristotle describes individuals as thing of which one may predicate, but which are not themselves predicable.
Perhaps this inderdiction applies to $hazz$ but not to $izz$, to accidental but not essential predication.
(We should add the rule ¬³ A hazz A® which is easy to prove.)
I don't know any more detail about Aristotle's attitude towards predication by individuals.
If one cannot, where do we stand when we do, as in ``Socrates is Socrates'' and ``Socrates is Aristotle''.
Anyway, if these were to have a truth value (which surely they do) then the truth value will be as in this rule.

\item[c02]
Behind the scenes this is transitivity of set inclusion.

\item[c03]
This is because {\it izz} is intracategorial and {\it hazz} is intercategorial.
An obvious but useful corrolary is that they are not equal (c03b).

\item[c04]
This, and most of the other theorems involving existential quantification, is rather odd.
Its proof depends on the conjecture $c04a$, which we have proven, and which involves no existential quantification, but its content is not significantly greater than that rule.
From right to left $l04$ is $l04b$ (you just pull out the existential and it turns into a universal).
Frin left to right $l04$ is trivial, since $B$ serves as a witness for the existential.

Ideally we would be working with claims which are expressible syllogistically, i.e. without benefit of quantifiers.
We can make an exception for universals on the left, since these are interconvertible with the conjecture with free variables instead which we can think of as schemata.
Where an existential quatifier appears in a negative context it will turn universal if pulled out to the top level and can therefore be dispensed with.
Elsewhere its worth asking whether the content is significant (including, as here, one half of the content implicit in putting an existential under an equivalence).

$co4b$ is an obvious similar result to $c04a$.

\item[c05]
According to my definition this is the wrong way round.

\item[c06]
As it stands this is provably false since we have $¬A hazz B®$ on the left, which entails that $A$ and $B$ are not of the same category, and $¬A izz B®$ in the right, which entails that they are of the same category.

\item[c07]
This, at the expense of using an existential, nevertheless tells us nothing that is not immediate from the definitions.

\item[c08]
Is just our definition.

\item[c09]
This turns into $c04$ (apart from the variable names) once you expand the definition of {\it accidentally\_predicable\_of}.

\item[c10]
Behind the scenes, {\it izz} is set inclusion, so this is obvious.

\item[c11-13]
These contain modal operators which cannot be defined using this model.

\item[c14-c15]
I've not worked out what a ``thing'' is.
Not even sure that I should have rendered Speranza's version using that term.
However, I do think I know that {\it particular} and {\it universal} are opposites (contradictories), and hence I could conclude from these two conjectures that there can be no {\it forms} since they entail that a form is both individual and universal.
Sounds like I have the wrong end of some stick or other.

\item[c16]
I don't know enough about ``thing''s to prove this one.

\item[c17]
This is $c01$ in other words.

\item[c018]
This is $c03b$ in other words.

\item[c19]

This is the contrapositive of the claim that {\it accidentally\_predicable\_of} is reflexive, which is false.
Would be true for {\it essentially\_predicable\_of}, but we already have that stated directly as c17.

\item[c20]
Immediate from my definitions.

\item[c21]
This turns out to be false under my definitions, because I have not excluded the possibility of an empty predicate.
However, one wonders why this should be excluded.

If I go over to a model adquate for modal operators then it will be easy to exclude this possibility.

\item[c21]
Fails for same reason as c20, though I could fix this by making the definition of {\it universal} insist on more than one member.

\item[c23]
I don't know why this should be true.
Any particular which partakes of a form contradicts it.

\item[c24]
This is not true in the present model, because we might have only one particular, and hence no non-trivial forms.

\item[c25-c26]
These two tell me that forms are not substance, but attributes, which contradicts c24 which tells us that there are subtantial forms (if particulars are substances). 

\item[c27]
I don't see why this should be true.

\item[c28-c29]
These two together entail that no universal is predicable of any particular.

\item[c30]
This says that nothing is essentially predicable of a particular except itself.

\item[c31]
This is a stronger version of c30 which says that, even if something isn't particular, nothing but itself is essentially predicable of it.

\end{description}

\section{METAPHYSICS (II)}\label{METAPHYSICSII}

In this section I offer a single model integrating Modal Syllogisms with the distinction between essential and accidental predication.

My interest is primarily in the extent to which may be found in Aristotle's philosophy a precursor of Hume's fork or the modern distinctions between analytic and synthetic or necessary and contingent propositions.
I see three Aristotelian ideas which have some relevance.

\begin{itemize}
\item the distinction between necessary and contingent propositions
\item the distinction between essential and accidental predication
\item the notion of demonstrability
\end{itemize}

It is only when we combine the syllogism with the metaphyics that we can explore the relationship between these various concepts.

I will give higher priority in this model to good structure while remaining faithful to Aristotle.
It is not the purpose of this model to further investigate the position in relation to Aristotle of Grice, Codd or Speranza.

I have constructed this model to give a good correspondence between necessary truth and essential predication.
If the model is successful in that respect it remains to consider whether it is consistent with the philosophy of Aristotle.
I do not know whether Aristotle talked about the relationship between essence and necessity.

I also hope that the model may help to explore the question of whether demonstrable truth, or rather the truths which are either ``intuitively or demonstrably certain'' to use Hume's words, coincides with necessary truth.

=SML
open_theory "aristotle";
force_new_theory "syll_metap";
=TEX

\ignore{
=SML
force_new_pc Û"'syll_metap"Ý;
merge_pcs ["'savedthm_cs_¶_proof"] "'syll_metap";
set_merge_pcs ["misc2", "'syll_metap"];
=TEX
}%ignore

\subsection{The Subject Matter}

In my first metaphysical model the main question in relations to subject matter was ``what are subjects and predicates'', to which a model of Aristotelian categories gives an answer.
The introduction of modality makes it necessary to consider something like possible worlds.
These were left uninterpreted in the modal treatment of the syllogism, but now that we expose the distinction between essential and accidental predication is it desirable to identify possible worlds with that which is accidental.

What is accidental is the extension of individual attributes, and this gives our concept of possible world.

It is convenient at this point to consider the question of extensionality.
According to Grice/Codd/Speranza, essential predicates are extensional (%
=INLINEFT
A izz B ± B izz A ´ A = B
=TEX
), but I know no reason to suppose that accidental predication is, and it seems counter-intuitive that it should be.
Consequently the modelling of an accidental predicate using a BOOLean valued function in HOL (in which functions are extensional) is inappropriate.
So I will separate out the extension from the individual attribute.

Nevertheless the only thing we need to know about an attribute is its extension.
I introduce a new unintepreted type for attributes:

=SML
new_type ("ATTR", 0);
=TEX

I retain the simplification from our model of modal syllogisms that the set of substantial individuals (particulars) is fixed across possible worlds.

=SML
new_type ("PART", 0);
=TEX

A possible world is then an assignment of extensions to individual attributes, where an extension is a set of particulars.
I will use a set rather than a propositional function.

=SML
declare_type_abbrev ("W", [], ”ATTR ­ PART SET®);
=TEX

I need to distinguish one possible world which is the actual world:

¹HOLCONST
Ü Ûactual_worldÝ : W
÷üüüüüü
Ü T
°

I also need a fixed (not accidental) allocation of the attributes to non-substantial categories.

=SML
new_type ("ACAT", 0);
=TEX

¹HOLCONST
Ü Ûattribute_categoryÝ : ATTR ­ ACAT
÷üüüüüü
Ü T
°

Finally the question of what subjects and predicates are can be determined.
I will call them {\it TERM}s and they are either a set of particulars or a set of attributes.
To allow for complementation I add a boolean component, which if true indicates a complement.

The sets in this case must be non-empty if we are to retain the existential fallacy.
The method used in my model of the modal syllogism in Section \ref{MODSYLL} will not do here, because (at least according to Code) we need an extensionality result, so I have instead introduced
\footnote{The definition has been placed in a separte document, \cite{rbjt006}.}
 for this purpose a new type ({\it NESET}) of non-empty sets which will give us both the existential fallacy and extensionality (for essential predication, not for accidental predication).

A term is therefore modelled as either a non-empty set of individual substances or a non-empty set of individual attributes.

=SML
declare_type_abbrev (Û"TERM"Ý, [], ”(PART NESET + ATTR NESET)®);
=TEX

¹HOLCONST
Ü Ûmk_SubsTermÝ : PART ð ­ TERM
÷üüüüüü
Ü µs· mk_SubsTerm s = InL (NeSet s)
°

¹HOLCONST
Ü Ûmk_AttrTermÝ : ATTR ð ­ TERM
÷üüüüüü
Ü µs· mk_AttrTerm s = InR (NeSet s)
°

The type {\it ACAT} is the type of attribute categories.
To get a type of all categories we add one more which will be the category of substances.

=SML
declare_type_abbrev (Û"CAT"Ý, [], ”ONE + ACAT®);
=TEX

It may be useful to have a name for the predicate encompassing all substance.

¹HOLCONST
Ü ÛSubstanceÝ : TERM
÷üüüüüü
Ü Substance = mk_SubsTerm Universe
°

\subsection{Predication}

The syllogism comes with four kinds of predication (a, e, i, o), and the metaphysics with three (izz, hazz and izz or hazz).
Combining these would give twelve combinations.

To simplify a bit I will separate out the quantifier but defining {\it All} and {\it Some} appropriately, and provide a postfix negator for izz an hazz.

I will then treat the modal operators as operators over propositions, and introduce the syllogism as a kind of judgement.

The type of the primitive copulas is:

=SML
declare_type_abbrev("COPULA", [], ”PART + ATTR ­ TERM ­ (W ­ BOOL)®);
=TEX

The first parameter is an individual substance or attribute rather than a TERM, the quantifying operator will arrange for each of the relevant individuals or attributes to be supplied.

\paragraph{Propositions}

=SML
declare_type_abbrev ("MPROP", [], ”W ­ BOOL®);
=TEX

\paragraph{Complementation}

The distinction between affirmative and negative is achieved by a postfix negation so we can say ``izz not'', ``hazz not'' or ``are not''.

=SML
declare_postfix (100, "not");
=TEX

¹HOLCONST
Ü $ÛnotÝ : COPULA ­ COPULA
÷üüüüüü
Ü µpred· pred not = Ìpa t w· ³ pred pa t w 
°

\paragraph{Quantifiers}

The following function is used by both quantifiers to check if something is in the range of quantification.

Think of a TERM as denoting a set of individuals, this is test for membership of that set.
The complications are because substances and attributes have different types in this model.

=SML
declare_infix(300, "InTERM");
=TEX

¹HOLCONST
Ü $ÛInTERMÝ : (PART + ATTR) ­ TERM ­ BOOL
÷üüüüüü
Ü µ pa t· pa InTERM t ¤ 
Ü	if IsL pa
Ü	then OutL pa  Set (OutL t)
Ü	else OutR pa  Set (OutR t)
°

We then use that membership test in defining the quantifiers.
The quantifiers expect to be supplied with a copula and a term.
The quantifier then predicates using the copula the term of everything or something in the domain of quantification (which is the subject term).
The copulas are defined below.

=IGN
declare_prefix(400, "All");
declare_prefix(400, "Some");
=TEX

¹HOLCONST
Ü $ÛAllÝ : TERM ­ ((PART+ATTR) ­ TERM ­ MPROP) ­ TERM ­ MPROP
÷üüüüüü
Ü µ s r p· All s r p = Ìw· µz· z InTERM s ´ r z p w
°

¹HOLCONST
Ü ÛSomeÝ : TERM ­ ((PART+ATTR) ­ TERM ­ MPROP) ­ TERM ­ MPROP
÷üüüüüü
Ü µ s r p· Some s r p = Ìw· ¶z· z InTERM s ± r z p w
°

\paragraph{Predicators}


¹HOLCONST
Ü ÛizzÝ : (PART+ATTR) ­ TERM ­ MPROP
÷üüüüüü
Ü µ pa t· izz pa t = Ìw·
Ü	if IsL pa
Ü	then if IsL t then OutL pa  Set (OutL t) else F
Ü	else OutR pa  Set (OutR t)
°

¹HOLCONST
Ü ÛhazzÝ : (PART+ATTR) ­ TERM ­ MPROP
÷üüüüüü
Ü µ pa t· hazz pa t = Ìw·
Ü	if IsL pa
Ü	then if IsL t then F else (¶a· a  Set(OutR t) ± OutL pa  w a)
Ü	else F
°

¹HOLCONST
Ü ÛareÝ : (PART+ATTR) ­ TERM ­ MPROP
÷üüüüüü
Ü µ pa t· are pa t = Ìw· izz pa t w ² hazz pa t w
Ü	
°

\paragraph{Judgements}

=SML
declare_infix(300, "˜");
=TEX

¹HOLCONST
Ü $Û˜Ý : MPROP LIST ­ MPROP ­ BOOL
÷üüüüüü
Ü µlp c· lp ˜ c ¤ Fold (Ìp t· p actual_world ± t) lp T ´ c actual_world
°

\paragraph{Modal Operators}

In this model the model operators are operators over propositions.

¹HOLCONST
Ü Û¨Ý : MPROP ­ MPROP
÷üüüüüü
Ü µp· ¨ p = Ìw· ¶w'· p w' 
°

¹HOLCONST
Ü Û©Ý : MPROP ­ MPROP
÷üüüüüü
Ü µp· © p = Ìw· µw'· p w' 
°

\subsection{Immediate Inference}

This model is significantly more complex than any of the preceding models, and proofs are therefore more difficult and automation of proof will be more of a challenge.

So far I have just put a toe in the water by proving the following elementary illustrations of the relationship between necessity and essential predication.

=GFT
Û©_izz_thmÝ = ô [© (All A izz B)] ˜ All A izz B
Û©_hazz_thmÝ = ô [© (All A hazz B)] ˜ All A izz B
Ûizz_©_thmÝ = ô [All A izz B] ˜ © (All A izz B)
=TEX

$©_hazz_thm$ is a bit odd.
Really what I wanted to prove was that no accidental predication is necessary, but I have no negation in the syllogism, so I just proved that if an accidental predication were necessary then it would be essential.

There are many theorems which one would naturally prove at this point, to facilitate further proofs and proof automation, which are not expressible syllogistically.
Proof automation depends heavily on the demonstration of equations, so that proof may proceed by rewriting.
But syllogisms are not suitable for this.

The natural way to proceed in such a case is to continue in this theory doing things which support proofs of syllogisms without being restrained to syllogisms, and then to have a separate theory in which the syllogistic claims are presented.
Some reflection is desirable on what the philosophical objectives are and what course will best contribute to those purposes.

\ignore{
=SML
set_goal([], ¬[© (All A izz B)] ˜ All A izz B®);
a (rewrite_tac  (map get_spec [¬$˜®, ¬Fold®, ¬©®, ¬All®, ¬izz®])
	THEN REPEAT strip_tac);
val ©_izz_thm = save_pop_thm "©_izz_thm";

set_goal([], ¬[© (All A hazz B)] ˜ All A izz B®);
a (rewrite_tac  (map get_spec [¬$˜®, ¬Fold®])
	THEN REPEAT strip_tac);
a (swap_nth_asm_concl_tac 1);
a (rewrite_tac (map get_spec [¬©®, ¬All®, ¬hazz®])
	THEN strip_tac);
a (¶_tac ¬Ìw· {}® THEN rewrite_tac[get_spec ¬$InTERM®] THEN strip_tac);
a (lemma_tac ¬¶d· d  Set (OutL A)® THEN1 rewrite_tac[]);
a (¶_tac ¬InL d® THEN asm_rewrite_tac[]);
a (cond_cases_tac ¬IsL B®);
val ©_hazz_thm = save_pop_thm "©_hazz_thm";

set_goal([], ¬[All A izz B] ˜ © (All  A izz B)®);
a (rewrite_tac  (map get_spec [¬$˜®, ¬Fold®, ¬©®, ¬All®, ¬izz®])
	THEN REPEAT strip_tac);
val izz_©_thm = save_pop_thm "izz_©_thm";
=TEX
}%ignore

\section{POSTSCRIPT}\label{POSTSCRIPT}

These are the kinds of thing which {\it might} happen in future issues of this document:

\begin{itemize}
\item If I get constructive feedback (pointing out errors counts, telling me its a waste of time doesn't, explaining bits of Aristotle I'm getting wrong would be great) then I will probably do something about it.

\item There is a good chance I will get to know something about what Aristotle really said and make improvements arising from this.
In that case I would like to put some hyperlinks into my online hypertext of Aristotle's relevant works, connecting the specific features of the model with the passages in Aristotle which they reflect.

\item I am interested in the methods, and I may spend more time trying to describe them in a way which might be intelligible to philosophers.

\item If this ever becomes a good approximation to Aristotle's position there would then be some philosophical analysis of the metaphysics (by contrast with a purely logical analysis), and somewhere there are points to be made about the kind of analysis which I am aiming for.
\end{itemize}

There are three stages I envisage in the process of getting philosophical insights from this kind of work:

\begin{description}
\item[formal modelling]
I now have a series of models, the last one looks as if it might be useful.

\item[model verification]
The models need checking against Aristotle's writings.

\item[formal analysis]
Further formal work is needed to come to an understanding of these models.

\item[philosophical analysis]
After the models are formulated and verified, and formal analysis has deepened our undertanding of these models, we may then be in a position to obtain some interesting philosophical insights.

\end{description}


\appendix

{
\let\Section\section
\def\section#1{\Section{#1}\label{syllog1}}
\include{syllog1.th}
\def\section#1{\Section{#1}\label{syllog2}}
\include{syllog2.th}
\def\section#1{\Section{#1}\label{modsyllog}}
\include{modsyllog.th}
\def\section#1{\Section{#1}\label{ariscat}}
\include{ariscat.th}
\def\section#1{\Section{#1}\label{syll_metap}}
\include{syll_metap.th}
}  %\let

\pagebreak
\section*{BIBLIOGRAPHY}\label{BIBLIOGRAPHY}
\addcontentsline{toc}{section}{BIBLIOGRAPHY}

{\def\section*#1{\ignore{#1}}
\raggedright
\bibliographystyle{rbjfmu}
\bibliography{rbj,fmu}
} %\raggedright

{\twocolumn[\section*{INDEX}\label{index}]
\addcontentsline{toc}{section}{INDEX}
{\small\printindex}}

\end{document}
