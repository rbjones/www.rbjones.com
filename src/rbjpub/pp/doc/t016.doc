=IGN
$Id: t016.doc,v 1.3 2006/12/11 12:14:52 rbj01 Exp $
=TEX
\documentclass[11pt,a4paper]{article}
\usepackage{latexsym}
\usepackage{ProofPower}
\ftlinepenalty=9999
\tabstop=0.25in
\usepackage{A4}

\def\Hide#1{\relax}
\newcommand{\ignore}[1]{}

\title{X-Logic Models}
\author{Roger Bishop Jones}
\date{$ $Date: 2006/12/11 12:14:52 $ $}

\usepackage[pdftex]{hyperref}
\makeindex
\begin{document}
\vfill
\maketitle
\begin{abstract}
Formal models of various aspects of X-Logic in Z
\end{abstract}
\vfill

\begin{centering}
{\footnotesize

Created 2005/04/09

Last Change $ $Date: 2006/12/11 12:14:52 $ $

\href{http://www.rbjones.com/rbjpub/pp/doc/t016.pdf}
{http://www.rbjones.com/rbjpub/pp/doc/t016.pdf}

$ $Id: t016.doc,v 1.3 2006/12/11 12:14:52 rbj01 Exp $ $

\copyright\ Roger Bishop Jones; Licenced under Gnu LGPL

}%footnotesize
\end{centering}
\newpage
\setcounter{tocdepth}{4}
{\parskip=0pt\tableofcontents}
\newpage
%%%%

{\raggedright
\bibliographystyle{fmu}
\bibliography{rbj,fmu}
} %\raggedright

\section{Introduction}

Purposes and key ideas.


\section{Model 1 - Languages Truth and Inference}

\subsection{Introduction}

\subsubsection{Purposes}

The main ideas explored in this model are:

\begin{enumerate}
\item Logic at the document level - the propositions of this logic are complete documents.
\item Multilingual logic - the documents can be in any language which has a propositional semantics.
\item Specified computation as inference - any computation over documents by a program which meets a specification will be an inference in the logic.
\item Language as specification - the specification of a program for the purposes here is simply the identification of the input and output languages, the specification then means that whenever the program is supplied true documents in the input languages then if it outputs a document it will be a true document of the output language.
\end{enumerate}

\subsubsection{The Theory X-Logic-1}

This version written in HOL as a child of rbjmisc.

=SML
open_theory "rbjmisc";
force_new_theory "X-Logic-1";
set_merge_pcs["hol", "'savedthm_cs_∂_proof"];
=TEX

\subsubsection{Caveats}
The caveats on metamodel 1 are not necessarily applicable here.
The model is rewritten in Z to see whether Z might be better for present purposes.
The caveats on metamodel 1 are a bit vaguely stated and so I'm not sure what I had in mind then.
Its clear that a major defect is that inferences may have only one premise, and so I am fixing that problem, and in the process maybe I will remember whether there were other problems.

\subsection{Types}

An overview of the model with specifications of the various types of entity involved in it.

\subsubsection{Domain of Discourse}

The subject matter of the model is programs which perform transformations over documents, which are written in a variety of languages.
 
We take the set of documents to be unspecified, and hence use a given set.
A language is modelled as a set of documents.
 
This should be understood as a purely {\it semantic} definition, in which the essential feature of a document is that it expresses an assertion, and the only matter of interest for our present purposes is whether that assertion is true.
 

Thus the set of documents which constitutes a language is the set of documents which when interpreted in that language are {\it true}.
 
A program is any partial function over the documents.
A specification is a pair, the first element is a list of languages which are the languages of the inputs to the program and the second element is the language of the single output document.
 
\subsubsection{Basic Types}

The following definitions should be understood as introducing the semantic objects which correspond to the parts of a very simple language.
Of these, the last three are kinds of "proposition" corresponding two three kinds of sentence which are available in our language.
Informally they are the propositions respectively that a document in some language is true, that a program satisfies some specification, and that one document has been computed from some others by some program.

=SML
new_type("DOC",0);
declare_type_abbrev("LANG", [], îDOC Æ);
declare_type_abbrev("PROG", [], îDOC LIST ≠ DOC LISTÆ);
declare_type_abbrev("SPEC", [], îLANG LIST ∏ LANG LISTÆ);
declare_type_abbrev("DOCPROP", [], îLANG ∏ DOCÆ);
declare_type_abbrev("PROGPROP", [], îSPEC ∏ PROGÆ);
declare_type_abbrev("INFERPROP", [], îPROG ∏ DOC LIST ∏ DOC LISTÆ);
=TEX
πHOLCONST
‹ (s_inl: SPEC ≠ LANG LIST) (s_outl: SPEC ≠ LANG LIST)
‹ (dp_lan: DOCPROP ≠ LANG) (dp_doc: DOCPROP ≠ DOC)
‹ (pp_spec: PROGPROP ≠ SPEC) (pp_prog: PROGPROP ≠ PROG)
‹ (ip_prog: INFERPROP ≠ PROG) (ip_inl: INFERPROP ≠ DOC LIST)
‹   (ip_outl: INFERPROP ≠ DOC LIST)
˜¸¸¸¸¸¸
‹   s_inl = Fst ± s_outl = Snd
‹ ± dp_lan = Fst ± dp_doc = Snd
‹ ± pp_spec = Fst ± pp_prog = Snd
‹ ± ip_prog = Fst ± ip_inl = Fst o Snd ± ip_outl = Snd o Snd
∞

\subsubsection{Constructors and Projections}

Since we are using schema types where appropriate the binding display and component selection notations will serve instead of defining constructor and projection functions.
\subsection{Propositions}

Three kinds of proposition are defined, concerning truth of documents, correctness of programs and derivation of documents.

In this section we provide the meaning for the three kinds of proposition introduced above. In each case this is a property which should be understood as defining when the relevant kind of sentence is true.

\subsubsection{Truth}
First, a document is true in some language if it is a member of that language.
(it suffices for our present purposes to model a language by its set of true sentences) 

πHOLCONST
 TrueDocP: DOCPROP ≠ BOOL
˜
 µdp:DOCPROP∑ TrueDocP dp § dp_doc dp ç dp_lan dp
∞

\subsubsection{Inference}

Next, a list of documents (the conclusions) is inferred by a program from a list of documents (the premises) if the function which is the value of the program maps the premises to the conclusions. 

πHOLCONST
  DocInferP: INFERPROP ≠ BOOL
˜
  µip:INFERPROP∑ DocInferP ip § (ip_prog ip) (ip_inl ip) = ip_outl ip
∞

\subsubsection{Soundness}

A program is sound with respect to some specification if any list of documents computed by that program from a sequence of rue documents in its input languages will be a true document of the output language.

πHOLCONST
 SoundProgP: PROGPROP ≠ BOOL
˜
 µpp: PROGPROP∑ SoundProgP pp § (µidl: DOC LIST∑
	  µâL (Map TrueDocP (Combine (s_inl(pp_spec pp)) idl))
	¥ µâL (Map TrueDocP (Combine (s_outl(pp_spec pp)) (pp_prog pp idl))))
∞

\subsubsection{Soundness of Identity Function}

This is the most trivial soundness result I could think up, that the identity function is sound wrt any specification in which the output languages are the same as the input languages.

=SML
set_goal([],¨µll: LANG LIST∑ SoundProgP ((ll, ll), (Ãx∑x))Æ);
a (rewrite_tac [
	get_spec ¨SoundProgPÆ,
	get_spec ¨s_inlÆ]);
val id_spec_thm =
	save_pop_thm "id_spec_thm";
=TEX

\subsection{Meta Reasoning}

Elementary reasoning about inferences and their composition.

\subsubsection{Introduction}

In the following we investigate the kind of reasoning which could be undertaken in a language suitable for talking about the model we have introduced.
Rather than invent a language, we use the syntax already available to us, and build up some elementary tools for reasoning about the model.
If we then devised a suitable special concrete syntax and gave this its semantics in terms of the model by a semantic embedding into ProofPower GST, the proof tools we devise here would then serve as a tools for reasoning about this new language.
The step to concrete syntax will be omitted, however, since we expect further elaborations to the model before this would be worthwhile.

\subsubsection{What kind of logic?}

We have a language in which programs, modelled as functions, are applied to documents to yield new documents, and hence an expression language involving function application.
We have a couple of predicates which are applied to these programs and documents.
So it looks like we are heading for some kind of predicate calculus.
 
On the other hand, if we consider languages as types of document and specifications as types of program, then both our predicates become typing assertions in an applicative calculus.
Since typing inference in pure combinatory logic is the same as a fragment of propositional logic we may hope that a metalanguage based on the simple model we have in hand will logically much simpler than the predicate calculus, and we may hope for fully automatic proofs.
 
\subsubsection{Rule Application}

The central principle is that a sound program when applied to true premises yields true results.
"Soundness" is of course, relative to a specification, and the specification tells you relative to which semantics the premises and conclusions are expected to be "true".
=SML
set_goal([],¨µ(in_docs:DOC LIST) (out_docs:DOC LIST) (in_lans: LANG LIST)
	prog out_docs out_lans∑
 (µâL (Map TrueDocP (Combine in_lans in_docs)))
± SoundProgP ((in_lans, out_lans), prog)
± DocInferP (prog, (in_docs, out_docs))
¥ µâL (Map TrueDocP (Combine out_lans out_docs))Æ);
a (rewrite_tac[
	get_spec ¨TrueDocPÆ, 
	get_spec ¨SoundProgPÆ, 
	get_spec ¨DocInferPÆ,
	get_spec ¨CombineÆ,
	get_spec ¨UncurryÆ,
	get_spec ¨MapÆ,
	get_spec ¨s_outlÆ,
	get_spec ¨µâLÆ,
	get_spec ¨UncurryÆ,
	get_spec ¨FoldÆ]
	THEN REPEAT strip_tac);
a (ALL_ASM_FC_T (MAP_EVERY ante_tac) []
	THEN asm_rewrite_tac[]);
val mm1_mp_thm =
	save_pop_thm "mm1_mp_thm";
=TEX
Because programs are permitted only one input and one output document, the limitations of this metamodel are very severe.
Now we have modus ponens we can easily compose inferences to give results over chains of computations, but that's about all we can do.

\subsubsection{Composition of Inferences}
The following proof demonstrates that sound inferences compose.
=SML
set_goal([],¨µlans1 lans2 lans3 prog1 prog2∑
  SoundProgP ((lans1, lans2), prog1)
± SoundProgP ((lans2, lans3), prog2)
¥ SoundProgP ((lans1, lans3), prog2 o prog1)Æ );
a (rewrite_tac (map get_spec [¨SoundProgPÆ, ¨s_inlÆ])
	THEN REPEAT strip_tac THEN REPEAT (all_asm_ufc_tac[]));
val mm1_comp_thm = save_pop_thm "mm1_mpc_thm";
=TEX

\section{Model 2 - Oracles and Assurance}

\subsection{Overview}

Model 2 revolved around the truth of documents.
If the semantics of an abstract language is fixed then the truth of documents is thereby determined.
The semantics of specifications is defined in terms of the relationship between truth of the inputs to the program and truth of outputs.
Thus we may expect that various programs will help us to determine the truth of documents.

Their help will be incomplete.
When a document is output by some program its truth depends on the truth of any inputs to the program, and even if there are none, depends also on the fact that the program meets its specification.
There is here an infinite regress which prevents our ever knowing the truth of a document with absolute certainty.

In the model which follows this is made explicit.
The truth of documents is to be certified relative to certain assumptions.
Since in practical applications of the proposed assurance calculus the number of assumptions might otherwise prove large, the assumptions we consider are effectively that some authority is infallible.

This permits authorities to be established which endorse a package of ``assumptions'' which provides a practical basis for establishing truth in some domain of interest.
A simple example might be an authority for set theoretic truth which endorses the deductive aparatus of first order logic, the axioms known as ``ZFC'' and one or more proof tools which are judged capable of checking whether a document contains contains only claims provable in first order logic from the axioms of  ZFC. 

This you may view as a fairly exacting kind of scepticism.
No document will ever receive unconditional or absolute assent.
Docuemnts will sometime received qualified assent, which means that we affirm that they are true if some collection of authories has been infallible in their judgements on ``less difficult'' documents.

In this context an oracle is a program alleged to satisfy some specification, the specification prescribing in effect some subject matter in which the oracle is competent.

It is expected that when an authority endorses something that this endorsement is recorded as a digital signature, however, this is not covered by the model.

\subsection{Abstract Syntax}

In this model we introduce a language in which certain kinds of statement can be expressed and asserted relative to some set of authorities.
The language is simple and non-recursive, and so its abstract syntax does not require an recursive definition, though the semantics will be recursively defined.

\subsubsection{Theory X-Logic-2}

Theory X-Logic-2 is a theory in {\Product} HOL, derived from a previous model written in Isabelle HOL.

This model begins with an abstract syntax for the language.
The language is about documents (which are understood as propositions) expressed in various object languages, and programs (whose computations are interpreted as inferences) which read documents and create new documents.
These documents languages and programs are all understood to inhabit the World Wide Web and each identified by a URI, which is a string.
So we begin with a type abbreviation indicating that URIs are to be represented by strings.

=SML
open_theory "X-Logic-1";
force_new_theory "X-Logic-2";
set_merge_pcs["hol", "'savedthm_cs_∂_proof"];
=TEX

=SML
declare_type_abbrev("URI", [], îSTRINGÆ);
declare_type_abbrev("DOCU", [], îURIÆ);
declare_type_abbrev("LANU", [], îURIÆ);
declare_type_abbrev("PROGU", [], îURIÆ);
declare_type_abbrev("AUTH", [], îURIÆ);
=TEX

\subsubsection{sentences}

The subject matter of the metalanguage is the truth of documents.
The metalanguage permits the establishment (proof) of truth to be compounded from inferences performed by a variety of programs in various languages.
From premises about the inferences performed by these various programs (which may be thought of as demonstrating lemmas) it is to be possible in the metalanguage to infer an overall conclusion.

The metalanguage therefore contains sentences which express the claim that:

\begin{enumerate}
\item certain documents are true documents of particular languages
\item a certain program satisfies a specification formulated as soundness with respect to given lists of input and output languages
\item a specified list of output documents was computed by a program from a list of input documents
\end{enumerate}

=SML
declare_type_abbrev("SENT", [], î(DOCU LIST ∏ LANU LIST)
	+ (PROGU ∏ LANU LIST ∏ LANU LIST)
	+ (PROGU ∏ DOCU LIST ∏ DOCU LIST)Æ);
=TEX

The significance of endorsements will become clearer shortly.

\subsubsection{judgements}
In general sentences are not proven absolutely, but on the assurance of various authorities (sometimes called oracles).
The combination of a sentence with a set of authorities which have contributed to our grounds for asserting the sentence is called a "judgement".
For reasons connected with well-definedness of the semantics of judgements a judgement also contains a number.
This may be thought of as a time-stamp, but is more loosely specified.

=SML
declare_type_abbrev("STAMP", [], îÓÆ);
declare_type_abbrev("JUDG", [], î(STAMP ∏ AUTH ∏ AUTH SET ∏ SENT) + (AUTH SET)Æ);
=TEX

A special authority called $‚$ (bottom) may be used without signature, and is therefore untrustworthy.

πHOLCONST
‹  ‚:AUTH
˜¸¸¸¸¸¸
‹ T
∞


=GFT
consts
    jstamp :: judgement => stamp
    jauth  :: judgement => authority
    jauths :: judgement => authority set
    jsent  :: judgement => sentence

primrec
    "jstamp (Assert st as se) = st"
primrec
    "jauth (Endorse a as) = a"
primrec
    "jauths (Assert st as se) = as"
    "jauths (Endorse a as) = as"
primrec
    "jsent (Assert st as se) = se"

=TEX

The set of authorities can be empty, but when asserted a judgement must be signed by an authority.
The meaning of a judgement is that <i>if</i> all the authorities cited in the list have been hitherto infallible then the sentence is true.

However, the judgement is known only with that degree of confidence which we attach to the authority which asserts it (and has signed it), so even an unconditional judgement (one with an empty set of cited authorities) is still no better assured than its signing authority.

An authority has been "hitherto infallible" if all the judgements which it has signed with numbers less than that of the judgement in hand are true.
In fallibility and truth are therefore mutually defined, the numbers attached to judgements relativise infallibility so as to make the mutual recursion well-founded.

\subsection{Semantics}

The semantics of sentences and judgements is defined as truth valuations relative to appropriate interpretations.

\subsubsection{sentence interpretations}

=GFT Isabelle
types
	document_map = document => string
	language_map = language => string set
	program_map = program => (string list => string list)

datatype Sinterp = SI document_map language_map program_map

consts
	docmap :: Sinterp => document_map
	langmap :: Sinterp => language_map
	progmap :: Sinterp => program_map

primrec "docmap (SI d l p) = d"
primrec "langmap (SI d l p) = l"
primrec "progmap (SI d l p) = p"
=TEX


\subsubsection{true sentences}

=GFT Isabelle
consts
	truedoclist :: [Sinterp, document list, language list] => bool

primrec
   "truedoclist i (h_d#t_d) l_l =
     (case l_l of
      [] => False |
      (h_l#t_l) =>  (docmap i h_d):(langmap i h_l) & truedoclist i t_d t_l)"
   "truedoclist i [] l_l = (case l_l of [] => True | (h_l#t_l) => False)"

constdefs
   trueprogspec :: [Sinterp, program, language list, language list] => bool
    "trueprogspec i p ill oll ==
     (! idl . truedoclist i idl ill
              --> truedoclist i (progmap i p idl) oll)"

   truecompute :: [Sinterp, program, document list, document list] => bool
    "truecompute i p idl odl == (odl = progmap i p idl)"

   trueendorse :: [Sinterp, authority set] => bool
    "trueendorse i al == True"

consts
   truesen :: [Sinterp, sentence] => bool

primrec
   "truesen i (TrueDocs dl ll) = truedoclist i dl ll"
   "truesen i (ProgSpec p ill oll) = trueprogspec i p ill oll"
   "truesen i (Compute p idl odl) = truecompute i p idl odl"
=TEX


\subsubsection{judgement interpretations}

A judgement is true if infallibility of its authorities implies the truth of its sentence.
To formalise this we need to talk about infallibility, and to talk about infallibility we need to have an interpretation which tells us which judgements have been affirmed by which authorities.


We therefore devise an extended interpretation for judgements in which a judgement map is available mapping each authority to the judgements it has affirmed.

=GFT Isabelle
types
	judgement_map = authority => judgement set

datatype Jinterp = JI Sinterp judgement_map

consts
	judgemap :: Jinterp => judgement_map
	sinterp :: Jinterp => Sinterp

primrec "judgemap (JI s j) = j"
primrec "sinterp (JI s j) = s"
=TEX


\subsubsection{infallibility}

Informally an authority is infallible if it only asserts true judgements.
However, the definition of truth of a judgement will depend upon the infallibility of authorities, and this naive view does not lead to a well defined concept.

This is fixed by slighly <i>strengthening</i> the meaning of judgements, so that their truth depends only on the truth of <i>previous</i> judgements, and it is for this reason that judgements have been given a "stamp".
This leads us to the property of being "hitherto infallible" at some stamp value.
This is the property that all judgements affirmed by the authority with smaller stamp values are true.
It will be clear from the proof rules which we show later that this mechanism does not have to be implemented with timestamps.

One further complication is necessary, arising from endorsement.
The infallibility of an authority is conditional on the infallibility of the authorities it has endorsed in a way which cannot be allowed for by attaching a truth value to the judgement in which the endorsement takes place.
This is because the truth value of the endorsement can only depend on that of previous judgements, but the infallibility of an authority at some time depends on judgements made by authorities he has endorsed between the time at which the endorsement took place and the later time at which an infallibility judgement may be taking place.

Endorsements are therefore held to create a timeless partial ordering on authorities, and we require for the infallibility of an authority at some moment that neither he nor any greater authority has made a previous error.
Greater in this case means directly or indirectly endorsed by the authority in question.


=GFT Isabelle
types
	inftest = [nat, authority, Jinterp] => bool
	truthtest = [judgement, Jinterp] => bool

constdefs

   authrel :: "judgement_map => (authority * authority)set"
   "authrel jm == rtrancl {p. ? as. (snd p):as
      & (Endorse (fst p) as):(jm (fst p))}"

   hirec :: "[nat, (inftest * truthtest)] => inftest"
   "hirec n1 tsts n2 auth ji == case n1 of
     0       => True |
     (Suc m) => !a. (auth,a):(authrel (judgemap ji))
                 --> (!j. j:(judgemap ji a) & (jstamp j) <= m
                         --> (snd tsts j ji))"

   jtrec :: "[nat, (inftest * truthtest)] => truthtest"
   "jtrec n tsts j ji == case n of
     0       => snd tsts j ji |
     (Suc m) => (!auth. auth:(jauths j) --> (fst tsts) (n-1) auth ji)
                --> snd tsts j ji"

consts
   hijt :: "nat => (inftest * truthtest)"

primrec
   "hijt 0       = ((Ãx y z. True), (Ãx y. True))"
   "hijt (Suc n) = (hirec n (hijt n), jtrec n (hijt n))"

constdefs
   hitherto_infallible  :: [nat, authority, Jinterp] => bool
   "hitherto_infallible n == fst (hijt n) n"
=TEX

\subsubsection{true judgements}

=GFT Isabelle
consts
   truej  :: [Jinterp, judgement] => bool

primrec
   "truej ji (Assert stamp auths sent)
    = snd (hijt stamp) (Assert stamp auths sent) ji"
   "truej ji (Endorse auth auths) = True"
=TEX

\subsection{Proof Rules}

\subsubsection{inference}
=GFT Isabelle
consts
   thms :: judgement set => judgement set
   "|-"  :: [judgement set, judgement] => bool   (infixl 50)

translations
   "H |- p" == "p : thms(H)"

inductive "thms(H)"
   intrs
   H "p:H ==> H |- p"
   E "[| H |- Assert n1 (ll Un levels1) sent;
         H |- Endorse l ll;
         n1 < n3;
         n2 < n3 |]
     ==> H |- Assert n3 ({l} Un levels2) sent"
  TI "[| H |- Assert n1 levels1 (TrueDocs [d] [l]);
         H |- Assert n2 levels2 (TrueDocs dl ll);
         n1 < n3;
         n2 < n3 |]
     ==> H |- Assert n3 (levels1 Un levels2) (TrueDocs (d#dl) (l#ll))"
 TEH "[| H |- Assert n1 levels (TrueDocs (d#dl) (l#ll));
         n1 < n2 |] 
     ==> H |- Assert n2 levels (TrueDocs [d] [l])"
 TET "[| H |- Assert n1 levels (TrueDocs (d#dl) (l#ll));
         n3 < n2 |] 
     ==> H |- Assert n2 levels (TrueDocs dl ll)"
  MP "[| H |- Assert n1 levels (TrueDocs idl ill);
         H |- Assert n2 levels (ProgSpec p ill oll);
         H |- Assert n3 levels (Compute p idl odl);
         n1 < n4;
         n2 < n4;
         n3 < n4 |]
     ==> H |- Assert n4 levels (TrueDocs odl oll)"
end
=TEX

\section{Model 3 - Digital Signatures}

{\let\Section\section
\def\section#1{\Section{#1}\label{TheoryListing}}
\include{X-Logic-1.th}
}  %\let

{\let\Section\section
\def\section#1{\Section{#1}\label{TheoryListing}}
\include{X-Logic-2.th}
}  %\let

\twocolumn[\section{INDEX}\label{INDEX}]
{\small\printindex}

\end{document}
=SML
set_flag ("pp_use_alias", true);
open_theory "X-Logic-1";
output_theory{out_file="X-Logic-1.th.doc", theory="X-Logic-1"};
open_theory "X-Logic-2";
output_theory{out_file="X-Logic-2.th.doc", theory="X-Logic-2"};
set_flag ("pp_use_alias", false);
=TEX
