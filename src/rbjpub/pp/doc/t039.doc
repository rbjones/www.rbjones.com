=TEX
\def\rbjidtADJdoc{$$Id: t039.doc,v 1.2 2010/07/20 19:11:23 rbj Exp $$}

\section{Universal Algebra}

=SML
open_theory "rbjmisc";
force_new_theory "unalg";
force_new_pc Û"'unalg"İ;
merge_pcs ["'prove_¶_´_conv", "'savedthm_cs_¶_proof"] "'unalg";
set_merge_pcs ["rbjmisc", "'unalg"];
=TEX

To make the operators fairly general within the constrainst imposed by the HOL type system we will have operators as functions over indexed sets of values.

The following labelled product is used as a general notion of ``structure'' independent of signature.
Of course any particular algebra will have a definite signature.

A signature is a string indexed set of arities, where an arity is a natural number.

=SML
declare_type_abbrev ("SIG", [], ”(STRING, î) IX®);
=TEX

The operators over the algebra are represented by functions from indexed sets of operands to a single result value.
In this case we pack the arguments into a total function and ignore the values which do not correspond to the signature.
The signature (i.e. the arity of each operator) is explicit in this structure, otherwise the range of significance of the operators would not be known.

¹HOLLABPROD ÛSTRUCTİüüüüüüüüüüüüüüü
Ü	ÛSCarİ		: 'a SET;
Ü	ÛSOpsİ		: (STRING, (î ¸ ((î ­ 'a) ­ 'a)))IX
°üüüüüüüüüüüüüüüüüüüüüüüüüüüüü

¹HOLCONST
Ü ÛArity‰uİ : ('a) STRUCT ­ STRING ­ î
÷üüüüüüüüüüü
Ü µA n· Arity‰u A n = Fst (ValueOf (SOps A n)) 
°

¹HOLCONST
Ü ÛOperİ : ('a) STRUCT ­ STRING ­ ((î ­ 'a) ­ 'a)
÷üüüüüüüüüüü
Ü µA n· Oper A n = Snd (ValueOf (SOps A n)) 
°

The following function extracts the signature from a structure.

¹HOLCONST
Ü ÛSigİ : ('a) STRUCT ­ SIG
÷üüüüüüüüüüü
Ü µs· Sig s = IxCompIx (SOps s) (Ìx· Value (Fst x)) 
°

=GFT
ÛIxDom_Sig_thmİ =
	ô µ S· IxDom (Sig S) = IxDom (SOps S)

Û_IxDom_Sig_thmİ =
	ô µ S x· x  IxDom (Sig S) ¤ x  IxDom (SOps S)
=TEX

\ignore{
=SML
val IxCompIx_def = get_spec ¬$IxCompIx®;
val Arity‰u_def = get_spec ¬Arity‰u®;
val Oper_def = get_spec ¬Oper®;
val Sig_def = get_spec ¬Sig®;

set_goal ([], ¬µS· IxDom (Sig S) = IxDom (SOps S)®);
a (strip_tac THEN rewrite_tac[Sig_def, IxCompIx_def, IxDom_def, sets_ext_clauses]
	THEN REPEAT strip_tac THEN_TRY asm_rewrite_tac[]);
a (swap_nth_asm_concl_tac 1 THEN asm_rewrite_tac[]);
val IxDom_Sig_thm = save_pop_thm "IxDom_Sig_thm";

set_goal ([], ¬µS x· x  IxDom (Sig S) ¤ x  IxDom (SOps S)®);
a (strip_tac THEN rewrite_tac[Sig_def, IxCompIx_def, IxDom_def, sets_ext_clauses]
	THEN REPEAT strip_tac THEN_TRY asm_rewrite_tac[]);
a (swap_nth_asm_concl_tac 1 THEN asm_rewrite_tac[]);
val _IxDom_Sig_thm = save_pop_thm "_IxDom_Sig_thm";
=TEX
}%ignore

¹HOLCONST
Ü ÛArity‰iİ : SIG ­ STRING ­ î
÷üüüüüüüüüüü
Ü µA n· Arity‰i A n = ValueOf (A n) 
°

=GFT
Ûsig_arity_lemmaİ =
	ô µ A n· n  IxDom (Sig A) ´ Arity‰i (Sig A) n = Arity‰u A n
=TEX

\ignore{
=SML
val Arity‰i_def = get_spec ¬Arity‰i®;

set_goal([], ¬µA n· n  IxDom (Sig A) ´ Arity‰i (Sig A) n = Arity‰u A n®);
a (REPEAT µ_tac THEN rewrite_tac[Arity‰i_def, Arity‰u_def, Sig_def, IxCompIx_def, IxDom_def]
	THEN cond_cases_tac ¬SOps A n = Undefined®);
val sig_arity_lemma = save_pop_thm "sig_arity_lemma";
=TEX
}%ignore


\emph{IxInc} (aliased as $Ã$) is inclusion of indexed sets, and suffices for signature inclusion.

=GFT
ÛIxDom_Sig_SOps_thmİ =
	ô µ A· IxDom (Sig A) = IxDom (SOps A)

ÛSigInc_IxDom_€_thmİ =
	ô µ A B· Sig A Ã Sig B ´ IxDom (Sig A) € IxDom (Sig B)

ÛSigInc_IxDom_Sops_€_thmİ =
	ô µ A B· Sig A Ã Sig B ´ IxDom (SOps A) € IxDom (SOps B)

ÛSigInc_Arity‰i_thmİ =
	ô µ A B n· Sig A Ã Sig B ± n  IxDom (Sig A)
         ´ Arity‰i (Sig A) n = Arity‰i (Sig B) n

ÛSigInc_Arity‰u_thmİ =
	ô µ A B n· Sig A Ã Sig B ± n  IxDom (Sig A)
	´ Arity‰u A n = Arity‰u B n
=TEX

\ignore{
=SML
set_goal([], ¬µA· IxDom (Sig A) = IxDom (SOps A)®);
a (REPEAT µ_tac THEN rewrite_tac[Sig_def, IxDom_def, sets_ext_clauses, IxCompIx_def] THEN strip_tac);
a (cond_cases_tac ¬SOps A x = Undefined®);
val IxDom_Sig_SOps_thm = save_pop_thm "IxDom_Sig_SOps_thm";

set_goal([], ¬µA B· Sig A Ã Sig B ´ IxDom (Sig A) € IxDom (Sig B)®);
a (REPEAT µ_tac THEN rewrite_tac[IxInc_def, IxDom_def]);
a (PC_T "hol1" (REPEAT strip_tac) THEN asm_fc_tac[] THEN asm_rewrite_tac[]);
val SigInc_IxDom_€_thm = save_pop_thm "SigInc_IxDom_€_thm";

set_goal([], ¬µA B· Sig A Ã Sig B ´ IxDom (SOps A) € IxDom (SOps B)®);
a (REPEAT strip_tac THEN fc_tac[SigInc_IxDom_€_thm]);
a (asm_rewrite_tac [map_eq_sym_rule IxDom_Sig_SOps_thm]);
val SigInc_IxDom_Sops_€_thm = save_pop_thm "SigInc_IxDom_Sops_€_thm";

set_goal([], ¬µA B n· Sig A Ã Sig B ± n  IxDom (Sig A) ´ Arity‰i (Sig A) n = Arity‰i (Sig B) n®);
a (REPEAT strip_tac THEN rewrite_tac[Arity‰i_def]);
a (all_fc_tac [Ã_IxVal_thm]);
a (POP_ASM_T ante_tac THEN rewrite_tac [IxVal_def] THEN STRIP_T rewrite_thm_tac);
val SigInc_Arity‰i_thm = save_pop_thm "SigInc_Arity‰i_thm";

set_goal([], ¬µA B n· Sig A Ã Sig B ± n  IxDom (Sig A) ´ Arity‰u A n = Arity‰u B n®);
a (REPEAT strip_tac THEN all_asm_fc_tac [SigInc_Arity‰i_thm]);
a (all_asm_fc_tac [sig_arity_lemma, IxDom_Ã_thm]);
a (all_asm_fc_tac [sig_arity_lemma]);
a (SYM_ASMS_T rewrite_tac);
val SigInc_Arity‰u_thm = save_pop_thm "SigInc_Arity‰u_thm";
=TEX
}%ignore

This is probably too crude, it would probably be better to ignore the irrelevant behaviour of the operators (i.e. values off sig or out of domain).

¹HOLCONST
Ü ÛStructIncİ : ('a) STRUCT ­ ('a) STRUCT ­ BOOL
÷üüüüüüüüüüü
Ü µs t· StructInc s t ¤ SCar s = SCar t ± IxInc (SOps s) (SOps t) 
°

=SML
declare_alias("Ã", ¬StructInc®);
=TEX

There is a general requirement on structures that the operators are closed on the domain of the structure.

¹HOLCONST
Ü ÛClosedOpİ : 'a SET ­ (î ¸ ((î ­ 'a) ­ 'a)) ­ BOOL
÷üüüüüüüüüüü
Ü µs p· ClosedOp s p = µf· (µi· i < Fst p ´ f i  s) ´ Snd p f  s
°

¹HOLCONST
Ü ÛClosedStructİ : ('a) STRUCT ­ BOOL
÷üüüüüüüüüüü
Ü µs· ClosedStruct s ¤ µp· p  IxRan (SOps s) ´ ClosedOp (SCar s) p
°

\subsection{Packing Functions}

The form of the operators is not idea for talking about the structures, so we define some functions which will make more convenient forms readily obtainable.

There are two things we need to be able to do.
The first is to convert 0-ary 1-ary and 2-ary operations in their usual convenient representation to the representation in which the arguments are collected into an indexed set.
The second is to collect the operators into a name-indexed set.

Note that the two kinds of indexed set are represented differently (not that they are different in kind).

¹HOLCONST
Ü ÛPackIxİ : ('a ¸ 'b)LIST ­ ('a, 'b)IX
÷üüüüüüüüüüü
Ü         	PackIx [] = (Ìis· Undefined)
Ü ± µh t·	PackIx (Cons h t) = Ìis·
			if Fst h = is then Value (Snd h) else PackIx t is
°

¹HOLCONST
Ü Ûpack0opİ : 'a ­ (î ¸ ((î ­ 'a) ­ 'a))
÷üüüüüüüüüüü
Ü µc· pack0op c = (0, Ìis· c)
°

¹HOLCONST
Ü Ûpack1opİ : ('a ­ 'a) ­ (î ¸ ((î ­ 'a) ­ 'a))
÷üüüüüüüüüüü
Ü µf· pack1op f = (1, Ìis· f (is 0))
°

¹HOLCONST
Ü Ûpack2opİ : ('a ­ 'a ­ 'a) ­ (î ¸ ((î ­ 'a) ­ 'a))
÷üüüüüüüüüüü
Ü µf· pack2op f = (2, Ìis· f (is 0) (is 1))
°

¹HOLCONST
Ü Ûpackopsİ : (STRING ¸ (î ¸ ((î ­ 'a) ­ 'a)))LIST ­ (STRING, (î ¸ ((î ­ 'a) ­ 'a)))IX
÷üüüüüüüüüüü
Ü         packops [] = (Ìis· Undefined)
Ü ± µh t· packops (Cons h t) = Ìis·
		if Fst h = is then Value (Snd h) else packops t is
°

\subsection{Homomorphisms}

Now we can define the notion of homomorphism.

First we define the requirement on the homomorphism to map the domain of the source into the domain of the target.

¹HOLCONST
Ü ÛFunClosedİ : ('b)STRUCT  ¸ ('b ­ 'c) ¸ ('c) STRUCT ­ BOOL
÷üüüüüü
Ü µ A f B· FunClosed (A, f, B) ¤ µ x· x  SCar A ´ f x  SCar B
°

=GFT
ÛFunClosed_trans_thmİ = ô µ A f B g C·
	FunClosed (A, f, B) ± FunClosed (B, g, C) ´ FunClosed (A, g o f, C)

ÛFunClosed_FunImage_thmİ =
	ô µ A f B· FunClosed (A, f, B) ¤ FunImage f (SCar A) € SCar B
=TEX

\ignore{
=SML
val FunClosed_def = get_spec ¬FunClosed®;

set_goal([], ¬µ A f B g C· FunClosed (A, f, B) ± FunClosed (B, g, C) ´ FunClosed (A, g o f, C)®);
a (REPEAT µ_tac THEN rewrite_tac [FunClosed_def] THEN REPEAT strip_tac THEN REPEAT (all_asm_ufc_tac[]));
val FunClosed_trans_thm = save_pop_thm "FunClosed_trans_thm";

set_goal([], ¬µ A f B· FunClosed (A, f, B) ¤ FunImage f (SCar A) € (SCar B)®);
a (REPEAT µ_tac THEN rewrite_tac [FunClosed_def, FunImage_def, sets_ext_clauses] THEN REPEAT strip_tac THEN REPEAT (all_asm_ufc_tac[]));
(* *** Goal "1" *** *)
a (SYM_ASMS_T rewrite_tac);
(* *** Goal "2" *** *)
a (spec_nth_asm_tac 2 ¬f x®);
a (spec_nth_asm_tac 1 ¬x®);
val FunClosed_FunImage_thm = save_pop_thm "FunClosed_FunImage_thm";
=TEX
}%ignore

Then the requirement that the function respects an operator

¹HOLCONST
Ü ÛHomOpİ : ('b)STRUCT  ¸ ('b ­ 'c) ¸ ('c) STRUCT ­ BOOL
÷üüüüüü
Ü µ A B f· HomOp (A, f, B) ¤ Sig A Ã Sig B ± FunClosed (A, f, B) ±
	µs· s  IxDom (SOps A) ´
		µg· FunImage g {i | i < Arity‰u A s} € (SCar A)
			´ f (Oper A s g) = (Oper B s) (Ìx· f (g x))
°

=GFT
ÛHomOp_o_thmİ =
	ô µ A f B g C· HomOp (A, f, B) ± HomOp (B, g, C) ´ HomOp (A, g o f, C)
=TEX

\ignore{
=SML
val HomOp_def = get_spec ¬HomOp®;

set_goal([], ¬µ A f B g C· HomOp (A, f, B) ± HomOp (B, g, C) ´ HomOp (A, g o f, C)®);
a (REPEAT µ_tac THEN rewrite_tac [HomOp_def] THEN strip_tac);
a (all_fc_tac [FunClosed_trans_thm] THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a (all_fc_tac [IxInc_trans_thm]);
(* *** Goal "2" *** *)
a (ALL_ASM_FC_T rewrite_tac []);
a (rule_nth_asm_tac 2 (rewrite_rule[map_eq_sym_rule IxDom_Sig_thm]));
a (all_asm_fc_tac [IxDom_Ã_thm]);
a (rule_nth_asm_tac 1 (rewrite_rule[IxDom_Sig_thm]));
a (lemma_tac ¬FunImage (f o g') {i|i < Arity‰u B s} € SCar B®);
(* *** Goal "2.1" *** *)
a (ALL_FC_T (MAP_EVERY (rewrite_thm_tac o eq_sym_rule)) [SigInc_Arity‰u_thm]);
a (rewrite_tac [FunImage_o_thm]);
a (all_fc_tac [FunImage_mono_thm]);
a (all_fc_tac [FunClosed_FunImage_thm]);
a (all_ufc_tac [€_trans_thm]);
(* *** Goal "2.2" *** *)
a (ALL_ASM_FC_T (rewrite_tac o (map(rewrite_rule[
			prove_rule [get_spec ¬$o:(('a­'c)­(('b­'a)­('b­'c)))®, ext_thm] ¬(f o g') = (Ì x· f (g' x))®
			]))) []);
val HomOp_o_thm = save_pop_thm "HomOp_o_thm";
=TEX
}%ignore

¹HOLCONST
Ü ÛAlgHomİ : ('b)STRUCT  ¸ ('b ­ 'c) ¸ ('c) STRUCT ­ BOOL
÷üüüüüü
Ü µ A f B· AlgHom (A, f, B) ¤
Ü	Sig A Ã Sig B ± FunClosed (A, f, B) ± HomOp (A, f, B)
°

=GFT
ÛAlgHom_o_thmİ =
	ô µ A f B g C· AlgHom (A, f, B) ± AlgHom (B, g, C) ´ AlgHom (A, g o f, C)
=TEX

\ignore{
=SML
val AlgHom_def = get_spec ¬AlgHom®;

set_goal([], ¬µ A f B g C· AlgHom (A, f, B) ± AlgHom (B, g, C) ´ AlgHom (A, g o f, C)®);
a (REPEAT µ_tac THEN rewrite_tac [AlgHom_def] THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a (all_fc_tac [IxInc_trans_thm]);
(* *** Goal "2" *** *)
a (all_fc_tac [FunClosed_trans_thm]);
(* *** Goal "3" *** *)
a (all_fc_tac [HomOp_o_thm]);
val AlgHom_o_thm = save_pop_thm "AlgHom_o_thm";
=TEX
}%ignore

\subsection{Algebraic Equations}

Algebraic equations in an algebra are preserved under homomorphism.

To prove this general claim we must first define the concept of an algebraic equation, which will be done inductively.
We need to be able to talk about the same algebraic equation over two distinct algebras so the notion will be parameterised by an algebra.

We will represent an expression over an algebra by a function from a valuation of variables to a value.
We generate the expressions for a specific ``signature''.
The signature is just a triple giving the number of 0-ary, 1-ary and 2-ary operations in the algebra.

=SML
declare_type_abbrev("EXPR", ["'a"], ”('a) STRUCT ­ ((î ­ 'a) ­ 'a)®);
=TEX

There is no syntax in this account of polynomials, so the list is a list of the values of the variables.

An equation is a pair of polynomials.

To define the set of polynomials we first define the ways in which new polynomials can be constucted from a set already to hand.
This is by the use of any of the operations in the algebra, and the operation involved is functional composition.

¹HOLCONST
Ü ÛVExprİ : î ­ 'a EXPR
÷üüüüüü
Ü µn· VExpr n = Ìa va· va n
°

¹HOLCONST
Ü ÛVExprsİ : î ­ 'a EXPR SET
÷üüüüüü
Ü µn· VExprs n = {p | ¶m· m < n ± p = VExpr m}
°

¹HOLCONST
Ü ÛCExprsİ : SIG ­ 'a EXPR SET ­ 'a EXPR SET
÷üüüüüü
Ü µsig es· CExprs sig es = {e | ¶name arity am·
Ü		name  IxDom sig ± sig name = Value arity
Ü	±	(µi· i < arity ´ am i  es)
Ü	±	e = Ìstruct va·  (Snd (ValueOf (SOps struct name))) (Ìi· am i struct va)}
°

Now we define closure under the above operators.

¹HOLCONST
Ü ÛExprClosedİ : SIG ­ 'a EXPR SET ­ BOOL
÷üüüüüü
Ü µs es· ExprClosed s es ¤ CExprs s es € es
°

¹HOLCONST
Ü ÛExprsİ : SIG ­ î ­ 'a EXPR SET
÷üüüüüü
Ü µs n· Exprs s n = ¥{ps | ExprClosed s ps ± VExprs n € ps}
°

\ignore{

\subsection{Quotient Algebras}

 ¹HOLCONST
Ü ÛQuotientStructİ : ('b, 'a) STRUCT ­ ('b ­ 'b ­ BOOL) ­ ('b SET, 'a) ALG
 ÷üüüüüü
Ü µ A $¦‰d· QuotientStruct A $¦‰d = 
Ü	let (C, ops) = Å(C, ops)· (MkSTRUCT C ops = A)
Ü	in let D = (C, $¦‰d)
Ü	in MkSTRUCT (EquivClasses D) (Map (Ìop· op MonOpLift D) mops) 
 °

}%ignore


\ignore{
=SML
commit_pc "'unalg";

force_new_pc "Ûunalgİ";
merge_pcs ["rbjmisc", "'unalg"] "unalg";
commit_pc "unalg";

force_new_pc "Ûunalg1İ";
merge_pcs ["rbjmisc1", "'unalg"] "unalg1";
commit_pc "unalg1";
=TEX
}%ignore

\section{Lattices}

=SML
open_theory "unalg";
force_new_theory "lattice";
force_new_pc Û"'lattice"İ;
merge_pcs ["'prove_¶_´_conv", "'savedthm_cs_¶_proof"] "'lattice";
set_merge_pcs ["unalg", "'lattice"];
=TEX

The beginnings of a theory of lattices.
This version was done using Universal Algebra, the previous version will be discarded if this version conformant with the approach to universal algebra is found satisfactory.

=SML
set_merge_pcs ["unalg", "'lattice"] ;
=TEX

\subsection{Signature and Defining Property}

We will use the general structure type \emph{STRUCT} to represent lattice structures.

¹HOLCONST
Ü ÛLatSigİ : SIG
÷üüüüüü
Ü LatSig = PackIx [("²‰L" , 2); ("²‰L" , 2)]
°

We will use L and M as variables for lattices and the following infixity declarations will be useful as names for the corresponding operations.

¹HOLCONST
Ü ÛMkLatİ : 'a SET ­ ('a ­ 'a ­ 'a) ­ ('a ­ 'a ­ 'a) ­ ('a) STRUCT
÷üüüüüü
Ü µd j m· MkLat d j m = MkSTRUCT d (packops [("²‰L" , pack2op j); ("±‰L" , pack2op m)])
°

=SML
declare_infix (235, "²‰L");
declare_infix (235, "²‰M");
declare_infix (240, "±‰L");
declare_infix (240, "±‰M");
=TEX


¹HOLCONST
Ü ÛIsLatİ : ('a) STRUCT ­ BOOL
÷üüüüüü
Ü µ L·	IsLat L ¤ µ C $²‰L $±‰L· StructInc (MkLat C $²‰L $±‰L) L ´ 
Ü       (µx y· x  C ± y  C ´
		x ²‰L y  C ± x ±‰L y  C
	±	x ²‰L y = y ²‰L x ± x ±‰L y = y ±‰L x
	±	x ±‰L (x ²‰L y) = x ± x ²‰L (x ±‰L y) = x
        ± (µz· z  C
		´	(x ²‰L y) ²‰L z = x ²‰L (y ²‰L z)
		±	(x ±‰L y) ±‰L z = x ±‰L (y ±‰L z)))
°

\subsection{Elementary Theorems}

=GFT
Û±‰L_idempot_thmİ =
   ô µ L· IsLat L ´ (µ C $²‰L $±‰L· MkLat C $²‰L $±‰L Ã L
	´ (µ x· x  C ´ x ±‰L x = x))

Û²‰L_idempot_thmİ =
   ô µ L· IsLat L ´ (µ C $²‰L $±‰L· MkLat C $²‰L $±‰L Ã L
	´ (µ x· x  C ´ x ²‰L x = x))
=TEX

\ignore{
=SML
val MkLat_def = get_spec ¬MkLat®;
val IsLat_def = get_spec ¬IsLat®;
val LatSig_def = get_spec ¬LatSig®;

set_goal([], ¬µL· IsLat L ´ µ C $²‰L $±‰L· StructInc (MkLat C $²‰L $±‰L) L ´
	µx· x  C ´ x ±‰L x = x®);
a (REPEAT strip_tac);
a (lemma_tac ¬x ±‰L x  C® THEN1 all_ufc_tac [IsLat_def]);
a (lemma_tac ¬x ±‰L (x ²‰L x ±‰L x) = x® THEN1 all_ufc_tac [IsLat_def]);
a (lemma_tac ¬x ²‰L x ±‰L x = x® THEN1 all_ufc_tac [IsLat_def]);
a (DROP_NTH_ASM_T 2 ante_tac THEN asm_rewrite_tac[]);
val ±‰L_idempot_thm1 = save_pop_thm "±‰L_idempot_thm1";

set_goal([], ¬µL· IsLat L ´ µ C $²‰L $±‰L· StructInc (MkLat C $²‰L $±‰L) L ´
	µx· x  C ´ x ²‰L x = x®);
a (REPEAT_N 8 strip_tac);
a (lemma_tac ¬x ²‰L x  C® THEN1 all_ufc_tac [IsLat_def]);
a (lemma_tac ¬x ²‰L (x ±‰L (x ²‰L x)) = x® THEN1 all_ufc_tac [IsLat_def]);
a (lemma_tac ¬x ±‰L (x ²‰L x) = x® THEN1 all_ufc_tac [IsLat_def]);
a (DROP_NTH_ASM_T 2 ante_tac THEN asm_rewrite_tac[]);
val ²‰L_idempot_thm1 = save_pop_thm "²‰L_idempot_thm1";
=TEX
}%ignore

\subsection{Homomorphisms}

I am hoping that results from Univeral Algebra will not prove difficult to instantiate to Lattice theory.

Let us define a Lattice homomorphism as a homomorphism whose source is a lattice.

¹HOLCONST
Ü ÛLatHomİ : (('a) STRUCT ¸ ('a ­ 'b) ¸ 'b STRUCT) ­ BOOL
÷üüüüüü
Ü µ A f B· LatHom (A, f, B) ¤ AlgHom (A, f, B) ± Sig A = LatSig
°

=GFT
ÛLatHom_o_thmİ =
   ô µ A f B g C· LatHom (A, f, B) ± AlgHom (B, g, C) ´ LatHom (A, g o f, C)
=TEX

\ignore{
=SML
val LatHom_def = get_spec ¬LatHom®;

set_goal([], ¬µA f B g C· LatHom (A,f,B) ± AlgHom (B,g,C) ´ LatHom (A, g o f, C)®);
a (REPEAT µ_tac THEN rewrite_tac [LatHom_def] THEN REPEAT strip_tac THEN all_fc_tac [AlgHom_o_thm]);
val LatHom_o_thm = save_pop_thm "LatHom_o_thm";

=IGN
set_goal([], ¬µA f B· LatHom (A,f,B) ¤ Sig A Ã Sig B ± Sig A = LatSig ± FunClosed (A, f, B)
	± (µ C $²‰L $±‰L D $²‰M $±‰M· MkLat C $²‰L $±‰L Ã A ± MkLat D $²‰M $±‰M Ã B
		´ µl r· l  C ± r  C ´ f(l ²‰L r) = (f l) ²‰M (f r)
			± f(l ±‰L r) = (f l) ±‰M (f r))®);
a (REPEAT µ_tac THEN rewrite_tac [LatHom_def, LatSig_def, IsLat_def, AlgHom_def, FunClosed_def, HomOp_def, MkLat_def]);
a (REPEAT strip_tac THEN_TRY all_asm_fc_tac[]);
val LatHom_o_thm = save_pop_thm "LatHom_o_thm";

=TEX
}%ignore

\ignore{
=SML
commit_pc "'lattice";

force_new_pc "Ûlatticeİ";
merge_pcs ["unalg", "'lattice"] "lattice";
commit_pc "lattice";

force_new_pc "Ûlattice1İ";
merge_pcs ["unalg1", "'lattice"] "lattice1";
commit_pc "lattice1";
=TEX
}%ignore

\section{Conclusions}
