=IGN
$Id: t027.doc,v 1.4 2009/03/01 15:32:39 rbj Exp $
open_theory "infos";

set_flag ("pp_use_alias", true);

set_merge_pcs ["misc21", "'infos"];
=TEX
\documentclass[11pt,a4paper]{article}
\usepackage{latexsym}
\usepackage{ProofPower}
\usepackage{graphics}
%\ftlinepenalty=9999
\usepackage{A4}

%\def\ExpName{\mbox{{\sf exp}
%\def\Exp#1{\ExpName(#1)}

\tabstop=0.4in
\newcommand{\ignore}[1]{}

\title{Infinitary First Order Set Theory}
\makeindex
\usepackage[unicode,pdftex]{hyperref}
\hypersetup{pdfauthor={Roger Bishop Jones}, bookmarks=false, pdffitwindow=false}
\hypersetup{colorlinks=true, urlcolor=black, citecolor=black, filecolor=black, linkcolor=black}

\author{Roger Bishop Jones}
\date{\ }

\begin{document}
\begin{titlepage}
\maketitle
\begin{abstract}
The abstract syntax and semantics of an infinitary first order set theory.
\end{abstract}

\vfill

\begin{centering}

{\footnotesize

Created: 2008/12/05

Last Change $ $Date: 2009/03/01 15:32:39 $ $

\href{http://www.rbjones.com/rbjpub/pp/doc/t027.pdf}
{http://www.rbjones.com/rbjpub/pp/doc/t027.pdf}

$ $Id: t027.doc,v 1.4 2009/03/01 15:32:39 rbj Exp $ $

\copyright\ Roger Bishop Jones; Licenced under Gnu LGPL

}%footnotesize

\end{centering}

\thispagestyle{empty}
\end{titlepage}

\newpage
\addtocounter{page}{1}
%\section{DOCUMENT CONTROL}
%\subsection{Contents list}
{\parskip=0pt\tableofcontents}
%\newpage
%\subsection{Document cross references}

{\raggedright
\bibliographystyle{fmu}
\bibliography{rbj,fmu}
} %\raggedright

\newpage
\section{INTRODUCTION}

The idea is to obtain exotic models of set theory using definability in first order set theory as a source of candidate sets.

To ensure that we get all the well-founded sets we start with definability in an infinitary first order set theory ({\it infos}).
Given any membership structure, i.e. a domain of discourse and a membership relation over that domain, each formula of {\it infos} with one free variable will define a subset of the domain of discourse (you may prefer to think of these as classes, since they will often have the same size as the domain).

If we take as our domain of discourse the formulae of {\it infos} having a single free variable, then the semantics of {\it infos} gives rise to a functor which, given one membership relation over that domain will yield another membership relation.
Over this domain the functor can have no fixed point, for we would have a formula for the Russell set.
To obtain a set theory, we must omit some of these potential sets, i.e. we must consisider subsets as potential domains.
Any subset together with a fixed point of the semantic functor will yeild an interpretation of set theory.

It seems clear that some subsets of the formulae of {\it infos} do have fixed points under the semantics of {\it infos}.
For example, a collection of formulae denoting all the well-founded sets, or those denoting well-founded sets or their complements.

It is the purpose of this work to see whether models for rich non-well-founded set theories can be obtained in this way.
The purpose is ultimately to provide a semantic basis for a kind of type theory suitable for ``formalised mathematics in the large'', in which ordinary mathematics is done primarily using well-founded sets and abstract mathematics often involves non-well-founded sets (theories generic over many types).

=SML
open_theory "misc2";
force_new_theory "ÛinfosÝ";
force_new_pc Û"'infos"Ý;
merge_pcs ["'savedthm_cs_¶_proof"] "'infos";
set_merge_pcs ["misc21", "'infos"];
=TEX

\section{SYNTAX}

The syntax of infinitary first order set theory is to be encoded as sets in a higher order set theory.

This is (in effect if not in appearance) an ``inductive datatype'' (albeit transfinite) so we should expect the usual kinds of theorems.

Informally these should say:

\begin{enumerate}
\item Syntax is closed under the two constructors.
\item The syntax constructors are injections and have disjoint ranges
\item The ranges of the constructors partition the syntax. 
\item Any syntactic property which is preserved by the constructors (i.e. is true of any construction if it is true of all its syntactic constituents) is true of everything in the syntax (this is an induction principle).
\item A recursion theorem which supports definition of recursive functions over the syntax.
\end{enumerate}

As well as the constructors, discriminators and destructors are defined.

\subsection{Constructors, Discriminators and Destructors}

Preliminary to presenting the inductive definition of the required classes we define the nuts and bolts operations on the required syntactic entities (some of which will be used in the inductive definition).

A constructor puts together some syntactic entity from its constituents, discriminators distinguist between the different kinds of entity and destructors take them apart.

``Atomic'' formulae are just membership predicates.
So its just an ordered pair of `terms' (and in our case that just means variable names)  tagged with a zero.

¹HOLCONST
Ü ÛMkAfÝ : GS ¸ GS ­ GS
÷üüüüüüüüüüü
Ü µlr· MkAf lr = (Nat‰g 0) í‰g ((Fst lr) í‰g (Snd lr))
°

¹HOLCONST
Ü ÛIsAfÝ : GS ­ BOOL
÷üüüüüüüüüüü
Ü    µt· IsAf t ¤ ¶lr· t = MkAf lr
°

¹HOLCONST
Ü ÛAfSetÝ : GS ­ GS
÷üüüüüüüüüüü
Ü  AfSet = Ìx· snd(snd x)
°

¹HOLCONST
Ü ÛAfMemÝ : GS ­ GS
÷üüüüüüüüüüü
Ü  AfMem = Ìx· fst(snd x)
°

¹HOLCONST
Ü ÛMkCfÝ : GS ¸ GS ­ GS
÷üüüüüüüüüüü
Ü µvc· MkCf vc = (Nat‰g 1) í‰g ((Fst vc) í‰g (Snd vc))
°

¹HOLCONST
Ü ÛIsCfÝ : GS ­ BOOL
÷üüüüüüüüüüü
Ü    µt· IsCf t ¤ ¶vc· t = MkCf vc
°

¹HOLCONST
Ü ÛCfVarsÝ : GS ­ GS
÷üüüüüüüüüüü
Ü  CfVars = Ìx· fst(snd x)
°

¹HOLCONST
Ü ÛCfFormsÝ : GS ­ GS
÷üüüüüüüüüüü
Ü  CfForms = Ìx· snd(snd x)
°

=GFT
ÛIs_clausesÝ =
   ô (µ x· IsAf (MkAf x))
       ± (µ x· ³ IsAf (MkCf x))
       ± (µ x· ³ IsCf (MkAf x))
       ± (µ x· IsCf (MkCf x))
=TEX
=GFT
Ûsyn_proj_clausesÝ =
    ô (µ s m· AfSet (MkAf (s, m)) = s)
       ± (µ s m· AfMem (MkAf (s, m)) = m)
       ± (µ v f· CfVars (MkCf (v, f)) = v)
       ± (µ v f· CfForms (MkCf (v, f)) = f)
=TEX
=GFT
Ûsyn_con_inv_fc_clausesÝ =
   ô µ p
     · (IsAf p ´ MkAf (AfMem p, AfSet p) = p)
         ± (IsCf p ´ MkCf (CfVars p, CfForms p) = p)
=TEX
=GFT
Ûsyn_con_eq_clausesÝ =
   ô µp1 p2· (MkAf p1 = MkAf p2 ¤ p1 = p2) ± (MkCf p1 =  MkCf p2 ¤ p1 = p2)
=TEX
=GFT
Ûsyn_con_neq_clausesÝ =
   ô µ x y· ³ MkAf x = MkCf y
=TEX
=GFT
Ûis_fc_clauses1Ý =
   ô µ x
     · (IsAf x ´ (¶ s m· x = MkAf (s, m)))
         ± (IsCf x ´ (¶ vars fs· x = MkCf (vars, fs)))
=TEX
=GFT
ÛIs_not_casesÝ =
   ô µ x· ³ IsAf x ² ³ IsCf x

ÛIs_not_fc_clausesÝ =
   ô (µ x· IsAf x ´ ³ IsCf x) ± (µ x· IsCf x ´ ³ IsAf x)
=TEX

\ignore{
=IGN
set_flag("subgoal_package_quiet", true);
=SML

set_goal([], ¬(µx· IsAf (MkAf x))
	± (µx· ³ IsAf (MkCf x))
	± (µx· ³ IsCf (MkAf x))
	± (µx· IsCf (MkCf x))
	®);
a (rewrite_tac [get_spec ¬IsAf®,
	get_spec ¬MkAf®,
	get_spec ¬IsCf®,
	get_spec ¬MkCf®]);
a (strip_tac);
a (¶_tac ¬x® THEN rewrite_tac[]);
val Is_clauses = save_pop_thm "Is_clauses";

set_goal([], ¬(µs m· AfMem (MkAf (m, s)) = m)
	±	(µs m· AfSet (MkAf (m, s)) = s)
	±	(µv f· CfVars (MkCf (v, f)) = v)
	±	(µv f· CfForms (MkCf (v, f)) = f)
®);
a (rewrite_tac (map get_spec [
	¬MkAf®, ¬MkCf®,
	¬AfSet®, ¬AfMem®, ¬CfVars®, ¬CfForms®]));
val syn_proj_clauses = save_pop_thm "syn_proj_clauses";

set_goal([], ¬µp· (IsAf p ´ MkAf (AfMem p, AfSet p) = p)
	±	(IsCf p ´ MkCf (CfVars p, CfForms p) = p)
®);
a (rewrite_tac (map get_spec [
	¬MkAf®, ¬MkCf®,
	¬AfSet®, ¬AfMem®, ¬CfVars®, ¬CfForms®, ¬IsAf®, ¬IsCf®])
	THEN REPEAT strip_tac
	THEN asm_rewrite_tac[]);
val syn_con_inv_fc_clauses = save_pop_thm "syn_con_inv_fc_clauses";

set_goal([], ¬µp1 p2· (MkAf p1 = MkAf p2 ¤ p1 = p2) ± (MkCf p1 =  MkCf p2 ¤ p1 = p2)®);
a (REPEAT µ_tac THEN once_rewrite_tac [prove_rule [] ¬µp· p = (Fst p, Snd p)®]
	THEN rewrite_tac (map get_spec [¬MkAf®, ¬MkCf®, ¬AfSet®, ¬AfMem®, ¬CfVars®, ¬CfForms®, ¬IsAf®, ¬IsCf®])
	THEN REPEAT strip_tac
	THEN asm_rewrite_tac[]);
val syn_con_eq_clauses = save_pop_thm "syn_con_eq_clauses";

set_goal([], ¬µx y· ³ MkAf x = MkCf y®);
a (rewrite_tac (map get_spec [¬MkAf®, ¬MkCf®]));
val syn_con_neq_clauses = save_pop_thm "syn_con_neq_clauses";

add_pc_thms "'infos" [ord_nat_thm, Is_clauses, syn_proj_clauses, syn_con_eq_clauses, syn_con_neq_clauses];
set_merge_pcs ["misc21", "'infos"];

set_goal([], ¬µx·
	(IsAf x ´ ¶s m· x = MkAf (s, m))
±	(IsCf x ´ ¶vars fs· x = MkCf (vars, fs))
®);
a (REPEAT µ_tac THEN rewrite_tac [get_spec ¬IsAf®, get_spec ¬MkAf®, get_spec ¬IsCf®, get_spec ¬MkCf®]);
a (REPEAT strip_tac);
a (¶_tac ¬Fst lr® THEN ¶_tac ¬Snd lr® THEN asm_rewrite_tac[]);
a (¶_tac ¬Fst vc® THEN ¶_tac ¬Snd vc® THEN asm_rewrite_tac[]);
val is_fc_clauses1 = save_pop_thm "is_fc_clauses1";

set_goal([], ¬µx· ³ IsAf x ² ³ IsCf x®);
a (rewrite_tac (map get_spec [¬IsAf®, ¬IsCf®, ¬MkAf®, ¬MkCf®]));
a (REPEAT strip_tac THEN asm_rewrite_tac[]
	THEN contr_tac THEN FC_T (MAP_EVERY ante_tac) [natg_one_one_thm]
	THEN PC_T1 "lin_arith" rewrite_tac[]);
val Is_not_cases = save_pop_thm "Is_not_cases";

set_goal ([], ¬
	(µx· IsAf x ´ ³ IsCf x)
±	(µx· IsCf x ´ ³ IsAf x)
®);
a (rewrite_tac (map get_spec [¬IsAf®, ¬IsCf®, ¬MkAf®, ¬MkCf®]));
a (REPEAT strip_tac THEN asm_rewrite_tac[]
	THEN contr_tac THEN FC_T (MAP_EVERY ante_tac) [natg_one_one_thm]
	THEN PC_T1 "lin_arith" rewrite_tac[]);
val Is_not_fc_clauses = save_pop_thm "Is_not_fc_clauses";
=TEX
}%ignore

Some derived syntax:

¹HOLCONST
Ü ÛMkNotÝ : GS ­ GS
÷üüüüüüüüüüü
Ü µf· MkNot f = MkCf (š‰g, Pair f f)
°

\subsection{The Inductive Definition of Syntax}

This is accomplished by defining the required closure condition (closure under the above constructors for arguments of the right kind) and then taking the intersection of all sets which satisfy the closure condition.

The closure condition is:

¹HOLCONST
Ü ÛRepClosedÝ: GS SET ­ BOOL
÷üüüüüüüüüüü
Ü µ s· RepClosed s ¤
Ü	(µ s2 m· MkAf (s2, m)  s)
Ü±	(µ vars fs· X‰g fs € s ´ MkCf (vars, fs)  s)
°

The well-formed syntax is then the smallest set closed under these constructions.

¹HOLCONST
Ü ÛSyntaxÝ : GS SET
÷üüüüüüüüüüü
Ü Syntax = ¥{x | RepClosed x}
°

I have contrived to arrange the semantics which follows as a monotone function over a complete partial order, so that when I start to look for fixed points of the semantic functor (to give the membership relation for an intepretation of set theory) I can look at the least and greatest fixed points, and either prove one of the total or otherwise employ them to find a total fixed point.

In this scenario the least and greatest fixed points are dual to each other, and there should be a close correspondence between the proofs, the least fixed point corresponding to an inductive and the greatest to a coinductive definition of membership.

When looking at the syntax, which is of course inductively defined, this dualistic mania made me think perhaps that I should also be working with a coinductive version and this provoked my to define {\it CoSyntax} and replicate some results dual to those proven for the syntax.

I doubt very much that there is any value in this exercise (even if I have got it right), since the pertinent duality flows from the lattice of (four) truth values which I use in the semantics, and this has nothing to do with the syntax.
However, pro-tem I will leave the cosyntax definitions in place.

¹HOLCONST
Ü ÛRepOpenÝ: GS SET ­ BOOL
÷üüüüüüüüüüü
Ü µ s· RepOpen s ¤ (µ vars fs· MkCf (vars, fs)  s ´ X‰g fs € s)
°

¹HOLCONST
Ü ÛCoSyntaxÝ : GS SET
÷üüüüüüüüüüü
Ü CoSyntax = Þ{x | RepOpen x}
°

\subsection{Closure}\label{Closure}

=GFT
Ûrepclosed_syntax_lemmaÝ =
	ô RepClosed Syntax

Ûrepopen_cosyntax_lemmaÝ =
	ô RepOpen CoSyntax
=TEX
=GFT
Ûrepclosed_syntax_thmÝ =
	ô (µ s m· MkAf (s, m)  Syntax)
       ± (µ vars fs
       · (µ x· x  X‰g fs ´ x  Syntax) ´ MkCf (vars, fs)  Syntax)

Ûrepopen_cosyntax_thmÝ =
   ô µ vars fs· MkCf (vars, fs)  CoSyntax ´ (µ x· x  X‰g fs ´ x  CoSyntax)
=TEX
=GFT
Ûrepclosed_syntax_thm2Ý =
   ô (µ s2 m· MkAf (s2, m)  Syntax)
       ± (µ vars fs· (µ x· x ‰g fs ´ x  Syntax) ´ MkCf (vars, fs)  Syntax)

Ûrepopen_cosyntax_thm2Ý =
   ô µ vars fs· MkCf (vars, fs)  CoSyntax ´ (µ x· x ‰g fs ´ x  CoSyntax)
=TEX
=GFT
Ûrepclosed_syntax_lemma1Ý =
	ô µ s· RepClosed s ´ Syntax € s

Ûrepopen_cosyntax_lemma1Ý =
	ô µ s· RepOpen s ´ s € CoSyntax
=TEX
=GFT
Ûrepclosed_syntax_lemma2Ý =
	ô µ p· RepClosed {x|p x} ´ (µ x· x  Syntax ´ p x)

Ûrepopen_cosyntax_lemma2Ý =
   ô µ p· RepOpen {x|p x} ´ (µ x· p x ´ x  CoSyntax)
=TEX

\ignore{
=SML
set_goal([], ¬RepClosed Syntax®);
val _ = a (rewrite_tac (map get_spec [¬RepClosed®])
	THEN strip_tac);
(* *** Goal "1" *** *)
val _ = a (rewrite_tac (map get_spec [¬RepClosed®, ¬Syntax®])
	THEN REPEAT strip_tac THEN asm_fc_tac [] THEN asm_rewrite_tac[]);
(* *** Goal "2" *** *)
val _ = a (rewrite_tac (map get_spec [ ¬Syntax®])
	THEN REPEAT strip_tac
	THEN all_asm_fc_tac[]);
val _ = a (fc_tac [get_spec ¬RepClosed®]);
val _ = a (lemma_tac ¬µ x· x  X‰g fs ´ x  s®
	THEN1 (REPEAT strip_tac THEN all_asm_fc_tac[]));
val _ = a (all_asm_fc_tac[]);
a (asm_rewrite_tac[]);
val repclosed_syntax_lemma = pop_thm();

set_goal([], ¬RepOpen CoSyntax®);
a (rewrite_tac (map get_spec [¬RepOpen®, ¬CoSyntax®])
	THEN REPEAT strip_tac);
a (all_asm_fc_tac []);
a (¶_tac ¬s® THEN asm_rewrite_tac[]);
val repopen_cosyntax_lemma = pop_thm();

val repclosed_syntax_thm = save_thm ("repclosed_syntax_thm",
	rewrite_rule [get_spec ¬RepClosed®] repclosed_syntax_lemma);

val repopen_cosyntax_thm = save_thm ("repopen_cosyntax_thm",
	rewrite_rule [get_spec ¬RepOpen®] repopen_cosyntax_lemma);

val repclosed_syntax_thm2 = save_thm ("repclosed_syntax_thm2",
	rewrite_rule [get_spec ¬X‰g®] repclosed_syntax_thm);

val repopen_cosyntax_thm2 = save_thm ("repopen_cosyntax_thm2",
	rewrite_rule [get_spec ¬X‰g®] repopen_cosyntax_thm);

local val _ = set_goal([], ¬µs· RepClosed s ´ Syntax € s®);
val _ = a (rewrite_tac [get_spec ¬Syntax®]
	THEN prove_tac[]);
in val repclosed_syntax_lemma1 = save_pop_thm "repclosed_syntax_lemma1";
end;

set_goal([], ¬µs· RepOpen s ´ s € CoSyntax®);
a (rewrite_tac [get_spec ¬CoSyntax®]
	THEN prove_tac[]);
val repopen_cosyntax_lemma1 = save_pop_thm "repopen_cosyntax_lemma1";

local val _ = set_goal([], ¬µp· RepClosed {x | p x} ´ µx· x  Syntax ´ p x®);
val _ = a (rewrite_tac [get_spec ¬Syntax®] THEN REPEAT strip_tac);
val _ = a (asm_fc_tac[]);
in val repclosed_syntax_lemma2 = save_pop_thm "repclosed_syntax_lemma2";
end;

set_goal([], ¬µp· RepOpen {x | p x} ´ µx· p x ´ x  CoSyntax®);
val _ = a (rewrite_tac [get_spec ¬CoSyntax®] THEN REPEAT strip_tac);
a (¶_tac ¬{x|p x}® THEN asm_rewrite_tac[]);
val repopen_cosyntax_lemma2 = save_pop_thm "repopen_cosyntax_lemma2";
=TEX
}%ignore

\subsection{Recursion and Induction Principles and Rules}\label{Induction}

We need to be able to define functions by recursion over this syntax.
To do that we need to prove that the syntax of comprehensions is well-founded.
This is itself equivalent to an induction principle, so we can try and derive it using the induction principles already available.

We must first define the relation of priority over the syntax, i.e. the relation between an element of the syntax and its constitutents.

¹HOLCONST
Ü ÛScPrecÝ : GS REL
÷üüüüüüüüüüü
Ü µÁ Ç· ScPrec Á Ç ¤
Ü	¶ord fs· Á ‰g fs ± {Á; Ç} € Syntax ± Ç = MkCf (ord, fs)
°

¹HOLCONST
Ü ÛScPrec2Ý : GS REL
÷üüüüüüüüüüü
Ü µÁ Ç· ScPrec2 Á Ç ¤
Ü	¶ord fs· Á ‰g fs ± Ç = MkCf (ord, fs)
°

=GFT
ÛScPrec_tc__thmÝ =
	ô µ x y· ScPrec x y ´ tc $‰g x y

Ûwell_founded_ScPrec_thmÝ =
	ô well_founded ScPrec
=TEX

\ignore{
=SML
local val _ = set_goal([], ¬µx y· ScPrec x y ´ tc $‰g x y®);
val _ = a (rewrite_tac (map get_spec [¬ScPrec®, ¬MkCf®]));
val _ = a (REPEAT strip_tac THEN asm_rewrite_tac [í_tc_thm]);
val _ = a (lemma_tac ¬tc $‰g fs (ord í‰g fs) ± tc $‰g (ord í‰g fs) (Nat‰g 1 í‰g ord í‰g fs)®
	THEN1 rewrite_tac [í_tc_thm]);
val _ = a (all_fc_tac [tc_incr_thm]);
val _ = a (all_fc_tac [tran_tc_thm2]);
val _ = a (all_fc_tac [tran_tc_thm2]);
in val ScPrec_tc__thm = pop_thm();
end;

local val _ = set_goal ([], ¬well_founded ScPrec®);
val _ = a (rewrite_tac [get_spec ¬well_founded®]);
val _ = a (REPEAT strip_tac);
val _ = a (asm_tac (µ_elim ¬s® gs_cv_ind_thm));
val _ = a (lemma_tac ¬µ x· (µ y· tc $‰g y x ´ s y) ´ s x®
	THEN1 REPEAT strip_tac);
(* *** Goal "1" *** *)
val _ = a (lemma_tac ¬µ y· ScPrec y x ´ s y®
	THEN1 (REPEAT strip_tac THEN all_fc_tac [ScPrec_tc__thm]
		THEN asm_fc_tac []));
val _ = a (asm_fc_tac[]);
(* *** Goal "2" *** *)
val _ = a (asm_fc_tac[]);
val _ = a (asm_rewrite_tac[]);
in val well_founded_ScPrec_thm =  save_pop_thm "well_founded_ScPrec_thm";
end;
=TEX
}%ignore

=GFT
ÛScPrec2_tc__thmÝ =
	ô µ x y· ScPrec2 x y ´ tc $‰g x y

Ûwell_founded_ScPrec2_thmÝ =
	ô well_founded ScPrec2

Ûwell_founded_tcScPrec2_thmÝ =
	ô well_founded (tc ScPrec2)
=TEX

\ignore{
=SML
set_goal([], ¬µx y· ScPrec2 x y ´ tc $‰g x y®);
val _ = a (rewrite_tac (map get_spec [¬ScPrec2®, ¬MkCf®]));
val _ = a (REPEAT strip_tac THEN asm_rewrite_tac [í_tc_thm]);
val _ = a (lemma_tac ¬tc $‰g fs (ord í‰g fs) ± tc $‰g (ord í‰g fs) (Nat‰g 1 í‰g ord í‰g fs)®
	THEN1 rewrite_tac [í_tc_thm]);
val _ = a (all_fc_tac [tc_incr_thm]);
val _ = a (all_fc_tac [tran_tc_thm2]);
val _ = a (all_fc_tac [tran_tc_thm2]);
val ScPrec2_tc__thm = pop_thm();

set_goal ([], ¬well_founded ScPrec2®);
val _ = a (rewrite_tac [get_spec ¬well_founded®]);
val _ = a (REPEAT strip_tac);
val _ = a (asm_tac (µ_elim ¬s® gs_cv_ind_thm));
val _ = a (lemma_tac ¬µ x· (µ y· tc $‰g y x ´ s y) ´ s x®
	THEN1 REPEAT strip_tac);
(* *** Goal "1" *** *)
val _ = a (lemma_tac ¬µ y· ScPrec2 y x ´ s y®
	THEN1 (REPEAT strip_tac THEN all_fc_tac [ScPrec2_tc__thm]
		THEN asm_fc_tac []));
val _ = a (asm_fc_tac[]);
(* *** Goal "2" *** *)
val _ = a (asm_fc_tac[]);
val _ = a (asm_rewrite_tac[]);
val well_founded_ScPrec2_thm =  save_pop_thm "well_founded_ScPrec2_thm";

set_goal([], ¬well_founded (tc ScPrec2)®);
val _ = a (asm_tac well_founded_ScPrec2_thm);
val _ = a (fc_tac [wf_tc_wf_thm]);
val well_founded_tcScPrec2_thm = save_pop_thm ("well_founded_tcScPrec2_thm");
=TEX
}%ignore

=SML
val ÛSC2_INDUCTION_TÝ = WF_INDUCTION_T well_founded_ScPrec2_thm;
val Ûsc2_induction_tacÝ = wf_induction_tac well_founded_ScPrec2_thm;
=TEX

The set Syntax gives us the syntactically well-formed phrases of our language.
It will be useful to have some predicates which incorporate well-formedness, which are defined here.

=GFT
Ûsyntax_disj_thmÝ =
   ô µ x
     · x  Syntax
         ´ (¶ s m· x = MkAf (s, m))
           ² (¶ vars fs· (µ y· y ‰g fs ´ y  Syntax) ± x = MkCf (vars, fs))

Ûsyntax_cases_thmÝ =
   ô µ x· x  Syntax ´ IsAf x ² IsCf x

Ûsyntax_cases_fc_clausesÝ =
   ô µ x· x  Syntax ´ (³ IsAf x ´ IsCf x) ± (³ IsCf x ´ IsAf x)
=TEX
=GFT
Ûis_fc_clausesÝ =
   ô µ x
     · x  Syntax
         ´ (IsAf x ´ (¶ s m· x = MkAf (s, m)))
           ± (IsCf x
             ´ (¶ vars fs
             · (µ y· y ‰g fs ´ y  Syntax) ± x = MkCf (vars, fs)))

Ûis_fc_clauses2Ý =
   ô µ x· x  Syntax ´ IsCf x ´ (µ y· y ‰g CfForms x ´ y  Syntax)
=TEX
=GFT
Û³š‰g__syntax_lemmaÝ =
   ô ³ š‰g  Syntax

Û³š‰g__syntax_lemma2Ý =
   ô µ x· x  Syntax ´ ³ x = š‰g

Û³š‰g__syntax_lemma3Ý =
   ô µ V x· x  V ± V € Syntax ´ ³ x = š‰g

ÛMkAf_MkCf_³_š‰g_lemmaÝ =
   ô µ x y· ³ MkAf (x, y) = š‰g ± ³ MkCf (x, y) = š‰g

Ûsyn_comp_fc_clausesÝ =
   ô µ v f· MkCf (v, f)  Syntax ´ (µ y· y ‰g f ´ y  Syntax)

Ûscprec_fc_clausesÝ =
   ô µ Á Ç vars fs· Ç  Syntax ´ Ç = MkCf (vars, fs) ± Á ‰g fs ´ ScPrec Á Ç

Ûscprec2_fc_clausesÝ =
   ô µ Á Ç vars fs· Ç = MkCf (vars, fs) ± Á ‰g fs ´ ScPrec2 Á Ç

Ûscprec_fc_clauses2Ý =
   ô µ t· t  Syntax ´ IsCf t ´ (µ f· f ‰g CfForms t ´ ScPrec f t)

Ûscprec2_fc_clauses2Ý =
   ô µ t· IsCf t ´ (µ f· f ‰g CfForms t ´ ScPrec2 f t)

ÛMkAf__Syntax_lemmaÝ =
   ô µ x y· MkAf (x, y)  Syntax
=TEX

\ignore{
=SML
local val _ = set_goal([], ¬µx·	x  Syntax
´	(¶s m· x = MkAf (s, m))
  ²	(¶vars fs· (µy· y ‰g fs ´ y  Syntax) ± x = MkCf (vars, fs))
®);
val _ = a (contr_tac);
val _ = a (lemma_tac ¬RepClosed (Syntax \ {x})®
	THEN1 (rewrite_tac [get_spec ¬RepClosed®]
		THEN strip_tac));
(* *** Goal "1" *** *)
val _ = a (strip_tac THEN strip_tac
	THEN rewrite_tac [repclosed_syntax_thm]);
val _ = a (spec_nth_asm_tac 2 ¬s2®);
val _ = a (spec_nth_asm_tac 1 ¬m®);
val _ = a (swap_nth_asm_concl_tac 1 THEN (SYM_ASMS_T rewrite_tac));
(* *** Goal "2" *** *)
val _ = a (REPEAT_N 3 strip_tac);
val _ = a (spec_nth_asm_tac 2 ¬vars®);
val _ = a (DROP_NTH_ASM_T 2 ante_tac THEN rewrite_tac [get_spec ¬X‰g®]
	THEN strip_tac);
val _ = a (lemma_tac ¬µ y· y ‰g fs ´ y  Syntax®
	THEN1 (REPEAT strip_tac THEN all_asm_fc_tac[]));
val _ = a (all_fc_tac [rewrite_rule [get_spec ¬X‰g®] repclosed_syntax_thm]);
val _ = a (asm_rewrite_tac[]);
val _ = a (spec_nth_asm_tac 4 ¬fs®);
(* *** Goal "2.1" *** *)
val _ = a (asm_fc_tac[]);
(* *** Goal "2.2" *** *)
val _ = a (swap_nth_asm_concl_tac 1 THEN asm_rewrite_tac[]);
(* *** Goal "3" *** *)
val _ = a (asm_tac repclosed_syntax_lemma1);
val _ = a (spec_nth_asm_tac 1 ¬Syntax \ {x}®);
val _ = a (spec_nth_asm_tac 1 ¬x®);
in val syntax_disj_thm = save_pop_thm "syntax_disj_thm";
end;

local val _ = set_goal([], ¬µx· x  Syntax ´ IsAf x ² IsCf x®);
val _ = a (REPEAT_N 2 strip_tac THEN fc_tac [syntax_disj_thm]
	THEN asm_rewrite_tac[]);
in val syntax_cases_thm = save_pop_thm "syntax_cases_thm";
end;

set_goal ([], ¬µx· x  Syntax ´
	(³ IsAf x ´ IsCf x)
±	(³ IsCf x ´ IsAf x)®);
a (strip_tac THEN strip_tac
	THEN FC_T (MAP_EVERY ante_tac) [syntax_cases_thm]
	THEN (rewrite_tac (map get_spec [¬IsAf®, ¬IsCf®])));
a (REPEAT strip_tac THEN asm_fc_tac[]);
a (¶_tac ¬lr® THEN asm_rewrite_tac[]);
a (¶_tac ¬vc® THEN asm_rewrite_tac[]);
val syntax_cases_fc_clauses = save_pop_thm "syntax_cases_fc_clauses";

local val _ = set_goal([], ¬µx·	x  Syntax
´	(IsAf x ´ ¶s m· x = MkAf (s, m))
±	(IsCf x ´ ¶vars fs· (µy· y ‰g fs ´ y  Syntax) ± x = MkCf (vars, fs))
®);
val _ = a (REPEAT_N 2 strip_tac);
val _ = a (asm_tac (syntax_disj_thm));
val _ = a (asm_fc_tac[] THEN asm_rewrite_tac [Is_clauses]);
(* *** Goal "1" *** *)
val _ = a (¶_tac ¬s® THEN ¶_tac ¬m® THEN asm_rewrite_tac[]);
(* *** Goal "2" *** *)
val _ = a (¶_tac ¬vars® THEN ¶_tac ¬fs® THEN asm_rewrite_tac[]);
in val is_fc_clauses = save_pop_thm "is_fc_clauses";
end;

set_goal([], ¬µx y· MkAf (x,y)  Syntax®);
a (rewrite_tac [get_spec ¬Syntax®, sets_ext_clauses, _in_clauses, get_spec ¬RepClosed®]
	THEN REPEAT strip_tac
	THEN asm_rewrite_tac[]);
val MkAf__Syntax_lemma = save_pop_thm "MkAf__Syntax_lemma";

set_goal([], ¬³ š‰g  Syntax®);
a (LEMMA_T ¬µx· x  Syntax ´ ³ x = š‰g® (fn x => contr_tac THEN fc_tac [x])
	THEN strip_tac);
a (sc2_induction_tac ¬x® THEN strip_tac);
a (strip_asm_tac (µ_elim ¬t® syntax_cases_thm)
	THEN (fc_tac [is_fc_clauses]));
(* *** Goal "1" *** *)
a (POP_ASM_T ante_tac THEN rewrite_tac [get_spec ¬MkAf®]
	THEN strip_tac THEN asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a (POP_ASM_T ante_tac THEN rewrite_tac [get_spec ¬MkAf®]
	THEN strip_tac THEN asm_rewrite_tac[]);
(* *** Goal "3" *** *)
a (POP_ASM_T discard_tac THEN POP_ASM_T ante_tac THEN rewrite_tac [get_spec ¬MkCf®]
	THEN strip_tac THEN asm_rewrite_tac[]);
(* *** Goal "3" *** *)
a (POP_ASM_T ante_tac THEN rewrite_tac [get_spec ¬MkAf®]
	THEN strip_tac THEN asm_rewrite_tac[]);
val ³š‰g__syntax_lemma = save_pop_thm "³š‰g__syntax_lemma";

set_goal([], ¬µx· x  Syntax ´ ³ x = š‰g®);
a (contr_tac THEN var_elim_nth_asm_tac 1
	THEN POP_ASM_T ante_tac
	THEN rewrite_tac [³š‰g__syntax_lemma]);
val ³š‰g__syntax_lemma2 = save_pop_thm "³š‰g__syntax_lemma2";
 
set_goal([], ¬µV x· x  V ± V € Syntax ´ ³ x = š‰g®);
a (REPEAT strip_tac
	THEN lemma_tac ¬x  Syntax® THEN1 PC_T1 "hol1" asm_prove_tac[]
	THEN fc_tac [³š‰g__syntax_lemma2]);
val ³š‰g__syntax_lemma3 = save_pop_thm "³š‰g__syntax_lemma3";

set_goal([], ¬µx y· ³ MkAf (x, y) = š‰g ± ³ MkCf (x, y) = š‰g®);
a (REPEAT strip_tac THEN rewrite_tac [get_spec ¬MkAf®, get_spec ¬MkCf®]);
val MkAf_MkCf_³_š‰g_lemma = pop_thm();

add_pc_thms "'infos" [syn_proj_clauses, ³š‰g__syntax_lemma, MkAf__Syntax_lemma, MkAf_MkCf_³_š‰g_lemma];
set_merge_pcs ["misc21", "'infos"];

local val _ = set_goal([], ¬µx· x  Syntax
	´ (IsCf x ´ (µy· y ‰g (CfForms x) ´ y  Syntax))
®);
val _ = a (REPEAT strip_tac
	THEN all_fc_tac [is_fc_clauses]
	THEN GET_NTH_ASM_T 1 (var_elim_asm_tac o concl)
	THEN_TRY asm_rewrite_tac[]);
val _ = a (DROP_NTH_ASM_T 2 (asm_tac o (rewrite_rule[]))
	THEN all_asm_fc_tac[]);
in val is_fc_clauses2 = save_pop_thm "is_fc_clauses2";
end;

local val _ = set_goal([], ¬
	(µv f· MkCf (v, f)  Syntax ´ (µy· y ‰g f ´ y  Syntax))®);
val _ = a (REPEAT strip_tac
	THEN FC_T (MAP_EVERY (strip_asm_tac o (rewrite_rule []))) [is_fc_clauses2]
	THEN asm_fc_tac[]);
in val syn_comp_fc_clauses = save_pop_thm "syn_comp_fc_clauses";
end;

local val _ = set_goal([], ¬µÁ Ç vars fs· Ç  Syntax ´
		(Ç = MkCf (vars, fs) ± Á ‰g fs) ´ ScPrec Á Ç
®);
val _ = a (rewrite_tac [get_spec ¬ScPrec®]);
val _ = a (REPEAT µ_tac THEN strip_tac THEN strip_tac);
val _ = a (¶_tac ¬vars® THEN ¶_tac ¬fs® THEN asm_rewrite_tac[]);
val _ = a (REPEAT strip_tac THEN var_elim_nth_asm_tac 1);
(* *** Goal "1" *** *)
val _ = a (var_elim_nth_asm_tac 2);
val _ = a (fc_tac [syn_comp_fc_clauses]);
val _ = a (asm_fc_tac[]);
(* *** Goal "2" *** *)
val _ = a (var_elim_nth_asm_tac 2);
in val scprec_fc_clauses = save_pop_thm "scprec_fc_clauses";
end;

set_goal([], ¬µÁ Ç vars fs· Ç = MkCf (vars, fs) ± Á ‰g fs ´ ScPrec2 Á Ç
®);
val _ = a (rewrite_tac [get_spec ¬ScPrec2®]);
val _ = a (REPEAT µ_tac THEN strip_tac);
val _ = a (¶_tac ¬vars® THEN ¶_tac ¬fs® THEN asm_rewrite_tac[]);
val scprec2_fc_clauses = save_pop_thm "scprec2_fc_clauses";

local val _ = set_goal ([], ¬µt· t  Syntax ´ 
	(IsCf t ´ µf· f ‰g CfForms t ´ ScPrec (f) t)®);
val _ = a (REPEAT strip_tac
	THEN all_fc_tac [is_fc_clauses]
	THEN DROP_NTH_ASM_T 3 ante_tac
	THEN asm_rewrite_tac[]
	THEN strip_tac
	THEN all_fc_tac [scprec_fc_clauses]
	THEN POP_ASM_T ante_tac
	THEN_TRY asm_rewrite_tac []);
in val scprec_fc_clauses2 = save_pop_thm "scprec_fc_clauses2";
end;

set_goal ([], ¬µt· IsCf t ´ µf· f ‰g CfForms t ´ ScPrec2 f t®);
a (REPEAT strip_tac
	THEN rewrite_tac [get_spec ¬ScPrec2®]);
a (¶_tac ¬CfVars t® THEN ¶_tac ¬CfForms t® THEN asm_rewrite_tac[]);
a (ALL_FC_T rewrite_tac [syn_con_inv_fc_clauses]);
val scprec2_fc_clauses2 = save_pop_thm "scprec2_fc_clauses2";
=TEX
}%ignore

Inductive proofs using the well-foundedness of ScPrec are fiddly.
The following induction principle simplifies the proofs.

=GFT
Ûsyn_induction_thmÝ =
   ô µ p
     · (µ x y· p (MkAf (x, y)))
	± (µ vars fs· (µf· f ‰g fs ´ f  Syntax)
		± (µf· f ‰g fs ´ p f) ´ p (MkCf (vars, fs)))
         ´ (µ x· x  Syntax ´ p x)
=TEX

\ignore{
=SML
set_goal([], ¬µp· (µx y· p (MkAf (x,y)))
	± (µvars fs· (µf· f ‰g fs ´ f  Syntax) ± (µf· f ‰g fs ´ p f) ´ p (MkCf (vars, fs)))
	´ µx· x  Syntax ´ p x®);
a (REPEAT strip_tac);
a (POP_ASM_T ante_tac THEN sc2_induction_tac ¬x® THEN strip_tac);
a (fc_tac [syntax_cases_thm] THEN fc_tac [is_fc_clauses] THEN asm_rewrite_tac[]);
a (list_spec_nth_asm_tac 7 [¬vars®, ¬fs®] THEN asm_fc_tac[]);
a (lemma_tac ¬tc ScPrec2 f t® THEN_LIST [bc_tac [tc_incr_thm], all_asm_fc_tac []]);
a (all_fc_tac [scprec2_fc_clauses]);
val syn_induction_thm = save_pop_thm "syn_induction_thm";
=TEX
}%ignore

Using this induction principle an induction tactic is defined as follows:

=SML
fun Ûinfos_induction_tacÝ t (a,c) = (
	let val l1 = mk_app (mk_Ì (t,c), t)
	    and l2 = mk_app (mk_app (mk_const ("", ”GS ­ GS SET ­ BOOL®), t),
					mk_const ("Syntax", ”GS SET®))
	in  let val l3 = mk_µ (t, mk_´ (l2, l1))
	in  LEMMA_T l1 (rewrite_thm_tac o rewrite_rule[])
	THEN DROP_ASM_T l2 ante_tac
	THEN LEMMA_T l3 (rewrite_thm_tac o rewrite_rule[])
	THEN bc_tac [syn_induction_thm]
	THEN rewrite_tac[]
	THEN strip_tac
	end end) (a,c);
=TEX

This tactic expects an argument $t$ of type $TERM$ which is a free variable of type $GS$ whose sole occurrence in the assumptions is in an assumption ¬‘t®  Syntax®, and results in two subgoals, one requiring a proof for atomic and the other for compound formulae (with the benefit of the induction hypothesis in the assumptions).

\subsection{Recursion Theorem}\label{Recursion}

The following recursion theorem supports definition by primitive recursion of functions over the syntax.
This version does require (or allow) stipulation of a value for elements which are not part of the syntax (which is sometimes necessary).
The function defined is total over the type GS, but its value is only known for members of {\it Syntax}.

=GFT
Ûsc_recursion_lemmaÝ =
   ô µ af cf
     · ¶ f
       · (µ m s· f (MkAf (m, s)) = af m s)
           ± (µ vars forms
           · f (MkCf (vars, forms)) = cf (FunImage‰g f forms) vars forms)
=TEX

\ignore{
=SML
set_goal([], ¬µaf cf· ¶f· (µm s· f (MkAf (m, s)) = af m s)
	± (µvars forms· f (MkCf (vars, forms)) = cf (FunImage‰g f forms) vars forms)®);
val _ = a (REPEAT strip_tac);
val _ = a (lemma_tac ¬¶g· g = Ìf x·
		if (¶vars forms· x = MkCf(vars,forms)) then cf (FunImage‰g f (CfForms x)) (CfVars x) (CfForms x)
		else af (AfMem x) (AfSet x)®
	THEN1 prove_¶_tac);
val _ = a (lemma_tac ¬g respects ScPrec2®
	THEN1 (asm_rewrite_tac [get_spec ¬$respects®] THEN REPEAT strip_tac));
(* *** Goal "1" *** *)
a (cond_cases_tac ¬¶ vars forms· x = MkCf (vars, forms)®);
a (asm_rewrite_tac[get_spec ¬FunImage‰g®]);
a (LEMMA_T ¬{x'|¶ y· y ‰g forms ± x' = g' y}
             = {x'|¶ y· y ‰g forms ± x' = h y}® rewrite_thm_tac
	THEN1 (rewrite_tac [sets_ext_clauses, _in_clauses]
		THEN REPEAT strip_tac));
(* *** Goal "1.1" *** *)
a (¶_tac ¬y® THEN asm_rewrite_tac[]);
a (lemma_tac ¬ScPrec2 y x®
	THEN1 rewrite_tac [get_spec ¬ScPrec2®]);
(* *** Goal "1.1.1" *** *)
a (¶_tac ¬vars® THEN ¶_tac ¬forms® THEN asm_rewrite_tac[]);
(* *** Goal "1.1.2" *** *)
a (fc_tac[tc_incr_thm] THEN asm_fc_tac[]);
(* *** Goal "1.2" *** *)
a (¶_tac ¬y® THEN asm_rewrite_tac[]);
a (lemma_tac ¬ScPrec2 y x®
	THEN1 rewrite_tac [get_spec ¬ScPrec2®]);
(* *** Goal "1.2.1" *** *)
a (¶_tac ¬vars® THEN ¶_tac ¬forms® THEN asm_rewrite_tac[]);
(* *** Goal "1.2.2" *** *)
a (fc_tac[tc_incr_thm] THEN asm_fc_tac[] THEN asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a (¶_tac ¬fix g®);
a (asm_tac well_founded_ScPrec2_thm);
a (all_fc_tac [get_spec ¬fix®]);
a (POP_ASM_T ante_tac THEN asm_rewrite_tac[] THEN strip_tac);
a (SYM_ASMS_T rewrite_tac THEN REPEAT µ_tac);
a (LEMMA_T ¬¶ vars' forms'· vars = vars' ± forms = forms'® rewrite_thm_tac);
a (¶_tac ¬vars® THEN ¶_tac ¬forms® THEN rewrite_tac[]);
val sc_recursion_lemma = save_pop_thm "sc_recursion_lemma";
=TEX
}%ignore

This gets plugged into proof context {\it 'infos} for use in consistency proofs.

=SML
add_¶_cd_thms [sc_recursion_lemma] "'infos";
set_merge_pcs ["misc21", "'infos"];
=TEX

Definitions of the form supported by the above recursion lemma do not allow sufficient control over the value of a function when applied outside the range of the syntactic constructors.
The following version (if it works) is suitable for cases where this level of control is necessary.

=GFT
Ûsc_recursion_lemma2Ý =
   ô µ af cf ov
     · ¶ f
       · (µ m s· f (MkAf (m, s)) = af m s)
           ± (µ vars forms
           · f (MkCf (vars, forms)) = cf (FunImage‰g f forms) vars forms)
           ± (µ x· ³ IsAf x ± ³ IsCf x ´ f x = ov x)
=TEX

\ignore{
=SML
set_goal([], ¬µaf cf ov· ¶f· (µm s· f (MkAf (m, s)) = af m s)
	± (µvars forms· f (MkCf (vars, forms)) = cf (FunImage‰g f forms) vars forms)
	± (µx· (³ IsAf x ± ³ IsCf x) ´ f x = ov x)
®);
a (REPEAT strip_tac);
a (lemma_tac ¬¶g· g = Ìf x·
		if (¶vars forms· x = MkCf(vars,forms)) then cf (FunImage‰g f (CfForms x)) (CfVars x) (CfForms x)
		else if ¶m s· x = MkAf (m, s) then af (AfMem x) (AfSet x) else ov x®
	THEN1 prove_¶_tac);
a (lemma_tac ¬g respects ScPrec2®
	THEN1 (asm_rewrite_tac [get_spec ¬$respects®] THEN REPEAT strip_tac));
(* *** Goal "1" *** *)
a (cond_cases_tac ¬¶ vars forms· x = MkCf (vars, forms)®);
a (asm_rewrite_tac[get_spec ¬FunImage‰g®]);
a (LEMMA_T ¬{x'|¶ y· y ‰g forms ± x' = g' y}
             = {x'|¶ y· y ‰g forms ± x' = h y}® rewrite_thm_tac
	THEN1 (rewrite_tac [sets_ext_clauses, _in_clauses]
		THEN REPEAT strip_tac));
(* *** Goal "1.1" *** *)
a (¶_tac ¬y® THEN asm_rewrite_tac[]);
a (lemma_tac ¬ScPrec2 y x®
	THEN1 rewrite_tac [get_spec ¬ScPrec2®]);
(* *** Goal "1.1.1" *** *)
a (¶_tac ¬vars® THEN ¶_tac ¬forms® THEN asm_rewrite_tac[]);
(* *** Goal "1.1.2" *** *)
a (fc_tac[tc_incr_thm] THEN asm_fc_tac[]);
(* *** Goal "1.2" *** *)
a (¶_tac ¬y® THEN asm_rewrite_tac[]);
a (lemma_tac ¬ScPrec2 y x®
	THEN1 rewrite_tac [get_spec ¬ScPrec2®]);
(* *** Goal "1.2.1" *** *)
a (¶_tac ¬vars® THEN ¶_tac ¬forms® THEN asm_rewrite_tac[]);
(* *** Goal "1.2.2" *** *)
a (fc_tac[tc_incr_thm] THEN asm_fc_tac[] THEN asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a (¶_tac ¬fix g®);
a (asm_tac well_founded_ScPrec2_thm);
a (all_fc_tac [get_spec ¬fix®]);
a (POP_ASM_T ante_tac THEN asm_rewrite_tac[] THEN strip_tac);
a (SYM_ASMS_T rewrite_tac THEN REPEAT ±_tac THEN REPEAT µ_tac);
(* *** Goal "2.1" *** *)
a (LEMMA_T ¬¶m' s'· m = m' ± s = s'® rewrite_thm_tac
	THEN1 prove_¶_tac);
(* *** Goal "2.2" *** *)
a (LEMMA_T ¬¶ vars' forms'· vars = vars' ± forms = forms'® rewrite_thm_tac
	THEN1 prove_¶_tac);
(* *** Goal "2.3" *** *)
a (strip_tac);
a (LEMMA_T ¬³ ¶ vars forms· x = MkCf (vars, forms)® rewrite_thm_tac);
(* *** Goal "2.3.1" *** *)
a (contr_tac);
a (swap_nth_asm_concl_tac 2 THEN asm_rewrite_tac[]);
(* *** Goal "2.3.2" *** *)
a (LEMMA_T ¬³ ¶ m s· x = MkAf (m, s)® rewrite_thm_tac);
a (swap_nth_asm_concl_tac 2 THEN asm_rewrite_tac[]);
val sc_recursion_lemma2 = pop_thm ();
=TEX
}%ignore


¹HOLCONST
Ü ÛMkTrashÝ : GS ­ GS
÷üüüüüüüüüüü
Ü µx· MkTrash x = if IsAf x ² IsCf x then š‰g else x
°

=GFT
Ûsc_recursion_lemma3Ý =
   ô µ af cf ov
     · ¶ f
       · (µ m s· f (MkAf (m, s)) = af m s)
           ± (µ vars forms
           · f (MkCf (vars, forms)) = cf (FunImage‰g f forms) vars forms)
           ± (µ x· f (MkTrash x) = ov (MkTrash x))
=TEX

\ignore{
=SML
set_goal([], ¬µaf cf ov· ¶f· (µm s· f (MkAf (m, s)) = af m s)
	± (µvars forms· f (MkCf (vars, forms)) = cf (FunImage‰g f forms) vars forms)
	± (µx· f (MkTrash x) = ov (MkTrash x))
®);
a (REPEAT strip_tac);
a (rewrite_tac [get_spec ¬MkTrash®]);
a ((strip_asm_tac o (rewrite_rule [])) (list_µ_elim [¬af®, ¬cf®, ¬Ìz· if IsAf z ² IsCf z then ov š‰g else ov z®] sc_recursion_lemma2));
a (¶_tac ¬f® THEN asm_rewrite_tac []);
a (strip_tac);
a (cond_cases_tac ¬³ IsAf x ± ³ IsCf x® THEN_TRY asm_rewrite_tac[]);
(* *** Goal "1" *** *)
a (ALL_ASM_FC_T asm_rewrite_tac []);
(* *** Goal "2" *** *);
a (spec_nth_asm_tac 2 ¬š‰g® THEN fc_tac [syn_con_inv_fc_clauses]);
a (asm_rewrite_tac []);
a (cond_cases_tac ¬IsAf š‰g ² IsCf š‰g®);
(* *** Goal "3" *** *)
a (spec_nth_asm_tac 2 ¬š‰g® THEN fc_tac [syn_con_inv_fc_clauses]);
a (asm_rewrite_tac []);
a (cond_cases_tac ¬IsAf š‰g ² IsCf š‰g®);
val sc_recursion_lemma3 = save_pop_thm "sc_recursion_lemma3";
=TEX
}%ignore

This also gets plugged into proof context {\it 'infos} for use in consistency proofs.

=SML
add_¶_cd_thms [sc_recursion_lemma3] "'infos";
set_merge_pcs ["misc21", "'infos"];
=TEX

\subsection{Auxiliary Concepts}

Its useful to be able to talk about the free variables in a formula so the definition is given here.

The definition is by recursion over the structure of the syntax.

¹HOLCONST
Ü ÛFreeVarsÝ : GS ­ GS SET
÷üüüüüüüüüüü
Ü (µx y·
Ü	FreeVars (MkAf (x, y)) = {x; y})
Ü± (µvars forms·
Ü	FreeVars (MkCf (vars, forms)) = Þ (FunImage‰g FreeVars forms) \ (X‰g vars))
°

The name {\it SetReps} is defined as the set of formulae with exactly one free variable which is the empty set.
These are the candidate representatives for sets, and represent the set coextensive with the property expressed by the formula.
To know what set that is you need to know the domain of discourse (which in the cases of interest here will always be a subset of {\it SetReps}) and the semantics of formulae, which is defined below.

¹HOLCONST
Ü ÛSetRepsÝ : GS SET
÷üüüüüüüüüüü
Ü SetReps = {x | x  Syntax ± ¶y· FreeVars x = {y}}
°

=GFT
Ûsetreps_€_syntax_lemmaÝ =
	ô SetReps € Syntax

Ûsetreps_€_syntax_lemma2Ý =
	ô V € SetReps ´ V € Syntax
=TEX

\ignore{
=SML
set_goal ([], ¬SetReps € Syntax®);
a (PC_T1 "hol1" prove_tac [get_spec ¬SetReps®]);
val setreps_€_syntax_lemma = save_pop_thm "setreps_€_syntax_lemma";

set_goal ([], ¬V € SetReps ´ V € Syntax®);
a (PC_T1 "hol1" prove_tac [get_spec ¬SetReps®]);
val setreps_€_syntax_lemma2 = save_pop_thm "setreps_€_syntax_lemma2";

set_goal ([], ¬³ š‰g  SetReps®);
a (ante_tac setreps_€_syntax_lemma);
a (rewrite_tac [sets_ext_clauses]
	THEN contr_tac THEN asm_fc_tac[]);
val ³š‰g__setreps_lemma = save_pop_thm "³š‰g__setreps_lemma";

add_pc_thms "'infos" [³š‰g__setreps_lemma];
set_merge_pcs ["misc21", "'infos"];
=TEX
}%ignore


\section{SEMANTICS}

The semantics of infinitary first order logic is given by defining ``truth in an interpretation''.

\subsection{Type Abbreviations}

We consider here some of the value domains which are significant in the semantics.

The following type abbreviations are introduced:

\begin{description}
\item{RV}
Relation Value - this is the type for the meaning of a formula with free variables.
The parameters are the type of the domain of discourse and the type of truth values.
\item{ST}
Structure = a structure is a domain of discourse (a set) together with a binary relation (the membership relation) over that domain.
The membership relation need not (and will not) be boolean.
The parameters are the type of the domain of discourse and the type of truth values.
\end{description}

=SML
declare_infix(300, "‰v");
declare_type_abbrev("ÛRVÝ", ["'a","'b"], ”(GS, 'a)IX ­ 'b®);
declare_type_abbrev("ÛSTÝ", ["'a","'b"], ”'a SET ¸ ('a, 'b)BR®);
=TEX

\subsection{Formula Evaluation}

Now we define the evaluation of formulae, i.e. the notion of truth in a structure given a variable assignment.

There are two cases in the syntax, atomic and compound formulae.

The truth values of the atomic formulae (which are all membership claims) are obtained from a structure given the values of the arguments, which are always variables, i.e. to evaluate an atomic formula you look up the values of the arguments in the current context (variable assignment) and then look up the truth value of the membership relation for those arguments in the structure.
Note that this specification is generic in the type of truth values.

¹HOLCONST
Ü ÛEvalAfÝ : 't REL ­ GS ­ ('a, 't) ST ­ ('a, 't) RV
÷üüüüüüüüüüü
Ü µ$¼‰t (at:GS) (st:('a, 't) ST) (va:(GS, 'a)IX)· EvalAf $¼‰t at st va =
Ü	let d = Fst st
Ü	and rv = Snd st
Ü	and set = AfSet at
Ü	and mem = AfMem at
Ü	in	if mem  IxDom va ± set  IxDom va
Ü		then rv (IxVal va mem) (IxVal va set)
Ü		else Lub $¼‰t {}
°

=GFT
ÛEvalAf_MkAf_lemmaÝ =
   ô µ ¼‰t mem set st va
     · EvalAf ¼‰t (MkAf (set, mem)) st va
         = (if mem  IxDom va ± set  IxDom va
           then Snd st (IxVal va mem) (IxVal va set)
           else Lub ¼‰t {})
=TEX

\ignore{
=SML
set_goal([], ¬µ$¼‰t mem set st va· EvalAf $¼‰t (MkAf (set, mem)) st va =
	if set  IxDom va ± mem  IxDom va
		then Snd st (IxVal va set) (IxVal va mem)
		else Lub $¼‰t {}®);
a (REPEAT µ_tac THEN rewrite_tac [get_spec ¬EvalAf®, let_def]);
val EvalAf_MkAf_lemma = pop_thm ();
=TEX
}%ignore

To evaluate a compound formula you must first evaluate the constituent formulae in every context obtainable by modification of those variables which are bound by the compound formula.
You need only remember the resulting truth values, the compound formulae are in this sense ``truth functional'', and, though this may involve evaluating a very large number of instances of subformulae, it can only yield some subset of the available truth values.

The definition of the truth function depends upon the type of truth values, and is therefore a parameter of the semantics.

The relevant definitions for three and four valued truth types are given here.

=SML
declare_type_abbrev(Û"CFE"Ý, ["'t"], ”'t SET ­ 't®);
=TEX

This function is the core of the semantics of the logic, and captures the truth functional character of first order logic, including the quantifiers even in the infinitary case.
It should be remembered that though I am working here with four truth values, the logic we are formalising is a classical two valued first order logic.
The extra truth values are included to facilitate the discovery of interpretations by making the semantics monotonic and taking least and/or greatest fixed points.

To make this clear I am defining the semantics as a two valued function first so that you can see the intended semantics without the clutter of the extra truth values.
The semantics is for a single compound formula constructor which takes a set of formulae and a set of variables and yields the negation of the (infinitary) conjunction of all the instances of the formulae for every possible valuation of the bound variables.
This function expects the results of evaluating these formulae as a set of truth values, and returns the truth value of the compound formula.

¹HOLCONST
Ü ÛEvalCf_boolÝ : BOOL SET ­ BOOL
÷üüüüüüüüüüü
Ü µresults· EvalCf_bool results = F  results
°

That looks unbelievably simple doesn't it.

When we generalise this to operate with four truth values, you should think of the truth values as sets of boolean truth values ordered by inclusion, i.e. with the empty set as ``bottom'' and the set of both truth values as ``top''.
Then think of the required evaluation function as arising by mapping the boolean evaluator above over the set of choice sets formed from the set of sets of booleans.

¹HOLCONST
Ü ÛLiftEvalCf_boolÝ : BOOL SET SET ­ BOOL SET
÷üüüüüüüüüüü
Ü µresults· LiftEvalCf_bool results =
	{v:BOOL | ¶w f· w = FunImage f results ± v = EvalCf_bool w
		± µx· x  results ± (¶y· y  x) ´ (f x)  x}
°

To get the required evaluator we need to modify this to work with type FTV instead of BOOL SET.

The conversions are:

¹HOLCONST
Ü ÛBoolSet2FTVÝ : BOOL SET ­ FTV
÷üüüüüüüüüüü
Ü µbs· BoolSet2FTV bs =
Ü	if T  bs
Ü	then if F  bs then fT else fTrue
Ü	else if F  bs then fFalse	else fB
°

¹HOLCONST
Ü ÛFTV2BoolSetÝ : FTV ­ BOOL SET
÷üüüüüüüüüüü
Ü µftv· FTV2BoolSet ftv =
	{x | (x = T ± fTrue ¼‰t‰4 ftv) ² (x = F ± fFalse ¼‰t‰4 ftv )}
°

¹HOLCONST
Ü ÛEvalCf2_ftvÝ : FTV CFE
÷üüüüüüüüüüü
Ü µresults· EvalCf2_ftv results =
Ü	BoolSet2FTV (LiftEvalCf_bool (FunImage FTV2BoolSet results))
°

Deriving the result by that means looked like it would be a bit complicated so here's my guess what the result should be:

¹HOLCONST
Ü ÛEvalCf_ftvÝ : FTV CFE
÷üüüüüüüüüüü
Ü µresults· EvalCf_ftv results =  Lub $¼‰t‰4 {t | 
Ü		(fFalse  results ² fT   results) ± t = fTrue
Ü		²
Ü		(³ fFalse  results ± ³ fB  results) ± t = fFalse
Ü		}
°

=GFT
Ûevalcf_ftv_lemmaÝ =
   ô µ s
     · EvalCf_ftv s
         = (if fFalse  s ² fT  s
           then if ³ fFalse  s ± ³ fB  s then fT else fTrue
           else if ³ fFalse  s ± ³ fB  s
           then fFalse
           else fB)

Ûevalcf_ftv_ft_lemmaÝ =
   ô µ s· EvalCf_ftv s = fT ¤ ³ fFalse  s ± fT  s ± ³ fB  s

Ûevalcf_ftv_ft_lemma1Ý =
   ô µ s· EvalCf_ftv s = fT ´ ³ fFalse  s ± fT  s ± ³ fB  s

Ûevalcf_ftv_fb_lemmaÝ =
   ô µ s· EvalCf_ftv s = fB ¤ ³ fFalse  s ± ³ fT  s ± fB  s

Ûevalcf_ftv_fb_lemma1Ý =
   ô µ s· EvalCf_ftv s = fB ´ ³ fFalse  s ± ³ fT  s ± fB  s
=TEX

\ignore{
=SML
push_merge_pcs ["misc2", "'infos"];

set_goal([], ¬µs· EvalCf_ftv s = if fFalse  s ² fT  s
               then if ³ fFalse  s ± ³ fB  s then fT else fTrue
               else if ³ fFalse  s ± ³ fB  s
               then fFalse
               else fB®);
a (rewrite_tac [get_spec ¬EvalCf_ftv®, ¼‰t‰4_lub_thm]);
val evalcf_ftv_lemma = save_pop_thm "evalcf_ftv_lemma";

set_goal([], ¬µs· EvalCf_ftv s = fT ¤ ³ fFalse  s ± fT  s ± ³ fB  s®);
a (µ_tac THEN rewrite_tac [get_spec ¬EvalCf_ftv®, ¼‰t‰4_lub_thm]);
a (cases_tac ¬fFalse  s® THEN_TRY asm_rewrite_tac[]);
a (cases_tac ¬fT  s® THEN cases_tac ¬fB  s® THEN_TRY asm_rewrite_tac[]);
val evalcf_ftv_ft_lemma = save_pop_thm "evalcf_ftv_ft_lemma";

set_goal([], ¬µs· EvalCf_ftv s = fT ´ ³ fFalse  s ± fT  s ± ³ fB  s®);
a (µ_tac THEN rewrite_tac [evalcf_ftv_ft_lemma]);
val evalcf_ftv_ft_lemma1 = save_pop_thm "evalcf_ftv_ft_lemma1";

pop_pc();

set_goal([], ¬µs· EvalCf_ftv s = fB ¤ ³ fFalse  s ± ³ fT  s ± fB  s®);
a (µ_tac THEN rewrite_tac [get_spec ¬EvalCf_ftv®, ¼‰t‰4_lub_thm]);
a (cases_tac ¬fFalse  s® THEN cases_tac ¬fT  s® THEN cases_tac ¬fB  s®
	THEN asm_rewrite_tac[]);
val evalcf_ftv_fb_lemma = save_pop_thm "evalcf_ftv_fb_lemma";

set_goal([], ¬µs· EvalCf_ftv s = fB ´ ³ fFalse  s ± ³ fT  s ± fB  s®);
a (µ_tac THEN rewrite_tac [evalcf_ftv_fb_lemma]);
val evalcf_ftv_fb_lemma1 = save_pop_thm "evalcf_ftv_fb_lemma1";

(*
set_goal([], ¬µs· EvalCf_ftv s = fB ¤ fB  s ± ³ fFalse  s ± ³ fT  s®);
a (µ_tac THEN rewrite_tac [get_spec ¬EvalCf_ftv®]);
a (cond_cases_tac ¬µ x· x  s ´ x = fTrue®);
(* *** Goal "1" *** *)
a (contr_tac THEN asm_fc_tac[]);
(* *** Goal "2" *** *)
a (cond_cases_tac ¬µ x· x  s ´ x = fTrue ² x = fB®);
(* *** Goal "2.1" *** *)
a (contr_tac THEN asm_fc_tac[]);
a (var_elim_nth_asm_tac 1);
(* *** Goal "2.2" *** *)
a (cond_cases_tac ¬fT  s®);
a (contr_tac THEN asm_fc_tac[]);
a (REPEAT (POP_ASM_T ante_tac)
	THEN strip_asm_tac (µ_elim ¬x'® ftv_cases_thm)
	THEN asm_rewrite_tac[]
	THEN contr_tac);
val evalcf_ftv_fb_lemma = save_pop_thm "evalcf_ftv_fb_lemma";
*)
=TEX
}%ignore

This definition shows how the set of truth values of instances of the constituents is obtained from the denotations of the constituent formulae.

¹HOLCONST
Ü ÛEvalCfÝ : 't CFE ­ GS ­ ('a, 't) ST ­ ('a, 't) RV SET ­ ('a, 't) RV
÷üüüüüüüüüüü
Ü µetf f· EvalCf etf f = Ìst rvs va· 
Ü	let Î = CfVars f
Ü	and V = Fst st
Ü	in etf {pb | ¶rv v·
Ü		  rv  rvs
Ü		± IxDom v = X‰g Î
Ü		± IxRan v € V
Ü		± pb = rv (IxOverRide va v)}
°

=GFT
EvalCf_MkCf_lemma =
   ô µ etf vars forms st rvs va
     · EvalCf etf (MkCf (vars, forms)) st rvs va
         = etf
           {pb
             |¶ rv v
               · rv  rvs
                   ± IxDom v = X‰g vars
                   ± IxRan v € Fst st
                   ± pb = rv (IxOverRide va v)}
=TEX

\ignore{
=SML
set_goal([], ¬µetf vars forms st rvs va· EvalCf etf (MkCf (vars, forms)) st rvs va =
		etf {pb | ¶rv v·
Ü		  rv  rvs
Ü		± IxDom v = X‰g vars
Ü		± IxRan v € Fst st
Ü		± pb = rv (IxOverRide va v)}®);
a (REPEAT µ_tac THEN rewrite_tac [get_spec ¬EvalCf®, let_def]);
val EvalCf_MkCf_lemma = pop_thm ();

set_merge_pcs ["misc2", "'infos"];
=TEX
}%ignore

Now we define a parameterised functor of which the semantic function is a fixed point.

¹HOLCONST
Ü ÛEvalFormFunctÝ : 't CFE ¸ 't REL ¸ ('a, 't) ST ­ (GS ­ ('a, 't) RV)
Ü	­ (GS ­ ('a, 't) RV)
÷üüüüüüüüüüü
Ü µcfe $¼‰t st· EvalFormFunct (cfe, $¼‰t, st) = Ìef f·
Ü	if f  Syntax
Ü	then if IsAf f
Ü	     then EvalAf $¼‰t f st
Ü	     else
Ü		let rvs = FunImage ef (X‰g(CfForms f))
Ü	     	in  EvalCf cfe f st rvs
Ü	else Åx·T
°

The semantics of formulae is then given by:

¹HOLCONST
Ü ÛEvalFormÝ : 't CFE ¸ 't REL ¸ ('a, 't) ST ­ GS ­ ('a, 't) RV
÷üüüüüüüüüüü
Ü µcfe $¼‰t st· EvalForm (cfe, $¼‰t, st) = fix (EvalFormFunct (cfe, $¼‰t, st))
°

To use this definition we need to show that there exists a fixed point, for which we must show that the functor respects some well-founded relation.

=GFT
Ûevalformfunct_respect_thmÝ =
   ô µ cfe ¼‰t st· EvalFormFunct (cfe, ¼‰t, st) respects ScPrec

Ûevalformfunct_fixp_lemmaÝ =
   ô µ cfe ¼‰t st
     · EvalForm (cfe, ¼‰t, st)
         = EvalFormFunct (cfe, ¼‰t, st) (EvalForm (cfe, ¼‰t, st))
=TEX
=GFT
Ûevalformfunct_thmÝ =
   ô µ cfe ¼‰t st
     · EvalForm (cfe, ¼‰t, st)
         = (Ì f
         · if f  Syntax
           then
             if IsAf f
             then EvalAf ¼‰t f st
             else 
               let rvs = FunImage (EvalForm (cfe, ¼‰t, st)) (X‰g (CfForms f))
               in EvalCf cfe f st rvs
           else Å x· T)
=TEX
=GFT
Ûevalformfunct_thm2Ý =
   ô µ cfe ¼‰t st f
     · EvalForm (cfe, ¼‰t, st) f
         = (if f  Syntax
           then
             if IsAf f
             then EvalAf ¼‰t f st
             else
               (let rvs
                     = FunImage (EvalForm (cfe, ¼‰t, st)) (X‰g (CfForms f))
               in EvalCf cfe f st rvs)
           else Å f· T)
=TEX

\ignore{
=SML
local val _ = set_goal([], ¬µcfe $¼‰t st· (EvalFormFunct (cfe, $¼‰t, st)) respects ScPrec®);
val _ = a (rewrite_tac [get_spec ¬EvalFormFunct®, get_spec ¬$respects®]
	THEN REPEAT strip_tac);
val _ = a (cases_tac ¬IsAf x® THEN asm_rewrite_tac[]);
val _ = a (cases_tac ¬x  Syntax® THEN asm_rewrite_tac[]);
val _ = a (lemma_tac ¬FunImage g (X‰g (CfForms x)) = FunImage h (X‰g (CfForms x))®
	THEN_TRY asm_rewrite_tac[get_spec ¬X‰g®]);
val _ = a (PC_T1 "hol1" rewrite_tac [get_spec ¬FunImage®]
	THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
val _ = a (fc_tac [syntax_cases_thm]);
val _ = a (all_fc_tac [scprec_fc_clauses2]);
val _ = a (all_asm_fc_tac[tc_incr_thm]);
val _ = a (all_asm_fc_tac[]);
val _ = a (¶_tac ¬a® THEN asm_rewrite_tac[]);
val _ = a (POP_ASM_T (fn x => rewrite_thm_tac (eq_sym_rule x)));
val _ = a (asm_rewrite_tac[]);
(* *** Goal "2" *** *)
val _ = a (fc_tac [syntax_cases_thm]);
val _ = a (all_fc_tac [scprec_fc_clauses2]);
val _ = a (all_asm_fc_tac[tc_incr_thm]);
val _ = a (all_asm_fc_tac[]);
val _ = a (¶_tac ¬a® THEN asm_rewrite_tac[]);
in val evalformfunct_respect_thm = save_pop_thm "evalformfunct_respect_thm";
end;

local val _ = set_goal([], ¬µcfe $¼‰t st· EvalForm (cfe, $¼‰t, st) = EvalFormFunct (cfe, $¼‰t, st) (EvalForm (cfe, $¼‰t, st))®);
val _ = a (asm_tac well_founded_ScPrec_thm);
val _ = a (asm_tac evalformfunct_respect_thm);
val _ = a (REPEAT µ_tac);
val _ = a (list_spec_nth_asm_tac 1 [¬cfe®, ¬$¼‰t®, ¬st®]);
val _ = a (all_fc_tac [µ_elim ¬ScPrec® (µ_elim ¬EvalFormFunct (cfe, $¼‰t, st)® (get_spec ¬fix®))]);
val _ = a (rewrite_tac [get_spec ¬EvalForm®]);
val _ = a (asm_rewrite_tac[]);
in val evalformfunct_fixp_lemma = save_pop_thm "evalformfunct_fixp_lemma";
end;

val evalformfunct_thm = save_thm ("evalformfunct_thm",
	rewrite_rule [get_spec ¬EvalFormFunct®] evalformfunct_fixp_lemma);

local val _ = set_goal([], ¬µ cfe $¼‰t st f
     · EvalForm (cfe, $¼‰t, st) f
         = if f  Syntax
             then
               if IsAf f
               then EvalAf $¼‰t f st
               else 
                 let rvs = FunImage (EvalForm (cfe, $¼‰t, st)) (X‰g (CfForms f))
                 in EvalCf cfe f st rvs
             else Å f· T®);
val _ = a (REPEAT strip_tac THEN rewrite_tac[rewrite_rule [](once_rewrite_rule [ext_thm] evalformfunct_thm)]);
in val evalformfunct_thm2 = save_pop_thm "evalformfunct_thm2";
end;
=TEX
}%ignore

A similar effect can be obtained more concisely as follows:

¹HOLCONST
Ü ÛEvalForm2Ý : 't CFE ¸ 't REL ¸ ('a, 't) ST ­ GS ­ ('a, 't) RV
÷üüüüüüüüüüü
Ü
Ü (µcfe $¼‰t V rv mem set va· EvalForm2 (cfe, $¼‰t, (V, rv)) (MkAf (mem, set)) va = 
Ü	if mem  IxDom va ± set  IxDom va
Ü	then rv (IxVal va mem) (IxVal va set)
Ü	else Lub $¼‰t {})
Ü  ±
Ü (µcfe $¼‰t V rv Î forms va· EvalForm2 (cfe, $¼‰t, (V, rv)) (MkCf (Î, forms)) va =
Ü	cfe {pb | ¶rv2 v· rv2  FunImage‰g (EvalForm2 (cfe, $¼‰t, (V, rv))) forms
Ü		± IxDom v = X‰g Î
Ü		± IxRan v € V
Ü		± pb = rv2 (IxOverRide va v)})
Ü  ±
Ü (µcfe $¼‰t V rv x va· EvalForm2 (cfe, $¼‰t, (V, rv)) (MkTrash x) va = Lub $¼‰t {})
°

However the effect is not identical, and this does not stipulate what happens to elements in the domain type of the function (taking this as GS and treating previous arguments as parameters) but not in the set {\it Syntax}.
This might complicate the problem of establishing the monotonicity of the semantics.

=GFT
ÛEvalForm_MkAf_lemmaÝ =
   ô µ cfe ¼‰t st set mem
     · EvalForm (cfe, ¼‰t, st) (MkAf (set, mem))
         = EvalAf ¼‰t (MkAf (set, mem)) st
=TEX

\ignore{
=IGN
set_goal([], ¬¶EvalForm3· (µcfe $¼‰t V rv mem set va· EvalForm3 (cfe, $¼‰t, (V, rv)) (MkAf (mem, set)) va = 
Ü	if mem  IxDom va ± set  IxDom va
Ü	then rv (IxVal va mem) (IxVal va set)
Ü	else Lub $¼‰t {})
Ü  ±
Ü (µcfe $¼‰t V rv Î forms va· EvalForm3 (cfe, $¼‰t, (V, rv)) (MkCf (Î, forms)) va =
Ü	cfe {pb | ¶rv2 v· rv2  FunImage‰g (EvalForm2 (cfe, $¼‰t, (V, rv))) forms
Ü		± IxDom v = X‰g Î
Ü		± IxRan v € V
Ü		± pb = rv2 (IxOverRide va v)})
    ± µcfe $¼‰t V rv x va· (³ IsAf x ± ³ IsCf x) ´ EvalForm3 (cfe, $¼‰t, (V, rv)) x va = Åy·T
®);

a (prove_¶_tac);


=SML
add_pc_thms "'infos" [get_spec ¬EvalForm2®];
set_merge_pcs ["misc2", "'infos"];
=TEX

=SML
set_goal([], ¬µ cfe $¼‰t st set mem· EvalForm (cfe, $¼‰t, st) (MkAf (set, mem)) = EvalAf $¼‰t (MkAf (set, mem)) st®);
a (REPEAT µ_tac THEN rewrite_tac [evalformfunct_thm2]);
val EvalForm_MkAf_lemma = pop_thm ();
=TEX
}%ignore


=GFT
ÛEvalForm_fT_lemmaÝ =
   ô µ V y
     · y  Syntax
         ´ (µ va
         · FreeVars y € IxDom va
               ± IxRan va € V À {š‰g}
               ± EvalForm (EvalCf_ftv, $¼‰t‰4, V À {š‰g}, $‰v) y va = fT
             ´ (¶ x y· x  V À {š‰g} ± y  V À {š‰g} ± x ‰v y = fT))

ÛEvalForm2_fT_lemmaÝ =
   ô µ V y
     · y  Syntax
         ´ (µ va
         · FreeVars y € IxDom va
               ± IxRan va € V À {š‰g}
               ± EvalForm2 (EvalCf_ftv, $¼‰t‰4, V À {š‰g}, $‰v) y va = fT
             ´ (¶ x y· x  V À {š‰g} ± y  V À {š‰g} ± x ‰v y = fT))
=TEX
=GFT
ÛEvalForm_fT_lemma2Ý =
   ô µ y
     · y  Syntax
         ´ (µ va
         · FreeVars y € IxDom va
               ± IxRan va € V À {š‰g}
               ± EvalForm (EvalCf_ftv, $¼‰t‰4, V, $‰v) y va = fT
             ´ (¶ x y· x  V À {š‰g} ± y  V À {š‰g} ± x ‰v y = fT))

ÛEvalForm2_fT_lemma2Ý =
   ô µ V y
     · y  Syntax
         ´ (µ va
         · FreeVars y € IxDom va
               ± IxRan va € V À {š‰g}
               ± EvalForm2 (EvalCf_ftv, $¼‰t‰4, V, $‰v) y va = fT
             ´ (¶ x y· x  V À {š‰g} ± y  V À {š‰g} ± x ‰v y = fT))
=TEX

\ignore{
=SML
add_pc_thms "'infos" [EvalAf_MkAf_lemma, EvalCf_MkCf_lemma, EvalForm_MkAf_lemma];

push_merge_pcs ["misc2", "'infos"];

set_goal([], ¬µV y· y  Syntax ´ µva· FreeVars y € IxDom va ± IxRan va € V À {š‰g}
	± EvalForm (EvalCf_ftv, $¼‰t‰4, V À {š‰g}, $‰v) y va = fT
	´ (¶ x y:GS· x  V À {š‰g} ± y  V À {š‰g} ± y ‰v x = fT)®);
a (strip_tac THEN strip_tac THEN strip_tac);
a (infos_induction_tac ¬y® THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a (POP_ASM_T ante_tac THEN DROP_NTH_ASM_T 2 ante_tac
	THEN asm_rewrite_tac[get_spec ¬FreeVars®, get_spec ¬$€®, _in_clauses]);
a (strip_tac);
a (spec_nth_asm_tac 1 ¬x®);
a (spec_nth_asm_tac 2 ¬y®);
a (asm_rewrite_tac[]);
a (strip_tac THEN ¶_tac ¬IxVal va y® THEN ¶_tac ¬IxVal va x®);
a (all_fc_tac[ix_domran_lemma]);
a (PC_T1 "hol1" asm_prove_tac []);
(* *** Goal "2" *** *)
a (POP_ASM_T ante_tac THEN rewrite_tac [evalformfunct_thm2, let_def]);
a (ALL_FC_T (fn x => rewrite_tac (x @ [evalcf_ftv_ft_lemma])) [repclosed_syntax_thm2] THEN strip_tac);
a (DROP_NTH_ASM_T 5 ante_tac
	THEN rewrite_tac [get_spec ¬FunImage®, get_spec ¬X‰g®]
	THEN strip_tac
	THEN all_asm_fc_tac []);
a (DROP_NTH_ASM_T 5 ante_tac THEN SYM_ASMS_T rewrite_tac);
a (STRIP_T (asm_tac o eq_sym_rule));
a (spec_nth_asm_tac 11 ¬a®);
a (lemma_tac ¬MkCf(vars, fs)  Syntax®
	THEN1 ALL_FC_T rewrite_tac [rewrite_rule [get_spec ¬X‰g®] repclosed_syntax_thm]);
a (lemma_tac ¬FreeVars a € IxDom (IxOverRide va v)
                 ± IxRan (IxOverRide va v) € V À {š‰g}®
	THEN1 (asm_rewrite_tac []));
(* *** Goal "2.1" *** *)
a (REPEAT strip_tac);
(* *** Goal "2.1.1" *** *)
a (DROP_NTH_ASM_T 12 (ante_tac o (rewrite_rule [get_spec ¬FreeVars®])));
a (asm_rewrite_tac[get_spec ¬FunImage‰g®]);
a (PC_T "hol1" contr_tac);
a (spec_nth_asm_tac 4 ¬x®);
a (spec_nth_asm_tac 1 ¬FreeVars a®);
a (spec_nth_asm_tac 1 ¬a®);
(* *** Goal "2.1.2" *** *)
a (asm_tac (list_µ_elim [¬va®, ¬v®] ixoverride_ixran_lemma));
push_goal([], ¬µA B C D:GS SET· A € B À C ± B € D ± C € D ´ A € D®);
a (PC_T1 "hol1" rewrite_tac [] THEN REPEAT strip_tac THEN REPEAT (asm_fc_tac []));
a (all_fc_tac [pop_thm()]);
(* *** Goal "2.2" *** *)
a (ALL_ASM_FC_T (MAP_EVERY asm_tac) []);
a ((POP_ASM_T discard_tac) THEN POP_ASM_T ante_tac);
a (PC_T1 "hol1" prove_tac[]);
val EvalForm_fT_lemma = save_pop_thm "EvalForm_fT_lemma";

set_goal([], ¬µy· y  Syntax ´ µva· FreeVars y € IxDom va ± IxRan va € V À {š‰g}
	± EvalForm (EvalCf_ftv, $¼‰t‰4, V, $‰v) y va = fT
	´ (¶ x y· x  V À {š‰g} ± y  V À {š‰g} ± y ‰v x = fT)®);
a (strip_tac THEN strip_tac);
a (infos_induction_tac ¬y® THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a (POP_ASM_T ante_tac THEN DROP_NTH_ASM_T 2 ante_tac
	THEN asm_rewrite_tac[get_spec ¬FreeVars®, get_spec ¬$€®, _in_clauses]);
a (strip_tac);
a (spec_nth_asm_tac 1 ¬x®);
a (spec_nth_asm_tac 2 ¬y®);
a (asm_rewrite_tac[]);
a (strip_tac THEN ¶_tac ¬IxVal va y® THEN ¶_tac ¬IxVal va x®
	THEN asm_rewrite_tac[]);
a (all_fc_tac[ix_domran_lemma]);
a (PC_T1 "hol1" asm_prove_tac []);
(* *** Goal "2" *** *)
a (POP_ASM_T ante_tac THEN rewrite_tac [evalformfunct_thm2, let_def]);
a (ALL_FC_T (fn x => rewrite_tac (x @ [evalcf_ftv_ft_lemma])) [repclosed_syntax_thm2] THEN strip_tac);
a (DROP_NTH_ASM_T 5 ante_tac
	THEN rewrite_tac [get_spec ¬FunImage®, get_spec ¬X‰g®]
	THEN strip_tac
	THEN all_asm_fc_tac []);
a (DROP_NTH_ASM_T 5 ante_tac THEN SYM_ASMS_T rewrite_tac);
a (STRIP_T (asm_tac o eq_sym_rule));
a (spec_nth_asm_tac 11 ¬a®);
a (lemma_tac ¬MkCf(vars, fs)  Syntax®
	THEN1 ALL_FC_T rewrite_tac [rewrite_rule [get_spec ¬X‰g®] repclosed_syntax_thm]);
a (lemma_tac ¬FreeVars a € IxDom (IxOverRide va v)
                 ± IxRan (IxOverRide va v) € V À {š‰g}®
	THEN1 (asm_rewrite_tac []));
(* *** Goal "2.1" *** *)
a (REPEAT strip_tac);
(* *** Goal "2.1.1" *** *)
a (DROP_NTH_ASM_T 12 (ante_tac o (rewrite_rule [get_spec ¬FreeVars®])));
a (asm_rewrite_tac[get_spec ¬FunImage‰g®]);
a (PC_T "hol1" contr_tac);
a (spec_nth_asm_tac 4 ¬x®);
a (spec_nth_asm_tac 1 ¬FreeVars a®);
a (spec_nth_asm_tac 1 ¬a®);
(* *** Goal "2.1.2" *** *)
a (asm_tac (list_µ_elim [¬va®, ¬v®] ixoverride_ixran_lemma));
a (lemma_tac ¬IxRan v € V À {š‰g}®
	THEN1 PC_T "hol1" (GET_ASM_T ¬IxRan v € V® ante_tac THEN prove_tac []));
push_goal([], ¬µA B C D:GS SET· A € B À C ± B € D ± C € D ´ A € D®);
a (PC_T1 "hol1" rewrite_tac [] THEN REPEAT strip_tac THEN REPEAT (asm_fc_tac []));
a (all_fc_tac [pop_thm()]);
(* *** Goal "2.2" *** *)
a (ALL_ASM_FC_T (MAP_EVERY asm_tac) []);
a ((POP_ASM_T discard_tac) THEN POP_ASM_T ante_tac);
a (PC_T1 "hol1" prove_tac[]);
val EvalForm_fT_lemma2 = save_pop_thm "EvalForm_fT_lemma2";

set_goal([], ¬µV y· y  Syntax ´ µva· FreeVars y € IxDom va ± IxRan va € V À {š‰g}
	± EvalForm2 (EvalCf_ftv, $¼‰t‰4, V À {š‰g}, $‰v) y va = fT
	´ (¶ x y:GS· x  V À {š‰g} ± y  V À {š‰g} ± x ‰v y = fT)®);
a (strip_tac THEN strip_tac THEN strip_tac);
a (infos_induction_tac ¬y® THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a (POP_ASM_T ante_tac THEN DROP_NTH_ASM_T 2 ante_tac
	THEN asm_rewrite_tac[get_spec ¬FreeVars®, get_spec ¬$€®, _in_clauses]);
a (strip_tac);
a (spec_nth_asm_tac 1 ¬x®);
a (spec_nth_asm_tac 2 ¬y®);
a (asm_rewrite_tac[]);
a (strip_tac THEN ¶_tac ¬IxVal va x® THEN ¶_tac ¬IxVal va y®
	THEN asm_rewrite_tac[]);
a (all_fc_tac[ix_domran_lemma]);
a (PC_T1 "hol1" asm_prove_tac []);
(* *** Goal "2" *** *)
a (POP_ASM_T ante_tac);
a (ALL_FC_T (fn x => rewrite_tac (x @ [evalcf_ftv_ft_lemma])) [repclosed_syntax_thm2] THEN strip_tac);
a (DROP_NTH_ASM_T 5 ante_tac
	THEN rewrite_tac [get_spec ¬FunImage‰g®]
	THEN strip_tac
	THEN all_asm_fc_tac []);
a (DROP_NTH_ASM_T 5 ante_tac THEN asm_rewrite_tac[]);
a (STRIP_T (asm_tac o eq_sym_rule));
a (spec_nth_asm_tac 11 ¬y®);
a (lemma_tac ¬MkCf(vars, fs)  Syntax®
	THEN1 ALL_FC_T rewrite_tac [rewrite_rule [get_spec ¬X‰g®] repclosed_syntax_thm]);
a (lemma_tac ¬FreeVars y € IxDom (IxOverRide va v)
                 ± IxRan (IxOverRide va v) € V À {š‰g}®
	THEN1 (asm_rewrite_tac []));
(* *** Goal "2.1" *** *)
a (REPEAT strip_tac);
(* *** Goal "2.1.1" *** *)
a (DROP_NTH_ASM_T 12 ante_tac
	THEN rewrite_tac[get_spec ¬FreeVars®, get_spec ¬FunImage‰g®]);
a (once_rewrite_tac [sets_ext_clauses]);
a (rewrite_tac [_in_clauses] THEN REPEAT strip_tac);
a (spec_nth_asm_tac 3 ¬x®);
a (spec_nth_asm_tac 1 ¬FreeVars y®);
a (spec_nth_asm_tac 1 ¬y®);
(* *** Goal "2.1.2" *** *)
a (asm_tac (list_µ_elim [¬va®, ¬v®] ixoverride_ixran_lemma));
push_goal([], ¬µA B C D:GS SET· A € B À C ± B € D ± C € D ´ A € D®);
a (PC_T1 "hol1" rewrite_tac [] THEN REPEAT strip_tac THEN REPEAT (asm_fc_tac []));
a (all_fc_tac [pop_thm()]);
(* *** Goal "2.2" *** *)
a (SPEC_NTH_ASM_T 4 ¬IxOverRide va v® (accept_tac o (rewrite_rule
	[asm_rule ¬FreeVars y € IxDom (IxOverRide va v)®,
	asm_rule ¬IxRan (IxOverRide va v) € V À {š‰g}®,
	asm_rule ¬EvalForm2 (EvalCf_ftv, $¼‰t‰4, V À {š‰g}, $‰v) y (IxOverRide va v) = fT®])));
val EvalForm2_fT_lemma = save_pop_thm "EvalForm2_fT_lemma";

set_goal([], ¬µV y· y  Syntax ´ µva· FreeVars y € IxDom va ± IxRan va € V À {š‰g}
	± EvalForm2 (EvalCf_ftv, $¼‰t‰4, V, $‰v) y va = fT
	´ (¶ x y· x  V À {š‰g} ± y  V À {š‰g} ± x ‰v y = fT)®);
a (strip_tac THEN strip_tac THEN strip_tac);
a (infos_induction_tac ¬y® THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a (POP_ASM_T ante_tac THEN DROP_NTH_ASM_T 2 ante_tac
	THEN asm_rewrite_tac[get_spec ¬FreeVars®, get_spec ¬$€®, _in_clauses]);
a (strip_tac);
a (spec_nth_asm_tac 1 ¬x®);
a (spec_nth_asm_tac 2 ¬y®);
a (asm_rewrite_tac[]);
a (strip_tac THEN ¶_tac ¬IxVal va x® THEN ¶_tac ¬IxVal va y®
	THEN asm_rewrite_tac[]);
a (all_fc_tac[ix_domran_lemma]);
a (PC_T1 "hol1" asm_prove_tac []);
(* *** Goal "2" *** *)
a (POP_ASM_T ante_tac
	THEN ALL_FC_T (fn x => rewrite_tac (x @ [evalcf_ftv_ft_lemma, get_spec ¬EvalForm2®]))
		[repclosed_syntax_thm2] THEN strip_tac);
a (DROP_NTH_ASM_T 5 ante_tac
	THEN rewrite_tac [get_spec ¬FunImage‰g®]
	THEN strip_tac
	THEN all_asm_fc_tac []);
a (DROP_NTH_ASM_T 5 ante_tac THEN asm_rewrite_tac []);
a (STRIP_T (asm_tac o eq_sym_rule));
a (spec_nth_asm_tac 11 ¬y®);
a (lemma_tac ¬MkCf(vars, fs)  Syntax®
	THEN1 ALL_FC_T rewrite_tac [rewrite_rule [get_spec ¬X‰g®] repclosed_syntax_thm]);
a (lemma_tac ¬FreeVars y € IxDom (IxOverRide va v)
                 ± IxRan (IxOverRide va v) € V À {š‰g}®
	THEN1 (asm_rewrite_tac []));
(* *** Goal "2.1" *** *)
a (REPEAT strip_tac);
(* *** Goal "2.1.1" *** *)
a (DROP_NTH_ASM_T 12 (ante_tac o (rewrite_rule [get_spec ¬FreeVars®])));
a (asm_rewrite_tac[get_spec ¬FunImage‰g®]);
a (PC_T "hol1" contr_tac);
a (spec_nth_asm_tac 4 ¬x®);
a (spec_nth_asm_tac 1 ¬FreeVars y®);
a (spec_nth_asm_tac 1 ¬y®);
(* *** Goal "2.1.2" *** *)
a (asm_tac (list_µ_elim [¬va®, ¬v®] ixoverride_ixran_lemma));
a (lemma_tac ¬IxRan v € V À {š‰g}®
	THEN1 PC_T "hol1" (GET_ASM_T ¬IxRan v € V® ante_tac THEN prove_tac []));
push_goal([], ¬µA B C D:GS SET· A € B À C ± B € D ± C € D ´ A € D®);
a (PC_T1 "hol1" rewrite_tac [] THEN REPEAT strip_tac THEN REPEAT (asm_fc_tac []));
a (all_fc_tac [pop_thm()]);
(* *** Goal "2.2" *** *)
a (ALL_ASM_FC_T (MAP_EVERY asm_tac) []);
a ((POP_ASM_T discard_tac) THEN POP_ASM_T ante_tac);
a (PC_T1 "hol1" prove_tac[]);
val EvalForm2_fT_lemma2 = save_pop_thm "EvalForm2_fT_lemma2";

pop_pc();
=TEX
}%ignore

\section{MONOTONICITY}

\subsection{Equivalence of Membership Relations}

It proves useful in later proofs to have a notion of equivalence over partial membership relations and to obtain here some lemmas about aspects of the semantics which depend upon a prior notion of membership and give the same result for equivalent relations.

¹HOLCONST
Ü ÛPmrEqÝ : 'a SET ­ ('a, 'b) BR ­ ('a, 'b) BR ­ BOOL
÷üüüüüüüüüüü
Ü µV· PmrEq V = Ìr1 r2· µx y· x  V ± y  V ´ r1 x y = r2 x y
°

=GFT
ÛPmrEq_EvalForm_lemmaÝ =
   ô µ cfe ¼‰t V W f r1 r2
     · V € W ± PmrEq W r1 r2
         ´ f  Syntax
         ´ (µ z
         · IxRan z € W
             ´ EvalForm (cfe, ¼‰t, V, r1) f z
               = EvalForm (cfe, ¼‰t, V, r2) f z)

ÛPmrEq_EvalForm2_lemmaÝ =
   ô µ cfe ¼‰t V W f r1 r2
     · V € W ± PmrEq W r1 r2
         ´ f  Syntax
         ´ (µ z
         · IxRan z € W
             ´ EvalForm2 (cfe, ¼‰t, V, r1) f z
               = EvalForm2 (cfe, ¼‰t, V, r2) f z)
=TEX

\ignore{
=SML
set_goal([], ¬µ cfe ¼‰t V W f r1 r2· V € W ± PmrEq W r1 r2
	´ f  Syntax ´ µz· IxRan z € W ´ EvalForm (cfe, ¼‰t, (V, r1)) f z = EvalForm (cfe, ¼‰t, (V, r2)) f z®);
a (REPEAT µ_tac THEN rewrite_tac [get_spec ¬PmrEq®] THEN strip_tac THEN strip_tac);
a (infos_induction_tac ¬f® THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a (rewrite_tac [evalformfunct_thm2, repclosed_syntax_thm, get_spec ¬EvalAf®, let_def]);
a (cond_cases_tac ¬x  IxDom z ± y  IxDom z®);
a (DROP_ASM_T ¬IxRan z € W® (asm_tac o (rewrite_rule[sets_ext_clauses])));
a (list_spec_nth_asm_tac 4 [¬IxVal z x®, ¬IxVal z y®]);
a (lemma_tac ¬IxVal z x  W®
	THEN1 (fc_tac [ix_domran_lemma] THEN asm_fc_tac[]));
a (lemma_tac ¬IxVal z y  W®
	THEN1 (fc_tac [ix_domran_lemma] THEN asm_fc_tac[]));
(* *** Goal "2" *** *)
a (rewrite_tac [evalformfunct_thm2, let_def]);
a (LEMMA_T ¬MkCf (vars, fs)  Syntax® rewrite_thm_tac
	THEN1 FC_T rewrite_tac [repclosed_syntax_thm2]);
a (rewrite_tac[get_spec ¬EvalCf®, let_def]);
a (LEMMA_T ¬{pb
                 |¶ rv v
                   · rv  FunImage (EvalForm (cfe, ¼‰t, V, r1)) (X‰g fs)
                       ± IxDom v = X‰g vars
                       ± IxRan v € V
                       ± pb = rv (IxOverRide z v)}
             = {pb
                 |¶ rv v
                   · rv  FunImage (EvalForm (cfe, ¼‰t, V, r2)) (X‰g fs)
                       ± IxDom v = X‰g vars
                       ± IxRan v € V
                       ± pb = rv (IxOverRide z v)}® rewrite_thm_tac);
a (rewrite_tac [sets_ext_clauses, _in_clauses]
	THEN REPEAT strip_tac);
(* *** Goal "2.1" *** *)
a (DROP_NTH_ASM_T 4 (strip_asm_tac o (rewrite_rule [get_spec ¬FunImage®])));
a (¶_tac ¬EvalForm (cfe, ¼‰t, V, r2) a® THEN ¶_tac ¬v® THEN asm_rewrite_tac []);
a (SYM_ASMS_T rewrite_tac);
a (DROP_ASM_T ¬a  X‰g fs® (asm_tac o (rewrite_rule [get_spec ¬X‰g®])));
a (asm_fc_tac []);
a (rewrite_tac [get_spec ¬FunImage®] THEN strip_tac);
(* *** Goal "2.1.1" *** *)
a (¶_tac ¬a® THEN asm_rewrite_tac [get_spec ¬X‰g®]);
(* *** Goal "2.1.2" *** *)
a (asm_rewrite_tac []);
a (rewrite_tac [eq_sym_rule (asm_rule ¬EvalForm (cfe, ¼‰t, V, r1) a = rv® )]);
a (all_asm_fc_tac []);
a (lemma_tac ¬IxRan (IxOverRide z v) € W®);
a (asm_tac (list_µ_elim [¬z®, ¬v®] ixoverride_ixran_lemma));
a (lemma_tac ¬IxRan z À IxRan v € W® THEN1 (PC_T1 "hol1" asm_prove_tac []));
a (all_fc_tac [€_trans_thm]);
a (all_asm_fc_tac[]);
(* *** Goal "2.2" *** *)
a (DROP_NTH_ASM_T 4 (strip_asm_tac o (rewrite_rule [get_spec ¬FunImage®])));
a (¶_tac ¬EvalForm (cfe, ¼‰t, V, r1) a® THEN ¶_tac ¬v® THEN asm_rewrite_tac []);
a (SYM_ASMS_T rewrite_tac);
a (DROP_ASM_T ¬a  X‰g fs® (asm_tac o (rewrite_rule [get_spec ¬X‰g®])));
a (asm_fc_tac []);
a (rewrite_tac [get_spec ¬FunImage®] THEN strip_tac);
(* *** Goal "2.2.1" *** *)
a (¶_tac ¬a® THEN asm_rewrite_tac [get_spec ¬X‰g®]);
(* *** Goal "2.2.2" *** *)
a (asm_rewrite_tac []);
a (rewrite_tac [eq_sym_rule (asm_rule ¬EvalForm (cfe, ¼‰t, V, r2) a = rv® )]);
a (all_asm_fc_tac []);
a (lemma_tac ¬IxRan (IxOverRide z v) € W®);
a (asm_tac (list_µ_elim [¬z®, ¬v®] ixoverride_ixran_lemma));
a (lemma_tac ¬IxRan z À IxRan v € W® THEN1 (PC_T1 "hol1" asm_prove_tac []));
a (all_fc_tac [€_trans_thm]);
a (all_asm_fc_tac[]);
a (asm_rewrite_tac[]);
val PmrEq_EvalForm_lemma = save_pop_thm "PmrEq_EvalForm_lemma";

set_goal([], ¬µ cfe ¼‰t V W f r1 r2· V € W ± PmrEq W r1 r2
	´ f  Syntax ´ µz· IxRan z € W ´ EvalForm2 (cfe, ¼‰t, (V, r1)) f z = EvalForm2 (cfe, ¼‰t, (V, r2)) f z®);
a (REPEAT µ_tac THEN rewrite_tac [get_spec ¬PmrEq®] THEN strip_tac THEN strip_tac);
a (infos_induction_tac ¬f®);
(* *** Goal "1" *** *)
a (strip_tac);
a (cond_cases_tac ¬x  IxDom z ± y  IxDom z®);
a (DROP_ASM_T ¬IxRan z € W® (asm_tac o (rewrite_rule[sets_ext_clauses])));
a (lemma_tac ¬IxVal z y  W®
	THEN1 (fc_tac [ix_domran_lemma] THEN asm_fc_tac[]));
a (lemma_tac ¬IxVal z x  W®
	THEN1 (fc_tac [ix_domran_lemma] THEN asm_fc_tac[]));
a (list_spec_nth_asm_tac 6 [¬IxVal z x®, ¬IxVal z y®]);
(* *** Goal "2" *** *)
a (REPEAT strip_tac);
a (LEMMA_T ¬{pb
                 |¶ rv2 v
                   · rv2  FunImage‰g (EvalForm2 (cfe, ¼‰t, V, r1)) fs
                       ± IxDom v = X‰g vars
                       ± IxRan v € V
                       ± pb = rv2 (IxOverRide z v)}
             = {pb
                 |¶ rv2 v
                   · rv2  FunImage‰g (EvalForm2 (cfe, ¼‰t, V, r2)) fs
                       ± IxDom v = X‰g vars
                       ± IxRan v € V
                       ± pb = rv2 (IxOverRide z v)}® rewrite_thm_tac);
a (rewrite_tac [sets_ext_clauses, _in_clauses]
	THEN REPEAT strip_tac);
(* *** Goal "2.1" *** *)
a (DROP_NTH_ASM_T 4 (strip_asm_tac o (rewrite_rule [get_spec ¬FunImage‰g®])));
a (¶_tac ¬EvalForm2 (cfe, ¼‰t, V, r2) y® THEN ¶_tac ¬v®
	THEN asm_rewrite_tac [get_spec ¬FunImage‰g®]
	THEN strip_tac);
(* *** Goal "2.1.1" *** *)
a (¶_tac ¬y® THEN asm_rewrite_tac []);
(* *** Goal "2.1.2" *** *)
a (all_asm_fc_tac []);
a (lemma_tac ¬IxRan (IxOverRide z v) € W®);
(* *** Goal "2.1.2.1" *** *)
a (asm_tac (list_µ_elim [¬z®, ¬v®] ixoverride_ixran_lemma));
a (lemma_tac ¬IxRan z À IxRan v € W® THEN1 (PC_T1 "hol1" asm_prove_tac []));
a (all_fc_tac [€_trans_thm]);
(* *** Goal "2.1.2.2" *** *)
a (all_asm_fc_tac[]);
(* *** Goal "2.2" *** *)
a (DROP_NTH_ASM_T 4 (strip_asm_tac o (rewrite_rule [get_spec ¬FunImage‰g®])));
a (¶_tac ¬EvalForm2 (cfe, ¼‰t, V, r1) y® THEN ¶_tac ¬v®
	THEN asm_rewrite_tac [get_spec ¬FunImage‰g®]
	THEN strip_tac);
(* *** Goal "2.2.1" *** *)
a (¶_tac ¬y® THEN asm_rewrite_tac []);
(* *** Goal "2.2.2" *** *)
a (all_asm_fc_tac []);
a (lemma_tac ¬IxRan (IxOverRide z v) € W®);
(* *** Goal "2.2.2.1" *** *)
a (asm_tac (list_µ_elim [¬z®, ¬v®] ixoverride_ixran_lemma));
a (lemma_tac ¬IxRan z À IxRan v € W® THEN1 (PC_T1 "hol1" asm_prove_tac []));
a (all_fc_tac [€_trans_thm]);
(* *** Goal "2.2.2.2" *** *)
a (all_asm_fc_tac[]);
a (asm_rewrite_tac[]);
val PmrEq_EvalForm2_lemma = save_pop_thm "PmrEq_EvalForm2_lemma";
=TEX
}%ignore

\subsection{Some Orderings}

To help in the location of fixed points we want a semantics which is monotonic, and therefore define here orderings on these domains relative to which we expect the sematantics to be monotonic.

The ordering on relations derives from the ordering on the truth values, using the operator {\it Pw}.

¹HOLCONST
Ü ÛRvOÝ : ('b ­ 'b ­ BOOL) ­ ('a, 'b) RV ­ ('a, 'b) RV ­ BOOL
÷üüüüüüüüüüü
Ü µr· RvO r = Pw r
°

=GFT
Ûrvo_lubs_exist_thmÝ =
	ô µ r· LubsExist r ´ LubsExist (RvO r)

Ûrvo_glbs_exist_thmÝ =
	ô µ r· GlbsExist r ´ GlbsExist (RvO r)
=TEX

\ignore{
=SML
local val _ = set_goal([], ¬µr· LubsExist r ´ LubsExist (RvO r)®);
val _ = a (REPEAT strip_tac
	THEN rewrite_tac [get_spec ¬RvO®]
	THEN REPEAT_N 2 (bc_tac [pw_lubs_exist_thm])
	THEN strip_tac);
in val rvo_lubs_exist_thm = save_pop_thm "rvo_lubs_exist_thm";
end;

local val _ = set_goal([], ¬µr· GlbsExist r ´ GlbsExist (RvO r)®);
val _ = a (REPEAT strip_tac
	THEN rewrite_tac [get_spec ¬RvO®]
	THEN REPEAT_N 2 (bc_tac [pw_glbs_exist_thm])
	THEN strip_tac);
in val rvo_glbs_exist_thm = save_pop_thm "rvo_glbs_exist_thm";
end;
=TEX
}%ignore

¹HOLCONST
Ü ÛRvIsOÝ : ('b ­ 'b ­ BOOL) ­ ('a, 'b) RV IS ­ ('a, 'b) RV IS ­ BOOL
÷üüüüüüüüüüü
Ü µr· RvIsO r = IsEO (RvO r)
°

=GFT
Ûrviso_lubs_exist_thmÝ =
	ô µ r· LubsExist r ´ LubsExist (RvIsO r)

Ûrviso_glbs_exist_thmÝ =
	ô µ r· GlbsExist r ´ GlbsExist (RvIsO r)
=TEX

\ignore{
=SML
local val _ = set_goal([], ¬µr· LubsExist r ´ LubsExist (RvIsO r)®);
val _ = a (REPEAT strip_tac
	THEN rewrite_tac [get_spec ¬RvIsO®]
	THEN bc_tac [is_lubs_exist_thm]
	THEN bc_tac [rvo_lubs_exist_thm]
	THEN strip_tac);
in val rviso_lubs_exist_thm = save_pop_thm "rviso_lubs_exist_thm";
end;

local val _ = set_goal([], ¬µr· GlbsExist r ´ GlbsExist (RvIsO r)®);
val _ = a (REPEAT strip_tac
	THEN rewrite_tac [get_spec ¬RvIsO®]
	THEN bc_tac [is_glbs_exist_thm]
	THEN bc_tac [rvo_glbs_exist_thm]
	THEN strip_tac);
in val rviso_glbs_exist_thm = save_pop_thm "rviso_glbs_exist_thm";
end;
=TEX
}%ignore

¹HOLCONST
Ü ÛStOÝ : ('b ­ 'b ­ BOOL) ­ ('a, 'b) ST ­ ('a, 'b) ST ­ BOOL
÷üüüüüüüüüüü
Ü µr· StO r = DerivedOrder Snd (Pw (Pw r))
°

=GFT
Ûsto_lubs_exist_thmÝ =
	ô µ r· LubsExist r ´ LubsExist (StO r)

Ûsto_glbs_exist_thmÝ =
	ô µ r· GlbsExist r ´ GlbsExist (StO r)
=TEX

\ignore{
=SML
local val _ = set_goal([], ¬µr· LubsExist r ´ LubsExist (StO r)®);
val _ = a (REPEAT strip_tac
	THEN rewrite_tac [get_spec ¬StO®]
	THEN bc_tac [lubsexist_dosnd_thm]
	THEN bc_tac [pw_lubs_exist_thm]
	THEN bc_tac [pw_lubs_exist_thm]
	THEN strip_tac);
in val sto_lubs_exist_thm = save_pop_thm "sto_lubs_exist_thm";
end;

local val _ = set_goal([], ¬µr· GlbsExist r ´ GlbsExist (StO r)®);
val _ = a (REPEAT strip_tac
	THEN rewrite_tac [get_spec ¬StO®]
	THEN bc_tac [glbsexist_dosnd_thm]
	THEN bc_tac [pw_glbs_exist_thm]
	THEN bc_tac [pw_glbs_exist_thm]
	THEN strip_tac);
in val sto_glbs_exist_thm = save_pop_thm "sto_glbs_exist_thm";
end;
=TEX
}%ignore

We will be looking for fixed points of the semantics and one approach to this is to take greatest of least fixed points over various subdomains of the formulae of this set theory.
This is why we are working with non-standard truth value types, so that we can arrange for the semantics to be monotonic relative to orderings derived from that on the truth values.

In order to prove that the semantics is monotonic, we must first define the partial orderings relative to which the semantics is monotonic, and we must obtain fixpoint theorems for the orderings.

We have at present two cases under consideration, according to whether three or four truth values are adopted.

The three valued case turns out in some respects more complex than the four valued case, because it is necessary to make do with chain completeness and the fixed point theorem is more difficult to prove (though in fact the proof has been completed).
I will therefore progress only the four valued case until I find a reason to further progress the three valued case.

Here is the beginning of the three valued case which I started before.

It is also necessary to prove that these partial orderings are CCPOs (chain complete partial orders), this being the weakest condition for which we have a suitable fixed point theorem.
It is convenient to be slightly more definite, to make the orderings all reflexive, and show that they are reflexive CCPOs (for which we use the term CCRPO).

The following ordering is applicable to partial predicates.

=SML
declare_infix(300, "¼‰f‰t‰3");
=TEX

¹HOLCONST
Ü Û$¼‰f‰t‰3Ý : ('a ­ TTV) ­ ('a ­ TTV) ­ BOOL
÷üüüüüüüüüüü
Ü $¼‰f‰t‰3 = Pw $¼‰t‰3
°

=GFT
Ûccrpou_¼‰f‰t‰3_thmÝ =
	ô CcRpoU $¼‰f‰t‰3
=TEX

\ignore{
=SML
local val _ = set_goal([], ¬CcRpoU $¼‰f‰t‰3®);
val _ = a (rewrite_tac [get_spec ¬$¼‰f‰t‰3®]);
val _ = a (asm_tac ccrpou_¼‰t‰3_thm);
val _ = a (fc_tac [pw_ccrpou_thm]);
in val ccrpou_¼‰f‰t‰3_thm = save_pop_thm "ccrpou_¼‰f‰t‰3_thm";
end;
=TEX
}%ignore

Lets now get on with the four valued case.

=SML
declare_infix(300, "¼‰f‰t‰4");
=TEX

¹HOLCONST
Ü Û$¼‰f‰t‰4Ý : ('a ­ FTV) ­ ('a ­ FTV) ­ BOOL
÷üüüüüüüüüüü
Ü $¼‰f‰t‰4 = Pw $¼‰t‰4
°

=GFT
Û¼‰f‰t‰4_crpou_thmÝ =
	ô  CRpoU $¼‰f‰t‰4
=TEX

\ignore{
=SML
local val _ = set_goal([], ¬CRpoU $¼‰f‰t‰4®);
val _ = a (rewrite_tac [get_spec ¬$¼‰f‰t‰4®]);
val _ = a (asm_tac ¼‰t‰4_crpou_thm);
val _ = a (fc_tac [pw_crpou_thm]);
in val ¼‰f‰t‰4_crpou_thm = save_pop_thm "¼‰f‰t‰4_crpou_thm";
end;
=TEX
}%ignore

We need an ordering over variable assignments relative to membership relations which corresponds to degrees of well-definedness of the sets assigned to variables under the membership relation.

It might be helpful to do this separately for the extension and the essence of the sets, so that's what I propose to do here.

We begin with pre-orderings over {\it SetReps} corresponding to extension.

¹HOLCONST
Ü ÛExtSROÝ : GS SET ¸ (GS, FTV)BR ­ GS ­ GS ­ BOOL
÷üüüüüüüüüüü
Ü µV r· ExtSRO (V, r) = Ìx y· µz· z  V ´ r z x ¼‰t‰4 r z y
°

and to essences.

¹HOLCONST
Ü ÛEssSROÝ : GS SET ¸ (GS, FTV)BR ­ GS ­ GS ­ BOOL
÷üüüüüüüüüüü
Ü µV r· EssSRO (V, r) = Ìx y· µz· z  V ´ r x z ¼‰t‰4 r y z
°

Though I suspect I may only need:

¹HOLCONST
Ü ÛExsSROÝ : GS SET ¸ (GS, FTV)BR ­ GS ­ GS ­ BOOL
÷üüüüüüüüüüü
Ü µs· ExsSRO s = ConjOrder (ExtSRO s) (EssSRO s)
°

From this we obtain a pre-ordering over variable assignments:

¹HOLCONST
Ü ÛExsVaOÝ : ('a, GS) IX SET ¸ (GS SET ¸ (GS, FTV)BR)
	­ ('a, GS) IX ­ ('a, GS) IX ­ BOOL
÷üüüüüüüüüüü
Ü µd s· ExsVaO (d, s) = IxO2 (d, (ExsSRO s))
°

The following function is given to determine appropriate sets of indexed sets for use with this ordering.
That is, for any domain V the set of V-valued indexed sets (there is no constraint on the domain for any set can be a variable and we use the indexed sets primarily for variable assignments).

¹HOLCONST
Ü ÛV2IxSetÝ : GS SET ­ ('a, GS) IX SET
÷üüüüüüüüüüü
Ü µV· V2IxSet V = {ix | IxRan ix € V}
°

=GFT
Ûexsvao_ixoverride_lemmaÝ =
   ô µ V $‰v x y v
     · ExsVaO (V2IxSet V, V, $‰v) x y ± IxRan v € V
         ´ ExsVaO (V2IxSet V, V, $‰v) (IxOverRide x v) (IxOverRide y v)

Ûexsvao_ixoverride_lemma2Ý =
   ô µ V W $‰v x y v
     · ExsVaO (V2IxSet V, W, $‰v) x y ± IxRan v € V
         ´ ExsVaO (V2IxSet V, W, $‰v) (IxOverRide x v) (IxOverRide y v)
=TEX

\ignore{
=SML
local val _ = set_goal([], ¬µV $‰v x y v· ExsVaO (V2IxSet V, V, $‰v) x y ± IxRan v € V 
	´ ExsVaO (V2IxSet V, V, $‰v) (IxOverRide x v) (IxOverRide y v)®);
val _ = a (REPEAT µ_tac
	THEN rewrite_tac (map get_spec
	[¬ExsVaO®, ¬IxO2®, ¬ExsSRO®, ¬ExtSRO®, ¬EssSRO®, ¬ConjOrder®, ¬IxO®, ¬OptO®, ¬Pw®, ¬V2IxSet®]));
val _ = a (CASES_T ¬IxRan x € V ± IxRan y € V® asm_tac
	THEN asm_rewrite_tac []
	THEN strip_tac THEN_TRY asm_rewrite_tac[]);
(* *** Goal "1" *** *)
val _ = a (DROP_NTH_ASM_T 4 strip_asm_tac);
val _ = a (LEMMA_T ¬IxRan (IxOverRide x v) € V® rewrite_thm_tac);
(* *** Goal "1.1" *** *)
val _ = a (lemma_tac ¬IxRan (IxOverRide x v) € IxRan x À IxRan v® 
	THEN1 rewrite_tac [ixoverride_ixran_lemma]);
val _ = a (lemma_tac ¬IxRan x À IxRan v € V®
	THEN1 (PC_T1 "hol1" asm_prove_tac []));
val _ = a (all_fc_tac [pc_rule1 "hol1" prove_rule [] ¬µA B C· A € B ± B € C ´ A € C®]);
(* *** Goal "1.2" *** *)
val _ = a (LEMMA_T ¬IxRan (IxOverRide y v) € V® rewrite_thm_tac);
(* *** Goal "1.2.1" *** *)
val _ = a (lemma_tac ¬IxRan (IxOverRide y v) € IxRan y À IxRan v® 
	THEN1 rewrite_tac [ixoverride_ixran_lemma]);
val _ = a (lemma_tac ¬IxRan y À IxRan v € V®
	THEN1 (PC_T1 "hol1" asm_prove_tac []));
val _ = a (all_fc_tac [pc_rule1 "hol1" prove_rule [] ¬µA B C· A € B ± B € C ´ A € C®]);
(* *** Goal "1.2.2" *** *)
val _ = a (strip_tac);
val _ = a (cases_tac ¬IxOverRide x v x' = Undefined® THEN asm_rewrite_tac[]);
(* *** Goal "1.2.2.1" *** *)
val _ = a (lemma_tac ¬IxOverRide y v x' = Undefined ´ IxOverRide x v x' = Undefined®
	THEN1 rewrite_tac [get_spec ¬IxOverRide®, get_spec ¬IxUd®]);
val _ = a (cases_tac ¬v x' = Undefined® THEN asm_rewrite_tac[]);
val _ = a (GET_NTH_ASM_T 7 ante_tac THEN rewrite_tac [get_spec ¬IxDom®, sets_ext_clauses]
	THEN contr_tac THEN asm_fc_tac[]);
(* *** Goal "1.2.2.2" *** *)
val _ = a (asm_rewrite_tac[]);
val _ = a (spec_nth_asm_tac 6 ¬x'®);
(* *** Goal "1.2.2.2.1" *** *)
val _ = a (LEMMA_T ¬IxOverRide x v x' = v x' ± IxOverRide y v x' = v x'® rewrite_thm_tac
	THEN1 (cases_tac ¬v x' = Undefined®
		THEN asm_rewrite_tac[get_spec ¬IxOverRide®, get_spec ¬IxUd®]));
val _ = a (DROP_NTH_ASM_T 9 ante_tac THEN rewrite_tac [get_spec ¬IxDom®, sets_ext_clauses]);
val _ = a (strip_tac THEN spec_nth_asm_tac 1 ¬x'®);
(* *** Goal "1.2.2.2.2" *** *)
val _ = a (cases_tac ¬v x' = Undefined®);
(* *** Goal "1.2.2.2.2.1" *** *)
val _ = a (LEMMA_T ¬IxOverRide x v x' = x x' ± IxOverRide y v x' = y x'® rewrite_thm_tac
	THEN1 (asm_rewrite_tac [get_spec ¬IxOverRide®, get_spec ¬IxUd®]));
val _ = a (spec_nth_asm_tac 11 ¬x'® THEN asm_rewrite_tac []);
(* *** Goal "1.2.2.2.2.2" *** *)
val _ = a (LEMMA_T ¬IxOverRide x v x' = v x' ± IxOverRide y v x' = v x'® rewrite_thm_tac
	THEN1 (asm_rewrite_tac[get_spec ¬IxOverRide®, get_spec ¬IxUd®]));
(* *** Goal "2" *** *)
val _ = a (cases_tac ¬IxRan (IxOverRide y v) € V®	
	THEN asm_rewrite_tac[]
	THEN REPEAT strip_tac);
in val exsvao_ixoverride_lemma = save_pop_thm "exsvao_ixoverride_lemma";
end;

set_goal([], ¬µV W $‰v x y v· ExsVaO (V2IxSet V, W, $‰v) x y ± IxRan v € V 
	´ ExsVaO (V2IxSet V, W, $‰v) (IxOverRide x v) (IxOverRide y v)®);
val _ = a (REPEAT µ_tac
	THEN rewrite_tac (map get_spec
	[¬ExsVaO®, ¬IxO2®, ¬ExsSRO®, ¬ExtSRO®, ¬EssSRO®, ¬ConjOrder®, ¬IxO®, ¬OptO®, ¬Pw®, ¬V2IxSet®]));
val _ = a (CASES_T ¬IxRan x € V ± IxRan y € V® asm_tac
	THEN asm_rewrite_tac []
	THEN strip_tac THEN_TRY asm_rewrite_tac[]);
(* *** Goal "1" *** *)
val _ = a (DROP_NTH_ASM_T 4 strip_asm_tac);
val _ = a (LEMMA_T ¬IxRan (IxOverRide x v) € V® rewrite_thm_tac);
(* *** Goal "1.1" *** *)
val _ = a (lemma_tac ¬IxRan (IxOverRide x v) € IxRan x À IxRan v® 
	THEN1 rewrite_tac [ixoverride_ixran_lemma]);
val _ = a (lemma_tac ¬IxRan x À IxRan v € V®
	THEN1 (PC_T1 "hol1" asm_prove_tac []));
val _ = a (all_fc_tac [pc_rule1 "hol1" prove_rule [] ¬µA B C· A € B ± B € C ´ A € C®]);
(* *** Goal "1.2" *** *)
val _ = a (LEMMA_T ¬IxRan (IxOverRide y v) € V® rewrite_thm_tac);
(* *** Goal "1.2.1" *** *)
val _ = a (lemma_tac ¬IxRan (IxOverRide y v) € IxRan y À IxRan v® 
	THEN1 rewrite_tac [ixoverride_ixran_lemma]);
val _ = a (lemma_tac ¬IxRan y À IxRan v € V®
	THEN1 (PC_T1 "hol1" asm_prove_tac []));
val _ = a (all_fc_tac [pc_rule1 "hol1" prove_rule [] ¬µA B C· A € B ± B € C ´ A € C®]);
(* *** Goal "1.2.2" *** *)
val _ = a (strip_tac);
val _ = a (cases_tac ¬IxOverRide x v x' = Undefined® THEN asm_rewrite_tac[]);
val _ = a (lemma_tac ¬IxOverRide y v x' = Undefined ´ IxOverRide x v x' = Undefined®
	THEN1 rewrite_tac [get_spec ¬IxOverRide®, get_spec ¬IxUd®]);
(* *** Goal "1.2.2.1" *** *)
val _ = a (cases_tac ¬v x' = Undefined® THEN asm_rewrite_tac[]);
val _ = a (GET_NTH_ASM_T 7 ante_tac THEN rewrite_tac [get_spec ¬IxDom®, sets_ext_clauses]
	THEN contr_tac THEN asm_fc_tac[]);
(* *** Goal "1.2.2.2" *** *)
val _ = a (asm_rewrite_tac[]);
val _ = a (spec_nth_asm_tac 6 ¬x'®);
(* *** Goal "1.2.2.2.1" *** *)
val _ = a (LEMMA_T ¬IxOverRide x v x' = v x' ± IxOverRide y v x' = v x'® rewrite_thm_tac
	THEN1 (cases_tac ¬v x' = Undefined®
		THEN asm_rewrite_tac[get_spec ¬IxOverRide®, get_spec ¬IxUd®]));
val _ = a (DROP_NTH_ASM_T 9 ante_tac THEN rewrite_tac [get_spec ¬IxDom®, sets_ext_clauses]);
val _ = a (strip_tac THEN spec_nth_asm_tac 1 ¬x'®);
(* *** Goal "1.2.2.2.2" *** *)
val _ = a (cases_tac ¬v x' = Undefined®);
(* *** Goal "1.2.2.2.2.1" *** *)
val _ = a (LEMMA_T ¬IxOverRide x v x' = x x' ± IxOverRide y v x' = y x'® rewrite_thm_tac
	THEN1 (asm_rewrite_tac [get_spec ¬IxOverRide®, get_spec ¬IxUd®]));
val _ = a (spec_nth_asm_tac 11 ¬x'® THEN asm_rewrite_tac []);
(* *** Goal "1.2.2.2.2.2" *** *)
val _ = a (LEMMA_T ¬IxOverRide x v x' = v x' ± IxOverRide y v x' = v x'® rewrite_thm_tac
	THEN1 (asm_rewrite_tac[get_spec ¬IxOverRide®, get_spec ¬IxUd®]));
(* *** Goal "2" *** *)
val _ = a (cases_tac ¬IxRan (IxOverRide y v) € V®	
	THEN asm_rewrite_tac[]
	THEN REPEAT strip_tac);
val exsvao_ixoverride_lemma2 = save_pop_thm "exsvao_ixoverride_lemma2";
=TEX
}%ignore

\subsection{Monotonicity Results}

First we prove the monotonicity of {\it EvalForm}.

=GFT
Ûevalcf_ftv_increasing_lemmaÝ =
   ô Increasing (SetO $¼‰t‰4) $¼‰t‰4 EvalCf_ftv
=TEX

\ignore{
=SML
set_goal([], ¬Increasing (SetO $¼‰t‰4) $¼‰t‰4 EvalCf_ftv®);
a (rewrite_tac (map get_spec [¬Increasing®]));
a (rewrite_tac [get_spec ¬EvalCf_ftv®]);
a (REPEAT strip_tac THEN bc_tac [rewrite_rule [pure_rewrite_rule [get_spec ¬CRpoU®, get_spec ¬CRpo®] ¼‰t‰4_crpou_thm, get_spec ¬RpoU®] 		(µ_elim ¬$¼‰t‰4® (rewrite_rule [get_spec ¬Increasing®] lub_increasing2_lemma))]);
a (rewrite_tac (map get_spec [¬SetO2®]));
a (REPEAT strip_tac THEN var_elim_nth_asm_tac 1);
(* *** Goal "1" *** *)
a (¶_tac ¬fTrue® THEN rewrite_tac[]);
a (DROP_NTH_ASM_T 2 (strip_asm_tac o (rewrite_rule [get_spec ¬SetO®])));
a (asm_fc_tac []);
a (REPEAT_N 2 (POP_ASM_T ante_tac));
a (strip_asm_tac (µ_elim ¬y'® ftv_cases_thm)
	THEN_TRY asm_rewrite_tac[]
	THEN REPEAT strip_tac);
(* *** Goal "2" *** *)
a (¶_tac ¬fTrue® THEN rewrite_tac[]);
a (DROP_NTH_ASM_T 2 (strip_asm_tac o (rewrite_rule [get_spec ¬SetO®])));
a (asm_fc_tac []);
a (REPEAT_N 2 (POP_ASM_T ante_tac));
a (strip_asm_tac (µ_elim ¬y'® ftv_cases_thm)
	THEN_TRY asm_rewrite_tac[]
	THEN REPEAT strip_tac);
(* *** Goal "3" *** *)
a (¶_tac ¬fFalse® THEN rewrite_tac[]);
a (DROP_NTH_ASM_T 3 (strip_asm_tac o (rewrite_rule [get_spec ¬SetO®])));
a (contr_tac THEN asm_fc_tac[]);
(* *** Goal "3.1" *** *)
a (REPEAT_N 2 (DROP_NTH_ASM_T 6 ante_tac));
a (REPEAT_N 2 (POP_ASM_T ante_tac));
a (strip_asm_tac (µ_elim ¬x'® ftv_cases_thm)
	THEN_TRY asm_rewrite_tac[]
	THEN REPEAT strip_tac);
(* *** Goal "3.2" *** *)
a (REPEAT_N 2 (DROP_NTH_ASM_T 6 ante_tac));
a (REPEAT_N 2 (POP_ASM_T ante_tac));
a (strip_asm_tac (µ_elim ¬x'® ftv_cases_thm)
	THEN_TRY asm_rewrite_tac[]
	THEN REPEAT strip_tac);
val evalcf_ftv_increasing_lemma = save_pop_thm "evalcf_ftv_increasing_lemma";
=TEX
}%ignore

=GFT
Ûevalaf_increasing_lemmaÝ =
   ô µ tr g· CRpoU tr ´ Increasing (StO tr) (RvO tr) (EvalAf tr g)
=TEX

\ignore{
=SML
local val _ = set_goal([], ¬µ tr g· CRpoU tr ´ Increasing (StO tr) (RvO tr) (EvalAf tr g)®);
val _ = a (rewrite_tac (map get_spec [¬Increasing®, ¬EvalAf®, ¬StO®, ¬RvO®,
	¬Pw®, ¬DerivedOrder®, ¬IsEO®, ¬DpoEO®, ¬dpoUdef®, ¬dpoOdef®])
	THEN REPEAT strip_tac);
val _ = a (fc_tac [crpou_fc_clauses]);
val _ = a (rewrite_tac [let_def]);
val _ = a (CASES_T ¬AfMem g  IxDom x' ± AfSet g  IxDom x'® asm_rewrite_thm_tac);
in val evalaf_increasing_lemma = pop_thm();
end;
=TEX
}%ignore

To get a monotonicity result for the semantics of first order logic it is necessary to adjust the type of the semantic function.

The function which we wish to be monotonic is the mapping for each fixed domain of discourse and each particular formula, which take a membership structure (an interpretation of set theory over the gived domain) and returns the relation represented by the formula in that context.

The following function accepts one compound argument containing the relevent context and yields a function which we expect to be monotonic:

¹HOLCONST
Ü ÛMonoEvalFormÝ : 't CFE ¸ 't REL ¸ 'a SET ¸ GS ­ ('a, 't) BR ­ ('a, 't) RV
÷üüüüüüüüüüü
Ü µc r s g ris· MonoEvalForm (c, r, s, g) ris = EvalForm (c, r, (s, ris)) g
°

¹HOLCONST
Ü ÛMonoEvalForm2Ý : 't CFE ¸ 't REL ¸ 'a SET ¸ GS ­ ('a, 't) BR ­ ('a, 't) RV
÷üüüüüüüüüüü
Ü µc r s g ris· MonoEvalForm2 (c, r, s, g) ris = EvalForm2 (c, r, (s, ris)) g
°

=GFT
Ûmonoevalform_increasing_lemmaÝ =
   ô µ c r s g
     · CRpoU r ± Increasing (SetO r) r c
         ´ Increasing (Pw (Pw r)) (RvO r) (MonoEvalForm (c, r, s, g))

Ûevalform_increasing_thmÝ =
   ô µ c r s g
     · CRpoU r ± Increasing (SetO r) r c
         ´ Increasing (Pw (Pw r)) (RvO r) (Ì ris· EvalForm (c, r, s, ris) g)
=TEX

\ignore{
=SML
set_goal ([], ¬µc r s g· CRpoU r ± Increasing (SetO r) r c
	´ Increasing (Pw (Pw r)) (RvO r) (MonoEvalForm (c,r,s,g))®);
a (REPEAT strip_tac);
a (sc2_induction_tac ¬g® THEN_TRY asm_rewrite_tac[]);
a (rewrite_tac ((map get_spec [¬Increasing®, ¬MonoEvalForm®, ¬RvO®, ¬RvIsO®])@[evalformfunct_thm2])
	THEN REPEAT strip_tac);
a (cases_tac ¬t  Syntax® THEN asm_rewrite_tac[]);
(* *** Goal "1" *** *)
val _ = a (cases_tac ¬IsAf t® THEN asm_rewrite_tac[]);
(* *** Goal "1.1" *** *)
val _ = a (fc_tac [inst_type_rule [(”'a®, ”'b®), (”'b®, ”'a®)] evalaf_increasing_lemma]);
val _ = a (spec_nth_asm_tac 1 ¬t® THEN fc_tac [get_spec ¬Increasing®]);
val _ = a (POP_ASM_T ante_tac THEN rewrite_tac [get_spec¬StO®,get_spec¬RvO®,
	get_spec ¬DerivedOrder®] THEN strip_tac);
val _ = a (LIST_SPEC_NTH_ASM_T 1 [¬(s,x)®, ¬(s,y)®] ante_tac
	THEN rewrite_tac[]
	THEN strip_tac);
(* *** Goal "1.2" *** *)
val _ = a (rewrite_tac ((map get_spec [¬Pw®, ¬X‰g®, ¬EvalCf®])@[let_def]));
val _ = a (strip_tac THEN FC_T bc_tac [get_spec ¬Increasing®]);
val _ = a (rewrite_tac [get_spec ¬SetO®] THEN REPEAT strip_tac);
(* *** Goal "1.2.1" *** *)
val _ = a (GET_NTH_ASM_T 4 (strip_asm_tac o (rewrite_rule [get_spec ¬FunImage®])));
val _ = a (¶_tac ¬EvalForm (c, r, s, y) a (IxOverRide x' v)®
	THEN strip_tac);
(* *** Goal "1.2.1.1" *** *)
val _ = a (¶_tac ¬EvalForm (c, r, s, y) a®);
val _ = a (¶_tac ¬v® THEN asm_rewrite_tac[get_spec ¬FunImage®]);
val _ = a (¶_tac ¬a® THEN asm_rewrite_tac[]);
(* *** Goal "1.2.1.2" *** *)
val _ = a (asm_rewrite_tac[]);
val _ = a (GET_NTH_ASM_T 1 (rewrite_thm_tac o eq_sym_rule));
val _ = a (lemma_tac ¬tc ScPrec2 a t®);
(* *** Goal "1.2.1.2.1" *** *)
val _ = a (fc_tac [syntax_cases_thm]);
val _ = a (all_fc_tac [scprec2_fc_clauses2]);
val _ = a (fc_tac [tc_incr_thm]);
(* *** Goal "1.2.1.2.2" *** *)
val _ = a (all_asm_fc_tac[]);
val _ = a (fc_tac[get_spec ¬Increasing®]);
val _ = a (GET_NTH_ASM_T 1 ante_tac THEN rewrite_tac [get_spec ¬RvIsO®, get_spec ¬RvO®]
	THEN STRIP_T (fn x => fc_tac[x]));
val _ = a (POP_ASM_T ante_tac THEN rewrite_tac [get_spec ¬MonoEvalForm®, get_spec ¬Pw®]
	THEN STRIP_T rewrite_thm_tac);
(* *** Goal "1.2.2" *** *)
val _ = a (GET_NTH_ASM_T 4 (strip_asm_tac o (rewrite_rule [get_spec ¬FunImage®])));
val _ = a (¶_tac ¬EvalForm (c, r, s, x) a (IxOverRide x' v)®
	THEN strip_tac);
(* *** Goal "1.2.2.1" *** *)
val _ = a (¶_tac ¬EvalForm (c, r, s, x) a®);
val _ = a (¶_tac ¬v® THEN asm_rewrite_tac[get_spec ¬FunImage®]);
val _ = a (¶_tac ¬a® THEN asm_rewrite_tac[]);
(* *** Goal "1.2.2.2" *** *)
val _ = a (asm_rewrite_tac[]);
val _ = a (GET_NTH_ASM_T 1 (rewrite_thm_tac o eq_sym_rule));
val _ = a (lemma_tac ¬tc ScPrec2 a t®);
(* *** Goal "1.2.2.2.1" *** *)
val _ = a (fc_tac [syntax_cases_thm]);
val _ = a (all_fc_tac [scprec2_fc_clauses2]);
val _ = a (fc_tac [tc_incr_thm]);
(* *** Goal "1.2.2.2.2" *** *)
val _ = a (all_asm_fc_tac[]);
val _ = a (fc_tac[get_spec ¬Increasing®]);
val _ = a (GET_NTH_ASM_T 1 ante_tac THEN rewrite_tac [get_spec ¬RvIsO®, get_spec ¬RvO®]
	THEN STRIP_T (fn x => fc_tac[x]));
val _ = a (POP_ASM_T ante_tac THEN rewrite_tac [get_spec ¬MonoEvalForm®, get_spec ¬Pw®]
	THEN STRIP_T rewrite_thm_tac);
(* *** Goal "2" *** *)
val _ = a (fc_tac [inst_type_rule [(”'a®, ”'b®), (”GS ­ 'b OPT®, ”'a®)] pw_crpou_thm]);
val _ = a (fc_tac [crpou_fc_clauses] THEN asm_rewrite_tac[]);
val monoevalform_increasing_lemma = pop_thm();
=IGN
stop;

set_goal ([], ¬µc r s g· CRpoU r ± Increasing (SetO r) r c
	´ Increasing (Pw (Pw r)) (RvO r) (MonoEvalForm2 (c,r,s,g))®);
a (REPEAT strip_tac);
a (sc2_induction_tac ¬g® THEN_TRY asm_rewrite_tac[]);
a (rewrite_tac ((map get_spec [¬Increasing®, ¬MonoEvalForm2®, ¬RvO®, ¬RvIsO®, ¬EvalForm2®, ¬Pw®])@[])
	THEN REPEAT strip_tac);
a (cond_cases_tac ¬t  Syntax®);

(* *** Goal "1" *** *)
val _ = a (cases_tac ¬IsAf t® THEN asm_rewrite_tac[]);
(* *** Goal "1.1" *** *)
val _ = a (fc_tac [inst_type_rule [(”'a®, ”'b®), (”'b®, ”'a®)] evalaf_increasing_lemma]);
val _ = a (spec_nth_asm_tac 1 ¬t® THEN fc_tac [get_spec ¬Increasing®]);
val _ = a (POP_ASM_T ante_tac THEN rewrite_tac [get_spec¬StO®,get_spec¬RvO®,
	get_spec ¬DerivedOrder®] THEN strip_tac);
val _ = a (LIST_SPEC_NTH_ASM_T 1 [¬(s,x)®, ¬(s,y)®] ante_tac
	THEN rewrite_tac[]
	THEN strip_tac);
(* *** Goal "1.2" *** *)
val _ = a (rewrite_tac ((map get_spec [¬Pw®, ¬X‰g®, ¬EvalCf®])@[let_def]));
val _ = a (strip_tac THEN FC_T bc_tac [get_spec ¬Increasing®]);
val _ = a (rewrite_tac [get_spec ¬SetO®] THEN REPEAT strip_tac);
(* *** Goal "1.2.1" *** *)
val _ = a (GET_NTH_ASM_T 4 (strip_asm_tac o (rewrite_rule [get_spec ¬FunImage®])));
val _ = a (¶_tac ¬EvalForm (c, r, s, y) a (IxOverRide x' v)®
	THEN strip_tac);
(* *** Goal "1.2.1.1" *** *)
val _ = a (¶_tac ¬EvalForm (c, r, s, y) a®);
val _ = a (¶_tac ¬v® THEN asm_rewrite_tac[get_spec ¬FunImage®]);
val _ = a (¶_tac ¬a® THEN asm_rewrite_tac[]);
(* *** Goal "1.2.1.2" *** *)
val _ = a (asm_rewrite_tac[]);
val _ = a (GET_NTH_ASM_T 1 (rewrite_thm_tac o eq_sym_rule));
val _ = a (lemma_tac ¬tc ScPrec2 a t®);
(* *** Goal "1.2.1.2.1" *** *)
val _ = a (fc_tac [syntax_cases_thm]);
val _ = a (all_fc_tac [scprec2_fc_clauses2]);
val _ = a (fc_tac [tc_incr_thm]);
(* *** Goal "1.2.1.2.2" *** *)
val _ = a (all_asm_fc_tac[]);
val _ = a (fc_tac[get_spec ¬Increasing®]);
val _ = a (GET_NTH_ASM_T 1 ante_tac THEN rewrite_tac [get_spec ¬RvIsO®, get_spec ¬RvO®]
	THEN STRIP_T (fn x => fc_tac[x]));
val _ = a (POP_ASM_T ante_tac THEN rewrite_tac [get_spec ¬MonoEvalForm®, get_spec ¬Pw®]
	THEN STRIP_T rewrite_thm_tac);
(* *** Goal "1.2.2" *** *)
val _ = a (GET_NTH_ASM_T 4 (strip_asm_tac o (rewrite_rule [get_spec ¬FunImage®])));
val _ = a (¶_tac ¬EvalForm (c, r, s, x) a (IxOverRide x' v)®
	THEN strip_tac);
(* *** Goal "1.2.2.1" *** *)
val _ = a (¶_tac ¬EvalForm (c, r, s, x) a®);
val _ = a (¶_tac ¬v® THEN asm_rewrite_tac[get_spec ¬FunImage®]);
val _ = a (¶_tac ¬a® THEN asm_rewrite_tac[]);
(* *** Goal "1.2.2.2" *** *)
val _ = a (asm_rewrite_tac[]);
val _ = a (GET_NTH_ASM_T 1 (rewrite_thm_tac o eq_sym_rule));
val _ = a (lemma_tac ¬tc ScPrec2 a t®);
(* *** Goal "1.2.2.2.1" *** *)
val _ = a (fc_tac [syntax_cases_thm]);
val _ = a (all_fc_tac [scprec2_fc_clauses2]);
val _ = a (fc_tac [tc_incr_thm]);
(* *** Goal "1.2.2.2.2" *** *)
val _ = a (all_asm_fc_tac[]);
val _ = a (fc_tac[get_spec ¬Increasing®]);
val _ = a (GET_NTH_ASM_T 1 ante_tac THEN rewrite_tac [get_spec ¬RvIsO®, get_spec ¬RvO®]
	THEN STRIP_T (fn x => fc_tac[x]));
val _ = a (POP_ASM_T ante_tac THEN rewrite_tac [get_spec ¬MonoEvalForm®, get_spec ¬Pw®]
	THEN STRIP_T rewrite_thm_tac);
(* *** Goal "2" *** *)
set_labelled_goal "2";
val _ = a (fc_tac [inst_type_rule [(”'a®, ”'b®), (”GS ­ 'b OPT®, ”'a®)] pw_crpou_thm]);
val _ = a (fc_tac [crpou_fc_clauses] THEN asm_rewrite_tac[]);
val monoevalform2_increasing_lemma = pop_thm();

local val _ = set_goal([], ¬µ c r s g
     · CRpoU r ± Increasing (SetO r) r c
         ´ Increasing (Pw (Pw r)) (RvO r) (Ìris·EvalForm (c, r, s, ris) g)®);
val _ = a (REPEAT µ_tac);
val _ = a (lemma_tac ¬(Ìris·EvalForm (c, r, s, ris) g) = MonoEvalForm (c, r, s, g)®
	THEN1 rewrite_tac [ext_thm, get_spec ¬MonoEvalForm®]);
val _ = a (asm_rewrite_tac[monoevalform_increasing_lemma]);
in val evalform_increasing_thm = save_pop_thm "evalform_increasing_thm";
end;

stop;


=TEX
}%ignore

We will also need to prove monotonicity of formula evaluation relative to the extension and essences of the variable assignment providing the context for the evaluation.

=GFT
Ûevalform_increasing_thm2Ý =
   ô µ (V, $‰v) g
     · V € Syntax ± g  Syntax
         ´ Increasing
           (ExsVaO (V2IxSet V, V, $‰v))
           $¼‰t‰4
           (EvalForm (EvalCf_ftv, $¼‰t‰4, V, $‰v) g)

Ûevalform_increasing_thm3Ý =
   ô µ V $‰v g
     · V € Syntax ± g  Syntax
         ´ Increasing
           (ExsVaO (V2IxSet (V À {š‰g}), V À {š‰g}, $‰v))
           $¼‰t‰4
           (EvalForm (EvalCf_ftv, $¼‰t‰4, V, $‰v) g)
=TEX
=GFT
Ûevalform_increasing_thm4Ý =
   ô µ V W $‰v g
     · V € W ± V € Syntax ± g  Syntax
         ´ Increasing
           (ExsVaO (V2IxSet W, W, $‰v))
           $¼‰t‰4
           (EvalForm (EvalCf_ftv, $¼‰t‰4, V, $‰v) g)
=TEX

\ignore{
=SML
set_goal([], ¬µ(V, $‰v) g· V € Syntax ± g  Syntax
	´ Increasing (ExsVaO (V2IxSet V, (V, $‰v))) $¼‰t‰4 (EvalForm (EvalCf_ftv, $¼‰t‰4, (V, $‰v)) g)®);
val _ = a (REPEAT µ_tac THEN rewrite_tac [get_spec ¬$€®] THEN strip_tac THEN POP_ASM_T ante_tac);
val _ = a (sc2_induction_tac ¬g®);
val _ = a (strip_tac THEN asm_rewrite_tac ((map get_spec [¬Increasing®, ¬$€®]) @ [])
	THEN REPEAT strip_tac
	THEN asm_rewrite_tac [evalformfunct_thm2, let_def]);
val _ = a (cases_tac ¬IsAf t® THEN asm_rewrite_tac[let_def]);
(* *** Goal "1" *** *)
val _ = a (rewrite_tac [get_spec ¬EvalAf®, let_def]);
val _ = a (GET_NTH_ASM_T 2 (strip_asm_tac o (rewrite_rule (map get_spec
	[¬ExsVaO®, ¬IxO2®, ¬ExsSRO®, ¬ExtSRO®, ¬EssSRO®, ¬ConjOrder®, ¬IxO®, ¬OptO®, ¬Pw®, ¬V2IxSet®])))
	THEN asm_rewrite_tac[]);
val _ = a (POP_ASM_T ante_tac THEN POP_ASM_T ante_tac THEN rewrite_tac [get_spec ¬$€®] THEN REPEAT strip_tac);
val _ = a (CASES_T ¬AfMem t  IxDom y ± AfSet t  IxDom y® asm_tac THEN asm_rewrite_tac[]);
val _ = a (POP_ASM_T ante_tac THEN (SYM_ASMS_T rewrite_tac)
	THEN rewrite_tac [get_spec ¬IxDom®, get_spec ¬IsDefined®]
	THEN strip_tac);
val _ = a (spec_nth_asm_tac 5 ¬AfMem t®);
val _ = a (spec_nth_asm_tac 8 ¬AfSet t®);
val _ = a (rewrite_tac[get_spec ¬IxVal®]);
val _ = a (DROP_NTH_ASM_T 5 discard_tac THEN DROP_NTH_ASM_T 1 discard_tac);
val _ = a (spec_nth_asm_tac 3 ¬ValueOf (x (AfSet t))®
	THEN1 (fc_tac [ix_valueof_ran_lemma] THEN asm_fc_tac[]));
val _ = a (spec_nth_asm_tac 2 ¬ValueOf (y (AfMem t))®
	THEN1 (fc_tac [ix_valueof_ran_lemma] THEN asm_fc_tac[]));
val _ = a (all_fc_tac [¼‰t‰4_trans_thm]);
(* *** Goal "2" *** *)
val _ = a (rewrite_tac [get_spec ¬EvalCf®, let_def]);
val _ = a (bc_tac [rewrite_rule [get_spec ¬Increasing®] evalcf_ftv_increasing_lemma]);
val _ = a (rewrite_tac [get_spec ¬SetO®] THEN REPEAT strip_tac);
(* *** Goal "2.1" *** *)
val _ = a (¶_tac ¬rv (IxOverRide y v)® THEN strip_tac THEN_TRY asm_rewrite_tac[]);
(* *** Goal "2.1.1" *** *)
val _ = a (¶_tac ¬rv® THEN ¶_tac ¬v® THEN asm_rewrite_tac[]);
(* *** Goal "2.1.2" *** *)
val _ = a (GET_NTH_ASM_T 6 (strip_asm_tac o (rewrite_rule (map get_spec
	[¬ExsVaO®, ¬IxO2®, ¬ExsSRO®, ¬ExtSRO®, ¬EssSRO®, ¬ConjOrder®, ¬IxO®, ¬OptO®, ¬Pw®, ¬V2IxSet®])))
	THEN_TRY asm_rewrite_tac[]);
val _ = a (DROP_NTH_ASM_T 8 (strip_asm_tac o (rewrite_rule [get_spec ¬FunImage®])));
val _ = a (DROP_NTH_ASM_T 2 (strip_asm_tac o (rewrite_rule [get_spec ¬X‰g®])));
val _ = a (fc_tac [syntax_cases_fc_clauses]);
val _ = a (lemma_tac ¬ScPrec2 a t ± a  Syntax®);
val _ = a (all_fc_tac [is_fc_clauses]);
val _ = a (GET_NTH_ASM_T 4 (asm_tac o (rewrite_rule [asm_rule ¬t = MkCf (vars, fs)®])));
val _ = a (ASM_FC_T rewrite_tac []);
val _ = a (ufc_tac [scprec2_fc_clauses] THEN asm_ufc_tac[]);
(* *** Goal "2.1.2.2" *** *)
val _ = a (lemma_tac ¬tc ScPrec2 a t® THEN1 fc_tac [tc_incr_thm]);
val _ = a (all_asm_fc_tac[]);
val _ = a (POP_ASM_T ante_tac THEN asm_rewrite_tac[get_spec ¬Increasing®] THEN strip_tac);
val _ = a (LEMMA_T ¬ExsVaO (V2IxSet V, V, $‰v) (IxOverRide x v) (IxOverRide y v)®
	(asm_tac)
	THEN1 (all_fc_tac [exsvao_ixoverride_lemma]));
val _ = a (list_spec_nth_asm_tac 2 [¬IxOverRide x v®, ¬IxOverRide y v®]);
val _ = a (rewrite_tac [eq_sym_rule (asm_rule ¬EvalForm (EvalCf_ftv, $¼‰t‰4, V, $‰v) a = rv®)]);
val _ = a strip_tac;
(* *** Goal "2.2" *** *)
val _ = a (¶_tac ¬rv (IxOverRide x v)® THEN strip_tac THEN_TRY asm_rewrite_tac[]);
(* *** Goal "2.2.1" *** *)
val _ = a (¶_tac ¬rv® THEN ¶_tac ¬v® THEN asm_rewrite_tac[]);
(* *** Goal "2.2.2" *** *)
val _ = a (GET_NTH_ASM_T 6 (strip_asm_tac o (rewrite_rule (map get_spec
	[¬ExsVaO®, ¬IxO2®, ¬ExsSRO®, ¬ExtSRO®, ¬EssSRO®, ¬ConjOrder®, ¬IxO®, ¬OptO®, ¬Pw®, ¬V2IxSet®])))
	THEN_TRY asm_rewrite_tac[]);
val _ = a (DROP_NTH_ASM_T 8 (strip_asm_tac o (rewrite_rule [get_spec ¬FunImage®])));
val _ = a (DROP_NTH_ASM_T 2 (strip_asm_tac o (rewrite_rule [get_spec ¬X‰g®])));
val _ = a (fc_tac [syntax_cases_fc_clauses]);
val _ = a (lemma_tac ¬ScPrec2 a t ± a  Syntax®);
(* *** Goal "2.2.2.1" *** *)
val _ = a (all_fc_tac [is_fc_clauses]);
val _ = a (GET_NTH_ASM_T 4 (asm_tac o (rewrite_rule [asm_rule ¬t = MkCf (vars, fs)®])));
val _ = a (ASM_FC_T rewrite_tac []);
val _ = a (ufc_tac [scprec2_fc_clauses] THEN asm_ufc_tac[]);
(* *** Goal "2.2.2.2" *** *)
val _ = a (lemma_tac ¬tc ScPrec2 a t® THEN1 fc_tac [tc_incr_thm]);
val _ = a (all_asm_fc_tac[]);
val _ = a (POP_ASM_T ante_tac THEN asm_rewrite_tac[get_spec ¬Increasing®] THEN strip_tac);
val _ = a (LEMMA_T ¬ExsVaO (V2IxSet V, V, $‰v) (IxOverRide x v) (IxOverRide y v)®
	(asm_tac)
	THEN1 (all_fc_tac [exsvao_ixoverride_lemma]));
val _ = a (list_spec_nth_asm_tac 2 [¬IxOverRide x v®, ¬IxOverRide y v®]);
val _ = a (rewrite_tac [eq_sym_rule (asm_rule ¬EvalForm (EvalCf_ftv, $¼‰t‰4, V, $‰v) a = rv®)]);
val _ = a strip_tac;
val evalform_increasing_thm2 = save_pop_thm "evalform_increasing_thm2";

set_goal([], ¬µV $‰v g· V € Syntax ± g  Syntax
	´ Increasing (ExsVaO (V2IxSet (V À {š‰g}), (V À {š‰g}, $‰v))) $¼‰t‰4 (EvalForm (EvalCf_ftv, $¼‰t‰4, (V, $‰v)) g)®);
val _ = a (REPEAT µ_tac THEN rewrite_tac [get_spec ¬$€®] THEN strip_tac THEN POP_ASM_T ante_tac);
val _ = a (sc2_induction_tac ¬g®);
val _ = a (strip_tac THEN asm_rewrite_tac ((map get_spec [¬Increasing®, ¬$€®]) @ [])
	THEN REPEAT strip_tac
	THEN asm_rewrite_tac [evalformfunct_thm2, let_def]);
val _ = a (cases_tac ¬IsAf t® THEN asm_rewrite_tac[let_def]);
(* *** Goal "1" *** *)
val _ = a (rewrite_tac [get_spec ¬EvalAf®, let_def]);
val _ = a (GET_NTH_ASM_T 2 (strip_asm_tac o (rewrite_rule (map get_spec
	[¬ExsVaO®, ¬IxO2®, ¬ExsSRO®, ¬ExtSRO®, ¬EssSRO®, ¬ConjOrder®, ¬IxO®, ¬OptO®, ¬Pw®, ¬V2IxSet®])))
	THEN asm_rewrite_tac[]);
val _ = a (POP_ASM_T ante_tac THEN POP_ASM_T ante_tac THEN rewrite_tac [get_spec ¬$€®] THEN REPEAT strip_tac);
val _ = a (CASES_T ¬AfMem t  IxDom y ± AfSet t  IxDom y® asm_tac THEN asm_rewrite_tac[]);
val _ = a (POP_ASM_T ante_tac THEN (SYM_ASMS_T rewrite_tac)
	THEN rewrite_tac [get_spec ¬IxDom®, get_spec ¬IsDefined®]
	THEN strip_tac);
val _ = a (spec_nth_asm_tac 5 ¬AfMem t®);
val _ = a (spec_nth_asm_tac 8 ¬AfSet t®);
val _ = a (rewrite_tac[get_spec ¬IxVal®]);
val _ = a (DROP_NTH_ASM_T 5 discard_tac THEN DROP_NTH_ASM_T 1 discard_tac);
val _ = a (spec_nth_asm_tac 3 ¬ValueOf (x (AfSet t))®
	THEN1 (fc_tac [ix_valueof_ran_lemma] THEN asm_fc_tac[] THEN asm_fc_tac[]));
val _ = a (spec_nth_asm_tac 2 ¬ValueOf (y (AfMem t))®
	THEN1 (fc_tac [ix_valueof_ran_lemma] THEN asm_fc_tac[] THEN asm_fc_tac[]));
val _ = a (all_fc_tac [¼‰t‰4_trans_thm]);
(* *** Goal "2" *** *)
val _ = a (rewrite_tac [get_spec ¬EvalCf®, let_def]);
val _ = a (bc_tac [rewrite_rule [get_spec ¬Increasing®] evalcf_ftv_increasing_lemma]);
val _ = a (rewrite_tac [get_spec ¬SetO®] THEN REPEAT strip_tac);
(* *** Goal "2.1" *** *)
val _ = a (¶_tac ¬rv (IxOverRide y v)® THEN strip_tac THEN_TRY asm_rewrite_tac[]);
(* *** Goal "2.1.1" *** *)
val _ = a (¶_tac ¬rv® THEN ¶_tac ¬v® THEN asm_rewrite_tac[]);
(* *** Goal "2.1.2" *** *)
val _ = a (GET_NTH_ASM_T 6 (strip_asm_tac o (rewrite_rule (map get_spec
	[¬ExsVaO®, ¬IxO2®, ¬ExsSRO®, ¬ExtSRO®, ¬EssSRO®, ¬ConjOrder®, ¬IxO®, ¬OptO®, ¬Pw®, ¬V2IxSet®])))
	THEN_TRY asm_rewrite_tac[]);
val _ = a (DROP_NTH_ASM_T 8 (strip_asm_tac o (rewrite_rule [get_spec ¬FunImage®])));
val _ = a (DROP_NTH_ASM_T 2 (strip_asm_tac o (rewrite_rule [get_spec ¬X‰g®])));
val _ = a (fc_tac [syntax_cases_fc_clauses]);
val _ = a (lemma_tac ¬ScPrec2 a t ± a  Syntax®);
(* *** Goal "2.1.2.1" *** *)
val _ = a (all_fc_tac [is_fc_clauses]);
val _ = a (GET_NTH_ASM_T 4 (asm_tac o (rewrite_rule [asm_rule ¬t = MkCf (vars, fs)®])));
val _ = a (ASM_FC_T rewrite_tac []);
val _ = a (ufc_tac [scprec2_fc_clauses] THEN asm_ufc_tac[]);
(* *** Goal "2.1.2.2" *** *)
val _ = a (lemma_tac ¬tc ScPrec2 a t® THEN1 fc_tac [tc_incr_thm]);
val _ = a (all_asm_fc_tac[]);
val _ = a (POP_ASM_T ante_tac THEN asm_rewrite_tac[get_spec ¬Increasing®] THEN strip_tac);
a (lemma_tac ¬IxRan v € V À {š‰g}® THEN1
	(GET_ASM_T ¬IxRan v € V® ante_tac THEN PC_T1 "hol1" prove_tac[]));
a (LEMMA_T ¬ExsVaO (V2IxSet (V À {š‰g}), V À {š‰g}, $‰v) (IxOverRide x v) (IxOverRide y v)®
	(asm_tac) THEN1 (all_fc_tac [exsvao_ixoverride_lemma2]));
val _ = a (list_spec_nth_asm_tac 3 [¬IxOverRide x v®, ¬IxOverRide y v®]);
val _ = a (rewrite_tac [eq_sym_rule (asm_rule ¬EvalForm (EvalCf_ftv, $¼‰t‰4, V, $‰v) a = rv®)]);
val _ = a strip_tac;
(* *** Goal "2.2" *** *)
val _ = a (¶_tac ¬rv (IxOverRide x v)® THEN strip_tac THEN_TRY asm_rewrite_tac[]);
(* *** Goal "2.2.1" *** *)
val _ = a (¶_tac ¬rv® THEN ¶_tac ¬v® THEN asm_rewrite_tac[]);
(* *** Goal "2.2.2" *** *)
val _ = a (GET_NTH_ASM_T 6 (strip_asm_tac o (rewrite_rule (map get_spec
	[¬ExsVaO®, ¬IxO2®, ¬ExsSRO®, ¬ExtSRO®, ¬EssSRO®, ¬ConjOrder®, ¬IxO®, ¬OptO®, ¬Pw®, ¬V2IxSet®])))
	THEN_TRY asm_rewrite_tac[]);
val _ = a (DROP_NTH_ASM_T 8 (strip_asm_tac o (rewrite_rule [get_spec ¬FunImage®])));
val _ = a (DROP_NTH_ASM_T 2 (strip_asm_tac o (rewrite_rule [get_spec ¬X‰g®])));
val _ = a (fc_tac [syntax_cases_fc_clauses]);
val _ = a (lemma_tac ¬ScPrec2 a t ± a  Syntax®);
val _ = a (all_fc_tac [is_fc_clauses]);
val _ = a (GET_NTH_ASM_T 4 (asm_tac o (rewrite_rule [asm_rule ¬t = MkCf (vars, fs)®])));
val _ = a (ASM_FC_T rewrite_tac []);
val _ = a (ufc_tac [scprec2_fc_clauses] THEN asm_ufc_tac[]);
(* *** Goal "2.2.2.2" *** *)
val _ = a (lemma_tac ¬tc ScPrec2 a t® THEN1 fc_tac [tc_incr_thm]);
val _ = a (all_asm_fc_tac[]);
val _ = a (POP_ASM_T ante_tac THEN asm_rewrite_tac[get_spec ¬Increasing®] THEN strip_tac);
a (lemma_tac ¬IxRan v € V À {š‰g}® THEN1
	(GET_ASM_T ¬IxRan v € V® ante_tac THEN PC_T1 "hol1" prove_tac[]));
val _ = a (LEMMA_T ¬ExsVaO (V2IxSet (V À {š‰g}), V À {š‰g}, $‰v) (IxOverRide x v) (IxOverRide y v)®
	(asm_tac)
	THEN1 (all_fc_tac [exsvao_ixoverride_lemma2]));
val _ = a (list_spec_nth_asm_tac 3 [¬IxOverRide x v®, ¬IxOverRide y v®]);
val _ = a (rewrite_tac [eq_sym_rule (asm_rule ¬EvalForm (EvalCf_ftv, $¼‰t‰4, V, $‰v) a = rv®)]);
val _ = a strip_tac;
val evalform_increasing_thm3 = save_pop_thm "evalform_increasing_thm3";

set_goal([], ¬µV W $‰v g· V € W ± V € Syntax ± g  Syntax
	´ Increasing (ExsVaO (V2IxSet W, (W, $‰v))) $¼‰t‰4 (EvalForm (EvalCf_ftv, $¼‰t‰4, (V, $‰v)) g)®);
val _ = a (REPEAT µ_tac THEN rewrite_tac [get_spec ¬$€®] THEN strip_tac THEN POP_ASM_T ante_tac);
val _ = a (sc2_induction_tac ¬g®);
val _ = a (strip_tac THEN asm_rewrite_tac ((map get_spec [¬Increasing®, ¬$€®]) @ [])
	THEN REPEAT strip_tac
	THEN asm_rewrite_tac [evalformfunct_thm2, let_def]);
val _ = a (cases_tac ¬IsAf t® THEN asm_rewrite_tac[let_def]);
(* *** Goal "1" *** *)
val _ = a (rewrite_tac [get_spec ¬EvalAf®, let_def]);
val _ = a (GET_NTH_ASM_T 2 (strip_asm_tac o (rewrite_rule (map get_spec
	[¬ExsVaO®, ¬IxO2®, ¬ExsSRO®, ¬ExtSRO®, ¬EssSRO®, ¬ConjOrder®, ¬IxO®, ¬OptO®, ¬Pw®, ¬V2IxSet®])))
	THEN asm_rewrite_tac[]);
val _ = a (POP_ASM_T ante_tac THEN POP_ASM_T ante_tac THEN rewrite_tac [get_spec ¬$€®] THEN REPEAT strip_tac);
val _ = a (CASES_T ¬AfMem t  IxDom y ± AfSet t  IxDom y® asm_tac THEN asm_rewrite_tac[]);
val _ = a (POP_ASM_T ante_tac THEN (SYM_ASMS_T rewrite_tac)
	THEN rewrite_tac [get_spec ¬IxDom®, get_spec ¬IsDefined®]
	THEN strip_tac);
val _ = a (spec_nth_asm_tac 5 ¬AfMem t®);
val _ = a (spec_nth_asm_tac 8 ¬AfSet t®);
val _ = a (rewrite_tac[get_spec ¬IxVal®]);
val _ = a (DROP_NTH_ASM_T 5 discard_tac THEN DROP_NTH_ASM_T 1 discard_tac);
val _ = a (spec_nth_asm_tac 3 ¬ValueOf (x (AfSet t))®
	THEN1 (fc_tac [ix_valueof_ran_lemma] THEN asm_fc_tac[] THEN asm_fc_tac[]));
val _ = a (spec_nth_asm_tac 2 ¬ValueOf (y (AfMem t))®
	THEN1 (fc_tac [ix_valueof_ran_lemma] THEN asm_fc_tac[] THEN asm_fc_tac[]));
val _ = a (all_fc_tac [¼‰t‰4_trans_thm]);
(* *** Goal "2" *** *)
val _ = a (rewrite_tac [get_spec ¬EvalCf®, let_def]);
val _ = a (bc_tac [rewrite_rule [get_spec ¬Increasing®] evalcf_ftv_increasing_lemma]);
val _ = a (rewrite_tac [get_spec ¬SetO®] THEN REPEAT strip_tac);
(* *** Goal "2.1" *** *)
val _ = a (¶_tac ¬rv (IxOverRide y v)® THEN strip_tac THEN_TRY asm_rewrite_tac[]);
(* *** Goal "2.1.1" *** *)
val _ = a (¶_tac ¬rv® THEN ¶_tac ¬v® THEN asm_rewrite_tac[]);
(* *** Goal "2.1.2" *** *)
val _ = a (GET_NTH_ASM_T 6 (strip_asm_tac o (rewrite_rule (map get_spec
	[¬ExsVaO®, ¬IxO2®, ¬ExsSRO®, ¬ExtSRO®, ¬EssSRO®, ¬ConjOrder®, ¬IxO®, ¬OptO®, ¬Pw®, ¬V2IxSet®])))
	THEN_TRY asm_rewrite_tac[]);
val _ = a (DROP_NTH_ASM_T 8 (strip_asm_tac o (rewrite_rule [get_spec ¬FunImage®])));
val _ = a (DROP_NTH_ASM_T 2 (strip_asm_tac o (rewrite_rule [get_spec ¬X‰g®])));
val _ = a (fc_tac [syntax_cases_fc_clauses]);
val _ = a (lemma_tac ¬ScPrec2 a t ± a  Syntax®);
(* *** Goal "2.1.2.1" *** *)
val _ = a (all_fc_tac [is_fc_clauses]);
val _ = a (GET_NTH_ASM_T 4 (asm_tac o (rewrite_rule [asm_rule ¬t = MkCf (vars, fs)®])));
val _ = a (ASM_FC_T rewrite_tac []);
val _ = a (ufc_tac [scprec2_fc_clauses] THEN asm_ufc_tac[]);
(* *** Goal "2.1.2.2" *** *)
val _ = a (lemma_tac ¬tc ScPrec2 a t® THEN1 fc_tac [tc_incr_thm]);
val _ = a (all_asm_fc_tac[]);
val _ = a (POP_ASM_T ante_tac THEN asm_rewrite_tac[get_spec ¬Increasing®] THEN strip_tac);
a (lemma_tac ¬IxRan v € W® THEN1
	(GET_ASM_T ¬IxRan v € V® ante_tac
	THEN GET_ASM_T ¬µ x:GS· x  V ´ x  W® ante_tac
	THEN PC_T1 "hol1" prove_tac[]));
a (LEMMA_T ¬ExsVaO (V2IxSet W, W, $‰v) (IxOverRide x v) (IxOverRide y v)®
	(asm_tac) THEN1 (all_fc_tac [exsvao_ixoverride_lemma2]));
val _ = a (list_spec_nth_asm_tac 3 [¬IxOverRide x v®, ¬IxOverRide y v®]);
val _ = a (rewrite_tac [eq_sym_rule (asm_rule ¬EvalForm (EvalCf_ftv, $¼‰t‰4, V, $‰v) a = rv®)]);
val _ = a strip_tac;
(* *** Goal "2.2" *** *)
val _ = a (¶_tac ¬rv (IxOverRide x v)® THEN strip_tac THEN_TRY asm_rewrite_tac[]);
(* *** Goal "2.2.1" *** *)
val _ = a (¶_tac ¬rv® THEN ¶_tac ¬v® THEN asm_rewrite_tac[]);
(* *** Goal "2.2.2" *** *)
val _ = a (GET_NTH_ASM_T 6 (strip_asm_tac o (rewrite_rule (map get_spec
	[¬ExsVaO®, ¬IxO2®, ¬ExsSRO®, ¬ExtSRO®, ¬EssSRO®, ¬ConjOrder®, ¬IxO®, ¬OptO®, ¬Pw®, ¬V2IxSet®])))
	THEN_TRY asm_rewrite_tac[]);
val _ = a (DROP_NTH_ASM_T 8 (strip_asm_tac o (rewrite_rule [get_spec ¬FunImage®])));
val _ = a (DROP_NTH_ASM_T 2 (strip_asm_tac o (rewrite_rule [get_spec ¬X‰g®])));
val _ = a (fc_tac [syntax_cases_fc_clauses]);
val _ = a (lemma_tac ¬ScPrec2 a t ± a  Syntax®);
val _ = a (all_fc_tac [is_fc_clauses]);
val _ = a (GET_NTH_ASM_T 4 (asm_tac o (rewrite_rule [asm_rule ¬t = MkCf (vars, fs)®])));
val _ = a (ASM_FC_T rewrite_tac []);
val _ = a (ufc_tac [scprec2_fc_clauses] THEN asm_ufc_tac[]);
(* *** Goal "2.2.2.2" *** *)
val _ = a (lemma_tac ¬tc ScPrec2 a t® THEN1 fc_tac [tc_incr_thm]);
val _ = a (all_asm_fc_tac[]);
val _ = a (POP_ASM_T ante_tac THEN asm_rewrite_tac[get_spec ¬Increasing®] THEN strip_tac);
a (lemma_tac ¬IxRan v € W® THEN1
	(GET_ASM_T ¬IxRan v € V® ante_tac
	THEN GET_ASM_T ¬µ x:GS· x  V ´ x  W® ante_tac
	THEN PC_T1 "hol1" prove_tac[]));
val _ = a (LEMMA_T ¬ExsVaO (V2IxSet W, W, $‰v) (IxOverRide x v) (IxOverRide y v)®
	(asm_tac)
	THEN1 (all_fc_tac [exsvao_ixoverride_lemma2]));
val _ = a (list_spec_nth_asm_tac 3 [¬IxOverRide x v®, ¬IxOverRide y v®]);
val _ = a (rewrite_tac [eq_sym_rule (asm_rule ¬EvalForm (EvalCf_ftv, $¼‰t‰4, V, $‰v) a = rv®)]);
val _ = a strip_tac;
val evalform_increasing_thm4 = save_pop_thm "evalform_increasing_thm4";
=TEX
}%ignore

\section{EXTENSIONALITY}

\subsection{Extension and Essence, Compatibility and OverDefinedness}

The terminology is a bit uncertain here.
These lemmas about the semantics are proven in order to obtain extensionality results for fixed points of the semantic functor.

¹HOLCONST
Ü ÛExtensionÝ : (GS, FTV)BR ­ (GS, FTV)BR
÷üüüüüüüüüüü
Ü Extension = CombC
°

We now define a notion of `same extension' over some domain.

Two sets have the same extension over some domain if they have the same members in that domain.

¹HOLCONST
Ü ÛSameExtÝ : GS SET ­ (GS, FTV)BR ­ GS ­ GS ­ BOOL
÷üüüüüüüüüüü
Ü µV r· SameExt V r = Ìx y· µz· z  V ´ r z x = r z y
°

¹HOLCONST
Ü ÛEssenceÝ : (GS, FTV)BR ­ (GS, FTV)BR
÷üüüüüüüüüüü
Ü Essence = CombI
°

Two sets have the same essence over some domain if they are members of the same sets in that domain.

¹HOLCONST
Ü ÛSameEssÝ : GS SET ­ (GS, FTV)BR ­ GS ­ GS ­ BOOL
÷üüüüüüüüüüü
Ü µV r· SameEss V r = Ìx y·  µz· z  V ´ r x z = r y z
°

=GFT
Ûsameext_equiv_thmÝ =
   ô µ V r· Equiv (V, SameExt V r)

Ûsameess_equiv_thmÝ =
   ô µ V r· Equiv (V, SameEss V r)

Ûsameext_refl_lemmaÝ =
   ô µ V r x· x  V ´ SameExt V r x x

Ûsameess_refl_lemmaÝ =
   ô µ V r x· x  V ´ SameEss V r x x

Ûsameext_sym_lemmaÝ =
   ô µ V r x y· x  V ± y  V ´ (SameExt V r x y ¤ SameExt V r y x)

Ûsameess_sym_lemmaÝ =
   ô µ V r x y· x  V ± y  V ´ (SameEss V r x y ¤ SameEss V r y x)
=TEX

=GFT
Ûevalform_ext_lemmaÝ =
   ô µ V r
     · V € SetReps
         ´ (µ z
         · z  Syntax
             ´ (µ x y
             · IxDom x = IxDom y
                   ± FreeVars z € IxDom x
                   ± IxRan x € V
                   ± IxRan y € V
                   ± (µ v
                   · v  IxDom x
                       ´ SameExt V r (IxVal x v) (IxVal y v)
                         ± SameEss V r (IxVal x v) (IxVal y v))
                 ´ EvalForm (EvalCf_ftv, $¼‰t‰4, V, r) z x
                   = EvalForm (EvalCf_ftv, $¼‰t‰4, V, r) z y))

=TEX

\ignore{
=SML
local val _ = set_goal ([], ¬µV r· Equiv (V, (SameExt V r))®);
val _ = a (REPEAT µ_tac
	THEN rewrite_tac (map get_spec [¬SameExt®, ¬Equiv®, ¬Refl®, ¬Sym®, ¬Trans®])
	THEN REPEAT strip_tac
	THEN asm_fc_tac[]
	THEN asm_rewrite_tac[]);
in val sameext_equiv_thm = save_pop_thm "sameext_equiv_thm";
end;

local val _ = set_goal ([], ¬µV r· Equiv (V, (SameEss V r))®);
val _ = a (REPEAT µ_tac
	THEN rewrite_tac (map get_spec [¬SameEss®, ¬Equiv®, ¬Refl®, ¬Sym®, ¬Trans®])
	THEN REPEAT strip_tac
	THEN asm_fc_tac[]
	THEN asm_rewrite_tac[]);
in val sameess_equiv_thm = save_pop_thm "sameess_equiv_thm";
end;

local val _ = set_goal ([], ¬µV r x· x  V ´ SameExt V r x x®);
val _ = a (REPEAT strip_tac);
val _ = a (lemma_tac ¬Refl (V, SameExt V r)®
	THEN1 rewrite_tac [rewrite_rule [get_spec ¬Equiv®] sameext_equiv_thm]);
val _ = a (fc_tac [get_spec ¬Refl®] THEN asm_fc_tac[]);
in val sameext_refl_lemma = save_pop_thm "sameext_refl_lemma";
end;

local val _ = set_goal ([], ¬µV r x· x  V ´ SameEss V r x x®);
val _ = a (REPEAT strip_tac);
val _ = a (lemma_tac ¬Refl (V, SameEss V r)®
	THEN1 rewrite_tac [rewrite_rule [get_spec ¬Equiv®] sameess_equiv_thm]);
val _ = a (fc_tac [get_spec ¬Refl®] THEN asm_fc_tac[]);
in val sameess_refl_lemma = save_pop_thm "sameess_refl_lemma";
end;

local val _ = set_goal ([], ¬µV r x y· x  V ± y  V ´ (SameExt V r x y ¤ SameExt V r y x)®);
val _ = a (REPEAT strip_tac);
val _ = a (lemma_tac ¬Sym (V, SameExt V r)®
	THEN1 rewrite_tac [rewrite_rule [get_spec ¬Equiv®] sameext_equiv_thm]);
val _ = a (fc_tac [get_spec ¬Sym®] THEN all_asm_fc_tac[]);
val _ = a (lemma_tac ¬Sym (V, SameExt V r)®
	THEN1 rewrite_tac [rewrite_rule [get_spec ¬Equiv®] sameext_equiv_thm]);
val _ = a (fc_tac [get_spec ¬Sym®]);
val _ = a (list_spec_nth_asm_tac 1 [¬y®, ¬x®]);
in val sameext_sym_lemma = save_pop_thm "sameext_sym_lemma";
end;

local val _ = set_goal ([], ¬µV r x y· x  V ± y  V ´ (SameEss V r x y ¤ SameEss V r y x)®);
val _ = a (REPEAT strip_tac);
val _ = a (lemma_tac ¬Sym (V, SameEss V r)®
	THEN1 rewrite_tac [rewrite_rule [get_spec ¬Equiv®] sameess_equiv_thm]);
val _ = a (fc_tac [get_spec ¬Sym®] THEN all_asm_fc_tac[]);
val _ = a (lemma_tac ¬Sym (V, SameEss V r)®
	THEN1 rewrite_tac [rewrite_rule [get_spec ¬Equiv®] sameess_equiv_thm]);
val _ = a (fc_tac [get_spec ¬Sym®]);
val _ = a (list_spec_nth_asm_tac 1 [¬y®, ¬x®]);
in val sameess_sym_lemma = save_pop_thm "samess_sym_lemma";
end;
=TEX
}%ignore

Unfortunaately that last lemma is too weak for the purposes for which is was intended.
To obtain a stronger lemma it is necessary to have concepts weaker than {\it SameExt} and {\it SameEss}, as follows:

To obtain a stronger lemma we define the notion of `compatible extension'.

Two sets have compatible extensions over some domain if they do not definitely disagree about what their members are, where a disagreement is definite if at some point either is overdefined or if neither is undefined.
This is defined in terms of compatibility of truth value sets, which is defined in \cite{rbjt025}.

¹HOLCONST
Ü ÛCompExtÝ : GS SET ­ (GS, FTV)BR ­ GS ­ GS ­ BOOL
÷üüüüüüüüüüü
Ü µV r· CompExt V r = Ìx y· µz· z  V ´ {r z x; r z y}  CompFTV
°

¹HOLCONST
Ü ÛCoCompExtÝ : GS SET ­ (GS, FTV)BR ­ GS ­ GS ­ BOOL
÷üüüüüüüüüüü
Ü µV r· CoCompExt V r = Ìx y· µz· z  V ´ {r z x; r z y}  CoCompFTV
°

Two sets have compatible essences over some domain if they do not definitely disagree about which sets they are members of.

¹HOLCONST
Ü ÛCompEssÝ : GS SET ­ (GS, FTV)BR ­ GS ­ GS ­ BOOL
÷üüüüüüüüüüü
Ü µV r· CompEss V r = Ìx y· µz· z  V ´ {r x z; r y z}  CompFTV
°

¹HOLCONST
Ü ÛCoCompEssÝ : GS SET ­ (GS, FTV)BR ­ GS ­ GS ­ BOOL
÷üüüüüüüüüüü
Ü µV r· CoCompEss V r = Ìx y· µz· z  V ´ {r x z; r y z}  CoCompFTV
°

We also need to be able to talk about relations which are nowhere overdefined.
In fact we need to be able to talk about parts of relations, e.g. particular extensions and essences in these terms.

The following is a property, either of an extension or an essence, which tells you whether it anwhere takes the value {\it fT}.
The property is parameterised by the domain of discourse.

¹HOLCONST
Ü ÛOverDefinedLÝ : GS SET ­ (GS ­ FTV) ­ BOOL
÷üüüüüüüüüüü
Ü µV xe· OverDefinedL V xe ¤ ¶y· y  V ± xe y = fT
°

=GFT
ÛOverDefinedL_¼‰t‰4_lemmaÝ =
   ô µ V xe1 xe2
     · ³ OverDefinedL V xe1 ± PwS V $¼‰t‰4 xe2 xe1 ´ ³ OverDefinedL V xe2
=TEX

\ignore{
=SML
set_goal([], ¬µV xe1 xe2· ³ OverDefinedL V xe1 ± PwS V $¼‰t‰4 xe2 xe1 ´ ³ OverDefinedL V xe2®);
a (REPEAT µ_tac THEN rewrite_tac [get_spec ¬OverDefinedL®, get_spec ¬PwS®]
	THEN contr_tac
	THEN asm_fc_tac[]);
a (POP_ASM_T ante_tac THEN asm_rewrite_tac[ft_fb_thm]
	THEN contr_tac
	THEN asm_fc_tac[]);
val OverDefinedL_¼‰t‰4_lemma = save_pop_thm "OverDefinedL_¼‰t‰4_lemma";
=TEX
}%ignore

The following property of relations could have been defined in terms of the above, but actually it was defined first and is simpler left as it is.

¹HOLCONST
Ü ÛOverDefinedÝ : GS SET ­ (GS, FTV)BR ­ BOOL
÷üüüüüüüüüüü
Ü µV r· OverDefined V r ¤ ¶x y· x  V ± y  V ± r x y = fT
°

¹HOLCONST
Ü ÛOverDefinedEssÝ : GS SET ­ GS SET ­ (GS, FTV)BR ­ BOOL
÷üüüüüüüüüüü
Ü µV W r· OverDefinedEss V W r ¤ ¶x· x  V ± OverDefinedL W (Essence r x) 
°

¹HOLCONST
Ü ÛOverDefinedExtÝ : GS SET ­ GS SET ­ (GS, FTV)BR ­ BOOL
÷üüüüüüüüüüü
Ü µV W r· OverDefinedExt V W r ¤ ¶x· x  V ± OverDefinedL W (Extension r x) 
°

and the duals:

¹HOLCONST
Ü ÛUnderDefinedLÝ : GS SET ­ (GS ­ FTV) ­ BOOL
÷üüüüüüüüüüü
Ü µV xe· UnderDefinedL V xe ¤ ¶y· y  V ± xe y = fB
°

¹HOLCONST
Ü ÛUnderDefinedÝ : GS SET ­ (GS, FTV)BR ­ BOOL
÷üüüüüüüüüüü
Ü µV r· UnderDefined V r ¤ ¶x y· x  V ± y  V ± r x y = fB
°

=GFT
Ûcompext_refl_lemmaÝ =
   ô µ V r x· ³ OverDefined V r ´ x  V ´ CompExt V r x x

Ûcocompext_refl_lemmaÝ =
   ô µ V r x· ³ UnderDefined V r ´ x  V ´ CoCompExt V r x x
=TEX
=GFT
Ûcompess_refl_lemmaÝ =
   ô µ V r x· ³ OverDefined V r ´ x  V ´ CompEss V r x x

Ûcocompess_refl_lemmaÝ =
   ô µ V r x· ³ UnderDefined V r ´ x  V ´ CoCompEss V r x x
=TEX
=GFT
Ûcompext_sym_lemmaÝ =
   ô µ V r
     · ³ OverDefined V r
         ´ (µ x y· x  V ± y  V ´ (CompExt V r x y ¤ CompExt V r y x))

Ûcocompext_sym_lemmaÝ =
   ô µ V r
     · ³ UnderDefined V r
         ´ (µ x y· x  V ± y  V ´ (CoCompExt V r x y ¤ CoCompExt V r y x))
=TEX
=GFT
Ûcompess_sym_lemmaÝ =
   ô µ V r
     · ³ OverDefined V r
         ´ (µ x y· x  V ± y  V ´ (CompEss V r x y ¤ CompEss V r y x))

Ûcocompess_sym_lemmaÝ =
   ô µ V r
     · ³ UnderDefined V r
         ´ (µ x y· x  V ± y  V ´ (CoCompEss V r x y ¤ CoCompEss V r y x))
=TEX

\ignore{
=SML
local val _ = set_goal ([], ¬µV r x· ³ OverDefined V r ´ x  V ´ CompExt V r x x®);
val _ = a (REPEAT µ_tac THEN rewrite_tac[get_spec ¬OverDefined®, get_spec ¬CompExt®, get_spec ¬CompFTV®, let_def]
	THEN REPEAT_N 4 strip_tac);
val _ = a (spec_nth_asm_tac 3 ¬z®);
val _ = a (spec_nth_asm_tac 1 ¬x®);
val _ = a (strip_asm_tac (µ_elim ¬r z x® ftv_cases_thm)
	THEN asm_rewrite_tac[sets_ext_clauses, _in_clauses]);
in val compext_refl_lemma = save_pop_thm "compext_refl_lemma";
end;

local val _ = set_goal ([], ¬µV r x· ³ UnderDefined V r ´ x  V ´ CoCompExt V r x x®);
val _ = a (REPEAT µ_tac THEN rewrite_tac[get_spec ¬UnderDefined®, get_spec ¬CoCompExt®, get_spec ¬CoCompFTV®, let_def]
	THEN REPEAT_N 4 strip_tac);
val _ = a (spec_nth_asm_tac 3 ¬z®);
val _ = a (spec_nth_asm_tac 1 ¬x®);
val _ = a (strip_asm_tac (µ_elim ¬r z x® ftv_cases_thm)
	THEN asm_rewrite_tac[sets_ext_clauses, _in_clauses]);
in val cocompext_refl_lemma = save_pop_thm "cocompext_refl_lemma";
end;

local val _ = set_goal ([], ¬µV r x· ³ OverDefined V r ´ x  V ´ CompEss V r x x®);
val _ = a (REPEAT µ_tac THEN rewrite_tac[get_spec ¬OverDefined®, get_spec ¬CompEss®, get_spec ¬CompFTV®, let_def]
	THEN REPEAT_N 4 strip_tac);
val _ = a (spec_nth_asm_tac 3 ¬x®);
val _ = a (spec_nth_asm_tac 1 ¬z®);
val _ = a (strip_asm_tac (µ_elim ¬r x z® ftv_cases_thm)
	THEN asm_rewrite_tac[sets_ext_clauses, _in_clauses]);
in val compess_refl_lemma = save_pop_thm "compess_refl_lemma";
end;

local val _ = set_goal ([], ¬µV r x· ³ UnderDefined V r ´ x  V ´ CoCompEss V r x x®);
val _ = a (REPEAT µ_tac THEN rewrite_tac[get_spec ¬UnderDefined®, get_spec ¬CoCompEss®, get_spec ¬CoCompFTV®, let_def]
	THEN REPEAT_N 4 strip_tac);
val _ = a (spec_nth_asm_tac 3 ¬x®);
val _ = a (spec_nth_asm_tac 1 ¬z®);
val _ = a (strip_asm_tac (µ_elim ¬r x z® ftv_cases_thm)
	THEN asm_rewrite_tac[sets_ext_clauses, _in_clauses]);
in val cocompess_refl_lemma = save_pop_thm "cocompess_refl_lemma";
end;

set_goal ([], ¬µV r· ³ OverDefined V r ´ µx y· x  V ± y  V ´ (CompExt V r x y ¤ CompExt V r y x)®);
val _ = a (REPEAT µ_tac THEN rewrite_tac[get_spec ¬OverDefined®]
	THEN REPEAT (´_tac ORELSE µ_tac)
	THEN rewrite_tac [get_spec ¬CompExt®, compftv_lemma, let_def]
	THEN REPEAT_N 6 strip_tac);
(* *** Goal "1" *** *)
a (spec_nth_asm_tac 2 ¬z® THEN contr_tac);
(* *** Goal "2" *** *)
val _ = a (spec_nth_asm_tac 2 ¬z®
	THEN rewrite_tac[_in_clauses]
	THEN REPEAT_N 4 (POP_ASM_T rewrite_thm_tac));
(* *** Goal "3" *** *)
a (spec_nth_asm_tac 2 ¬z® THEN contr_tac);
(* *** Goal "4" *** *)
val _ = a (spec_nth_asm_tac 2 ¬z®
	THEN rewrite_tac[_in_clauses]
	THEN REPEAT_N 4 (POP_ASM_T rewrite_thm_tac));
val compext_sym_lemma = save_pop_thm "compext_sym_lemma";

set_goal ([], ¬µV r· ³ UnderDefined V r ´ µx y· x  V ± y  V ´ (CoCompExt V r x y ¤ CoCompExt V r y x)®);
val _ = a (REPEAT µ_tac THEN rewrite_tac[get_spec ¬UnderDefined®]
	THEN REPEAT (´_tac ORELSE µ_tac)
	THEN rewrite_tac [get_spec ¬CoCompExt®, cocompftv_lemma, let_def]
	THEN REPEAT_N 6 strip_tac);
a (spec_nth_asm_tac 2 ¬z® THEN contr_tac);
a (spec_nth_asm_tac 2 ¬z® THEN contr_tac);
a (spec_nth_asm_tac 2 ¬z® THEN contr_tac);
a (spec_nth_asm_tac 2 ¬z® THEN contr_tac);
val cocompext_sym_lemma = save_pop_thm "cocompext_sym_lemma";

local val _ = set_goal ([], ¬µV r· ³ OverDefined V r ´ µx y· x  V ± y  V ´ (CompEss V r x y ¤ CompEss V r y x)®);
val _ = a (REPEAT µ_tac THEN rewrite_tac[get_spec ¬OverDefined®]
	THEN REPEAT (´_tac ORELSE µ_tac)
	THEN rewrite_tac [get_spec ¬CompEss®, let_def]
	THEN contr_tac);
(* *** Goal "1" *** *)
val _ = a (spec_nth_asm_tac 3 ¬z®);
val _ = a (REPEAT_N 2 (POP_ASM_T ante_tac));
val _ = a (LEMMA_T ¬{r y z; r x z} = {r x z; r y z}® rewrite_thm_tac
	THEN1 PC_T1 "hol1" prove_tac[]);
(* *** Goal "2" *** *)
val _ = a (spec_nth_asm_tac 3 ¬z®);
val _ = a (REPEAT_N 2 (POP_ASM_T ante_tac));
val _ = a (LEMMA_T ¬{r y z; r x z} = {r x z; r y z}® rewrite_thm_tac
	THEN1 PC_T1 "hol1" prove_tac[]);
in val compess_sym_lemma = save_pop_thm "compess_sym_lemma";
end;

local val _ = set_goal ([], ¬µV r· ³ UnderDefined V r ´ µx y· x  V ± y  V ´ (CoCompEss V r x y ¤ CoCompEss V r y x)®);
val _ = a (REPEAT µ_tac THEN rewrite_tac[get_spec ¬UnderDefined®]
	THEN REPEAT (´_tac ORELSE µ_tac)
	THEN rewrite_tac [get_spec ¬CoCompEss®, let_def]
	THEN contr_tac);
(* *** Goal "1" *** *)
val _ = a (spec_nth_asm_tac 3 ¬z®);
val _ = a (REPEAT_N 2 (POP_ASM_T ante_tac));
val _ = a (LEMMA_T ¬{r y z; r x z} = {r x z; r y z}® rewrite_thm_tac
	THEN1 PC_T1 "hol1" prove_tac[]);
(* *** Goal "2" *** *)
val _ = a (spec_nth_asm_tac 3 ¬z®);
val _ = a (REPEAT_N 2 (POP_ASM_T ante_tac));
val _ = a (LEMMA_T ¬{r y z; r x z} = {r x z; r y z}® rewrite_thm_tac
	THEN1 PC_T1 "hol1" prove_tac[]);
in val cocompess_sym_lemma = save_pop_thm "cocompess_sym_lemma";
end;
=TEX
}%ignore

The following condition expresses the possibility that two set representatives might end up representing the same set after further iterations of the semantic functor in approaching a least fixed point.

This intended for use in proving that a total least fixed point will always be extensional, through a lemma which states that, under certain conditions, elements which are compatible will still have the same extension after one further application of the semantic functor.

To be compatible two elements must have the same essences and extensions, but this does not suffice.
It is also necessary to state that there is no disagreement about whether the element to which they might be refined by iteration of the semantic functor is a member of itself.

¹HOLCONST
Ü ÛCompatibleÝ : GS SET ­ (GS, FTV)BR ­ GS ­ GS ­ BOOL
÷üüüüüüüüüüü
Ü µV r· Compatible V r = Ìx y· {r x y; r y x; r x x; r y y}  CompFTV
Ü		± CompEss V r x y ± CompExt V r x y 
°

=GFT
ÛCompatible_lemma1Ý =
   ô µ V r x y· Compatible V r x y ¤ {r x y; r y x; r x x; r y y}  CompFTV
		± (µ z· z  V ´
			  {r z x; r z y}  CompFTV
			± {r x z; r y z}  CompFTV)
=TEX

\ignore{
=SML
set_goal([], ¬µV r x y· Compatible V r x y ¤
	{r x y; r y x; r x x; r y y}  CompFTV
	± µz· z  V ´ {r z x; r z y}  CompFTV ± {r x z; r y z}  CompFTV®);
a (REPEAT µ_tac THEN rewrite_tac (map get_spec [¬Compatible®, ¬CompEss®, ¬CompExt®])
	THEN REPEAT strip_tac
	THEN asm_fc_tac []
	THEN_TRY asm_rewrite_tac []);
val Compatible_lemma1 = save_pop_thm "Compatible_lemma1";

=IGN
set_flag("subgoal_package_quiet", false);

set_goal([], ¬µV r x y· Increasing $¼‰ (Ìs· ³ s  CompFTV)®);
a (REPEAT µ_tac THEN rewrite_tac [Compatible_lemma1]
	THEN REPEAT strip_tac);

=TEX
}%ignore


\section{PROOF CONTEXTS}

=SML
(* add_pc_thms "'infos" [evalcf_ftv_ft_lemma, evalcf_ftv_fb_lemma]; *)

(* add_pc_thms "'infos" [get_spec ¬Extension®, get_spec ¬Essence®]; *)
commit_pc "'infos";

force_new_pc "ÛinfosÝ";
merge_pcs ["misc2", "'infos"] "infos";
commit_pc "infos";

force_new_pc "Ûinfos1Ý";
merge_pcs ["misc21", "'infos"] "infos1";
commit_pc "infos1";
=TEX

=SML
set_flag ("subgoal_package_quiet", false);
=TEX

{\let\Section\section
\newcounter{ThyNum}
\def\section#1{\Section{#1}
\addtocounter{ThyNum}{1}\label{Theory\arabic{ThyNum}}}
\include{infos.th}
%\include{sfp.th}
}  %\let

\twocolumn[\section{INDEX}\label{index}]
{\small\printindex}

\end{document}
