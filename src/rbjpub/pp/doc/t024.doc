=IGN
$Id: t024.doc,v 1.7 2008/03/26 15:56:52 rbj01 Exp $
open_theory "ifol";
set_merge_pcs ["hol1", "'GS1", "'ifol"];
=TEX
\documentclass[11pt,a4paper]{article}
\usepackage{latexsym}
\usepackage{ProofPower}
\ftlinepenalty=9999
\usepackage{A4}

%\def\ExpName{\mbox{{\sf exp}
%\def\Exp#1{\ExpName(#1)}

\tabstop=0.4in
\newcommand{\ignore}[1]{}

\title{Infinitarily Definable Non-Well-Founded Sets}
\makeindex
\usepackage[unicode,pdftex]{hyperref}
\hypersetup{pdfauthor={Roger Bishop Jones}}
\hypersetup{colorlinks=true, urlcolor=black, citecolor=black, filecolor=black, linkcolor=black}

\author{Roger Bishop Jones}
\date{\ }

\begin{document}
\begin{titlepage}
\maketitle
\begin{abstract}
This paper is my second approach to set theory conceived as a maximal consistent theory of set comprehension.
The principle innovation in this version is to simplify the syntax by removing comprehension, so that the syntactic category of term is no longer required.
\end{abstract}

\vfill

\begin{centering}

{\footnotesize

Created: 2006/11/29

Last Change $ $Date: 2008/03/26 15:56:52 $ $

\href{http://www.rbjones.com/rbjpub/pp/doc/t021.pdf}
{http://www.rbjones.com/rbjpub/pp/doc/t021.pdf}

$ $Id: t024.doc,v 1.7 2008/03/26 15:56:52 rbj01 Exp $ $

\copyright\ Roger Bishop Jones; Licenced under Gnu LGPL

}%footnotesize

\end{centering}

\thispagestyle{empty}
\end{titlepage}
\newpage
\addtocounter{page}{1}
%\section{DOCUMENT CONTROL}
%\subsection{Contents list}
{\parskip=0pt\tableofcontents}
%\newpage
%\subsection{Document cross references}

\subsection*{To Do}
\begin{itemize}
\item 
\item 
\end{itemize}

{\raggedright
\bibliographystyle{fmu}
\bibliography{rbj,fmu}
} %\raggedright

\newpage
\section{INTRODUCTION}

See t021 for previous discussion.
I will put something better here if it works out.

=SML
open_theory "GS";
force_new_theory "€ifol›";
new_parent "fixp";
force_new_pc "€'ifol›";
merge_pcs ["'savedthm_cs_∂_proof"] "'ifol";
set_merge_pcs ["hol1", "'GS1", "'ifol"];
=TEX

\section{MISCELLANEA}

\subsection{Set Theory}

=GFT
insert_com_thm = 
	Ù µ x y z∑ Insert x (Insert y z) = Insert y (Insert x z)
=TEX


\ignore{
=SML
set_goal([], ¨µx y z∑ Insert x (Insert y z) = Insert y (Insert x z)Æ);
a (rewrite_tac [sets_ext_clauses, get_spec ¨InsertÆ] THEN REPEAT strip_tac);
val insert_com_thm = save_pop_thm "insert_com_thm";

infix symdiff;

fun x symdiff y = (x diff y) cup (y diff x);

fun dest_enum l =
	(fn DEnumSet els => els
	|  Dö t => []) (dest_term l);

fun enum_eq_sdiff t =
	let val DEq (lhs, rhs) = dest_term t
	in (dest_enum lhs) symdiff (dest_enum rhs)
	end;

fun false_enum_eq_conv t =
	let val (dt :: _) = enum_eq_sdiff t
	in 
		tac_proof(([], ¨ëtÆ § FÆ),
			rewrite_tac [sets_ext_clauses]
			THEN ≥_in_tac
			THEN ∂_tac dt THEN prove_tac[])
	end handle _ => fail_conv t;
=TEX
}%ignore

\subsection{Type OPT}

=SML
declare_type_abbrev("€OPT›", ["'a"], î'a + ONEÆ);
=TEX
To make use of the type abbreviation `OPT' more readable the following constants are introduced:

πHOLCONST
‹ €Value› : 'a ≠ 'a + ONE
˜¸¸¸¸¸¸¸¸¸¸¸
‹ µv∑ Value v = InL v
∞

πHOLCONST
‹ €Undefined› : 'a + ONE
˜¸¸¸¸¸¸¸¸¸¸¸
‹ Undefined = InR One
∞

\ignore{
=SML
set_goal([], ¨∂ValueOf: 'a + ONE ≠ 'a∑ ValueOf (Value v) = vÆ);
a (∂_tac ¨Ãx∑ ≈y∑ Value y = xÆ THEN rewrite_tac[get_spec ¨ValueÆ]);
a (≈_tac ¨≈ y∑ y = vÆ);
a (∂_tac ¨vÆ THEN rewrite_tac[]);
save_cs_∂_thm (pop_thm());
=TEX
}%ignore

πHOLCONST
‹ €ValueOf› : 'a + ONE ≠ 'a
˜¸¸¸¸¸¸¸¸¸¸¸
‹ µv∑ ValueOf (Value v) = v
∞

πHOLCONST
‹ €IsDefined› : 'a + ONE ≠ BOOL
˜¸¸¸¸¸¸¸¸¸¸¸
‹ IsDefined = IsL
∞

\ignore{
=SML
add_pc_thms "'ifol" (map get_spec [¨ValueÆ, ¨UndefinedÆ, ¨IsDefinedÆ, ¨ValueOfÆ]);
set_merge_pcs ["hol1", "'GS1", "'ifol"];
=TEX
}%ignore

\subsection{Discrete Partial Orders}

=SML
declare_type_abbrev("€DPO›", ["'a"], î'a + BOOLÆ);
=TEX

πHOLCONST
‹ €dpoB› : 'a DPO
˜¸¸¸¸¸¸¸¸¸¸¸
‹ dpoB = InR F
∞

πHOLCONST
‹ €dpoT› : 'a DPO
˜¸¸¸¸¸¸¸¸¸¸¸
‹ dpoT = InR T
∞

πHOLCONST
‹ €dpoE› : 'a ≠ 'a DPO
˜¸¸¸¸¸¸¸¸¸¸¸
‹ µe∑ dpoE e = InL e
∞

πHOLCONST
‹ €dpoV› : 'a DPO ≠ 'a
˜¸¸¸¸¸¸¸¸¸¸¸
‹ µx∑ dpoV x = OutL x
∞

πHOLCONST
‹ €dpoUdef› : 'a DPO ≠ BOOL
˜¸¸¸¸¸¸¸¸¸¸¸
‹ µx∑ dpoUdef x § x = dpoB
∞

πHOLCONST
‹ €dpoOdef› : 'a DPO ≠ BOOL
˜¸¸¸¸¸¸¸¸¸¸¸
‹ µx∑ dpoOdef x § x = dpoT
∞

πHOLCONST
‹ €Dpo› : 'a DPO ≠ 'a DPO ≠ BOOL
˜¸¸¸¸¸¸¸¸¸¸¸
‹ µx y∑ Dpo x y § x = y ≤ x = dpoB ≤ y = dpoT
∞

=GFT
€dpo_distinct_clauses› =
   Ù ≥ dpoT = dpoB
       ± ≥ dpoB = dpoT
       ± (µ e
       ∑ ≥ dpoE e = dpoT
           ± ≥ dpoE e = dpoB
           ± ≥ dpoT = dpoE e
           ± ≥ dpoB = dpoE e)

€dpoe_inj_thm› =
	Ù µ e f∑ (dpoE e = dpoE f) = e = f

€dpoe_inj_lemma› =
	Ù µ e f∑ (dpoE e = dpoE f) = e = f

€dpove_lemma1› =
	Ù µ e∑ dpoV (dpoE e) = e

€dpodef_lemma1› =
   Ù dpoUdef dpoB
       ± dpoOdef dpoT
       ± ≥ dpoUdef dpoT
       ± ≥ dpoOdef dpoB
       ± (µ e∑ ≥ dpoUdef (dpoE e) ± ≥ dpoOdef (dpoE e))

€dpo_cases_thm› =
	Ù µ x∑ x = dpoB ≤ x = dpoT ≤ (∂ e∑ x = dpoE e)

€dpoev_lemma1› =
	Ù µ x∑ ≥ dpoUdef x ± ≥ dpoOdef x ¥ dpoE (dpoV x) = x

€dpo_rpou_lemma› =
	Ù RpoU Dpo

€dpo_glbs_exist_thm› =
	Ù GlbsExist Dpo

€dpo_lubs_exist_thm› =
	Ù LubsExist Dpo
=TEX

\ignore{
=SML
set_goal([], ¨≥ dpoT = dpoB
	± ≥ dpoB = dpoT
	± (µe∑ ≥ dpoE e = dpoT
		± ≥ dpoE e = dpoB
		± ≥ dpoT = dpoE e
		± ≥ dpoB = dpoE e)Æ);
a (rewrite_tac (map get_spec [¨dpoTÆ, ¨dpoBÆ, ¨dpoEÆ])
	THEN REPEAT strip_tac THEN_TRY asm_rewrite_tac[]);
val dpo_distinct_clauses = save_pop_thm "dpo_distinct_clauses";

add_pc_thms "'ifol" [dpo_distinct_clauses];
set_merge_pcs ["hol1", "'GS1", "'ifol"];

set_goal([], ¨(µe f∑ ≥ e = f ¥ ≥ dpoE e = dpoE f)
	± (µe f∑ dpoE e = dpoE f ¥ e = f)Æ);
a (rewrite_tac (map get_spec [¨dpoEÆ])
	THEN REPEAT strip_tac THEN_TRY asm_rewrite_tac[]);
val dpo_distinct_fc_clauses = pop_thm ();

set_goal([], ¨µe f∑ dpoE e = dpoE f § e = fÆ);
a (REPEAT strip_tac THEN_TRY all_asm_fc_tac [dpo_distinct_fc_clauses]
	THEN asm_rewrite_tac[]);
val dpoe_inj_lemma = save_pop_thm "dpoe_inj_lemma";

add_pc_thms "'ifol" [dpoe_inj_lemma];
set_merge_pcs ["hol1", "'GS1", "'ifol"];

set_goal([], ¨µx∑ x = dpoB ≤ x = dpoT ≤ (∂e∑ x = dpoE e)Æ);
a (rewrite_tac [get_spec ¨dpoBÆ, get_spec ¨dpoTÆ, get_spec ¨dpoEÆ]
	THEN REPEAT strip_tac);
a (strip_asm_tac (µ_elim ¨xÆ sum_cases_thm));
(* *** Goal "1" *** *)
a (∂_tac ¨yÆ THEN asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a (cases_tac ¨zÆ THEN asm_rewrite_tac[]);
(* *** Goal "2.1" *** *)
a (DROP_ASM_T ¨x = InR zÆ ante_tac THEN asm_rewrite_tac[]);
(* *** Goal "2.2" *** *)
a (DROP_ASM_T ¨x = InR zÆ ante_tac THEN asm_rewrite_tac[]);
val dpo_cases_thm = save_pop_thm "dpo_cases_thm";

set_goal([], ¨µe∑ dpoV(dpoE e) = eÆ);
a (REPEAT strip_tac THEN rewrite_tac [get_spec ¨dpoEÆ, get_spec ¨dpoVÆ]
	THEN asm_rewrite_tac[]);
val dpove_lemma1 = save_pop_thm "dpove_lemma1";

add_pc_thms "'ifol" [dpove_lemma1];
set_merge_pcs ["hol1", "'GS1", "'ifol"];

set_goal([], ¨dpoUdef dpoB ± dpoOdef dpoT
	± ≥ dpoUdef dpoT ± ≥ dpoOdef dpoB
	± µe∑ ≥ dpoUdef (dpoE e) ± ≥ dpoOdef (dpoE e)Æ);
a (REPEAT strip_tac THEN_TRY asm_rewrite_tac [get_spec ¨dpoUdefÆ, get_spec ¨dpoOdefÆ]);
val dpodef_lemma1 = save_pop_thm "dpodef_lemma1";

add_pc_thms "'ifol" [dpodef_lemma1];
set_merge_pcs ["hol1", "'GS1", "'ifol"];

set_goal([], ¨µx∑ ≥ dpoUdef x ± ≥ dpoOdef x ¥ dpoE(dpoV x) = xÆ);
a (REPEAT µ_tac);
a (strip_asm_tac (µ_elim ¨xÆ dpo_cases_thm) THEN_TRY asm_rewrite_tac[]);
val dpoev_lemma1 = save_pop_thm "dpoev_lemma1";

set_goal([], ¨RpoU DpoÆ);
a (rewrite_tac (map get_spec [¨RpoUÆ, ¨RpoÆ, ¨ReflÆ, ¨PartialOrderÆ, ¨TransÆ, ¨AntisymÆ, ¨DpoÆ])
	THEN contr_tac
	THEN_TRY var_elim_nth_asm_tac 1
	THEN_TRY rewrite_tac [dpo_distinct_clauses]
	THEN_TRY all_var_elim_asm_tac);
val dpo_rpou_lemma = save_pop_thm "dpo_rpou_lemma";

set_goal([], ¨GlbsExist DpoÆ);
a (rewrite_tac [get_spec ¨GlbsExistÆ, get_spec ¨IsGlbÆ, get_spec ¨IsLbÆ, get_spec ¨DpoÆ]
	THEN REPEAT strip_tac);
a (cases_tac ¨dpoB ç sÆ THEN_TRY asm_rewrite_tac[]);
(* *** Goal "1" *** *)
a (∂_tac ¨dpoBÆ THEN_TRY asm_rewrite_tac[]
	THEN REPEAT strip_tac);
a (spec_nth_asm_tac 1 ¨dpoBÆ);
(* *** Goal "2" *** *)
a (PC_T1 "hol" cases_tac ¨s = {dpoT}Æ THEN_TRY asm_rewrite_tac[]);
(* *** Goal "2.1" *** *)
a (∂_tac ¨dpoTÆ THEN asm_rewrite_tac []
	THEN REPEAT strip_tac);
(* *** Goal "2.2" *** *)
a (PC_T1 "hol" cases_tac ¨s = {}Æ THEN_TRY asm_rewrite_tac[]);
(* *** Goal "2.2.1" *** *)
a (∂_tac ¨dpoTÆ THEN_TRY asm_rewrite_tac[]);
(* *** Goal "2.2.2" *** *)
a (PC_T1 "hol" cases_tac ¨∂e∑ s = {dpoE e} Æ THEN_TRY asm_rewrite_tac[]);
(* *** Goal "2.2.2.1" *** *)
a (∂_tac ¨dpoE eÆ THEN_TRY asm_rewrite_tac[]
	THEN REPEAT strip_tac THEN_TRY asm_rewrite_tac[]);
(* *** Goal "2.2.2.1.1" *** *)
a (DROP_ASM_T ¨≥ dpoE e = xÆ ante_tac THEN asm_rewrite_tac[]);
(* *** Goal "2.2.2.1.2" *** *)
a (spec_nth_asm_tac 2 ¨dpoE eÆ);
(* *** Goal "2.2.2.2" *** *)
a (cases_tac ¨∂f g∑ ≥ f = g ± dpoE f ç s ± dpoE g ç sÆ THEN_TRY asm_rewrite_tac[]);
(* *** Goal "2.2.2.2.1" *** *)
a (∂_tac ¨dpoBÆ THEN_TRY asm_rewrite_tac[]
	THEN REPEAT strip_tac THEN_TRY asm_rewrite_tac[]);
a (spec_nth_asm_tac 1 ¨dpoE fÆ);
a (spec_nth_asm_tac 2 ¨dpoE gÆ);
a (POP_ASM_T ante_tac THEN asm_rewrite_tac[]);
(* *** Goal "2.2.2.2.2" *** *)
a (cases_tac ¨∂h∑ dpoE h ç sÆ THEN_TRY asm_rewrite_tac[]);
(* *** Goal "2.2.2.2.2.1" *** *)
a (∂_tac ¨dpoE hÆ THEN_TRY asm_rewrite_tac[]
	THEN REPEAT strip_tac THEN_TRY asm_rewrite_tac[]);
(* *** Goal "2.2.2.2.2.1.1" *** *)
a (asm_fc_tac[]);
a (LEMMA_T ¨s = {dpoE h; dpoT}Æ asm_tac
	THEN1 (asm_rewrite_tac [] THEN strip_tac));
(* *** Goal "2.2.2.2.2.1.1.1" *** *)
a (strip_asm_tac (µ_elim ¨x'Æ dpo_cases_thm)
	THEN_TRY asm_rewrite_tac[]);
(* *** Goal "2.2.2.2.2.1.1.1.1" *** *)
a (lemma_tac ¨x = dpoTÆ
	THEN1 (strip_asm_tac (µ_elim ¨xÆ dpo_cases_thm)
		THEN_TRY asm_rewrite_tac[]));
(* *** Goal "2.2.2.2.2.1.1.1.1.1" *** *)
a (var_elim_asm_tac ¨x = dpoBÆ);
(* *** Goal "2.2.2.2.2.1.1.1.1.2" *** *)
a (var_elim_asm_tac ¨x = dpoE eÆ);
a (var_elim_asm_tac ¨x' = dpoTÆ);
a (all_asm_fc_tac[]);
a (var_elim_asm_tac ¨e = hÆ);
(* *** Goal "2.2.2.2.2.1.1.1.1.3" *** *)
a (var_elim_asm_tac ¨x = dpoTÆ);
(* *** Goal "2.2.2.2.2.1.1.1.2" *** *)
a (var_elim_asm_tac ¨x' = dpoE eÆ);
a (REPEAT strip_tac);
(* *** Goal "2.2.2.2.2.1.1.1.2.1" *** *)
a (all_asm_fc_tac[]);
(* *** Goal "2.2.2.2.2.1.1.1.2.2" *** *)
a (asm_rewrite_tac[]);
(* *** Goal "2.2.2.2.2.1.1.2" *** *)
a (var_elim_asm_tac ¨s = {dpoE h; dpoT}Æ);
(* *** Goal "2.2.2.2.2.1.1.2.1" *** *)
a (DROP_ASM_T ¨≥ dpoE h = xÆ ante_tac
	THEN asm_rewrite_tac[]);
(* *** Goal "2.2.2.2.2.1.1.2.2" *** *)
a (DROP_ASM_T ¨≥ dpoE h = xÆ ante_tac
	THEN asm_rewrite_tac[]);
(* *** Goal "2.2.2.2.2.1.2" *** *)
a (spec_nth_asm_tac 2 ¨dpoE hÆ);
(* *** Goal "2.2.2.2.2.2" *** *)
a (swap_nth_asm_concl_tac 4
	THEN rewrite_tac[]
	THEN contr_tac);
a (strip_asm_tac (µ_elim ¨xÆ dpo_cases_thm));
(* *** Goal "2.2.2.2.2.2.1" *** *)
a (var_elim_asm_tac ¨x = dpoBÆ);
(* *** Goal "2.2.2.2.2.2.2" *** *)
a (var_elim_asm_tac ¨x = dpoTÆ);
a (DROP_NTH_ASM_T 6 ante_tac
	THEN asm_rewrite_tac[]
	THEN contr_tac);
(* *** Goal "2.2.2.2.2.2.2.1" *** *)
a (strip_asm_tac (µ_elim ¨xÆ dpo_cases_thm));
(* *** Goal "2.2.2.2.2.2.2.1.1" *** *)
a (var_elim_asm_tac ¨x = dpoBÆ);
(* *** Goal "2.2.2.2.2.2.2.1.2" *** *)
a (var_elim_asm_tac ¨x = dpoE eÆ);
a (all_asm_fc_tac[]);
(* *** Goal "2.2.2.2.2.2.2.2" *** *)
a (POP_ASM_T ante_tac THEN asm_rewrite_tac[]);
(* *** Goal "2.2.2.2.2.2.3" *** *)
a (var_elim_asm_tac ¨x = dpoE eÆ);
a (all_asm_fc_tac[]);
val dpo_glbs_exist_thm = save_pop_thm "dpo_glbs_exist_thm";

set_goal([], ¨LubsExist DpoÆ);
a (rewrite_tac [get_spec ¨LubsExistÆ, get_spec ¨IsLubÆ, get_spec ¨IsUbÆ, get_spec ¨DpoÆ]
	THEN REPEAT strip_tac);
a (cases_tac ¨dpoT ç sÆ THEN_TRY asm_rewrite_tac[]);
(* *** Goal "1" *** *)
a (∂_tac ¨dpoTÆ THEN_TRY asm_rewrite_tac[]
	THEN REPEAT strip_tac);
a (spec_nth_asm_tac 2 ¨dpoTÆ);
(* *** Goal "2" *** *)
a (PC_T1 "hol" cases_tac ¨s = {dpoB}Æ THEN_TRY asm_rewrite_tac[]);
(* *** Goal "2.1" *** *)
a (∂_tac ¨dpoBÆ THEN asm_rewrite_tac []
	THEN REPEAT strip_tac);
(* *** Goal "2.2" *** *)
a (PC_T1 "hol" cases_tac ¨s = {}Æ THEN_TRY asm_rewrite_tac[]);
(* *** Goal "2.2.1" *** *)
a (∂_tac ¨dpoBÆ THEN_TRY asm_rewrite_tac[]);
(* *** Goal "2.2.2" *** *)
a (PC_T1 "hol" cases_tac ¨∂f∑ s = {dpoE f} Æ THEN_TRY asm_rewrite_tac[]);
(* *** Goal "2.2.2.1" *** *)
a (∂_tac ¨dpoE fÆ THEN_TRY asm_rewrite_tac[]
	THEN REPEAT strip_tac THEN_TRY asm_rewrite_tac[]);
a (spec_nth_asm_tac 2 ¨dpoE fÆ);
(* *** Goal "2.2.2.2" *** *)
a (cases_tac ¨∂f g∑ ≥ f = g ± dpoE f ç s ± dpoE g ç sÆ THEN_TRY asm_rewrite_tac[]);
(* *** Goal "2.2.2.2.1" *** *)
a (∂_tac ¨dpoTÆ THEN_TRY asm_rewrite_tac[]
	THEN REPEAT strip_tac THEN_TRY asm_rewrite_tac[]);
a (spec_nth_asm_tac 2 ¨dpoE fÆ);
a (spec_nth_asm_tac 3 ¨dpoE gÆ);
a (POP_ASM_T ante_tac THEN SYM_ASMS_T rewrite_tac);
(* *** Goal "2.2.2.2.2" *** *)
a (cases_tac ¨∂h∑ dpoE h ç sÆ THEN_TRY asm_rewrite_tac[]);
(* *** Goal "2.2.2.2.2.1" *** *)
a (∂_tac ¨dpoE hÆ THEN_TRY asm_rewrite_tac[]
	THEN REPEAT strip_tac THEN_TRY asm_rewrite_tac[]);
(* *** Goal "2.2.2.2.2.1.1" *** *)
a (asm_fc_tac[]);
a (LEMMA_T ¨s = {dpoE h; dpoB}Æ asm_tac
	THEN1 (asm_rewrite_tac [] THEN strip_tac));
(* *** Goal "2.2.2.2.2.1.1.1" *** *)
a (strip_asm_tac (µ_elim ¨x'Æ dpo_cases_thm)
	THEN_TRY asm_rewrite_tac[]);
(* *** Goal "2.2.2.2.2.1.1.1.1" *** *)
a (lemma_tac ¨x = dpoBÆ
	THEN1 (strip_asm_tac (µ_elim ¨xÆ dpo_cases_thm)
		THEN_TRY asm_rewrite_tac[]));
(* *** Goal "2.2.2.2.2.1.1.1.1.1" *** *)
a (var_elim_asm_tac ¨x = dpoTÆ);
(* *** Goal "2.2.2.2.2.1.1.1.1.2" *** *)
a (var_elim_asm_tac ¨x = dpoE eÆ);
a (var_elim_asm_tac ¨x' = dpoBÆ);
a (all_asm_fc_tac[]);
a (var_elim_asm_tac ¨e = hÆ);
(* *** Goal "2.2.2.2.2.1.1.1.1.3" *** *)
a (var_elim_asm_tac ¨x = dpoBÆ);
(* *** Goal "2.2.2.2.2.1.1.1.2" *** *)
a (var_elim_asm_tac ¨x' = dpoE eÆ);
a (REPEAT strip_tac);
(* *** Goal "2.2.2.2.2.1.1.1.2.1" *** *)
a (all_asm_fc_tac[]);
a (var_elim_asm_tac ¨e = hÆ);
(* *** Goal "2.2.2.2.2.1.1.2" *** *)
a (var_elim_asm_tac ¨s = {dpoE h; dpoB}Æ);
(* *** Goal "2.2.2.2.2.1.2" *** *)
a (spec_nth_asm_tac 2 ¨dpoE hÆ);
(* *** Goal "2.2.2.2.2.2" *** *)
a (swap_nth_asm_concl_tac 4
	THEN rewrite_tac[]
	THEN contr_tac);
a (strip_asm_tac (µ_elim ¨xÆ dpo_cases_thm));
(* *** Goal "2.2.2.2.2.2.1" *** *)
a (var_elim_asm_tac ¨x = dpoBÆ);
a (DROP_NTH_ASM_T 6 ante_tac
	THEN asm_rewrite_tac[]
	THEN contr_tac);
(* *** Goal "2.2.2.2.2.2.1.1" *** *)
a (strip_asm_tac (µ_elim ¨xÆ dpo_cases_thm));
(* *** Goal "2.2.2.2.2.2.1.1.1" *** *)
a (var_elim_asm_tac ¨x = dpoTÆ);
(* *** Goal "2.2.2.2.2.2.1.1.2" *** *)
a (var_elim_asm_tac ¨x = dpoE eÆ);
a (all_asm_fc_tac[]);
(* *** Goal "2.2.2.2.2.2.1.2" *** *)
a (var_elim_asm_tac ¨x = dpoBÆ);
(* *** Goal "2.2.2.2.2.2.2" *** *)
a (var_elim_asm_tac ¨x = dpoTÆ);
(* *** Goal "2.2.2.2.2.2.3" *** *)
a (var_elim_asm_tac ¨x = dpoE eÆ);
a (all_asm_fc_tac[]);
val dpo_lubs_exist_thm = save_pop_thm "dpo_lubs_exist_thm";
=TEX
}%ignore

\subsection{Truth Values}

I am uncertain at this point whether to work with three or four truth values, so both of these are provided for here.

\subsubsection{Three Valued}

=SML
declare_type_abbrev("€TTV›", [], îBOOL OPTÆ);
=TEX

πHOLCONST
‹ €pTrue› : TTV
˜¸¸¸¸¸¸¸¸¸¸¸
‹ pTrue = Value T
∞

πHOLCONST
‹ €pFalse› : TTV
˜¸¸¸¸¸¸¸¸¸¸¸
‹ pFalse = Value F
∞

πHOLCONST
‹ €pU› : TTV
˜¸¸¸¸¸¸¸¸¸¸¸
‹ pU = Undefined
∞

=GFT
€tv_cases_thm› =
	Ù µ x∑ x = pTrue ≤ x = pFalse ≤ x = pU

€tv_distinct_clauses› =
	Ù ≥ pTrue = pFalse
             ± ≥ pTrue = pU
             ± ≥ pFalse = pTrue
             ± ≥ pFalse = pU
             ± ≥ pU = pTrue
             ± ≥ pU = pFalse
=TEX

\ignore{
=SML
set_merge_pcs ["hol", "'GS1", "'ifol"];

set_goal([], ¨µx∑ x = pTrue ≤ x = pFalse ≤ x = pUÆ);
a (rewrite_tac (map get_spec [¨pTrueÆ, ¨pFalseÆ, ¨pUÆ]) THEN prove_tac[]);
a (strip_asm_tac (µ_elim ¨xÆ sum_cases_thm));
(* *** Goal "1" *** *)
a (POP_ASM_T ante_tac);
a (LEMMA_T ¨y = T ≤ y = FÆ (STRIP_THM_THEN asm_tac) THEN1 prove_tac[]
	THEN var_elim_nth_asm_tac 1
	THEN strip_tac);
(* ** Goal "2" *** *)
a (asm_rewrite_tac[one_def]);
val tv_cases_thm = save_pop_thm "tv_cases_thm";

set_goal([], ¨≥ pTrue = pFalse
	± ≥ pTrue = pU
	± ≥ pFalse = pTrue
	± ≥ pFalse = pU
	± ≥ pU = pTrue
	± ≥ pU = pFalse
Æ);
a (rewrite_tac (map get_spec [¨pTrueÆ, ¨pFalseÆ, ¨pUÆ]) THEN prove_tac[]);
val tv_distinct_clauses = save_pop_thm "tv_distinct_clauses";

add_pc_thms "'ifol" (map get_spec [] @ [tv_distinct_clauses]);
set_merge_pcs ["hol1", "'GS1", "'ifol"];
=TEX
}%ignore

=SML
declare_infix(300, "ºâtâ3");
=TEX

=SML
declare_type_abbrev ("REL", ["'a"], î'a ≠ 'a ≠ BOOLÆ);
=TEX

First an ordering on the ``truth values'' is defined.

πHOLCONST
‹ €$ºâtâ3› : TTV REL
˜¸¸¸¸¸¸¸¸¸¸¸
‹ µ t1 t2∑ 
‹	t1 ºâtâ3 t2 § t1 = t2 ≤ t1 = pU	
∞

=GFT
€ºâtâ3_refl_thm› =
	Ù µ x∑ x ºâtâ3 x

€ºâtâ3_trans_thm› =
	Ù µ x y z∑ x ºâtâ3 y ± y ºâtâ3 z ¥ x ºâtâ3 z

€ºâtâ3_antisym_thm› =
	Ù µ x y∑ x ºâtâ3 y ± y ºâtâ3 x ¥ x = y

€ºâtâ3_partialorder_thm› =
	Ù µ Y∑ PartialOrder (Y, $ºâtâ3)

€ºâtâ3_clauses› =
   Ù pU ºâtâ3 pTrue
       ± pU ºâtâ3 pFalse
       ± ≥ pTrue ºâtâ3 pU
       ± ≥ pFalse ºâtâ3 pU
       ± ≥ pFalse ºâtâ3 pTrue
       ± ≥ pTrue ºâtâ3 pFalse

€lin_ºâtâ3_lemma› =
   Ù µ Y∑ LinearOrder (Y, $ºâtâ3) § ≥ pTrue ç Y ≤ ≥ pFalse ç Y

€lin_ºâtâ3_cases_lemma› =
   Ù µ Y
     ∑ LinearOrder (Y, $ºâtâ3)
         § Y = {}
           ≤ Y = {pU}
           ≤ Y = {pTrue}
           ≤ Y = {pFalse}
           ≤ Y = {pU; pTrue}
           ≤ Y = {pU; pFalse}

€ºâtâ3_isub_cases_lemma› =
   Ù µ Y
     ∑ IsUb $ºâtâ3 {} = (Ã x∑ T)
         ± IsUb $ºâtâ3 {pU} = (Ã x∑ T)
         ± IsUb $ºâtâ3 {pTrue} = (Ã x∑ x = pTrue)
         ± IsUb $ºâtâ3 {pFalse} = (Ã x∑ x = pFalse)
         ± IsUb $ºâtâ3 {pU; pTrue} = (Ã x∑ x = pTrue)
         ± IsUb $ºâtâ3 {pU; pFalse} = (Ã x∑ x = pFalse)

€ºâtâ3_islub_cases_lemma› =
   Ù µ Y
     ∑ IsLub $ºâtâ3 {} pU
         ± IsLub $ºâtâ3 {pU} pU
         ± IsLub $ºâtâ3 {pTrue} pTrue
         ± IsLub $ºâtâ3 {pFalse} pFalse
         ± IsLub $ºâtâ3 {pU; pTrue} pTrue
         ± IsLub $ºâtâ3 {pU; pFalse} pFalse

€chaincomplete_ºâtâ3_kemma› =
	Ù ChainComplete (Universe, $ºâtâ3)

€ccrpou_ºâtâ3_thm› =
	Ù CcRpoU $ºâtâ3
=TEX

\ignore{
=SML
set_goal([], ¨µx∑ x ºâtâ3 xÆ);
a (rewrite_tac [get_spec ¨$ºâtâ3Æ]);
val ºâtâ3_refl_thm = save_pop_thm "ºâtâ3_refl_thm";

set_goal([], ¨µx y z∑ x ºâtâ3 y ± y ºâtâ3 z ¥ x ºâtâ3 zÆ);
a (rewrite_tac [get_spec ¨$ºâtâ3Æ]
	THEN REPEAT strip_tac
	THEN_TRY asm_rewrite_tac[]);
a (all_var_elim_asm_tac);
val ºâtâ3_trans_thm = save_pop_thm "ºâtâ3_trans_thm";

set_goal([], ¨µx y∑ x ºâtâ3 y ± y ºâtâ3 x ¥ x = yÆ);
a (rewrite_tac [get_spec ¨$ºâtâ3Æ]
	THEN REPEAT strip_tac
	THEN_TRY asm_rewrite_tac[]);
val ºâtâ3_antisym_thm = save_pop_thm "ºâtâ3_antisym_thm";

set_goal([], ¨(µx∑ pU ºâtâ3 x)
	± ≥ pTrue ºâtâ3 pU
	± ≥ pFalse ºâtâ3 pU
	± ≥ pFalse ºâtâ3 pTrue
	± ≥ pTrue ºâtâ3 pFalseÆ);
a (rewrite_tac [get_spec ¨$ºâtâ3Æ] THEN prove_tac[]);
val ºâtâ3_clauses = save_pop_thm "ºâtâ3_clauses";

add_pc_thms "'ifol" (map get_spec [] @ [ºâtâ3_refl_thm, ºâtâ3_clauses]);
set_merge_pcs ["hol1", "'GS1", "'ifol"];

set_goal([], ¨µY∑ PartialOrder (Y, $ºâtâ3)Æ);
a (rewrite_tac (map get_spec [¨PartialOrderÆ, ¨AntisymÆ, ¨TransÆ])
	THEN contr_tac);
a (all_fc_tac [ºâtâ3_antisym_thm]);
a (all_fc_tac [ºâtâ3_trans_thm]);
val ºâtâ3_partialorder_thm = save_pop_thm "ºâtâ3_partialorder_thm";

set_goal([], ¨µY∑ LinearOrder (Y, $ºâtâ3) § ≥ pTrue ç Y ≤ ≥ pFalse ç YÆ);
a (rewrite_tac [get_spec ¨LinearOrderÆ, get_spec ¨TrichÆ, ºâtâ3_partialorder_thm]
	THEN contr_tac);
(* *** Goal "1" *** *)
a (REPEAT (asm_fc_tac[]));
(* *** Goal "2" *** *)
a (strip_asm_tac (list_µ_elim [¨xÆ] tv_cases_thm)
	THEN asm_prove_tac[]);
a (strip_asm_tac (list_µ_elim [¨yÆ] tv_cases_thm)
	THEN asm_prove_tac[]);
(* *** Goal "3" *** *)
a (strip_asm_tac (list_µ_elim [¨xÆ] tv_cases_thm)
	THEN asm_prove_tac[]);
a (strip_asm_tac (list_µ_elim [¨yÆ] tv_cases_thm)
	THEN asm_prove_tac[]);
val lin_ºâtâ3_lemma = save_pop_thm "lin_ºâtâ3_lemma";

set_merge_pcs ["hol", "'GS1", "'ifol"];

set_goal([], ¨µY∑ LinearOrder (Y, $ºâtâ3) §
	  Y = {}
	≤ Y = {pU} ≤ Y = {pTrue} ≤ Y = {pFalse}
	≤ Y = {pU; pTrue} ≤ Y = {pU; pFalse}Æ);
a (rewrite_tac [lin_ºâtâ3_lemma] THEN REPEAT µ_tac);
a (		cases_tac ¨pTrue ç YÆ
	THEN	cases_tac ¨pFalse ç YÆ
	THEN	cases_tac ¨pU ç YÆ
	THEN_TRY asm_rewrite_tac[]);
(* *** Goal "1" *** *)
a (contr_tac THEN var_elim_nth_asm_tac 1);
(* *** Goal "2" *** *)
a (contr_tac THEN var_elim_nth_asm_tac 1);
(* *** Goal "3" *** *)
set_merge_pcs ["hol1", "'GS1", "'ifol"];
a (LEMMA_T ¨Y = {pU; pTrue}Æ asm_tac
	THEN1 (asm_rewrite_tac[]
		THEN µ_tac
		THEN (strip_asm_tac (µ_elim ¨x:TTVÆ tv_cases_thm)
		THEN asm_rewrite_tac[]))
	THEN asm_rewrite_tac[]);
(* *** Goal "4" *** *)
a (LEMMA_T ¨Y = {pTrue}Æ asm_tac
	THEN1 (asm_rewrite_tac[]
		THEN µ_tac
		THEN (strip_asm_tac (µ_elim ¨x:TTVÆ tv_cases_thm)
		THEN asm_rewrite_tac[]))
	THEN asm_rewrite_tac[]);
(* *** Goal "5" *** *)
a (LEMMA_T ¨Y = {pU; pFalse}Æ asm_tac
	THEN1 (asm_rewrite_tac[]
		THEN µ_tac
		THEN (strip_asm_tac (µ_elim ¨x:TTVÆ tv_cases_thm)
		THEN asm_rewrite_tac[]))
	THEN asm_rewrite_tac[]);
(* *** Goal "6" *** *)
a (LEMMA_T ¨Y = {pFalse}Æ asm_tac
	THEN1 (asm_rewrite_tac[]
		THEN µ_tac
		THEN (strip_asm_tac (µ_elim ¨x:TTVÆ tv_cases_thm)
		THEN asm_rewrite_tac[]))
	THEN asm_rewrite_tac[]);
(* *** Goal "7" *** *)
a (LEMMA_T ¨Y = {pU}Æ asm_tac
	THEN1 (asm_rewrite_tac[]
		THEN µ_tac
		THEN (strip_asm_tac (µ_elim ¨x:TTVÆ tv_cases_thm)
		THEN asm_rewrite_tac[]))
	THEN asm_rewrite_tac[]);
(* *** Goal "8" *** *)
a (LEMMA_T ¨Y = {}Æ asm_tac
	THEN1 (asm_rewrite_tac[]
		THEN µ_tac
		THEN (strip_asm_tac (µ_elim ¨x:TTVÆ tv_cases_thm)
		THEN asm_rewrite_tac[]))
	THEN asm_rewrite_tac[]);
val lin_ºâtâ3_cases_lemma = pop_thm ();

set_goal([], ¨µY∑ 
	  IsUb $ºâtâ3 {} = (Ãx∑ T)
	± IsUb $ºâtâ3 {pU} = (Ãx∑ T) ± IsUb $ºâtâ3 {pTrue} = (Ãx∑ x = pTrue) ± IsUb $ºâtâ3 {pFalse} = (Ãx∑ x = pFalse)
	± IsUb $ºâtâ3 {pU; pTrue} = (Ãx∑ x = pTrue) ± IsUb $ºâtâ3 {pU; pFalse} = (Ãx∑ x = pFalse)Æ);
a (rewrite_tac [get_spec ¨IsUbÆ]);
a (REPEAT strip_tac THEN_TRY asm_rewrite_tac[]);
(* *** Goal "1" *** *)
a (spec_nth_asm_tac 1 ¨pTrueÆ);
a (strip_asm_tac (µ_elim ¨xÆ tv_cases_thm) THEN_TRY asm_rewrite_tac[]
	THEN var_elim_nth_asm_tac 1);
(* *** Goal "2" *** *)
a (spec_nth_asm_tac 1 ¨pFalseÆ);
a (strip_asm_tac (µ_elim ¨xÆ tv_cases_thm) THEN_TRY asm_rewrite_tac[]
	THEN var_elim_nth_asm_tac 1);
(* *** Goal "3" *** *)
a (spec_nth_asm_tac 1 ¨pTrueÆ);
a (strip_asm_tac (µ_elim ¨xÆ tv_cases_thm) THEN_TRY asm_rewrite_tac[]
	THEN var_elim_nth_asm_tac 1);
(* *** Goal "4" *** *)
a (spec_nth_asm_tac 1 ¨pFalseÆ);
a (strip_asm_tac (µ_elim ¨xÆ tv_cases_thm) THEN_TRY asm_rewrite_tac[]
	THEN var_elim_nth_asm_tac 1);
val ºâtâ4_isub_cases_lemma = pop_thm ();

set_goal([], ¨µY∑ 
	  IsLub $ºâtâ3 {} pU
	± IsLub $ºâtâ3 {pU} pU ± IsLub $ºâtâ3 {pTrue} pTrue ± IsLub $ºâtâ3 {pFalse} pFalse
	± IsLub $ºâtâ3 {pU; pTrue} pTrue ± IsLub $ºâtâ3 {pU; pFalse} pFalseÆ);
a (rewrite_tac [get_spec ¨IsLubÆ]);
a (rewrite_tac [ºâtâ4_isub_cases_lemma]);
a (REPEAT strip_tac THEN asm_rewrite_tac[]);
val ºâtâ4_islub_cases_lemma = pop_thm ();

set_merge_pcs ["hol", "'GS1", "'ifol"];

set_goal([], ¨ChainComplete (Universe, $ºâtâ3)Æ);
a (rewrite_tac (map get_spec [¨ChainCompleteÆ]));
a (rewrite_tac [lin_ºâtâ3_cases_lemma]);
a (REPEAT strip_tac THEN asm_rewrite_tac[]);
a (∂_tac ¨pUÆ THEN rewrite_tac [ºâtâ4_islub_cases_lemma]);
a (∂_tac ¨pUÆ THEN rewrite_tac [ºâtâ4_islub_cases_lemma]);
a (∂_tac ¨pTrueÆ THEN rewrite_tac [ºâtâ4_islub_cases_lemma]);
a (∂_tac ¨pFalseÆ THEN rewrite_tac [ºâtâ4_islub_cases_lemma]);
a (∂_tac ¨pTrueÆ THEN rewrite_tac [ºâtâ4_islub_cases_lemma]);
a (∂_tac ¨pFalseÆ THEN rewrite_tac [ºâtâ4_islub_cases_lemma]);
val chaincomplete_ºâtâ3_kemma = pop_thm ();

set_goal([], ¨CcRpoU $ºâtâ3Æ);
a (rewrite_tac (map get_spec [¨CcRpoUÆ, ¨CcRpoÆ, ¨RpoÆ, ¨ReflÆ]
	@ [ºâtâ3_partialorder_thm, chaincomplete_ºâtâ3_kemma]));
val ccrpou_ºâtâ3_thm = save_pop_thm "ccrpou_ºâtâ3_thm";
=TEX
}%ignore

\subsubsection{Four Valued}

=SML
declare_type_abbrev("€FTV›", [], îBOOL DPOÆ);
=TEX

πHOLCONST
‹ €fTrue› : FTV
˜¸¸¸¸¸¸¸¸¸¸¸
‹ fTrue = dpoE T
∞

πHOLCONST
‹ €fFalse› : FTV
˜¸¸¸¸¸¸¸¸¸¸¸
‹ fFalse = dpoE F
∞

πHOLCONST
‹ €fB› : FTV
˜¸¸¸¸¸¸¸¸¸¸¸
‹ fB = dpoB
∞

πHOLCONST
‹ €fT› : FTV
˜¸¸¸¸¸¸¸¸¸¸¸
‹ fT = dpoT
∞

=GFT
€ftv_cases_thm› =
	Ù µ x∑ x = fTrue ≤ x = fFalse ≤ x = fB ≤ x = fT
€ftv_distinct_clauses› =
	Ù ≥ fTrue = fFalse
       ± ≥ fTrue = fB
       ± ≥ fTrue = fT
       ± ≥ fFalse = fTrue
       ± ≥ fFalse = fB
       ± ≥ fFalse = fT
       ± ≥ fB = fTrue
       ± ≥ fB = fFalse
       ± ≥ fB = fT
       ± ≥ fT = fTrue
       ± ≥ fT = fFalse
       ± ≥ fT = fB

€ftvs_cases_thm› =
   Ù µ x
     ∑ x = {}
         ≤ x = {fB}
         ≤ x = {fFalse}
         ≤ x = {fTrue}
         ≤ x = {fT}
         ≤ x = {fB; fFalse}
         ≤ x = {fB; fTrue}
         ≤ x = {fB; fT}
         ≤ x = {fFalse; fTrue}
         ≤ x = {fFalse; fT}
         ≤ x = {fTrue; fT}
         ≤ x = {fB; fFalse; fTrue}
         ≤ x = {fB; fFalse; fT}
         ≤ x = {fB; fTrue; fT}
         ≤ x = {fFalse; fTrue; fT}
         ≤ x = {fB; fFalse; fTrue; fT}
=TEX

\ignore{
=SML
set_merge_pcs ["hol", "'GS1", "'ifol"];

set_goal([], ¨µx∑ x = fTrue ≤ x = fFalse ≤ x = fB ≤ x = fTÆ);
a (rewrite_tac (map get_spec [¨fTrueÆ, ¨fFalseÆ, ¨fBÆ, ¨fTÆ]) THEN strip_tac);
a (strip_asm_tac (µ_elim ¨xÆ dpo_cases_thm)
	THEN asm_rewrite_tac[]);
a (cases_tac ¨eÆ THEN asm_rewrite_tac[]);
val ftv_cases_thm = save_pop_thm "ftv_cases_thm";

set_goal([], ¨≥ fTrue = fFalse
	± ≥ fTrue = fB
	± ≥ fTrue = fT
	± ≥ fFalse = fTrue
	± ≥ fFalse = fB
	± ≥ fFalse = fT
	± ≥ fB = fTrue
	± ≥ fB = fFalse
	± ≥ fB = fT
	± ≥ fT = fTrue
	± ≥ fT = fFalse
	± ≥ fT = fB
Æ);
a (LEMMA_T ¨≥ F = TÆ asm_tac THEN1 prove_tac[]);
a (fc_tac [dpo_distinct_fc_clauses]);
a (rewrite_tac (map get_spec [¨fTrueÆ, ¨fFalseÆ, ¨fBÆ, ¨fTÆ]) THEN prove_tac[dpo_distinct_clauses]);
val ftv_distinct_clauses = save_pop_thm "ftv_distinct_clauses";

add_pc_thms "'ifol" (map get_spec [] @ [ftv_distinct_clauses]);
set_merge_pcs ["hol1", "'GS1", "'ifol"];

set_goal([], ¨µx∑
	x = {}
	≤ x = {fB}
	≤ x = {fFalse}
	≤ x = {fTrue}
	≤ x = {fT}
	≤ x = {fB; fFalse}
	≤ x = {fB; fTrue}
	≤ x = {fB; fT}
	≤ x = {fFalse; fTrue}
	≤ x = {fFalse; fT}
	≤ x = {fTrue; fT}
	≤ x = {fB; fFalse; fTrue}
	≤ x = {fB; fFalse; fT}
	≤ x = {fB; fTrue; fT}
	≤ x = {fFalse; fTrue; fT}
	≤ x = {fB; fFalse; fTrue; fT}
Æ);
a (	strip_tac);
a (	cases_tac ¨fTrue ç xÆ
	THEN	cases_tac ¨fFalse ç xÆ
	THEN	cases_tac ¨fB ç xÆ
	THEN	cases_tac ¨fT ç xÆ);
(* *** Goal "1" *** *)
a (LEMMA_T  ¨x = {fB; fFalse; fTrue; fT}Æ rewrite_thm_tac
	THEN1 PC_T1 "hol1" rewrite_tac[]
		THEN strip_tac);
a (strip_asm_tac (µ_elim ¨x'Æ ftv_cases_thm) THEN asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a (LEMMA_T  ¨x = {fB; fFalse; fTrue}Æ (PC_T1 "hol1" rewrite_thm_tac)
	THEN1 PC_T1 "hol1" rewrite_tac[]
		THEN strip_tac);
a (strip_asm_tac (µ_elim ¨x'Æ ftv_cases_thm) THEN asm_rewrite_tac[]);
(* *** Goal "3" *** *)
a (LEMMA_T  ¨x = {fFalse; fTrue; fT}Æ rewrite_thm_tac
	THEN1 PC_T1 "hol1" rewrite_tac[]
		THEN strip_tac);
a (strip_asm_tac (µ_elim ¨x'Æ ftv_cases_thm) THEN asm_rewrite_tac[]);
(* *** Goal "4" *** *)
a (LEMMA_T  ¨x = {fFalse; fTrue}Æ rewrite_thm_tac
	THEN1 PC_T1 "hol1" rewrite_tac[]
		THEN strip_tac);
a (strip_asm_tac (µ_elim ¨x'Æ ftv_cases_thm) THEN asm_rewrite_tac[]);
(* *** Goal "5" *** *)
a (LEMMA_T  ¨x = {fB; fTrue; fT}Æ rewrite_thm_tac
	THEN1 PC_T1 "hol1" rewrite_tac[]
		THEN strip_tac);
a (strip_asm_tac (µ_elim ¨x'Æ ftv_cases_thm) THEN asm_rewrite_tac[]);
(* *** Goal "6" *** *)
a (LEMMA_T  ¨x = {fB; fTrue}Æ rewrite_thm_tac
	THEN1 PC_T1 "hol1" rewrite_tac[]
		THEN strip_tac);
a (strip_asm_tac (µ_elim ¨x'Æ ftv_cases_thm) THEN asm_rewrite_tac[]);
(* *** Goal "7" *** *)
a (LEMMA_T  ¨x = {fTrue; fT}Æ rewrite_thm_tac
	THEN1 PC_T1 "hol1" rewrite_tac[]
		THEN strip_tac);
a (strip_asm_tac (µ_elim ¨x'Æ ftv_cases_thm) THEN asm_rewrite_tac[]);
(* *** Goal "8" *** *)
a (LEMMA_T  ¨x = {fTrue}Æ rewrite_thm_tac
	THEN1 PC_T1 "hol1" rewrite_tac[]
		THEN strip_tac);
a (strip_asm_tac (µ_elim ¨x'Æ ftv_cases_thm) THEN asm_rewrite_tac[]);
(* *** Goal "9" *** *)
a (LEMMA_T  ¨x = {fB; fFalse; fT}Æ rewrite_thm_tac
	THEN1 PC_T1 "hol1" rewrite_tac[]
		THEN strip_tac);
a (strip_asm_tac (µ_elim ¨x'Æ ftv_cases_thm) THEN asm_rewrite_tac[]);
(* *** Goal "10" *** *)
a (LEMMA_T  ¨x = {fB; fFalse}Æ rewrite_thm_tac
	THEN1 PC_T1 "hol1" rewrite_tac[]
		THEN strip_tac);
a (strip_asm_tac (µ_elim ¨x'Æ ftv_cases_thm) THEN asm_rewrite_tac[]);
(* *** Goal "11" *** *)
a (LEMMA_T  ¨x = {fFalse; fT}Æ rewrite_thm_tac
	THEN1 PC_T1 "hol1" rewrite_tac[]
		THEN strip_tac);
a (strip_asm_tac (µ_elim ¨x'Æ ftv_cases_thm) THEN asm_rewrite_tac[]);
(* *** Goal "12" *** *)
a (LEMMA_T  ¨x = {fFalse}Æ rewrite_thm_tac
	THEN1 PC_T1 "hol1" rewrite_tac[]
		THEN strip_tac);
a (strip_asm_tac (µ_elim ¨x'Æ ftv_cases_thm) THEN asm_rewrite_tac[]);
(* *** Goal "13" *** *)
a (LEMMA_T  ¨x = {fB; fT}Æ rewrite_thm_tac
	THEN1 PC_T1 "hol1" rewrite_tac[]
		THEN strip_tac);
a (strip_asm_tac (µ_elim ¨x'Æ ftv_cases_thm) THEN asm_rewrite_tac[]);
(* *** Goal "14" *** *)
a (LEMMA_T  ¨x = {fB}Æ rewrite_thm_tac
	THEN1 PC_T1 "hol1" rewrite_tac[]
		THEN strip_tac);
a (strip_asm_tac (µ_elim ¨x'Æ ftv_cases_thm) THEN asm_rewrite_tac[]);
(* *** Goal "15" *** *)
a (LEMMA_T  ¨x = {fT}Æ rewrite_thm_tac
	THEN1 PC_T1 "hol1" rewrite_tac[]
		THEN strip_tac);
a (strip_asm_tac (µ_elim ¨x'Æ ftv_cases_thm) THEN asm_rewrite_tac[]);
(* *** Goal "16" *** *)
a (LEMMA_T  ¨x = {}Æ rewrite_thm_tac
	THEN1 PC_T1 "hol1" rewrite_tac[]
		THEN strip_tac);
a (strip_asm_tac (µ_elim ¨x'Æ ftv_cases_thm) THEN asm_rewrite_tac[]);
val ftvs_cases_thm = save_pop_thm "ftvs_cases_thm";
=TEX
}%ignore

=SML
declare_infix(300, "ºâtâ4");
=TEX

First an ordering on the ``truth values'' is defined.

πHOLCONST
‹ €$ºâtâ4› : FTV REL
˜¸¸¸¸¸¸¸¸¸¸¸
‹ µ t1 t2∑ 
‹	t1 ºâtâ4 t2 § t1 = t2 ≤ t1 = fB ≤ t2 = fT
∞

=GFT
€ºâtâ4_dpo_thm› =
	Ù $ºâtâ4 = Dpo

€ºâtâ4_refl_thm› =
	Ù µ x∑ x ºâtâ4 x

€ºâtâ4_trans_thm› =
	Ù µ x y z∑ x ºâtâ4 y ± y ºâtâ4 z ¥ x ºâtâ4 z

€ºâtâ4_antisym_thm› =
	Ù µ x y∑ x ºâtâ4 y ± y ºâtâ4 x ¥ x = y

€ft_fb_thm› =
	Ù µ x∑ (fT ºâtâ4 x § x = fT) ± (x ºâtâ4 fB § x = fB)

€ºâtâ4_partialorder_thm› =
	Ù µ Y∑ PartialOrder (Y, $ºâtâ4)

€ºâtâ4_clauses› =
   Ù fB ºâtâ4 fTrue
       ± fB ºâtâ4 fFalse
       ± ≥ fTrue ºâtâ4 fB
       ± ≥ fFalse ºâtâ4 fB
       ± ≥ fFalse ºâtâ4 fTrue
       ± ≥ fTrue ºâtâ4 fFalse

€ºâtâ4_lin_lemma› =
   Ù µ Y∑ LinearOrder (Y, $ºâtâ4) § ≥ fTrue ç Y ≤ ≥ fFalse ç Y

€ºâtâ4_lin_cases_lemma› =
   Ù µ Y
     ∑ LinearOrder (Y, $ºâtâ4)
         § Y = {}
           ≤ Y = {fB}
           ≤ Y = {fTrue}
           ≤ Y = {fFalse}
           ≤ Y = {fB; fTrue}
           ≤ Y = {fB; fFalse}

€ºâtâ4_isub_cases_lemma› =
   Ù µ Y
     ∑ IsUb $ºâtâ4 {} = (Ã x∑ T)
         ± IsUb $ºâtâ4 {fB} = (Ã x∑ T)
         ± IsUb $ºâtâ4 {fTrue} = (Ã x∑ x = fTrue)
         ± IsUb $ºâtâ4 {fFalse} = (Ã x∑ x = fFalse)
         ± IsUb $ºâtâ4 {fB; fTrue} = (Ã x∑ x = fTrue)
         ± IsUb $ºâtâ4 {fB; fFalse} = (Ã x∑ x = fFalse)

€ºâtâ4_islub_cases_lemma› =
   Ù µ Y
     ∑ IsLub $ºâtâ4 {} fB
         ± IsLub $ºâtâ4 {fB} fB
         ± IsLub $ºâtâ4 {fTrue} fTrue
         ± IsLub $ºâtâ4 {fFalse} fFalse
         ± IsLub $ºâtâ4 {fB; fTrue} fTrue
         ± IsLub $ºâtâ4 {fB; fFalse} fFalse

€ºâtâ4_lin_cases_lemma› =
   Ù µ Y
     ∑ LinearOrder (Y, $ºâtâ4)
         § Y = {}
           ≤ Y = {fB}
           ≤ Y = {fTrue}
           ≤ Y = {fFalse}
           ≤ Y = {fT}
           ≤ Y = {fB; fTrue}
           ≤ Y = {fB; fFalse}
           ≤ Y = {fB; fT}
           ≤ Y = {fTrue; fT}
           ≤ Y = {fFalse; fT}
           ≤ Y = {fB; fTrue; fT}
           ≤ Y = {fB; fFalse; fT}

€ºâtâ4_glbs_exist_thm› =
	Ù GlbsExist $ºâtâ4

€ºâtâ4_lubs_exist_thm› =
	Ù LubsExist $ºâtâ4
=TEX

\ignore{
=SML
set_goal([], ¨$ºâtâ4 = DpoÆ);
a (rewrite_tac (map get_spec [¨$ºâtâ4Æ, ¨DpoÆ, ¨fBÆ, ¨fTÆ, ¨fTrueÆ, ¨fFalseÆ])
	THEN REPEAT strip_tac);
val ºâtâ4_dpo_thm = save_pop_thm "ºâtâ4_dpo_thm";

set_goal([], ¨µx∑ x ºâtâ4 xÆ);
a (rewrite_tac [get_spec ¨$ºâtâ4Æ]);
val ºâtâ4_refl_thm = save_pop_thm "ºâtâ4_refl_thm";

set_goal([], ¨µx y z∑ x ºâtâ4 y ± y ºâtâ4 z ¥ x ºâtâ4 zÆ);
a (rewrite_tac [get_spec ¨$ºâtâ4Æ]
	THEN REPEAT strip_tac
	THEN_TRY all_var_elim_asm_tac
	THEN_TRY asm_rewrite_tac[]);
val ºâtâ4_trans_thm = save_pop_thm "ºâtâ4_trans_thm";

set_goal([], ¨µx y∑ x ºâtâ4 y ± y ºâtâ4 x ¥ x = yÆ);
a (rewrite_tac [get_spec ¨$ºâtâ4Æ]
	THEN REPEAT strip_tac
	THEN_TRY all_var_elim_asm_tac
	THEN_TRY asm_rewrite_tac[]);
val ºâtâ4_antisym_thm = save_pop_thm "ºâtâ4_antisym_thm";

set_goal([], ¨(µx∑ fB ºâtâ4 x)
	± (µx∑ x ºâtâ4 fT)
	± ≥ fTrue ºâtâ4 fB
	± ≥ fFalse ºâtâ4 fB
	± ≥ fT ºâtâ4 fB
	± ≥ fFalse ºâtâ4 fTrue
	± ≥ fT ºâtâ4 fTrue
	± ≥ fTrue ºâtâ4 fFalse
	± ≥ fT ºâtâ4 fFalseÆ);
a (rewrite_tac [get_spec ¨$ºâtâ4Æ] THEN prove_tac[]);
val ºâtâ4_clauses = save_pop_thm "ºâtâ4_clauses";

set_goal ([], ¨µx∑ (fT ºâtâ4 x § x = fT) ± (x ºâtâ4 fB § x = fB)Æ);
a (prove_tac [get_spec ¨$ºâtâ4Æ]);
val ft_fb_thm = save_pop_thm "ft_fb_thm";

add_pc_thms "'ifol" (map get_spec [] @ [ºâtâ4_refl_thm, ºâtâ4_clauses]);
set_merge_pcs ["hol1", "'GS1", "'ifol"];

set_goal([], ¨µY∑ PartialOrder (Y, $ºâtâ4)Æ);
a (rewrite_tac (map get_spec [¨PartialOrderÆ, ¨AntisymÆ, ¨TransÆ])
	THEN contr_tac);
a (all_fc_tac [ºâtâ4_antisym_thm]);
a (all_fc_tac [ºâtâ4_trans_thm]);
val ºâtâ4_partialorder_thm = save_pop_thm "ºâtâ4_partialorder_thm";

set_goal([], ¨µY∑ LinearOrder (Y, $ºâtâ4) § ≥ fTrue ç Y ≤ ≥ fFalse ç YÆ);
a (rewrite_tac [get_spec ¨LinearOrderÆ, get_spec ¨TrichÆ, ºâtâ4_partialorder_thm]
	THEN contr_tac);
(* *** Goal "1" *** *)
a (REPEAT (asm_fc_tac[]));
(* *** Goal "2" *** *)
a (strip_asm_tac (list_µ_elim [¨xÆ] ftv_cases_thm)
	THEN asm_prove_tac[]);
a (strip_asm_tac (list_µ_elim [¨yÆ] ftv_cases_thm)
	THEN asm_prove_tac[]);
(* *** Goal "3" *** *)
a (strip_asm_tac (list_µ_elim [¨xÆ] ftv_cases_thm)
	THEN asm_prove_tac[]);
a (strip_asm_tac (list_µ_elim [¨yÆ] ftv_cases_thm)
	THEN asm_prove_tac[]);
val ºâtâ4_lin_lemma = save_pop_thm "ºâtâ4_lin_lemma";

set_merge_pcs ["hol", "'GS1", "'ifol"];
set_goal([], ¨µY∑ LinearOrder (Y, $ºâtâ4) §
	  Y = {}
	≤ Y = {fB} ≤ Y = {fTrue} ≤ Y = {fFalse} ≤ Y = {fT}
	≤ Y = {fB; fTrue} ≤ Y = {fB; fFalse} ≤ Y = {fB; fT}
	≤ Y = {fTrue; fT} ≤ Y = {fFalse; fT}
	≤ Y = {fB; fTrue; fT} ≤ Y = {fB; fFalse; fT}
Æ);
a (rewrite_tac [ºâtâ4_lin_lemma] THEN REPEAT µ_tac);
a (strip_asm_tac (µ_elim ¨YÆ ftvs_cases_thm)
	THEN asm_rewrite_tac[]
	THEN_TRY (conv_tac (MAP_C false_enum_eq_conv))
	THEN_TRY PC_T1 "hol1" prove_tac[ftv_distinct_clauses]);
val ºâtâ4_lin_cases_lemma = pop_thm ();

set_goal([], ¨GlbsExist $ºâtâ4Æ);
a (rewrite_tac[ºâtâ4_dpo_thm, dpo_glbs_exist_thm]);
val ºâtâ4_glbs_exist_thm = save_pop_thm "ºâtâ4_glbs_exist_thm";

set_goal([], ¨LubsExist $ºâtâ4Æ);
a (rewrite_tac[ºâtâ4_dpo_thm, dpo_lubs_exist_thm]);
val ºâtâ4_lubs_exist_thm = save_pop_thm "ºâtâ4_lubs_exist_thm";

set_goal([], ¨CRpoU $ºâtâ4Æ);
a (rewrite_tac [get_spec ¨CRpoUÆ, get_spec ¨CRpoÆ,
	ºâtâ4_glbs_exist_thm, ºâtâ4_lubs_exist_thm, get_spec ¨RpoÆ,
	ºâtâ4_partialorder_thm, get_spec ¨ReflÆ]);
val ºâtâ4_crpou_thm = save_pop_thm "ºâtâ4_crpou_thm";
=TEX
}%ignore

\subsection{Indexed Sets}

In this implementation of indexed sets we use discrete partial orders in the codomain, so that the resulting partial orders are complete.

=SML
declare_type_abbrev("€IS›", ["'a"], îGS ≠ 'a DPOÆ);
=TEX

πHOLCONST
‹ €IsRan› : 'a IS ≠ 'a SET
˜¸¸¸¸¸¸¸¸¸¸¸
‹ µis∑ IsRan is = {v | ∂¡∑ dpoE v = is ¡}
∞

πHOLCONST
‹ €IsDom› : 'a IS ≠ GS SET
˜¸¸¸¸¸¸¸¸¸¸¸
‹ µis∑ IsDom is = {i | ≥ (is i) = dpoB}
∞

πHOLCONST
‹ €IsSDom› : 'a IS ≠ GS SET
˜¸¸¸¸¸¸¸¸¸¸¸
‹ µis∑ IsSDom is = {i | ≥ ((is i) = dpoB ≤ (is i) = dpoT)}
∞

πHOLCONST
‹ €IsOd› : 'a IS ≠ GS SET
˜¸¸¸¸¸¸¸¸¸¸¸
‹ µis∑ IsOd is = {i | is i = dpoT}
∞

πHOLCONST
‹ €IsOverRide› : 'a IS ≠ 'a IS ≠ 'a IS
˜¸¸¸¸¸¸¸¸¸¸¸
‹ µis1 is2∑ IsOverRide is1 is2 =
‹	Ãi∑ if ≥ dpoUdef (is2 i) then is2 i else is2 i 
∞

\subsection{Orders and Pre-orders}

\subsubsection{Derived Orderings}

I don't know a good name for these, but a common way to impose an order on a collection is by defining a function which maps the collection into some collection for which we have a suitable ordering.
Often suitable means well-founded, but in our case it is completeness which is desired.

πHOLCONST
‹ €DerivedOrder› : ('b ≠ 'a) ≠ ('a ≠ 'a ≠ BOOL) ≠ ('b ≠ 'b ≠ BOOL)
˜¸¸¸¸¸¸¸¸¸¸¸
‹ µf r∑ DerivedOrder f r = Ãx y∑ r (f x) (f y)
∞

We require sufficient conditions for the result to be complete.

=GFT
€fi_isub_lemma› =
   Ù µ f r s e∑ IsUb r (FunImage f s) (f e) ¥ IsUb (DerivedOrder f r) s e

€do_isub_lemma› =
   Ù µ f r s x∑ IsUb (DerivedOrder f r) s x ¥ IsUb r (FunImage f s) (f x)

€fi_islub_lemma› =
   Ù µ f r s e
     ∑ IsLub r (FunImage f s) (f e) ¥ IsLub (DerivedOrder f r) s e

€do_lubs_exist_thm› =
   Ù µ f r∑ LubsExist r ± Onto f ¥ LubsExist (DerivedOrder f r)
=TEX
=GFT
€fi_islb_lemma› =
   Ù µ f r s e∑ IsLb r (FunImage f s) (f e) ¥ IsLb (DerivedOrder f r) s e

€do_islb_lemma› =
   Ù µ f r s x∑ IsLb (DerivedOrder f r) s x ¥ IsLb r (FunImage f s) (f x)

€fi_isglb_lemma› =
   Ù µ f r s e∑ IsGlb r (FunImage f s) (f e) ¥ IsGlb (DerivedOrder f r) s e

€do_glbs_exist_thm› =
   Ù µ f r∑ GlbsExist r ± Onto f ¥ GlbsExist (DerivedOrder f r)
=TEX

\ignore{
=SML
set_goal([], ¨µf r s e∑ IsUb r (FunImage f s) (f e) ¥ IsUb (DerivedOrder f r) s eÆ);
a (rewrite_tac (map get_spec [¨OntoÆ, ¨DerivedOrderÆ, ¨IsUbÆ, ¨FunImageÆ])
	THEN REPEAT strip_tac);
a (spec_nth_asm_tac 2 ¨f xÆ);
a (spec_nth_asm_tac 1 ¨xÆ);
val fi_isub_lemma = pop_thm ();

set_goal([], ¨µf r s x∑ IsUb (DerivedOrder f r) s x ¥ IsUb r (FunImage f s) (f x)Æ);
a (rewrite_tac (map get_spec [¨IsUbÆ, ¨DerivedOrderÆ, ¨FunImageÆ]) THEN REPEAT strip_tac);
a (asm_fc_tac[]);
a (POP_ASM_T ante_tac THEN asm_rewrite_tac[]);
val do_isub_lemma = pop_thm ();

set_goal([], ¨µf r s e∑ IsLub r (FunImage f s) (f e) ¥ IsLub (DerivedOrder f r) s e Æ);
a (rewrite_tac (map get_spec [¨OntoÆ, ¨IsLubÆ]) THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a (fc_tac [fi_isub_lemma]);
(* *** Goal "2" *** *)
a (fc_tac [do_isub_lemma]);
a (all_asm_fc_tac[]);
a (rewrite_tac (map get_spec [¨DerivedOrderÆ]) THEN REPEAT strip_tac);
val fi_islub_lemma = pop_thm ();

set_goal([], ¨µf r∑ LubsExist r ± Onto f ¥ LubsExist (DerivedOrder f r)Æ);
a (rewrite_tac (map get_spec [¨OntoÆ, ¨LubsExistÆ]) THEN REPEAT strip_tac);
a (spec_nth_asm_tac 2 ¨FunImage f sÆ);
a (spec_nth_asm_tac 2 ¨eÆ);
a (var_elim_asm_tac ¨e = f xÆ THEN ∂_tac ¨xÆ THEN fc_tac [fi_islub_lemma] THEN asm_rewrite_tac[]);
val do_lubs_exist_thm = save_pop_thm "do_lubs_exist_thm";

set_goal([], ¨µf r s e∑ IsLb r (FunImage f s) (f e) ¥ IsLb (DerivedOrder f r) s eÆ);
a (rewrite_tac (map get_spec [¨OntoÆ, ¨DerivedOrderÆ, ¨IsLbÆ, ¨FunImageÆ])
	THEN REPEAT strip_tac);
a (spec_nth_asm_tac 2 ¨f xÆ);
a (spec_nth_asm_tac 1 ¨xÆ);
val fi_islb_lemma = pop_thm ();

set_goal([], ¨µf r s x∑ IsLb (DerivedOrder f r) s x ¥ IsLb r (FunImage f s) (f x)Æ);
a (rewrite_tac (map get_spec [¨IsLbÆ, ¨DerivedOrderÆ, ¨FunImageÆ]) THEN REPEAT strip_tac);
a (asm_fc_tac[]);
a (POP_ASM_T ante_tac THEN asm_rewrite_tac[]);
val do_islb_lemma = pop_thm ();

set_goal([], ¨µf r s e∑ IsGlb r (FunImage f s) (f e) ¥ IsGlb (DerivedOrder f r) s e Æ);
a (rewrite_tac (map get_spec [¨OntoÆ, ¨IsGlbÆ]) THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a (fc_tac [fi_islb_lemma]);
(* *** Goal "2" *** *)
a (fc_tac [do_islb_lemma]);
a (all_asm_fc_tac[]);
a (rewrite_tac (map get_spec [¨DerivedOrderÆ]) THEN REPEAT strip_tac);
val fi_isglb_lemma = pop_thm ();

set_goal([], ¨µf r∑ GlbsExist r ± Onto f ¥ GlbsExist (DerivedOrder f r)Æ);
a (rewrite_tac (map get_spec [¨OntoÆ, ¨GlbsExistÆ]) THEN REPEAT strip_tac);
a (spec_nth_asm_tac 2 ¨FunImage f sÆ);
a (spec_nth_asm_tac 2 ¨eÆ);
a (var_elim_asm_tac ¨e = f xÆ THEN ∂_tac ¨xÆ THEN fc_tac [fi_isglb_lemma] THEN asm_rewrite_tac[]);
val do_glbs_exist_thm = save_pop_thm "do_glbs_exist_thm";
=TEX
}%ignore

\subsubsection{Projections}

Projections are a special case of derived orderings in which the onto requirement can be taken for granted.

=GFT
€projections_onto_lemma› =
   Ù Onto Fst ± Onto Snd

€lubsexist_dofst_thm› =
   Ù µ f r∑ LubsExist r ¥ LubsExist (DerivedOrder Fst r)

€glbsexist_dofst_thm› =
   Ù µ f r∑ GlbsExist r ¥ GlbsExist (DerivedOrder Fst r)

€lubsexist_dosnd_thm› =
   Ù µ f r∑ LubsExist r ¥ LubsExist (DerivedOrder Snd r)

€glbsexist_dosnd_thm› =
   Ù µ f r∑ GlbsExist r ¥ GlbsExist (DerivedOrder Snd r)
=TEX


\ignore{
=SML
set_goal([], ¨Onto Fst ± Onto SndÆ);
a (rewrite_tac (map get_spec [¨OntoÆ]) THEN REPEAT strip_tac);
a (∂_tac ¨(y, z)Æ THEN rewrite_tac[]);
a (∂_tac ¨(z, y)Æ THEN rewrite_tac[]);
val projections_onto_lemma = pop_thm ();

set_goal([], ¨µf r∑ LubsExist r ¥ LubsExist (DerivedOrder Fst r)Æ);
a (REPEAT strip_tac THEN bc_tac [do_lubs_exist_thm]
	THEN_TRY asm_rewrite_tac[projections_onto_lemma]);
val lubsexist_dofst_thm = save_pop_thm "lubsexist_dofst_thm";

set_goal([], ¨µf r∑ GlbsExist r ¥ GlbsExist (DerivedOrder Fst r)Æ);
a (REPEAT strip_tac THEN bc_tac [do_glbs_exist_thm]
	THEN_TRY asm_rewrite_tac[projections_onto_lemma]);
val glbsexist_dofst_thm = save_pop_thm "glbsexist_dofst_thm";

set_goal([], ¨µf r∑ LubsExist r ¥ LubsExist (DerivedOrder Snd r)Æ);
a (REPEAT strip_tac THEN bc_tac [do_lubs_exist_thm]
	THEN_TRY asm_rewrite_tac[projections_onto_lemma]);
val lubsexist_dosnd_thm = save_pop_thm "lubsexist_dosnd_thm";

set_goal([], ¨µf r∑ GlbsExist r ¥ GlbsExist (DerivedOrder Snd r)Æ);
a (REPEAT strip_tac THEN bc_tac [do_glbs_exist_thm]
	THEN_TRY asm_rewrite_tac[projections_onto_lemma]);
val glbsexist_dosnd_thm = save_pop_thm "glbsexist_dosnd_thm";
=TEX
}%ignore

\subsubsection{Functions}

Most of our orderings are orderings of functions obtained from orderings of truth values by the following operation.

πHOLCONST
‹ €Pw› : ('a ≠ 'a ≠ BOOL) ≠ (('b ≠ 'a) ≠ ('b ≠ 'a) ≠ BOOL)
˜¸¸¸¸¸¸¸¸¸¸¸
‹ µ r∑ Pw r = Ã lo ro∑ µx∑ r (lo x) (ro x)
∞

=GFT
€pw_isub_lemma› =
   Ù µ r G f∑ (µ v∑ IsUb r {w|∂ g∑ g ç G ± w = g v} (f v)) ¥ IsUb (Pw r) G f

€pw_islb_lemma› =
   Ù µ r G f∑ (µ v∑ IsLb r {w|∂ g∑ g ç G ± w = g v} (f v)) ¥ IsLb (Pw r) G f

€pw_islub_lemma› =
   Ù µ r G f
     ∑ (µ v∑ IsLub r {w|∂ g∑ g ç G ± w = g v} (f v)) ¥ IsLub (Pw r) G f

€pw_isglb_lemma› =
   Ù µ r G f
     ∑ (µ v∑ IsGlb r {w|∂ g∑ g ç G ± w = g v} (f v)) ¥ IsGlb (Pw r) G f

€pw_rpo_lemma› =
	Ù µ r∑ Rpo (Universe, r) ¥ Rpo (Universe, Pw r)

€pw_cc_lemma› =
	Ù µ r∑ CcRpo (Universe, r) ¥ ChainComplete (Universe, Pw r)

€pw_ccrpou_thm› =
	Ù µ r∑ CcRpoU r ¥ CcRpoU (Pw r)

€pw_lubs_exist_thm› =
	Ù µ r∑ LubsExist r ¥ LubsExist (Pw r)

€pw_glbs_exist_thm› =
	Ù µ r∑ GlbsExist r ¥ GlbsExist (Pw r)

€pw_crpou_thm› =
	Ù µ r∑ CRpoU r ¥ CRpoU (Pw r)
=TEX

\ignore{
=SML
set_goal([], ¨µr G f∑ (µ v∑ IsUb r {w | ∂g∑ g ç G ± w = g v} (f v))
	¥ IsUb (Pw r) G fÆ);
a (rewrite_tac [get_spec ¨IsUbÆ, get_spec ¨PwÆ] THEN REPEAT strip_tac);
a (list_spec_nth_asm_tac 2 [¨x'Æ, ¨x x'Æ]);
a (spec_nth_asm_tac 1 ¨xÆ);
val pw_isub_lemma = pop_thm ();

set_goal([], ¨µr G f∑ (µ v∑ IsLb r {w | ∂g∑ g ç G ± w = g v} (f v))
	¥ IsLb (Pw r) G fÆ);
a (rewrite_tac [get_spec ¨IsLbÆ, get_spec ¨PwÆ] THEN REPEAT strip_tac);
a (list_spec_nth_asm_tac 2 [¨x'Æ, ¨x x'Æ]);
a (spec_nth_asm_tac 1 ¨xÆ);
val pw_islb_lemma = pop_thm ();

set_goal([], ¨µr G f∑ (µ v∑ IsLub r {w | ∂g∑ g ç G ± w = g v} (f v))
	¥ IsLub (Pw r) G fÆ);
a (REPEAT strip_tac THEN rewrite_tac [get_spec ¨IsLubÆ] THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a (lemma_tac ¨µ v∑ IsUb r {w|∂ g∑ g ç G ± w = g v} (f v)Æ
	THEN1 (POP_ASM_T (strip_asm_tac o (rewrite_rule [get_spec ¨IsLubÆ]))
		THEN asm_rewrite_tac[]));
a (fc_tac [pw_isub_lemma]);
(* *** Goal "2" *** *)
a (rewrite_tac [get_spec ¨PwÆ]
	THEN REPEAT strip_tac);
a (spec_nth_asm_tac 2 ¨x'Æ);
a (fc_tac [get_spec ¨IsLubÆ]);
a (spec_nth_asm_tac 2 ¨x x'Æ);
a (GET_ASM_T ¨IsUb (Pw r) G xÆ ante_tac
	THEN rewrite_tac [get_spec ¨PwÆ]);
a (swap_nth_asm_concl_tac 1);
a (DROP_NTH_ASM_T 6 ante_tac
	THEN rewrite_tac [get_spec ¨PwÆ, get_spec ¨IsUbÆ]
	THEN REPEAT strip_tac);
a (all_asm_fc_tac[]);
a (spec_nth_asm_tac 2 ¨x'Æ
	THEN POP_ASM_T ante_tac
	THEN asm_rewrite_tac[]);
val pw_islub_lemma = pop_thm ();

set_goal([], ¨µr G f∑ (µ v∑ IsGlb r {w | ∂g∑ g ç G ± w = g v} (f v))
	¥ IsGlb (Pw r) G fÆ);
a (REPEAT strip_tac THEN rewrite_tac [get_spec ¨IsGlbÆ] THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a (lemma_tac ¨µ v∑ IsLb r {w|∂ g∑ g ç G ± w = g v} (f v)Æ
	THEN1 (POP_ASM_T (strip_asm_tac o (rewrite_rule [get_spec ¨IsGlbÆ]))
		THEN asm_rewrite_tac[]));
a (fc_tac [pw_islb_lemma]);
(* *** Goal "2" *** *)
a (rewrite_tac [get_spec ¨PwÆ]
	THEN REPEAT strip_tac);
a (spec_nth_asm_tac 2 ¨x'Æ);
a (fc_tac [get_spec ¨IsGlbÆ]);
a (spec_nth_asm_tac 2 ¨x x'Æ);
a (GET_ASM_T ¨IsLb (Pw r) G xÆ ante_tac
	THEN rewrite_tac [get_spec ¨PwÆ]);
a (swap_nth_asm_concl_tac 1);
a (DROP_NTH_ASM_T 6 ante_tac
	THEN rewrite_tac [get_spec ¨PwÆ, get_spec ¨IsLbÆ]
	THEN REPEAT strip_tac);
a (all_asm_fc_tac[]);
a (spec_nth_asm_tac 2 ¨x'Æ
	THEN POP_ASM_T ante_tac
	THEN asm_rewrite_tac[]);
val pw_isglb_lemma = pop_thm ();

set_merge_pcs ["hol1", "'GS1", "'ifol"];

set_goal([], ¨µr∑ Rpo (Universe, r) ¥ Rpo (Universe, Pw r)Æ);
a (REPEAT strip_tac
	THEN fc_tac[rpou_fc_clauses]
	THEN rewrite_tac (map get_spec [¨RpoÆ, ¨PwÆ, ¨PartialOrderÆ, ¨AntisymÆ, ¨TransÆ, ¨ReflÆ])
	THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a (list_spec_nth_asm_tac 3 [¨x x'Æ, ¨y x'Æ]);
(* *** Goal "1.1" *** *)
a (∂_tac ¨x'Æ THEN strip_tac);
a (asm_fc_tac[]);
(* *** Goal "2" *** *)
a (REPEAT_N 2 (spec_nth_asm_tac 2 ¨x'Æ)
	THEN all_asm_fc_tac[]);
(* *** Goal "3" *** *)
a (asm_rewrite_tac[]);
val pw_rpo_lemma = pop_thm ();

set_goal([], ¨µr∑ RpoU r ¥ RpoU (Pw r)Æ);
a (rewrite_tac [get_spec ¨RpoUÆ] THEN REPEAT strip_tac);
a (fc_tac [pw_rpo_lemma]);
val pw_rpou_lemma = pop_thm ();

set_merge_pcs ["hol", "'GS1", "'ifol"];

set_goal([], ¨µr∑ CcRpo (Universe, r) ¥ ChainComplete (Universe, Pw r)Æ);
a (rewrite_tac (map get_spec [¨CcRpoÆ, ¨RpoÆ, ¨PartialOrderÆ, ¨AntisymÆ, ¨ChainCompleteÆ])
	THEN REPEAT strip_tac);
a (lemma_tac ¨µv∑ LinearOrder ({w | ∂f∑ f ç Y ± w = f v}, r)Æ);
(* *** Goal "1" *** *)
a (rewrite_tac (map get_spec [¨LinearOrderÆ, ¨PartialOrderÆ, ¨AntisymÆ, ¨TransÆ, ¨TrichÆ])
	THEN REPEAT strip_tac);
(* *** Goal "1.1" *** *)
a (all_asm_fc_tac[]);
(* *** Goal "1.2" *** *)
a (FC_T (MAP_EVERY (asm_tac o (rewrite_rule[]))) [get_spec ¨TransÆ]);
a (all_asm_fc_tac[]);
(* *** Goal "1.3" *** *)
a (fc_tac [get_spec ¨LinearOrderÆ]);
a (fc_tac [get_spec ¨TrichÆ]);
(* a (POP_ASM_T ante_tac THEN rewrite_tac [get_spec ¨PwÆ]
	THEN REPEAT strip_tac); *)
a (list_spec_nth_asm_tac 1 [¨fÆ, ¨f'Æ]);
(* *** Goal "1.3.1" *** *)
a (DROP_NTH_ASM_T 6 ante_tac THEN asm_rewrite_tac[]);
(* *** Goal "1.1.2" *** *)
a (POP_ASM_T ante_tac THEN rewrite_tac [get_spec ¨PwÆ] THEN strip_tac);
a (spec_nth_asm_tac 1 ¨vÆ);
a (DROP_NTH_ASM_T 6 ante_tac THEN asm_rewrite_tac[]);
(* *** Goal "1.3.3" *** *)
a (POP_ASM_T ante_tac THEN rewrite_tac [get_spec ¨PwÆ] THEN strip_tac);
a (asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a (lemma_tac ¨∂f∑ µv∑ IsLub r {w|∂ f∑ f ç Y ± w = f v} (f v)Æ
	THEN1 prove_∂_tac);
(* *** Goal "2.1" *** *)
a (strip_tac);
a (spec_nth_asm_tac 1 ¨v'Æ);
a (all_asm_fc_tac[]);
a (∂_tac ¨xÆ THEN strip_tac);
(* *** Goal "2.2" *** *)
a (∂_tac ¨fÆ);
a (bc_tac [pw_islub_lemma]);
a (asm_rewrite_tac[]);
val pw_cc_lemma = pop_thm ();

set_goal([], ¨µr∑ CcRpoU r ¥ CcRpoU (Pw r)Æ);
a (REPEAT strip_tac);
a (fc_tac [get_spec ¨CcRpoUÆ]);
a (fc_tac [get_spec ¨CcRpoÆ]);
a (fc_tac [pw_rpo_lemma]);
a (fc_tac [pw_cc_lemma]);
a (asm_rewrite_tac (map get_spec [¨CcRpoUÆ, ¨CcRpoÆ]));
val pw_ccrpou_thm = save_pop_thm "pw_ccrpou_thm";

set_goal([], ¨µr∑ LubsExist r ¥ LubsExist (Pw r)Æ);
a (rewrite_tac [get_spec ¨LubsExistÆ] THEN REPEAT strip_tac);
a (lemma_tac ¨∂f∑ µv∑ IsLub r {w|∂ g∑ g ç s ± w = g v} (f v)Æ
	THEN1 prove_∂_tac);
(* *** Goal "1" *** *)
a (strip_tac);
a (spec_nth_asm_tac 1 ¨{w|∂ g∑ g ç s ± w = g v'}Æ);
a (∂_tac ¨eÆ THEN asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a (fc_tac [pw_islub_lemma]);
a (∂_tac ¨fÆ THEN asm_rewrite_tac[]);
val pw_lubs_exist_thm = save_pop_thm "pw_lubs_exist_thm";

set_goal([], ¨µr∑ GlbsExist r ¥ GlbsExist (Pw r)Æ);
a (rewrite_tac [get_spec ¨GlbsExistÆ] THEN REPEAT strip_tac);
a (lemma_tac ¨∂f∑ µv∑ IsGlb r {w|∂ g∑ g ç s ± w = g v} (f v)Æ
	THEN1 prove_∂_tac);
(* *** Goal "1" *** *)
a (strip_tac);
a (spec_nth_asm_tac 1 ¨{w|∂ g∑ g ç s ± w = g v'}Æ);
a (∂_tac ¨eÆ THEN asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a (fc_tac [pw_isglb_lemma]);
a (∂_tac ¨fÆ THEN asm_rewrite_tac[]);
val pw_glbs_exist_thm = save_pop_thm "pw_glbs_exist_thm";

set_goal([], ¨µr∑ CRpoU r ¥ CRpoU (Pw r)Æ);
a (rewrite_tac (map get_spec [¨CRpoUÆ, ¨CRpoÆ]) THEN REPEAT strip_tac);
a (fc_tac [pw_rpo_lemma]);
a (fc_tac [pw_glbs_exist_thm]);
a (fc_tac [pw_lubs_exist_thm]);
val pw_crpou_thm = save_pop_thm "pw_crpou_thm";
=TEX
}%ignore

\subsubsection{Products}

We also need the following ordering over products.

πHOLCONST
‹ €PrO› : ('a ≠ 'a ≠ BOOL) ≠ ('b ≠ 'b ≠ BOOL) ≠ (('a ∏ 'b) ≠ ('a ∏ 'b) ≠ BOOL)
˜¸¸¸¸¸¸¸¸¸¸¸
‹ µ ra rb∑ PrO ra rb = Ãl r∑ ra (Fst l) (Fst r) ± rb (Snd l) (Snd r)
∞

=GFT
€pro_isub_lemma› =
   Ù µ ra rb s lub rub
     ∑ IsUb ra {w|∂ g∑ g ç s ± w = Fst g} lub
           ± IsUb rb {w|∂ g∑ g ç s ± w = Snd g} rub
         § IsUb (PrO ra rb) s (lub, rub)

€pro_islb_lemma› =
   Ù µ ra rb s llb rlb
     ∑ IsLb ra {w|∂ g∑ g ç s ± w = Fst g} llb
           ± IsLb rb {w|∂ g∑ g ç s ± w = Snd g} rlb
         § IsLb (PrO ra rb) s (llb, rlb)

€pro_islub_lemma› =
   Ù µ ra rb s llub rlub
     ∑ IsLub ra {w|∂ g∑ g ç s ± w = Fst g} llub
           ± IsLub rb {w|∂ g∑ g ç s ± w = Snd g} rlub
         ¥ IsLub (PrO ra rb) s (llub, rlub)

€pro_isglb_lemma› =
   Ù µ ra rb s lglb rglb
     ∑ IsGlb ra {w|∂ g∑ g ç s ± w = Fst g} lglb
           ± IsGlb rb {w|∂ g∑ g ç s ± w = Snd g} rglb
         ¥ IsGlb (PrO ra rb) s (lglb, rglb)

€pro_refl_lemma› =
   Ù µ ra rb
     ∑ Refl (Universe, ra) ± Refl (Universe, rb) ¥ Refl (Universe, PrO ra rb)

€pro_partialorder_lemma› =
   Ù µ ra rb
     ∑ PartialOrder (Universe, ra) ± PartialOrder (Universe, rb)
         ¥ PartialOrder (Universe, PrO ra rb)

€pro_rpo_lemma› =
   Ù µ ra rb
     ∑ Rpo (Universe, ra) ± Rpo (Universe, rb) ¥ Rpo (Universe, PrO ra rb)

€pro_lubs_exist_thm› =
   Ù µ ra rb∑ LubsExist ra ± LubsExist rb ¥ LubsExist (PrO ra rb)

€pro_glbs_exist_thm› =
   Ù µ ra rb∑ GlbsExist ra ± GlbsExist rb ¥ GlbsExist (PrO ra rb)

€pro_crpou_thm› =
   Ù µ ra rb∑ CRpoU ra ± CRpoU rb ¥ CRpoU (PrO ra rb)
=TEX

\ignore{
=SML
set_goal([], ¨µra rb s lub rub ∑
	  IsUb ra {w | ∂g∑ g ç s ± w = Fst g} lub
	± IsUb rb {w | ∂g∑ g ç s ± w = Snd g} rub
	§ IsUb (PrO ra rb) s (lub, rub)Æ);
a (rewrite_tac [get_spec ¨IsUbÆ, get_spec ¨PrOÆ] THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a (list_spec_nth_asm_tac 3 [¨Fst xÆ]);
a (spec_nth_asm_tac 1 ¨xÆ);
(* *** Goal "2" *** *)
a (list_spec_nth_asm_tac 2 [¨Snd xÆ]);
a (spec_nth_asm_tac 1 ¨xÆ);
(* *** Goal "3" *** *)
a (asm_fc_tac [] THEN asm_rewrite_tac[]);
(* *** Goal "4" *** *)
a (asm_fc_tac [] THEN asm_rewrite_tac[]);
val pro_isub_lemma = pop_thm ();

set_goal([], ¨µra rb s llb rlb∑
	  IsLb ra {w | ∂g∑ g ç s ± w = Fst g} llb
	± IsLb rb {w | ∂g∑ g ç s ± w = Snd g} rlb
	§ IsLb (PrO ra rb) s (llb, rlb)Æ);
a (rewrite_tac [get_spec ¨IsLbÆ, get_spec ¨PrOÆ] THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a (list_spec_nth_asm_tac 3 [¨Fst xÆ]);
a (spec_nth_asm_tac 1 ¨xÆ);
(* *** Goal "2" *** *)
a (list_spec_nth_asm_tac 2 [¨Snd xÆ]);
a (spec_nth_asm_tac 1 ¨xÆ);
(* *** Goal "3" *** *)
a (asm_fc_tac [] THEN asm_rewrite_tac[]);
(* *** Goal "4" *** *)
a (asm_fc_tac [] THEN asm_rewrite_tac[]);
val pro_islb_lemma = pop_thm ();

set_goal([], ¨µra rb s llub rlub ∑
	  IsLub ra {w | ∂g∑ g ç s ± w = Fst g} llub
	± IsLub rb {w | ∂g∑ g ç s ± w = Snd g} rlub
	¥ IsLub (PrO ra rb) s (llub, rlub)Æ);
a (rewrite_tac [get_spec ¨IsLubÆ] THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a (all_fc_tac [pro_isub_lemma]);
(* *** Goal "2" *** *)
a (strip_asm_tac (rewrite_rule [] (list_µ_elim [¨raÆ, ¨rbÆ, ¨sÆ, ¨Fst xÆ, ¨Snd xÆ]
	(map_eq_sym_rule pro_isub_lemma))));
a (rewrite_tac [get_spec ¨PrOÆ]);
a (all_asm_fc_tac[] THEN contr_tac);
val pro_islub_lemma = pop_thm ();

set_goal([], ¨µra rb s lglb rglb ∑
	  IsGlb ra {w | ∂g∑ g ç s ± w = Fst g} lglb
	± IsGlb rb {w | ∂g∑ g ç s ± w = Snd g} rglb
	¥ IsGlb (PrO ra rb) s (lglb, rglb)Æ);
a (rewrite_tac [get_spec ¨IsGlbÆ] THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a (all_fc_tac [pro_islb_lemma]);
(* *** Goal "2" *** *)
a (strip_asm_tac (rewrite_rule [] (list_µ_elim [¨raÆ, ¨rbÆ, ¨sÆ, ¨Fst xÆ, ¨Snd xÆ]
	(map_eq_sym_rule pro_islb_lemma))));
a (rewrite_tac [get_spec ¨PrOÆ]);
a (all_asm_fc_tac[] THEN contr_tac);
val pro_isglb_lemma = pop_thm ();

set_goal([], ¨µra rb∑ Refl (Universe, ra) ± Refl (Universe, rb) ¥ Refl (Universe, (PrO ra rb))Æ);
a (rewrite_tac [get_spec ¨ReflÆ, get_spec ¨PrOÆ]
	THEN REPEAT strip_tac
	THEN_TRY asm_rewrite_tac[]);
val pro_refl_lemma = save_pop_thm "pro_refl_lemma";

set_goal([], ¨µra rb∑ PartialOrder (Universe, ra) ± PartialOrder (Universe, rb)
	¥ PartialOrder (Universe, (PrO ra rb))Æ);
a (rewrite_tac [get_spec ¨PartialOrderÆ, get_spec ¨PrOÆ, get_spec ¨AntisymÆ, get_spec ¨TransÆ]
	THEN REPEAT strip_tac
	THEN_TRY asm_rewrite_tac[]);
(* *** Goal "1" *** *)
a (contr_tac THEN all_asm_fc_tac[]);
a (rename_tac[]);
a (lemma_tac ¨≥ (Fst x = Fst y ± Snd x = Snd y)Æ
	THEN1 contr_tac);
a (DROP_NTH_ASM_T 11 ante_tac THEN pure_once_asm_rewrite_tac [prove_rule [] ¨µx∑ x = (Fst x, Snd x)Æ]); 
a (asm_rewrite_tac []); 
(* *** Goal "1.2" *** *)
a (asm_fc_tac[]);
(* *** Goal "1.3" *** *)
a (asm_fc_tac[]);
(* *** Goal "2" *** *)
a (all_asm_fc_tac[]);
(* *** Goal "3" *** *)
a (all_asm_fc_tac[]);
val pro_partialorder_lemma = save_pop_thm "pro_partialorder_lemma";

set_goal([], ¨µra rb∑ Rpo (Universe, ra) ± Rpo (Universe, rb) ¥ Rpo (Universe, (PrO ra rb))Æ);
a (rewrite_tac [get_spec ¨RpoÆ]
	THEN REPEAT strip_tac
	THEN all_fc_tac [pro_refl_lemma, pro_partialorder_lemma]);
val pro_rpo_lemma = save_pop_thm "pro_rpo_lemma";

set_goal([], ¨µra rb∑ LubsExist ra ± LubsExist rb ¥ LubsExist (PrO ra rb)Æ);
a (rewrite_tac [get_spec ¨LubsExistÆ] THEN REPEAT strip_tac);
a (spec_nth_asm_tac 2 ¨{w | ∂ g∑ g ç s ± w = Fst g}Æ);
a (spec_nth_asm_tac 2 ¨{w | ∂ g∑ g ç s ± w = Snd g}Æ);
a (all_fc_tac [pro_islub_lemma]);
a (∂_tac ¨(e, e')Æ THEN asm_rewrite_tac[]);
val pro_lubs_exist_thm = save_pop_thm "pro_lubs_exist_thm";

set_goal([], ¨µra rb∑ GlbsExist ra ± GlbsExist rb ¥ GlbsExist (PrO ra rb)Æ);
a (rewrite_tac [get_spec ¨GlbsExistÆ] THEN REPEAT strip_tac);
a (spec_nth_asm_tac 2 ¨{w | ∂ g∑ g ç s ± w = Fst g}Æ);
a (spec_nth_asm_tac 2 ¨{w | ∂ g∑ g ç s ± w = Snd g}Æ);
a (all_fc_tac [pro_isglb_lemma]);
a (∂_tac ¨(e, e')Æ THEN asm_rewrite_tac[]);
val pro_glbs_exist_thm = save_pop_thm "pro_glbs_exist_thm";

set_goal([], ¨µra rb∑ CRpoU ra ± CRpoU rb ¥ CRpoU (PrO ra rb)Æ);
a (rewrite_tac [get_spec ¨CRpoUÆ, get_spec ¨CRpoÆ]
	THEN REPEAT strip_tac
	THEN all_fc_tac [pro_rpo_lemma, pro_glbs_exist_thm, pro_lubs_exist_thm]);
val pro_crpou_thm = save_pop_thm "pro_crpou_thm";
=TEX
}%ignore

\subsubsection{Discrete Partial Orders}

The things I am calling discrete partial orders come with the ordering of a discrete lattice.
When these are used to construct indexed sets whose elements have some ordering then there will be another ordering which is derived from that ordering.
This is defined for use in defining orderings over indexed sets.

πHOLCONST
‹ €DpoEO› : ('a ≠ 'a ≠ BOOL) ≠ ('a DPO ≠ 'a DPO ≠ BOOL)
˜¸¸¸¸¸¸¸¸¸¸¸
‹ µrl∑ DpoEO rl = Ãl r∑ dpoUdef l ≤ dpoOdef r
‹		≤ ∂le re∑ rl le re ± l = dpoE le ± r = dpoE re
∞

=GFT
€is_isub_lemma› =
   Ù µ r G d
     ∑ IsUb r G d ¥ IsUb (DpoEO r) {w|∂ v∑ v ç G ± w = dpoE v} (dpoE d)

€is_islb_lemma› =
   Ù µ r G d
     ∑ IsLb r G d ¥ IsLb (DpoEO r) {w|∂ v∑ v ç G ± w = dpoE v} (dpoE d)

€is_isub_lemma2› =
   Ù µ r G d
     ∑ IsUb (DpoEO r) G d
         = (d = dpoT
           ≤ G Ä {dpoB} ± d = dpoB
           ≤ (∂ e∑ d = dpoE e ± IsUb r {w|dpoE w ç G} e) ± ≥ dpoT ç G)

€is_islb_lemma2› =
   Ù µ r G d
     ∑ IsLb (DpoEO r) G d
         = (d = dpoB
           ≤ G Ä {dpoT} ± d = dpoT
           ≤ (∂ e∑ d = dpoE e ± IsLb r {w|dpoE w ç G} e) ± ≥ dpoB ç G)

€is_islub_lemma› =
   Ù µ r G d
     ∑ IsLub (DpoEO r) G d
         = ((dpoT ç G ≤ (∂ w∑ dpoE w ç G) ± ≥ (∂ e∑ IsUb r {w|dpoE w ç G} e))
             ± d = dpoT
           ≤ G Ä {dpoB} ± d = dpoB
           ≤ ≥ G Ä {dpoB}
             ± (∂ e∑ d = dpoE e ± IsLub r {w|dpoE w ç G} e)
             ± ≥ dpoT ç G)

€is_isglb_lemma› =
   Ù µ r G d
     ∑ IsGlb (DpoEO r) G d
         = ((dpoB ç G ≤ (∂ w∑ dpoE w ç G) ± ≥ (∂ e∑ IsLb r {w|dpoE w ç G} e))
             ± d = dpoB
           ≤ G Ä {dpoT} ± d = dpoT
           ≤ ≥ G Ä {dpoT}
             ± (∂ e∑ d = dpoE e ± IsGlb r {w|dpoE w ç G} e)
             ± ≥ dpoB ç G)
=TEX

\ignore{
=SML
set_goal([], ¨µr G d∑ IsUb r G d
	¥ IsUb (DpoEO r) {w | ∂v∑ v ç G ± w = dpoE v} (dpoE d)Æ);
a (rewrite_tac [get_spec ¨IsUbÆ, get_spec ¨DpoEOÆ] THEN REPEAT strip_tac);
a (∂_tac ¨vÆ THEN ∂_tac ¨dÆ THEN all_asm_fc_tac [] THEN asm_rewrite_tac[]);
val dpoeo_isub_lemma = pop_thm ();

set_goal([], ¨µr G d∑ IsLb r G d
	¥ IsLb (DpoEO r) {w | ∂v∑ v ç G ± w = dpoE v} (dpoE d)Æ);
a (rewrite_tac [get_spec ¨IsLbÆ, get_spec ¨DpoEOÆ] THEN REPEAT strip_tac);
a (∂_tac ¨dÆ THEN ∂_tac ¨vÆ THEN all_asm_fc_tac [] THEN asm_rewrite_tac[]);
val dpoeo_islb_lemma = pop_thm ();

set_goal([], ¨µr G d∑ IsUb (DpoEO r) G d
	§ d = dpoT
		≤ G Ä {dpoB} ± d = dpoB
		≤ (∂e∑ d = dpoE e ± IsUb r {w | dpoE w ç G} e) ± ≥ dpoT ç GÆ);
a (REPEAT µ_tac);
a (strip_asm_tac (µ_elim ¨dÆ dpo_cases_thm)
	THEN_TRY asm_rewrite_tac[get_spec ¨DpoEOÆ, get_spec ¨IsUbÆ, get_spec ¨dpoUdefÆ]);
(* *** Goal "1" *** *)
a (PC_T1 "hol1" prove_tac[]);
(* *** Goal "2" *** *)
a (REPEAT strip_tac THEN_TRY asm_rewrite_tac[]);
(* *** Goal "2.1" *** *)
a (∂_tac ¨eÆ THEN asm_rewrite_tac[get_spec ¨IsUbÆ]
	THEN REPEAT strip_tac
	THEN asm_fc_tac[]
	THEN asm_rewrite_tac[]);
(* *** Goal "2.2" *** *)
a (spec_nth_asm_tac 1 ¨dpoTÆ);
(* *** Goal "2.3" *** *)
a (strip_asm_tac (µ_elim ¨xÆ dpo_cases_thm));
(* *** Goal "2.3.1" *** *)
a (var_elim_asm_tac ¨x = dpoTÆ);
(* *** Goal "2.3.2" *** *)
a (∂_tac ¨dpoV xÆ THEN ∂_tac ¨eÆ
	THEN asm_rewrite_tac[]);
a (DROP_NTH_ASM_T 5 ante_tac
	THEN rewrite_tac[get_spec ¨IsUbÆ]
	THEN strip_tac);
a (var_elim_asm_tac ¨x = dpoE e''Æ
	THEN asm_fc_tac[]);
a (LEMMA_T ¨e = e'Æ (fn x => asm_rewrite_tac[x]));
a (var_elim_asm_tac ¨d = dpoE eÆ);
val dpoeo_isub_lemma2 = pop_thm ();

set_goal([], ¨µr G d∑ IsLb (DpoEO r) G d
	§ d = dpoB
		≤ G Ä {dpoT} ± d = dpoT
		≤ (∂e∑ d = dpoE e ± IsLb r {w | dpoE w ç G} e) ± ≥ dpoB ç GÆ);
a (REPEAT µ_tac);
a (strip_asm_tac (µ_elim ¨dÆ dpo_cases_thm)
	THEN_TRY asm_rewrite_tac[get_spec ¨DpoEOÆ, get_spec ¨IsLbÆ, get_spec ¨dpoOdefÆ]);
(* *** Goal "1" *** *)
a (PC_T1 "hol1" prove_tac[]);
(* *** Goal "2" *** *)
a (REPEAT strip_tac THEN_TRY asm_rewrite_tac[]);
(* *** Goal "2.1" *** *)
a (∂_tac ¨eÆ THEN asm_rewrite_tac[get_spec ¨IsLbÆ]
	THEN REPEAT strip_tac
	THEN asm_fc_tac[]
	THEN asm_rewrite_tac[]);
(* *** Goal "2.2" *** *)
a (spec_nth_asm_tac 1 ¨dpoBÆ);
(* *** Goal "2.3" *** *)
a (strip_asm_tac (µ_elim ¨xÆ dpo_cases_thm));
(* *** Goal "2.3.1" *** *)
a (var_elim_asm_tac ¨x = dpoBÆ);
(* *** Goal "2.3.2" *** *)
a (∂_tac ¨eÆ THEN ∂_tac ¨dpoV xÆ
	THEN asm_rewrite_tac[]);
a (DROP_NTH_ASM_T 5 ante_tac
	THEN rewrite_tac[get_spec ¨IsLbÆ]
	THEN strip_tac);
a (var_elim_asm_tac ¨x = dpoE e''Æ
	THEN asm_fc_tac[]);
a (LEMMA_T ¨e = e'Æ (fn x => asm_rewrite_tac[x]));
a (var_elim_asm_tac ¨d = dpoE eÆ);
val dpoeo_islb_lemma2 = pop_thm ();

set_goal([], ¨µr G d∑ IsLub (DpoEO r) G d
	§ (dpoT ç G ≤ (∂w∑ dpoE w ç G) ± ≥ (∂e∑ IsUb r {w | dpoE w ç G} e)) ± d = dpoT
		≤ G Ä {dpoB} ± d = dpoB
		≤ ≥ G Ä {dpoB} ± (∂e∑ d = dpoE e ± IsLub r {w | dpoE w ç G} e) ± ≥ dpoT ç GÆ);
a (REPEAT µ_tac);
a (strip_asm_tac (µ_elim ¨dÆ dpo_cases_thm)
	THEN_TRY asm_rewrite_tac[get_spec ¨IsLubÆ, dpoeo_isub_lemma2]);
(* *** Goal "1" *** *)
a (REPEAT strip_tac THEN_TRY asm_rewrite_tac [get_spec ¨DpoEOÆ]);
(* *** Goal "2" *** *)
a (asm_rewrite_tac [get_spec ¨DpoEOÆ]
	THEN REPEAT strip_tac
	THEN_TRY asm_rewrite_tac[]);
(* *** Goal "2.1" *** *)
a (spec_nth_asm_tac 2 ¨dpoBÆ);
a (DROP_NTH_ASM_T 2 ante_tac THEN PC_T "hol1" (REPEAT strip_tac));
a (strip_asm_tac (µ_elim ¨xÆ dpo_cases_thm)
	THEN_TRY asm_rewrite_tac[]);
(* *** Goal "2.1.1" *** *)
a (var_elim_asm_tac ¨x = dpoTÆ);
(* *** Goal "2.1.2" *** *)
a (var_elim_asm_tac ¨x = dpoE eÆ);
a (∂_tac ¨eÆ THEN asm_rewrite_tac[]);
(* *** Goal "2.2" *** *)
a (spec_nth_asm_tac 2 ¨dpoE eÆ
	THEN spec_nth_asm_tac 1 ¨eÆ);
(* *** Goal "2.3" *** *)
a (DROP_ASM_T ¨G Ä {dpoB}Æ ante_tac
	THEN PC_T "hol1" (REPEAT strip_tac)
	THEN asm_fc_tac[]);
(* *** Goal "2.4" *** *)
a (spec_nth_asm_tac 3 ¨dpoV dpoTÆ);
a (POP_ASM_T ante_tac
	THEN rewrite_tac [get_spec ¨IsUbÆ]
	THEN REPEAT strip_tac);
a (DROP_NTH_ASM_T 3 ante_tac
	THEN (PC_T "hol1" (REPEAT strip_tac))
	THEN asm_fc_tac[]);
(* *** Goal "2.5" *** *)
a (asm_fc_tac[]);
(* *** Goal "3" *** *)
a (asm_rewrite_tac [get_spec ¨DpoEOÆ]
	THEN REPEAT strip_tac
	THEN_TRY asm_rewrite_tac[]);
(* *** Goal "3.1" *** *)
a (spec_nth_asm_tac 1 ¨dpoBÆ);
(* *** Goal "3.2" *** *)
a (var_elim_asm_tac ¨d = dpoE e'Æ);
a (var_elim_asm_tac ¨e' = eÆ);
a (∂_tac ¨eÆ THEN asm_rewrite_tac[]);
a (asm_rewrite_tac [get_spec ¨IsLubÆ]
	THEN REPEAT strip_tac);
a (fc_tac [get_spec ¨IsUbÆ]);
(* *** Goal "3.2.1" *** *)
a (spec_nth_asm_tac 4 ¨dpoE xÆ);
(* *** Goal "3.2.1.1" *** *)
a (spec_nth_asm_tac 1 ¨xÆ);
(* *** Goal "3.2.1.2" *** *)
a (spec_nth_asm_tac 1 ¨xÆ);
(* *** Goal "3.2.1.3" *** *)
a (all_var_elim_asm_tac);
(* *** Goal "3.2.2" *** *)
a (spec_nth_asm_tac 4 ¨dpoE xÆ);
(* *** Goal "3.2.2.1" *** *)
a (spec_nth_asm_tac 1 ¨xÆ);
(* *** Goal "3.2.2.2" *** *)
a (spec_nth_asm_tac 1 ¨xÆ);
(* *** Goal "3.2.2.3" *** *)
a (all_var_elim_asm_tac);
(* *** Goal "3.3" *** *)
a (∂_tac ¨e'Æ THEN asm_rewrite_tac[]);
a (fc_tac [get_spec ¨IsLubÆ]);
(* *** Goal "3.4" *** *)
a (POP_ASM_T ante_tac THEN asm_rewrite_tac[]);
(* *** Goal "3.5" *** *)
a (var_elim_asm_tac ¨d = dpoE e'Æ);
a (var_elim_asm_tac ¨e' = eÆ);
a (∂_tac ¨eÆ THEN ∂_tac ¨e''Æ
	THEN asm_rewrite_tac[]);
a (fc_tac [get_spec ¨IsLubÆ]);
a (all_asm_fc_tac[]);
val dpoeo_islub_lemma = pop_thm ();

set_goal([], ¨µr G d∑ IsGlb (DpoEO r) G d
	§ (dpoB ç G ≤ (∂w∑ dpoE w ç G) ± ≥ (∂e∑ IsLb r {w | dpoE w ç G} e)) ± d = dpoB
		≤ G Ä {dpoT} ± d = dpoT
		≤ ≥ G Ä {dpoT} ± (∂e∑ d = dpoE e ± IsGlb r {w | dpoE w ç G} e) ± ≥ dpoB ç GÆ);
a (REPEAT µ_tac);
a (strip_asm_tac (µ_elim ¨dÆ dpo_cases_thm)
	THEN_TRY asm_rewrite_tac[get_spec ¨IsGlbÆ, dpoeo_islb_lemma2]);
(* *** Goal "2" *** *)
set_labelled_goal "2";
a (REPEAT strip_tac THEN_TRY asm_rewrite_tac [get_spec ¨DpoEOÆ]);
(* *** Goal "1" *** *)
a (asm_rewrite_tac [get_spec ¨DpoEOÆ]
	THEN REPEAT strip_tac
	THEN_TRY asm_rewrite_tac[]);
(* *** Goal "2.1" *** *)
a (spec_nth_asm_tac 2 ¨dpoTÆ);
a (DROP_NTH_ASM_T 2 ante_tac THEN PC_T "hol1" (REPEAT strip_tac));
a (strip_asm_tac (µ_elim ¨xÆ dpo_cases_thm)
	THEN_TRY asm_rewrite_tac[]);
(* *** Goal "2.1.1" *** *)
a (var_elim_asm_tac ¨x = dpoBÆ);
(* *** Goal "2.1.2" *** *)
a (var_elim_asm_tac ¨x = dpoE eÆ);
a (∂_tac ¨eÆ THEN asm_rewrite_tac[]);
(* *** Goal "2.2" *** *)
a (spec_nth_asm_tac 2 ¨dpoE eÆ
	THEN spec_nth_asm_tac 1 ¨eÆ);
(* *** Goal "2.3" *** *)
a (DROP_ASM_T ¨G Ä {dpoT}Æ ante_tac
	THEN PC_T "hol1" (REPEAT strip_tac)
	THEN asm_fc_tac[]);
(* *** Goal "2.4" *** *)
a (spec_nth_asm_tac 3 ¨dpoV dpoBÆ);
a (POP_ASM_T ante_tac
	THEN rewrite_tac [get_spec ¨IsLbÆ]
	THEN REPEAT strip_tac);
a (DROP_NTH_ASM_T 3 ante_tac
	THEN (PC_T "hol1" (REPEAT strip_tac))
	THEN asm_fc_tac[]);
(* *** Goal "2.5" *** *)
a (asm_fc_tac[]);
(* *** Goal "3" *** *)
a (asm_rewrite_tac [get_spec ¨DpoEOÆ]
	THEN REPEAT strip_tac
	THEN_TRY asm_rewrite_tac[]);
(* *** Goal "3.1" *** *)
a (spec_nth_asm_tac 1 ¨dpoTÆ);
(* *** Goal "3.2" *** *)
a (var_elim_asm_tac ¨d = dpoE e'Æ);
a (var_elim_asm_tac ¨e' = eÆ);
a (∂_tac ¨eÆ THEN asm_rewrite_tac[]);
a (asm_rewrite_tac [get_spec ¨IsGlbÆ]
	THEN REPEAT strip_tac);
a (fc_tac [get_spec ¨IsLbÆ]);
(* *** Goal "3.2.1" *** *)
a (spec_nth_asm_tac 4 ¨dpoE xÆ);
(* *** Goal "3.2.1.1" *** *)
a (spec_nth_asm_tac 1 ¨xÆ);
(* *** Goal "3.2.1.2" *** *)
a (spec_nth_asm_tac 1 ¨xÆ);
(* *** Goal "3.2.1.3" *** *)
a (all_var_elim_asm_tac);
(* *** Goal "3.2.2" *** *)
a (spec_nth_asm_tac 4 ¨dpoE xÆ);
(* *** Goal "3.2.2.1" *** *)
a (spec_nth_asm_tac 1 ¨xÆ);
(* *** Goal "3.2.2.2" *** *)
a (spec_nth_asm_tac 1 ¨xÆ);
(* *** Goal "3.2.2.3" *** *)
a (all_var_elim_asm_tac);
(* *** Goal "3.3" *** *)
a (∂_tac ¨e'Æ THEN asm_rewrite_tac[]);
a (fc_tac [get_spec ¨IsGlbÆ]);
(* *** Goal "3.4" *** *)
a (POP_ASM_T ante_tac THEN asm_rewrite_tac[]);
(* *** Goal "3.5" *** *)
a (var_elim_asm_tac ¨d = dpoE e'Æ);
a (var_elim_asm_tac ¨e' = eÆ);
a (∂_tac ¨e''Æ THEN ∂_tac ¨eÆ
	THEN asm_rewrite_tac[]);
a (fc_tac [get_spec ¨IsGlbÆ]);
a (all_asm_fc_tac[]);
val dpoeo_isglb_lemma = pop_thm ();

set_goal([], ¨µr∑ LubsExist r ¥ LubsExist (DpoEO r)Æ);
a (rewrite_tac [get_spec ¨LubsExistÆ, dpoeo_islub_lemma] THEN REPEAT strip_tac);
a (∂_tac ¨
	if dpoT ç s
	then dpoT
	else
		if s Ä {dpoB}
		then dpoB
		else dpoE (Lub r {y | dpoE y ç s})Æ);
a (cases_tac ¨dpoT ç sÆ THEN_TRY asm_rewrite_tac[]);
a (cases_tac ¨s Ä {dpoB}Æ THEN_TRY asm_rewrite_tac[]);
a (∂_tac ¨Lub r {y|dpoE y ç s}Æ THEN asm_rewrite_tac []);
a (spec_nth_asm_tac 3 ¨{w|dpoE w ç s}Æ);
a (all_fc_tac[lub_lub_lemma]);
val dpoeo_lubs_exist_thm = save_pop_thm "dpoeo_lubs_exist_thm";

set_goal([], ¨µr∑ GlbsExist r ¥ GlbsExist (DpoEO r)Æ);
a (rewrite_tac [get_spec ¨GlbsExistÆ, dpoeo_isglb_lemma] THEN REPEAT strip_tac);
a (∂_tac ¨
	if dpoB ç s
	then dpoB
	else
		if s Ä {dpoT}
		then dpoT
		else dpoE (Glb r {y | dpoE y ç s})Æ);
a (cases_tac ¨dpoB ç sÆ THEN_TRY asm_rewrite_tac[]);
a (cases_tac ¨s Ä {dpoT}Æ THEN_TRY asm_rewrite_tac[]);
a (∂_tac ¨Glb r {y|dpoE y ç s}Æ THEN asm_rewrite_tac []);
a (spec_nth_asm_tac 3 ¨{w | dpoE w ç s}Æ);
a (all_fc_tac[glb_glb_lemma]);
val dpoeo_glbs_exist_thm = save_pop_thm "dpoeo_glbs_exist_thm";
=TEX
}%ignore

\subsubsection{Indexed Sets}

Indexed sets are functions whose codomain is a discrete partial order.
From any ordering of the codomain an ordering of the indexed sets may be obtained using {\it Pw}.
This can be done with the discrete order, but we also need to do this with other orders.

The following function lifts an ordering on the elements of the codomain to an ordering on the indexed sets.

πHOLCONST
‹ €IsEO› : ('a ≠ 'a ≠ BOOL) ≠ ('a IS ≠ 'a IS ≠ BOOL)
˜¸¸¸¸¸¸¸¸¸¸¸
‹ µr∑ IsEO r = Pw (DpoEO r)
∞

=GFT
€is_lubs_exist_thm› =
	Ù µ r∑ LubsExist r ¥ LubsExist (IsEO r)

€is_glbs_exist_thm› =
	Ù µ r∑ GlbsExist r ¥ GlbsExist (IsEO r)
=TEX

\ignore{
=SML
set_goal([], ¨µr∑ LubsExist r ¥ LubsExist (IsEO r)Æ);
a (REPEAT strip_tac
	THEN rewrite_tac [get_spec ¨IsEOÆ]
	THEN fc_tac [dpoeo_lubs_exist_thm]
	THEN fc_tac [inst_type_rule [(îGSÆ, î'aÆ)] pw_lubs_exist_thm]
	THEN strip_tac);
val is_lubs_exist_thm = save_pop_thm "is_lubs_exist_thm";

set_goal([], ¨µr∑ GlbsExist r ¥ GlbsExist (IsEO r)Æ);
a (REPEAT strip_tac
	THEN rewrite_tac [get_spec ¨IsEOÆ]
	THEN fc_tac [dpoeo_glbs_exist_thm]
	THEN fc_tac [inst_type_rule [(îGSÆ, î'aÆ)] pw_glbs_exist_thm]
	THEN strip_tac);
val is_glbs_exist_thm = save_pop_thm "is_glbs_exist_thm";
=TEX
}%ignore

\subsubsection{A Pre-order on Sets}

The following pre-order on sets based on a pre-order of the elements is used later with sets of truth values.

πHOLCONST
‹ €SetO› : ('a ≠ 'a ≠ BOOL) ≠ ('a SET) ≠ ('a SET) ≠ BOOL
˜¸¸¸¸¸¸¸¸¸¸¸
‹ µ r∑ SetO r = Ãm n∑
‹		(µx∑ x ç m ¥ ∂y∑ y ç n ± r x y)
‹	±	(µy∑ y ç n ¥ ∂x∑ x ç m ± r x y)
∞

That turns out to be stronger than we need, this one simplifies matters.

πHOLCONST
‹ €SetO2› : ('a ≠ 'a ≠ BOOL) ≠ ('a SET) ≠ ('a SET) ≠ BOOL
˜¸¸¸¸¸¸¸¸¸¸¸
‹ µ r∑ SetO2 r = Ãm n∑ µx∑ x ç m ¥ ∂y∑ r x y ± y ç n
∞

=GFT
€trans_seto_lemma› =
	Ù µ r∑ Trans (Universe, r) ¥ Trans (Universe, SetO r)

€trans_seto2_lemma› =
   Ù µ r∑ Trans (Universe, r) ¥ Trans (Universe, SetO2 r)
=TEX

\ignore{
=SML
set_goal([], ¨µr∑ Trans (Universe, r) ¥ Trans (Universe, SetO r)Æ);
a (rewrite_tac [get_spec ¨TransÆ, get_spec ¨SetOÆ] THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a (all_asm_fc_tac[]);
a (all_asm_fc_tac[]);
a (all_asm_fc_tac[]);
a (∂_tac ¨y''Æ THEN asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a (all_asm_fc_tac[]);
a (all_asm_fc_tac[]);
a (all_asm_fc_tac[]);
a (∂_tac ¨x''Æ THEN asm_rewrite_tac[]);
val trans_seto_lemma = pop_thm ();

set_goal([], ¨µr∑ Trans (Universe, r) ¥ Trans (Universe, SetO2 r)Æ);
a (rewrite_tac [get_spec ¨TransÆ, get_spec ¨SetO2Æ] THEN REPEAT strip_tac);
a (all_asm_fc_tac[]);
a (all_asm_fc_tac[]);
a (all_asm_fc_tac[]);
a (∂_tac ¨y''Æ THEN asm_rewrite_tac[]);
val trans_seto2_lemma = pop_thm ();
=TEX
}%ignore

\subsubsection{A Pre-order for Sets of Functions}

To get a pre-order over sets of functions from an pre-order of the codomain of the functions, we could apply {\it Pw} and then {\it SetO}, however the following construction proves more useful.

[Though I don't appear to have used it!]

πHOLCONST
‹ €FunSetO› : ('a ≠ 'a ≠ BOOL) ≠ ('b ≠ 'a) SET ≠ ('b ≠ 'a) SET ≠ BOOL
˜¸¸¸¸¸¸¸¸¸¸¸
‹ µ r:('a ≠ 'a ≠ BOOL)∑ FunSetO r =
‹	Ãs t∑ Pw (SetO r) (Ãx∑ {v | ∂y∑ y ç s ± v = y x}) (Ãx∑ {v | ∂y∑ y ç t ± v = y x})
∞

=IGN
€trans_funseto_lemma› =
	µ r∑ Trans (Universe, r) ¥ Trans (Universe, FunSetO r)
=TEX

\ignore{
=IGN
set_goal([], ¨µr∑ Trans (Universe, r) ¥ Trans (Universe, FunSetO r)Æ);
a (rewrite_tac [get_spec ¨FunSetOÆ] THEN REPEAT strip_tac);
a (fc_tac [trans_seto_lemma]);
a (fc_tac [trans_seto_lemma]);
 THEN POP_ASM_T ante_tac
	THEN rewrite_tac [get_spec ¨TransÆ]);
	THEN REPEAT strip_tac
	THEN all_asm_ufc_tac[]
	THEN asm_rewrite_tac[]);
val trans_funseto_lemma = pop_thm ();
=TEX
}%ignore

\subsection{Some Theorems}

Monotonicity of Lub.

=GFT
€lub_increasing_lemma› =
	Ù µ r∑ RpoU r ± LubsExist r ¥ Increasing (SetO r) r (Lub r)

€lub_increasing2_lemma› =
	Ù µ r∑ RpoU r ± LubsExist r ¥ Increasing (SetO2 r) r (Lub r)

€lub_increasing_lemma2› =
	Ù µ r∑ CRpoU r ¥ Increasing (SetO r) r (Lub r)

€lub_increasing2_lemma2› =
	Ù µ r∑ CRpoU r ¥ Increasing (SetO2 r) r (Lub r)

€lub_increasing_lemma3› =
	Ù µ r∑ CRpoU r ¥ (µ x y∑ SetO r x y ¥ r (Lub r x) (Lub r y))

€lub_increasing2_lemma3› =
   Ù µ r∑ CRpoU r ¥ (µ x y∑ SetO2 r x y ¥ r (Lub r x) (Lub r y))
=TEX

\ignore{
=SML
set_goal([], ¨µr∑ RpoU r ± LubsExist r ¥ Increasing (SetO r) r (Lub r)Æ);
a (rewrite_tac (map get_spec [¨IncreasingÆ])
	THEN REPEAT strip_tac);
a (fc_tac [lub_lub_lemma2]);
a (spec_nth_asm_tac 1 ¨xÆ
	THEN spec_nth_asm_tac 2 ¨yÆ
	THEN fc_tac [get_spec ¨IsLubÆ]);
a (rename_tac[]);
a (lemma_tac ¨IsUb r x (Lub r y)Æ);
(* *** Goal "1" *** *)
a (DROP_ASM_T ¨SetO r x yÆ ante_tac THEN rewrite_tac [get_spec ¨SetOÆ]
	THEN strip_tac);
a (rewrite_tac [get_spec ¨IsUbÆ] THEN REPEAT strip_tac);
a (asm_fc_tac[]);
a (GET_NTH_ASM_T 8 ante_tac THEN rewrite_tac [get_spec ¨IsUbÆ] THEN REPEAT strip_tac);
a (asm_fc_tac[]);
a (fc_tac [rpou_fc_clauses2] THEN all_asm_fc_tac[]);
(* *** Goal "2" *** *)
a (asm_fc_tac[]);
val lub_increasing_lemma = save_pop_thm "lub_increasing_lemma";

set_goal([], ¨µr∑ RpoU r ± LubsExist r ¥ Increasing (SetO2 r) r (Lub r)Æ);
a (rewrite_tac (map get_spec [¨IncreasingÆ])
	THEN REPEAT strip_tac);
a (fc_tac [lub_lub_lemma2]);
a (spec_nth_asm_tac 1 ¨xÆ
	THEN spec_nth_asm_tac 2 ¨yÆ
	THEN fc_tac [get_spec ¨IsLubÆ]);
a (lemma_tac ¨IsUb r x (Lub r y)Æ);
(* *** Goal "1" *** *)
a (DROP_ASM_T ¨SetO2 r x yÆ ante_tac THEN rewrite_tac [get_spec ¨SetO2Æ]
	THEN strip_tac);
a (rewrite_tac [get_spec ¨IsUbÆ] THEN REPEAT strip_tac);
a (asm_fc_tac[]);
a (GET_NTH_ASM_T 7 ante_tac THEN rewrite_tac [get_spec ¨IsUbÆ] THEN REPEAT strip_tac);
a (asm_fc_tac[]);
a (fc_tac [rpou_fc_clauses2] THEN all_asm_fc_tac[]);
(* *** Goal "2" *** *)
a (asm_fc_tac[]);
val lub_increasing2_lemma = save_pop_thm "lub_increasing2_lemma";

set_goal([], ¨µ r∑ CRpoU r ¥ Increasing (SetO r) r (Lub r)Æ);
a (rewrite_tac [get_spec ¨CRpoUÆ, get_spec ¨CRpoÆ]
	THEN REPEAT strip_tac);
a (all_fc_tac [rewrite_rule [get_spec ¨RpoUÆ] lub_increasing_lemma]);
val lub_increasing_lemma2 = save_pop_thm "lub_increasing_lemma2";

set_goal([], ¨µ r∑ CRpoU r ¥ Increasing (SetO2 r) r (Lub r)Æ);
a (rewrite_tac [get_spec ¨CRpoUÆ, get_spec ¨CRpoÆ]
	THEN REPEAT strip_tac);
a (all_fc_tac [rewrite_rule [get_spec ¨RpoUÆ] lub_increasing2_lemma]);
val lub_increasing2_lemma2 = save_pop_thm "lub_increasing2_lemma2";

val lub_increasing_lemma3 = save_thm("lub_increasing_lemma3",
	rewrite_rule [get_spec¨IncreasingÆ] lub_increasing_lemma2);

val lub_increasing2_lemma3 = save_thm("lub_increasing2_lemma3",
	rewrite_rule [get_spec¨IncreasingÆ] lub_increasing2_lemma2);
=TEX
}%ignore

We now define the product of two functions:

πHOLCONST
‹ €FunProd› : ('a ≠ 'b) ≠ ('a ≠ 'c) ≠ ('a ≠ 'b ∏ 'c)
˜¸¸¸¸¸¸¸¸¸¸¸
‹ µ f g∑ FunProd f g = Ãx∑ (f x, g x)
∞

And prove that the product of two increasing functions is increasing.

=GFT
€funprod_increasing_thm› =
   Ù µ f g ra rb rc
     ∑ Increasing ra rb f ± Increasing ra rc g
         ¥ Increasing ra (PrO rb rc) (FunProd f g)
=TEX

\ignore{
=SML
set_goal([], ¨µf g ra rb rc∑ Increasing ra rb f ± Increasing ra rc g
	¥ Increasing ra (PrO rb rc) (FunProd f g)Æ);
a (rewrite_tac [get_spec ¨IncreasingÆ, get_spec ¨PrOÆ, get_spec ¨FunProdÆ]
	THEN REPEAT strip_tac
	THEN asm_fc_tac[]);
val funprod_increasing_thm = save_pop_thm "funprod_increasing_thm";
=TEX
}%ignore

πHOLCONST
‹ €FunLeft› : ('a ∏ 'c ≠ 'b) ≠ ('a ∏ 'c ≠ 'b ∏ 'c)
˜¸¸¸¸¸¸¸¸¸¸¸
‹ µ f∑ FunLeft f = Ãx∑ (f x, Snd x)
∞

πHOLCONST
‹ €FunRight› : ('c ∏ 'a ≠ 'b) ≠ ('c ∏ 'a ≠ 'c ∏ 'b)
˜¸¸¸¸¸¸¸¸¸¸¸
‹ µ f∑ FunRight f = Ãx∑ (Fst x, f x)
∞

=GFT
€funleft_increasing_thm› =
   Ù µ f ra rb rc
     ∑ Increasing (PrO ra rc) rb f
         ¥ Increasing (PrO ra rc) (PrO rb rc) (FunLeft f)

€funright_increasing_thm› =
   Ù µ f ra rb rc
     ∑ Increasing (PrO rc ra) rb f
         ¥ Increasing (PrO rc ra) (PrO rc rb) (FunRight f)
=TEX

\ignore{
=SML
set_goal([], ¨µf ra rb rc∑ Increasing (PrO ra rc) rb f
	¥ Increasing (PrO ra rc) (PrO rb rc) (FunLeft f)Æ);
a (rewrite_tac [get_spec ¨IncreasingÆ, get_spec ¨PrOÆ, get_spec ¨FunLeftÆ]
	THEN REPEAT strip_tac
	THEN asm_fc_tac[]);
val funleft_increasing_thm = save_pop_thm "funleft_increasing_thm";

set_goal([], ¨µf ra rb rc∑ Increasing (PrO rc ra) rb f
	¥ Increasing (PrO rc ra) (PrO rc rb) (FunRight f)Æ);
a (rewrite_tac [get_spec ¨IncreasingÆ, get_spec ¨PrOÆ, get_spec ¨FunRightÆ]
	THEN REPEAT strip_tac
	THEN asm_fc_tac[]);
val funright_increasing_thm = save_pop_thm "funright_increasing_thm";
=TEX
}%ignore

\newpage
\section{INFINITARY LOGIC}
\subsection{Syntax}

\subsubsection{Constructors, Discriminators and Destructors}

Preliminary to presenting the inductive definition of the required classes we define the nuts and bolts operations on the required syntactic entities (some of which will be used in the inductive definition).

A constructor puts together some syntactic entity from its constituents, discriminators distinguist between the different kinds of entity and destructors take them apart.

``Atomic'' formulae consist of a relation name together with an indexed collection of arguments.
The relation name may be any set.
The indexed set of arguments is any set which is a function, i.e. a many-one relation represented as a set of (Wiener-Kuratovski) ordered pairs.
The distinction between atomic and compound formulae is made by tagging the former with the ordinal zero and the latter with the ordinal 1, a tagged value in this  case being an ordered pair of which the left element is the tag and the right element is the value.

πHOLCONST
‹ €MkAf› : GS ∏ GS ≠ GS
˜¸¸¸¸¸¸¸¸¸¸¸
‹ µlr∑ MkAf lr = (Natâg 0) Ìâg ((Fst lr) Ìâg (Snd lr))
∞

πHOLCONST
‹ €IsAf› : GS ≠ BOOL
˜¸¸¸¸¸¸¸¸¸¸¸
‹    µt∑ IsAf t = fst t = (Natâg 0)
∞

πHOLCONST
‹ €AfRel› : GS ≠ GS
˜¸¸¸¸¸¸¸¸¸¸¸
‹  AfRel = Ãx∑ fst(snd x)
∞

πHOLCONST
‹ €AfPars› : GS ≠ GS
˜¸¸¸¸¸¸¸¸¸¸¸
‹  AfPars = Ãx∑ snd(snd x)
∞

πHOLCONST
‹ €MkCf› : GS ∏ GS ≠ GS
˜¸¸¸¸¸¸¸¸¸¸¸
‹ µvc∑ MkCf vc = (Natâg 1) Ìâg ((Fst vc) Ìâg (Snd vc))
∞

πHOLCONST
‹ €IsCf› : GS ≠ BOOL
˜¸¸¸¸¸¸¸¸¸¸¸
‹    µt∑ IsCf t = fst t = (Natâg 1)
∞

πHOLCONST
‹ €CfVars› : GS ≠ GS
˜¸¸¸¸¸¸¸¸¸¸¸
‹  CfVars = Ãx∑ fst(snd x)
∞

πHOLCONST
‹ €CfForms› : GS ≠ GS
˜¸¸¸¸¸¸¸¸¸¸¸
‹  CfForms = Ãx∑ snd(snd x)
∞

=GFT
€Is_clauses› =
   Ù (µ x∑ IsAf (MkAf x))
       ± (µ x∑ ≥ IsAf (MkCf x))
       ± (µ x∑ ≥ IsCf (MkAf x))
       ± (µ x∑ IsCf (MkCf x))

€Is_not_fc_clauses› =
   Ù (µ x∑ IsAf x ¥ ≥ IsCf x) ± (µ x∑ IsCf x ¥ ≥ IsAf x)
=TEX

\ignore{
=SML
set_goal([], ¨(µx∑ IsAf (MkAf x))
	± (µx∑ ≥ IsAf (MkCf x))
	± (µx∑ ≥ IsCf (MkAf x))
	± (µx∑ IsCf (MkCf x))
	Æ);
a (rewrite_tac [get_spec ¨IsAfÆ,
	get_spec ¨MkAfÆ,
	get_spec ¨IsCfÆ,
	get_spec ¨MkCfÆ]);
a (contr_tac THEN FC_T (MAP_EVERY ante_tac) [natg_one_one_thm] 
	THEN PC_T1 "lin_arith" prove_tac[]);
val Is_clauses = pop_thm();

add_pc_thms "'ifol" (map get_spec [] @ [ord_nat_thm, Is_clauses]);
set_merge_pcs ["hol1", "'GS1", "'ifol"];

set_goal ([], ¨
	(µx∑ IsAf x ¥ ≥ IsCf x)
±	(µx∑ IsCf x ¥ ≥ IsAf x)
Æ);
a (rewrite_tac (map get_spec [¨IsAfÆ, ¨IsCfÆ]));
a (REPEAT strip_tac THEN asm_rewrite_tac[]
	THEN contr_tac THEN FC_T (MAP_EVERY ante_tac) [natg_one_one_thm]
	THEN PC_T1 "lin_arith" rewrite_tac[]);
val Is_not_fc_clauses = save_pop_thm "Is_not_fc_clauses";
=TEX

}%ignore

Some derived syntax:

πHOLCONST
‹ €MkNot› : GS ≠ GS
˜¸¸¸¸¸¸¸¸¸¸¸
‹ µf∑ MkNot f = MkCf (öâg, Pair f f)
∞

\subsubsection{The Inductive Definition of Syntax}

This is accomplished by defining the required closure condition (closure under the above constructors for arguments of the right kind) and then taking the intersection of all sets which satisfy the closure condition.

The closure condition is:

πHOLCONST
‹ €RepClosed›: GS SET ≠ BOOL
˜¸¸¸¸¸¸¸¸¸¸¸
‹ µ s∑ RepClosed s §
‹	(µ n is∑ fun is ¥ MkAf (n, is) ç s)
‹±	(µ vars fs∑ Xâg fs Ä s ¥ MkCf (vars, fs) ç s)
∞

The well-formed syntax is then the smallest set closed under these constructions.

πHOLCONST
‹ €Syntax› : GS SET
˜¸¸¸¸¸¸¸¸¸¸¸
‹ Syntax = •{x | RepClosed x}
∞

=GFT
€syntax_Ä_repclosed_thm› =
	Ù µ s∑ RepClosed s ¥ Syntax Ä s
=TEX

\ignore{
=SML
set_goal([], ¨µs∑ RepClosed s ¥ Syntax Ä sÆ);
a (rewrite_tac [get_spec ¨SyntaxÆ]
	THEN REPEAT strip_tac THEN asm_fc_tac[]);
val syntax_Ä_repclosed_thm = pop_thm ();
=TEX
}%ignore

This is an ``inductive datatype'' so we should expect the usual kinds of theorems.

Informally these should say:

\begin{itemize}
\item Syntax is closed under the two constructors.
\item The syntax constructors are injections, have disjoint ranges, and partition the syntax. 
\item Any syntactic property which is preserved by the constructors (i.e. is true of any construction if it is true of all its syntactic constituents) is true of everything in syntax (this is an induction principle).
\end{itemize}

=GFT
€repclosed_syntax_lemma› =
	Ù RepClosed Syntax

€repclosed_syntax_thm› =
	Ù (µ n is∑ fun is ¥ MkAf (n, is) ç Syntax)
       ± (µ vars fs
       ∑ (µ x∑ x ç Xâg fs ¥ x ç Syntax) ¥ MkCf (vars, fs) ç Syntax)

€repclosed_syntax_lemma1› =
	Ù µ s∑ RepClosed s ¥ Syntax Ä s

€repclosed_syntax_lemma2› =
	Ù µ p∑ RepClosed {x|p x} ¥ (µ x∑ x ç Syntax ¥ p x)
=TEX

\ignore{
=SML
set_goal([], ¨RepClosed SyntaxÆ);
a (rewrite_tac (map get_spec [¨RepClosedÆ])
	THEN strip_tac);
(* *** Goal "1" *** *)
a (rewrite_tac (map get_spec [¨RepClosedÆ, ¨SyntaxÆ])
	THEN REPEAT strip_tac THEN asm_fc_tac [] THEN asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a (rewrite_tac (map get_spec [ ¨SyntaxÆ])
	THEN REPEAT strip_tac
	THEN all_asm_fc_tac[]);
a (fc_tac [get_spec ¨RepClosedÆ]);
a (lemma_tac ¨µ x∑ x ç Xâg fs ¥ x ç sÆ
	THEN1 (REPEAT strip_tac THEN all_asm_fc_tac[]));
a (all_asm_fc_tac[]);
a (asm_rewrite_tac[]);
val repclosed_syntax_lemma = pop_thm ();

val repclosed_syntax_thm = save_thm ("repclosed_syntax_thm",
	rewrite_rule [get_spec ¨RepClosedÆ] repclosed_syntax_lemma);

set_goal([], ¨µs∑ RepClosed s ¥ Syntax Ä sÆ);
a (rewrite_tac [get_spec ¨SyntaxÆ]
	THEN prove_tac[]);
val repclosed_syntax_lemma1 = save_pop_thm "repclosed_syntax_lemma1";

set_goal([], ¨µp∑ RepClosed {x | p x} ¥ µx∑ x ç Syntax ¥ p xÆ);
a (rewrite_tac [get_spec ¨SyntaxÆ] THEN REPEAT strip_tac);
a (asm_fc_tac[]);
val repclosed_syntax_lemma2 = save_pop_thm "repclosed_syntax_lemma2";
=TEX
}%ignore

We need to be able to define functions by recursion over this syntax.
To do that we need to prove that the syntax of comprehensions is well-founded.
This is itself equivalent to an induction principle, so we can try and derive it using the induction principles already available.

We must first define the relation of priority over the syntax, i.e. the relation between an element of the syntax and its constitutents.

πHOLCONST
‹ €ScPrec› : GS REL
˜¸¸¸¸¸¸¸¸¸¸¸
‹ µ¡ «∑ ScPrec ¡ « §
‹	∂ord fs∑ ¡ çâg fs ± {¡; «} Ä Syntax ± « = MkCf (ord, fs)
∞

=GFT
€ScPrec_tc_ç_thm› =
	Ù µ x y∑ ScPrec x y ¥ tc $çâg x y

€well_founded_ScPrec_thm› =
	Ù well_founded ScPrec

€well_founded_tcScPrec_thm› =
	Ù well_founded (tc ScPrec)
=TEX

\ignore{
=SML
set_goal([], ¨µx y∑ ScPrec x y ¥ tc $çâg x yÆ);
a (rewrite_tac (map get_spec [¨ScPrecÆ, ¨MkCfÆ]));
a (REPEAT strip_tac THEN asm_rewrite_tac [Ì_tc_thm]);
a (lemma_tac ¨tc $çâg fs (ord Ìâg fs) ± tc $çâg (ord Ìâg fs) (Natâg 1 Ìâg ord Ìâg fs)Æ
	THEN1 rewrite_tac [Ì_tc_thm]);
a (all_fc_tac [tc_incr_thm]);
a (all_fc_tac [tran_tc_thm2]);
a (all_fc_tac [tran_tc_thm2]);
val ScPrec_tc_ç_thm = pop_thm ();

set_goal ([], ¨well_founded ScPrecÆ);
a (rewrite_tac [get_spec ¨well_foundedÆ]);
a (REPEAT strip_tac);
a (asm_tac (µ_elim ¨sÆ gs_cv_ind_thm));
a (lemma_tac ¨µ x∑ (µ y∑ tc $çâg y x ¥ s y) ¥ s xÆ
	THEN1 REPEAT strip_tac);
(* *** Goal "1" *** *)
a (lemma_tac ¨µ y∑ ScPrec y x ¥ s yÆ
	THEN1 (REPEAT strip_tac THEN all_fc_tac [ScPrec_tc_ç_thm]
		THEN asm_fc_tac []));
a (asm_fc_tac[]);
(* *** Goal "2" *** *)
a (asm_fc_tac[]);
a (asm_rewrite_tac[]);
val well_founded_ScPrec_thm =  save_pop_thm "well_founded_ScPrec_thm";

set_goal([], ¨well_founded (tc ScPrec)Æ);
a (asm_tac well_founded_ScPrec_thm);
a (fc_tac [wf_tc_wf_thm]);
val well_founded_tcScPrec_thm = save_pop_thm ("well_founded_tcScPrec_thm");
=TEX

}%ignore

=SML
val €SC_INDUCTION_T› = WF_INDUCTION_T well_founded_ScPrec_thm;
val €sc_induction_tac› = wf_induction_tac well_founded_ScPrec_thm;
=TEX

The set Syntax gives us the syntactically well-formed phrases of our language.
It will be useful to have some predicates which incorporate well-formedness, which are defined here.

=GFT
€syntax_disj_thm› =
   Ù µ x
     ∑ x ç Syntax
         ¥ (∂ r pars∑ fun pars ± x = MkAf (r, pars))
           ≤ (∂ vars fs∑ (µ y∑ y çâg fs ¥ y ç Syntax) ± x = MkCf (vars, fs))

€syntax_cases_thm› =
   Ù µ x∑ x ç Syntax ¥ IsAf x ≤ IsCf x

€is_fc_clauses› =
   Ù µ x
     ∑ x ç Syntax
         ¥ (IsAf x ¥ (∂ r pars∑ fun pars ± x = MkAf (r, pars)))
           ± (IsCf x
             ¥ (∂ vars fs
             ∑ (µ y∑ y çâg fs ¥ y ç Syntax) ± x = MkCf (vars, fs)))

€syn_proj_clauses› =
    Ù (µ l r∑ AfRel (MkAf (l, r)) = l)
       ± (µ l r∑ AfPars (MkAf (l, r)) = r)
       ± (µ v f∑ CfVars (MkCf (v, f)) = v)
       ± (µ v f∑ CfForms (MkCf (v, f)) = f)

€is_fc_clauses2› =
   Ù µ x∑ x ç Syntax ¥ IsCf x ¥ (µ y∑ y çâg CfForms x ¥ y ç Syntax)

€stn_con_neq_clauses› =
   Ù µ x y∑ ≥ MkAf x = MkCf y

€syn_comp_fc_clauses› =
   Ù µ v f∑ MkCf (v, f) ç Syntax ¥ (µ y∑ y çâg f ¥ y ç Syntax)

€scprec_fc_clauses› =
   Ù µ ¡ « vars fs∑ « ç Syntax ¥ « = MkCf (vars, fs) ± ¡ çâg fs ¥ ScPrec ¡ «

€scprec_fc_clauses2› =
   Ù µ t∑ t ç Syntax ¥ IsCf t ¥ (µ f∑ f çâg CfForms t ¥ ScPrec f t)
=TEX

\ignore{
=SML
set_goal([], ¨µx∑	x ç Syntax
¥	(∂r pars∑ fun pars ± x = MkAf (r,pars))
  ≤	(∂vars fs∑ (µy∑ y çâg fs ¥ y ç Syntax) ± x = MkCf (vars, fs))
Æ);
a (contr_tac);
a (lemma_tac ¨RepClosed (Syntax \ {x})Æ
	THEN1 (rewrite_tac [get_spec ¨RepClosedÆ]
		THEN strip_tac));
(* *** Goal "1" *** *)
a (strip_tac THEN strip_tac THEN strip_tac
	THEN all_fc_tac [repclosed_syntax_thm]
	THEN_TRY asm_rewrite_tac[]);
a (spec_nth_asm_tac 4 ¨nÆ);
a (spec_nth_asm_tac 1 ¨isÆ THEN1 asm_fc_tac[]);
a (swap_nth_asm_concl_tac 1 THEN (SYM_ASMS_T rewrite_tac));
(* *** Goal "2" *** *)
a (REPEAT_N 3 strip_tac);
a (spec_nth_asm_tac 2 ¨varsÆ);
a (DROP_NTH_ASM_T 2 ante_tac THEN rewrite_tac [get_spec ¨XâgÆ]
	THEN strip_tac);
a (lemma_tac ¨µ y∑ y çâg fs ¥ y ç SyntaxÆ
	THEN1 (REPEAT strip_tac THEN all_asm_fc_tac[]));
a (all_fc_tac [rewrite_rule [get_spec ¨XâgÆ] repclosed_syntax_thm]);
a (asm_rewrite_tac[]);
a (spec_nth_asm_tac 4 ¨fsÆ);
(* *** Goal "2.1" *** *)
a (asm_fc_tac[]);
(* *** Goal "2.2" *** *)
a (swap_nth_asm_concl_tac 1 THEN asm_rewrite_tac[]);
(* *** Goal "3" *** *)
a (asm_tac repclosed_syntax_lemma1);
a (spec_nth_asm_tac 1 ¨Syntax \ {x}Æ);
a (spec_nth_asm_tac 1 ¨xÆ);
val syntax_disj_thm = save_pop_thm "syntax_disj_thm";

set_goal([], ¨µx∑ x ç Syntax ¥ IsAf x ≤ IsCf xÆ);
a (REPEAT_N 2 strip_tac THEN fc_tac [syntax_disj_thm]
	THEN asm_rewrite_tac[]);
val syntax_cases_thm = save_pop_thm "syntax_cases_thm";

set_goal([], ¨µx∑	x ç Syntax
¥	(IsAf x ¥ ∂r pars∑ fun pars ± x = MkAf (r, pars))
±	(IsCf x ¥ ∂vars fs∑ (µy∑ y çâg fs ¥ y ç Syntax) ± x = MkCf (vars, fs))
Æ);
a (REPEAT_N 2 strip_tac);
a (asm_tac (syntax_disj_thm));
a (asm_fc_tac[] THEN asm_rewrite_tac [Is_clauses]);
(* *** Goal "1" *** *)
a (∂_tac ¨rÆ THEN ∂_tac ¨parsÆ THEN asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a (∂_tac ¨varsÆ THEN ∂_tac ¨fsÆ THEN asm_rewrite_tac[]);
val is_fc_clauses = save_pop_thm "is_fc_clauses";

set_goal([], ¨(µl r∑ AfRel (MkAf (l, r)) = l)
	±	(µl r∑ AfPars (MkAf (l, r)) = r)
	±	(µv f∑ CfVars (MkCf (v, f)) = v)
	±	(µv f∑ CfForms (MkCf (v, f)) = f)
Æ);
a (rewrite_tac (map get_spec [
	¨MkAfÆ, ¨MkCfÆ,
	¨AfRelÆ, ¨AfParsÆ, ¨CfVarsÆ, ¨CfFormsÆ]));
val syn_proj_clauses = save_pop_thm "syn_proj_clauses";

add_pc_thms "'ifol" [syn_proj_clauses];
set_merge_pcs ["hol1", "'GS1", "'ifol"];

set_goal([], ¨µx∑	x ç Syntax
¥	(IsCf x ¥ (µy∑ y çâg (CfForms x) ¥ y ç Syntax))
Æ);
a (REPEAT strip_tac
	THEN all_fc_tac [is_fc_clauses]
	THEN GET_NTH_ASM_T 1 (var_elim_asm_tac o concl)
	THEN_TRY asm_rewrite_tac[]);
a (DROP_NTH_ASM_T 2 (asm_tac o (rewrite_rule[]))
	THEN all_asm_fc_tac[]);
val is_fc_clauses2 = save_pop_thm "is_fc_clauses2";

set_goal([], ¨µx y∑ ≥ MkAf x = MkCf yÆ);
a (rewrite_tac (map get_spec [¨MkAfÆ, ¨MkCfÆ]));
a (contr_tac THEN FC_T (MAP_EVERY ante_tac) [natg_one_one_thm]
	THEN (PC_T1 "lin_arith" rewrite_tac[]));
val syn_con_neq_clauses = save_pop_thm "syn_con_neq_clauses";

add_pc_thms "'ifol" [syn_con_neq_clauses];
set_merge_pcs ["hol1", "'GS1", "'ifol"];

set_goal([], ¨
	(µv f∑ MkCf (v, f) ç Syntax ¥ (µy∑ y çâg f ¥ y ç Syntax))Æ);
a (REPEAT strip_tac
	THEN FC_T (MAP_EVERY (strip_asm_tac o (rewrite_rule []))) [is_fc_clauses2]
	THEN asm_fc_tac[]);
val syn_comp_fc_clauses = save_pop_thm "syn_comp_fc_clauses";

set_goal([], ¨µ¡ « vars fs∑ « ç Syntax ¥
		(« = MkCf (vars, fs) ± ¡ çâg fs) ¥ ScPrec ¡ «
Æ);
a (rewrite_tac [get_spec ¨ScPrecÆ]);
a (REPEAT µ_tac THEN strip_tac THEN strip_tac);
a (∂_tac ¨varsÆ THEN ∂_tac ¨fsÆ THEN asm_rewrite_tac[]);
a (REPEAT strip_tac THEN var_elim_nth_asm_tac 1);
(* *** Goal "1" *** *)
a (var_elim_nth_asm_tac 2);
a (fc_tac [syn_comp_fc_clauses]);
a (asm_fc_tac[]);
(* *** Goal "2" *** *)
a (var_elim_nth_asm_tac 2);
val scprec_fc_clauses = save_pop_thm "scprec_fc_clauses";

set_goal ([], ¨µt∑ t ç Syntax ¥ 
	(IsCf t ¥ µf∑ f çâg CfForms t ¥ ScPrec (f) t)Æ);
a (REPEAT strip_tac
	THEN all_fc_tac [is_fc_clauses]
	THEN DROP_NTH_ASM_T 3 ante_tac
	THEN asm_rewrite_tac[]
	THEN strip_tac
	THEN all_fc_tac [scprec_fc_clauses]
	THEN POP_ASM_T ante_tac
	THEN_TRY asm_rewrite_tac []);
val scprec_fc_clauses2 = save_pop_thm "scprec_fc_clauses2";
=TEX
}%ignore

\subsection{Semantics}

The semantics of infinitary first order logic is given by defining ``truth in an interpretation''.

\subsubsection{Domains}

We consider here some of the value domains which are significant in the semantics.

The following type abbreviations are introduced:

\begin{description}
\item{RV}
Relation Value - the arguments to a relation can be represented by indexed sets (think of the indices as parameter names), and a relation is then a truth valued function over these indexed sets (a set of indexed sets won't do because we have three truth values).
Note that relations need not have a definite arity, and the function representing a relation must be total over the entire type of indexed sets.
There are questions about how best ordinary n-ary relations should be represented, one obvious choice would be to make the truth value undefined for any indexed sets which do not have exactly the right number of numerical indices.
\item{ST}
Structure = a structure is a domain of disccourse (a set) together with an indexed set of relations over that domain.
Ordinals are used for relation names as well as for variable names (no ambiguity arises) and a collection of relations can therefore be modelled in the same way as a relation valued variable assignment.
\end{description}

=SML
declare_type_abbrev("€RV›", ["'a","'b"], î'a IS ≠ 'bÆ);
declare_type_abbrev("€ST›", ["'a","'b"], î'a SET ∏ ('a, 'b) RV ISÆ);
=TEX

To help in the location of fixed points we want a semantics which is monotonic, and therefore define here orderings on these domains relative to which we expect the sematantics to be monotonic.

The ordering on relations derives from the ordering on the truth values, using the operator {\it Pw}.

πHOLCONST
‹ €RvO› : ('b ≠ 'b ≠ BOOL) ≠ ('a, 'b) RV ≠ ('a, 'b) RV ≠ BOOL
˜¸¸¸¸¸¸¸¸¸¸¸
‹ µr∑ RvO r = Pw r
∞

=GFT
€rvo_lubs_exist_thm› =
	Ù µ r∑ LubsExist r ¥ LubsExist (RvO r)

€rvo_glbs_exist_thm› =
	Ù µ r∑ GlbsExist r ¥ GlbsExist (RvO r)
=TEX

\ignore{
=SML
set_goal([], ¨µr∑ LubsExist r ¥ LubsExist (RvO r)Æ);
a (REPEAT strip_tac
	THEN rewrite_tac [get_spec ¨RvOÆ]
	THEN bc_tac [pw_lubs_exist_thm]
	THEN strip_tac);
val rvo_lubs_exist_thm = save_pop_thm "rvo_lubs_exist_thm";

set_goal([], ¨µr∑ GlbsExist r ¥ GlbsExist (RvO r)Æ);
a (REPEAT strip_tac
	THEN rewrite_tac [get_spec ¨RvOÆ]
	THEN bc_tac [pw_glbs_exist_thm]
	THEN strip_tac);
val rvo_glbs_exist_thm = save_pop_thm "rvo_glbs_exist_thm";
=TEX
}%ignore


πHOLCONST
‹ €RvIsO› : ('b ≠ 'b ≠ BOOL) ≠ ('a, 'b) RV IS ≠ ('a, 'b) RV IS ≠ BOOL
˜¸¸¸¸¸¸¸¸¸¸¸
‹ µr∑ RvIsO r = IsEO (RvO r)
∞

=GFT
€rviso_lubs_exist_thm› =
	Ù µ r∑ LubsExist r ¥ LubsExist (RvIsO r)

€rviso_glbs_exist_thm› =
	Ù µ r∑ GlbsExist r ¥ GlbsExist (RvIsO r)
=TEX

\ignore{
=SML
set_goal([], ¨µr∑ LubsExist r ¥ LubsExist (RvIsO r)Æ);
a (REPEAT strip_tac
	THEN rewrite_tac [get_spec ¨RvIsOÆ]
	THEN bc_tac [is_lubs_exist_thm]
	THEN bc_tac [rvo_lubs_exist_thm]
	THEN strip_tac);
val rviso_lubs_exist_thm = save_pop_thm "rviso_lubs_exist_thm";

set_goal([], ¨µr∑ GlbsExist r ¥ GlbsExist (RvIsO r)Æ);
a (REPEAT strip_tac
	THEN rewrite_tac [get_spec ¨RvIsOÆ]
	THEN bc_tac [is_glbs_exist_thm]
	THEN bc_tac [rvo_glbs_exist_thm]
	THEN strip_tac);
val rviso_glbs_exist_thm = save_pop_thm "rviso_glbs_exist_thm";
=TEX
}%ignore

[This one is probably not useful]

πHOLCONST
‹ €StO› : ('b ≠ 'b ≠ BOOL) ≠ ('a, 'b) ST ≠ ('a, 'b) ST ≠ BOOL
˜¸¸¸¸¸¸¸¸¸¸¸
‹ µr∑ StO r = DerivedOrder Snd (IsEO (RvO r))
∞

=GFT
€sto_lubs_exist_thm› =
	Ù µ r∑ LubsExist r ¥ LubsExist (StO r)

€sto_glbs_exist_thm› =
	Ù µ r∑ GlbsExist r ¥ GlbsExist (StO r)
=TEX

\ignore{
=SML
set_goal([], ¨µr∑ LubsExist r ¥ LubsExist (StO r)Æ);
a (REPEAT strip_tac
	THEN rewrite_tac [get_spec ¨StOÆ]
	THEN bc_tac [lubsexist_dosnd_thm]
	THEN bc_tac [is_lubs_exist_thm]
	THEN bc_tac [rvo_lubs_exist_thm]
	THEN strip_tac);
val sto_lubs_exist_thm = save_pop_thm "sto_lubs_exist_thm";

set_goal([], ¨µr∑ GlbsExist r ¥ GlbsExist (StO r)Æ);
a (REPEAT strip_tac
	THEN rewrite_tac [get_spec ¨StOÆ]
	THEN bc_tac [glbsexist_dosnd_thm]
	THEN bc_tac [is_glbs_exist_thm]
	THEN bc_tac [rvo_glbs_exist_thm]
	THEN strip_tac);
val sto_glbs_exist_thm = save_pop_thm "sto_glbs_exist_thm";
=TEX
}%ignore

\ignore{
[not in use]

 πHOLCONST
‹ €StrictFun› : ('a ≠ 'b) DPO ≠ 'a DPO ≠ 'b DPO
˜¸¸¸¸¸¸¸¸¸¸¸
‹ µf∑ StrictFun f = Ãx∑
	if dpoUdef f
	then dpoB
	else
		if dpoOdef f
		then dpoT
		else
			if dpoUdef x
			then dpoB
			else
				if dpoOdef x
				then dpoT
				else dpoE (dpoV f (dpoV x))
 ∞
}%ignore

\subsubsection{Manipulating Valuations}

In this syntax, by contrast with that in \cite{rbjt021}, we do not require variables to be ordinals, they may be arbitrary sets, since no steps are necessary to avoid variable capture.
There was no need even in \cite{rbjt021}, the use of a transfinite version of DeBriujn indices was a hang over from the PolySets where something of the kind really was needed.

This function is used in the evaluation of atomic formulae.
Given a set of indices (the names of actual parameters to an atomic formula, which are always variables) and an indexed set (the values of the variables) this function returns an indexed set which contains the values for the actual parameters to the relation.

πHOLCONST
‹ €VarComp› : GS ≠ 'a IS ≠ 'a IS
˜¸¸¸¸¸¸¸¸¸¸¸
‹ µm is∑ VarComp m is = 
‹	Ãv∑ if v çâg dom m then is (m âg v) else dpoB
∞

\subsubsection{Formula Evaluation}

Now we define the evaluation of formulae, i.e. the notion of truth in a structure given a variable assignment.

There are two cases in the syntax, atomic and compound formulae.
The truth values of the atomic formulae are obtained from an infinitary structure given the values of the arguments, which are always variables, i.e. to evaluate an atomic formula you look up the values of the arguments in the current context (variable assignment) and then look up the truth value of the stipulated relation for those arguments in the structure.

πHOLCONST
‹ €EvalAf› : 't REL ≠ GS ≠ ('a, 't) ST ≠ ('a, 't) RV
˜¸¸¸¸¸¸¸¸¸¸¸
‹ µ$ºât (at:GS) (st:('a, 't) ST) (va:'a IS)∑ EvalAf $ºât at st va =
‹	let r = AfRel at
‹	and pars = AfPars at
‹	in 
‹		let rv = (Snd st) r
‹		in
‹			if dpoUdef rv
‹			then Lub $ºât {}
‹			else
‹				if dpoOdef rv
‹				then Glb $ºât {}
‹				else (dpoV rv) (VarComp pars va)
∞

To evaluate a compound formula you must first evaluate the constituent formulae in every context obtable by modification of the variables bound by the compound formula.
You need only remember the resulting truth values, the compound formulae are in this sense ``truth functional'', and, though this may involve evaluating a very large number of instances of subformulae, it can only yield some subset of
=INLINEFT
{pTrue, pFalse, pU}
=TEX
.

The following definition shows how the truth values of the constituents of a compound formula then determines the truth value of the compound formula.

=SML
declare_type_abbrev("€CFE›", ["'t"], î't SET ≠ 'tÆ);
=TEX

πHOLCONST
‹ €EvalCf_tf3› : TTV CFE
˜¸¸¸¸¸¸¸¸¸¸¸
‹ µresults∑ EvalCf_tf3 results = 
‹	if results Ä {pTrue} then pFalse
‹		else if (pFalse) ç results then pTrue
‹		else pU
∞

πHOLCONST
‹ €EvalCf_tf4› : FTV CFE
˜¸¸¸¸¸¸¸¸¸¸¸
‹ µresults∑ EvalCf_tf4 results = 
‹	if results Ä {fTrue} then fFalse
‹		else if results Ä {fTrue; fB} then fB
‹		else if fT ç results then fT else fTrue
∞



This definition shows how the set of truth values of instances of the constituents is obtained from the denotations of the constituent formulae.

πHOLCONST
‹ €EvalCf› : 't CFE ≠ GS ≠ ('a, 't) ST ≠ ('a, 't) RV SET ≠ ('a, 't) RV
˜¸¸¸¸¸¸¸¸¸¸¸
‹ µetf f∑ EvalCf etf f = Ãst rvs va∑ 
‹	let Œ = CfVars f
‹	and V = Fst st
‹	in etf {pb | ∂rv v∑
‹		  rv ç rvs
‹		± IsDom v = Xâg Œ
‹		± IsRan v Ä V
‹		± pb = rv (IsOverRide v va)}
∞

Now we define a parameterised functor of which the semantic function is a fixed point.

πHOLCONST
‹ €EvalFormFunct› : 't CFE ∏ 't REL ∏ ('a, 't) ST ≠ (GS ≠ ('a, 't) RV) ≠ (GS ≠ ('a, 't) RV)
˜¸¸¸¸¸¸¸¸¸¸¸
‹ µcfe $ºât st∑ EvalFormFunct (cfe, $ºât, st) = Ãef f∑
‹	if f ç Syntax
‹	then if IsAf f
‹	     then EvalAf $ºât f st
‹	     else
‹		if IsCf f
‹		then let rvs = FunImage ef (Xâg(CfForms f))
‹		     in  EvalCf cfe f st rvs
‹		else ≈x∑T
‹	else ≈x∑T
∞

πHOLCONST
‹ €EvalForm› : 't CFE ∏ 't REL ∏ ('a, 't) ST ≠ GS ≠ ('a, 't) RV
˜¸¸¸¸¸¸¸¸¸¸¸
‹ µcfe $ºât st∑ EvalForm (cfe, $ºât, st) = fix (EvalFormFunct (cfe, $ºât, st))
∞

To use this definition we need to show that there exists a fixed point, for which we must show that the functor respects some well-founded relation.

=GFT
€evalformfunct_respect_thm› =
   Ù µ (V, r)∑ EvalFormFunct (V, r) respects ScPrec

€evalformfunct_fixp_lemma› =
   Ù µ st∑ EvalForm st = EvalFormFunct st (EvalForm st)

€evalformfunct_thm› =
   Ù µ st
     ∑ EvalForm st
         = (Ã f
         ∑ if f ç Syntax
           then
             if IsAf f
             then EvalAf f st
             else if IsCf f
             then
               let rvs = FunImage (EvalForm st) (Xâg (CfForms f))
               in EvalCf f st rvs
             else ≈ x∑ T
           else ≈ x∑ T)

€evalformfunct_thm2› =
   Ù µ st f
     ∑ EvalForm st f
         = (if f ç Syntax
           then
             if IsAf f
             then EvalAf f st
             else if IsCf f
             then
               let rvs = FunImage (EvalForm st) (Xâg (CfForms f))
               in EvalCf f st rvs
             else ≈ f∑ T
           else ≈ f∑ T)
=TEX

\ignore{
=SML
set_merge_pcs ["hol", "'GS1", "'ifol"];

set_goal([], ¨µcfe $ºât st∑ (EvalFormFunct (cfe, $ºât, st)) respects ScPrecÆ);
a (rewrite_tac [get_spec ¨EvalFormFunctÆ, get_spec ¨$respectsÆ]
	THEN REPEAT strip_tac);
a (cases_tac ¨IsAf xÆ THEN asm_rewrite_tac[]);
a (cases_tac ¨IsCf xÆ THEN asm_rewrite_tac[]);
a (cases_tac ¨x ç SyntaxÆ THEN asm_rewrite_tac[]);
a (lemma_tac ¨FunImage g (Xâg (CfForms x)) = FunImage h (Xâg (CfForms x))Æ
	THEN_TRY asm_rewrite_tac[get_spec ¨XâgÆ]);
a (PC_T1 "hol1" rewrite_tac [get_spec ¨FunImageÆ]
	THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a (all_fc_tac [scprec_fc_clauses2]);
a (all_asm_fc_tac[tc_incr_thm]);
a (all_asm_fc_tac[]);
a (∂_tac ¨aÆ THEN asm_rewrite_tac[]);
a (POP_ASM_T (fn x => rewrite_thm_tac (eq_sym_rule x)));
a (asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a (all_fc_tac [scprec_fc_clauses2]);
a (all_asm_fc_tac[tc_incr_thm]);
a (all_asm_fc_tac[]);
a (∂_tac ¨aÆ THEN asm_rewrite_tac[]);
val evalformfunct_respect_thm = save_pop_thm "evalformfunct_respect_thm";

set_goal([], ¨µcfe $ºât st∑ EvalForm (cfe, $ºât, st) = EvalFormFunct (cfe, $ºât, st) (EvalForm (cfe, $ºât, st))Æ);
a (asm_tac well_founded_ScPrec_thm);
a (asm_tac evalformfunct_respect_thm);
a (REPEAT µ_tac);
a (list_spec_nth_asm_tac 1 [¨cfeÆ, ¨$ºâtÆ, ¨stÆ]);
a (all_fc_tac [µ_elim ¨ScPrecÆ (µ_elim ¨EvalFormFunct (cfe, $ºât, st)Æ (get_spec ¨fixÆ))]);
a (rewrite_tac [get_spec ¨EvalFormÆ]);
a (asm_rewrite_tac[]);
val evalformfunct_fixp_lemma = save_pop_thm "evalformfunct_fixp_lemma";

val evalformfunct_thm = save_thm ("evalformfunct_thm",
	rewrite_rule [get_spec ¨EvalFormFunctÆ] evalformfunct_fixp_lemma);

set_goal([], ¨µ cfe $ºât st f
     ∑ EvalForm (cfe, $ºât, st) f
         = if f ç Syntax
             then
               if IsAf f
               then EvalAf $ºât f st
               else if IsCf f
               then
                 let rvs = FunImage (EvalForm (cfe, $ºât, st)) (Xâg (CfForms f))
                 in EvalCf cfe f st rvs
               else ≈ f∑ T
             else ≈ f∑ TÆ);
a (REPEAT strip_tac THEN rewrite_tac[rewrite_rule [](once_rewrite_rule [ext_thm] evalformfunct_thm)]);
val evalformfunct_thm2 = save_pop_thm "evalformfunct_thm2";
=TEX
}%ignore

\subsubsection{Some Orderings}

In order to prove that the semantics is monotonic, we must first define the partial orderings relative to which the semantics is monotonic, and we must obtain fixpoint theorems for the orderings.

We have at present two cases under consideration, according to whether three or four truth values are adopted.

The three valued case turns out in some respects more complex than the four valued case, because it is necessary to make do with chain completeness and the fixed point theorem is more difficult to prove.
I will therefore progress only the four valued case until I find a reason to further progress the three valued case.

Here is the beginning of the three valued case which I started before.

It is also necessary to prove that these partial orderings are CCPOs (chain complete partial orders), this being the weakest condition for which we have a suitable fixed point theorem.
It is convenient to be slightly more definite, to make the orderings all reflexive, and show that they are reflexive CCPOs (for which we use the term CCRPO).

The following ordering is applicable to partial relations.

=SML
declare_infix(300, "ºâfâtâ3");
=TEX

πHOLCONST
‹ €$ºâfâtâ3› : ('a ≠ TTV) ≠ ('a ≠ TTV) ≠ BOOL
˜¸¸¸¸¸¸¸¸¸¸¸
‹ $ºâfâtâ3 = Pw $ºâtâ3
∞

=GFT
€ccrpou_ºâfâtâ3_thm› =
	Ù CcRpoU $ºâfâtâ3
=TEX

\ignore{
=SML
set_goal([], ¨CcRpoU $ºâfâtâ3Æ);
a (rewrite_tac [get_spec ¨$ºâfâtâ3Æ]);
a (asm_tac ccrpou_ºâtâ3_thm);
a (fc_tac [pw_ccrpou_thm]);
val ccrpou_ºâfâtâ3_thm = save_pop_thm "ccrpou_ºâfâtâ3_thm";
=TEX
}%ignore

Lets now get on with the four valued case.

=SML
declare_infix(300, "ºâfâtâ4");
=TEX

πHOLCONST
‹ €$ºâfâtâ4› : ('a ≠ FTV) ≠ ('a ≠ FTV) ≠ BOOL
˜¸¸¸¸¸¸¸¸¸¸¸
‹ $ºâfâtâ4 = Pw $ºâtâ4
∞

=GFT
€ccrpou_ºâfâtâ4_thm› =
	Ù  $ºâfâtâ4
=TEX

\ignore{
=IGN
set_goal([], ¨CcRpoU $ºâfâtâ3Æ);
a (rewrite_tac [get_spec ¨$ºâfâtâ3Æ]);
a (asm_tac ccrpou_ºâtâ3_thm);
a (fc_tac [pw_ccrpou_thm]);
val ccrpou_ºâfâtâ3_thm = save_pop_thm "ccrpou_ºâfâtâ3_thm";
=TEX
}%ignore


=GFT
€evalcf_tf4_increasing_lemma› =
   Ù Increasing (SetO $ºâtâ4) $ºâtâ4 EvalCf_tf4
=TEX

\ignore{
=SML
set_goal([], ¨Increasing (SetO $ºâtâ4) $ºâtâ4 EvalCf_tf4Æ);
a (rewrite_tac (map get_spec [¨IncreasingÆ, ¨SetOÆ, ¨$ºâtâ4Æ, ¨EvalCf_tf4Æ]));
a (REPEAT_N 3 strip_tac THEN_TRY asm_rewrite_tac[]);
a (cases_tac ¨y Ä {fTrue}Æ THEN_TRY asm_rewrite_tac[]);
(* *** Goal "1" *** *)
a (cases_tac ¨x Ä {fTrue}Æ THEN_TRY asm_rewrite_tac[]);
a (POP_ASM_T (strip_asm_tac o (pc_rule1 "hol1" rewrite_rule[])));
a (all_asm_fc_tac[]);
(* *** Goal "1.1" *** *)
a (var_elim_asm_tac ¨x' = y'Æ);
a (DROP_NTH_ASM_T 4 (strip_asm_tac o (pc_rule1 "hol1" rewrite_rule[])));
a (all_asm_fc_tac[]);
(* *** Goal "1.2" *** *)
a (var_elim_asm_tac ¨x' = fBÆ THEN_TRY asm_rewrite_tac[]);
a (cases_tac ¨x Ä {fTrue; fB}Æ THEN_TRY asm_rewrite_tac[]);
a (POP_ASM_T (strip_asm_tac o (pc_rule1 "hol1" rewrite_rule[])));
a (strip_asm_tac (µ_elim ¨x'Æ ftv_cases_thm)
	THEN	var_elim_nth_asm_tac 1);
(* *** Goal "1.2.1" *** *)
a (spec_nth_asm_tac 9 ¨fFalseÆ);
(* *** Goal "1.2.1.1" *** *)
a (lemma_tac ¨fFalse ç yÆ
	THEN1 (asm_rewrite_tac[]));
a (DROP_NTH_ASM_T 10 (strip_asm_tac o (pc_rule1 "hol1" rewrite_rule[])));
a (all_asm_fc_tac[]);
(* *** Goal "1.2.1.2" *** *)
a (lemma_tac ¨fT ç yÆ
	THEN1 (SYM_ASMS_T rewrite_tac));
a (DROP_NTH_ASM_T 10 (strip_asm_tac o (pc_rule1 "hol1" rewrite_rule[])));
a (all_asm_fc_tac[]);
(* *** Goal "1.2.2" *** *)
a (spec_nth_asm_tac 9 ¨fTÆ);
(* *** Goal "1.2.2.1" *** *)
a (lemma_tac ¨fT ç yÆ
	THEN1 (asm_rewrite_tac[]));
a (DROP_NTH_ASM_T 10 (strip_asm_tac o (pc_rule1 "hol1" rewrite_rule[])));
a (all_asm_fc_tac[]);
(* *** Goal "1.2.2.2" *** *)
a (lemma_tac ¨fT ç yÆ
	THEN1 (SYM_ASMS_T rewrite_tac));
a (DROP_NTH_ASM_T 10 (strip_asm_tac o (pc_rule1 "hol1" rewrite_rule[])));
a (all_asm_fc_tac[]);
(* *** Goal "1.3" *** *)
a (var_elim_asm_tac ¨y' = fTÆ THEN_TRY asm_rewrite_tac[]);
a (cases_tac ¨x Ä {fTrue; fB}Æ THEN_TRY asm_rewrite_tac[]);
a (POP_ASM_T (strip_asm_tac o (pc_rule1 "hol1" rewrite_rule[])));
a (strip_asm_tac (µ_elim ¨x''Æ ftv_cases_thm)
	THEN	var_elim_nth_asm_tac 1);
(* *** Goal "1.3.1" *** *)
a (spec_nth_asm_tac 9 ¨fFalseÆ);
(* *** Goal "1.3.1.1" *** *)
a (lemma_tac ¨fFalse ç yÆ
	THEN1 (asm_rewrite_tac[]));
a (DROP_NTH_ASM_T 10 (strip_asm_tac o (pc_rule1 "hol1" rewrite_rule[])));
a (all_asm_fc_tac[]);
(* *** Goal "1.3.1.2" *** *)
a (DROP_NTH_ASM_T 9 (strip_asm_tac o (pc_rule1 "hol1" rewrite_rule[])));
a (all_asm_fc_tac[]);
(* *** Goal "1.3.2" *** *)
a (DROP_NTH_ASM_T 7 (strip_asm_tac o (pc_rule1 "hol1" rewrite_rule[])));
a (all_asm_fc_tac[]);
(* *** Goal "2" *** *)
a (cases_tac ¨x Ä {fTrue}Æ THEN_TRY asm_rewrite_tac[]);
(* *** Goal "2.1" *** *)
a (cases_tac ¨y Ä {fTrue; fB}Æ THEN_TRY asm_rewrite_tac[]);
(* *** Goal "2.1.1" *** *)
a (lemma_tac ¨fB ç yÆ
	THEN1 (GET_NTH_ASM_T 1 ante_tac
		THEN GET_NTH_ASM_T 3 ante_tac
		THEN PC_T1 "hol1" rewrite_tac[]
		THEN REPEAT strip_tac
		THEN asm_fc_tac[]
		THEN var_elim_nth_asm_tac 1));
a (spec_nth_asm_tac 5 ¨fBÆ);
(* *** Goal "2.1.1.1" *** *)
a (DROP_NTH_ASM_T 5 (strip_asm_tac o (pc_rule1 "hol1" rewrite_rule[])));
a (var_elim_nth_asm_tac 2 THEN asm_fc_tac []);
(* *** Goal "2.1.2" *** *)
a (cases_tac ¨fT ç yÆ THEN asm_rewrite_tac[]);
a (lemma_tac ¨fFalse ç yÆ);
(* *** Goal "2.1.2.1" *** *)
a (GET_NTH_ASM_T 2 ante_tac THEN (PC_T1 "hol1" rewrite_tac[])
	THEN strip_tac);
a (strip_asm_tac (µ_elim ¨x'Æ ftv_cases_thm)
	THEN	var_elim_nth_asm_tac 1);
(* *** Goal "2.1.2.2" *** *)
a (spec_nth_asm_tac 6 ¨fFalseÆ);
(* *** Goal "2.1.2.2.1" *** *)
a (GET_NTH_ASM_T 6 ante_tac THEN (PC_T1 "hol1" rewrite_tac[])
	THEN contr_tac);
a (var_elim_nth_asm_tac 2
	THEN all_asm_fc_tac[]);
(* *** Goal "2.1.2.2.2" *** *)
a (var_elim_nth_asm_tac 1);
a (DROP_NTH_ASM_T 5 (strip_asm_tac o (pc_rule1 "hol1" rewrite_rule[])));
a (asm_fc_tac[]);
(* *** Goal "2.2" *** *)
a (cases_tac ¨y Ä {fTrue; fB}Æ THEN_TRY asm_rewrite_tac[]);
(* *** Goal "2.2.1" *** *)
a (lemma_tac ¨fB ç yÆ
	THEN1 (GET_NTH_ASM_T 1 ante_tac
		THEN GET_NTH_ASM_T 3 ante_tac
		THEN PC_T1 "hol1" rewrite_tac[]
		THEN REPEAT strip_tac
		THEN asm_fc_tac[]
		THEN var_elim_nth_asm_tac 1));
a (cases_tac ¨x Ä {fTrue; fB}Æ THEN asm_rewrite_tac[]);
(* *** Goal "2.2.1.1" *** *)
a (DROP_NTH_ASM_T 1 (strip_asm_tac o (pc_rule1 "hol1" rewrite_rule[])));
a (strip_asm_tac (µ_elim ¨x'Æ ftv_cases_thm)
	THEN	var_elim_nth_asm_tac 1);
a (spec_nth_asm_tac 9 ¨fFalseÆ);
(* *** Goal "2.2.1.1.1" *** *)
a (lemma_tac ¨fFalse ç yÆ
	THEN1 asm_rewrite_tac[]);
a (DROP_NTH_ASM_T 8 (strip_asm_tac o (pc_rule1 "hol1" rewrite_rule[])));
a (spec_nth_asm_tac 1 ¨fFalseÆ);
(* *** Goal "2.2.1.1.2" *** *)
a (var_elim_nth_asm_tac 1);
a (DROP_NTH_ASM_T 6 (strip_asm_tac o (pc_rule1 "hol1" rewrite_rule[])));
a (spec_nth_asm_tac 1 ¨fTÆ);
(* *** Goal "2.2.1.2" *** *)
a (DROP_NTH_ASM_T 5 (strip_asm_tac o (pc_rule1 "hol1" rewrite_rule[])));
a (spec_nth_asm_tac 1 ¨fTÆ);
a (spec_nth_asm_tac 10 ¨fTÆ);
(* *** Goal "2.2.1.2.1" *** *)
a (DROP_NTH_ASM_T 3 ante_tac THEN asm_rewrite_tac[]);
(* *** Goal "2.2.1.2.2" *** *)
a (DROP_NTH_ASM_T 2 ante_tac THEN asm_rewrite_tac[]);
(* *** Goal "2.2.2" *** *)
a (cases_tac ¨x Ä {fTrue; fB}Æ THEN_TRY asm_rewrite_tac[]);
a (cases_tac ¨fT ç yÆ THEN_TRY asm_rewrite_tac[]);
a (cases_tac ¨fT ç xÆ THEN_TRY asm_rewrite_tac[]);
a (spec_nth_asm_tac 8 ¨fTÆ);
(* *** Goal "2.2.2.1" *** *)
a (DROP_NTH_ASM_T 4 ante_tac THEN asm_rewrite_tac[]);
(* *** Goal "2.2.2.2" *** *)
a (DROP_NTH_ASM_T 2 ante_tac THEN asm_rewrite_tac[]);
val evalcf_tf4_increasing_lemma = pop_thm ();
=TEX
}%ignore


\subsubsection{Monotonicity}

=GFT
€evalaf_increasing_lemma› =
   Ù µ tr g∑ CRpoU tr ¥ Increasing (StO tr) (RvO tr) (EvalAf tr g)
=TEX

\ignore{
=SML
set_goal([], ¨µ tr g∑ CRpoU tr ¥ Increasing (StO tr) (RvO tr) (EvalAf tr g)Æ);
a (rewrite_tac (map get_spec [¨IncreasingÆ, ¨EvalAfÆ, ¨StOÆ, ¨RvOÆ,
	¨PwÆ, ¨DerivedOrderÆ, ¨IsEOÆ, ¨DpoEOÆ, ¨dpoUdefÆ, ¨dpoOdefÆ])
	THEN REPEAT strip_tac);
a (rewrite_tac [let_def]);
a (spec_nth_asm_tac 1 ¨AfRel gÆ THEN_TRY asm_rewrite_tac[]);
(* *** Goal "1" *** *)
a (fc_tac [crpou_lub_glb_ö_lemma] THEN asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a (fc_tac [crpou_lub_glb_ö_lemma] THEN_TRY asm_rewrite_tac[]);
val evalaf_increasing_lemma = pop_thm();
=TEX
}%ignore

To get a monontonicity result for the semantics of first order logic it is necessary to adjust the type of the semantic function.

The function which we wish to be monotonic is the mappings for each fixed domain of discourse and each particular formula, which take an indexed set of relations (corresponding to some interpretation over the gived domain) and return the relation represented by the formulae in that context.

The following function accepts one compound argument containing the relevent context and yields a function which we expect to be monotonic:

πHOLCONST
‹ €MonoEvalForm› : 't CFE ∏ 't REL ∏ 'a SET ∏ GS ≠ ('a, 't) RV IS ≠ ('a, 't) RV
˜¸¸¸¸¸¸¸¸¸¸¸
‹ µc r s g ris∑ MonoEvalForm (c, r, s, g) ris = EvalForm (c, r, (s, ris)) g
∞

=GFT
€monoevalform_increasing_lemma› =
   Ù µ c r s g
     ∑ CRpoU r ± Increasing (SetO r) r c
         ¥ Increasing (RvIsO r) (RvO r) (MonoEvalForm (c, r, s, g))

€evalform_increasing_thm› =
   Ù µ c r s g
     ∑ CRpoU r ± Increasing (SetO r) r c
         ¥ Increasing (RvIsO r) (RvO r) (Ã ris∑ EvalForm (c, r, s, ris) g)
=TEX

\ignore{
=SML
set_goal ([], ¨µc r s g∑ CRpoU r ± Increasing (SetO r) r c
	¥ Increasing (RvIsO r) (RvO r) (MonoEvalForm (c,r,s,g))Æ);
a (REPEAT strip_tac);
a (sc_induction_tac ¨gÆ THEN_TRY asm_rewrite_tac[]);
a (rewrite_tac ((map get_spec [¨IncreasingÆ, ¨MonoEvalFormÆ, ¨RvOÆ, ¨RvIsOÆ])@[evalformfunct_thm2])
	THEN REPEAT strip_tac);
a (cases_tac ¨t ç SyntaxÆ THEN asm_rewrite_tac[]);
(* *** Goal "1" *** *)
a (cases_tac ¨IsAf tÆ THEN asm_rewrite_tac[]);
(* *** Goal "1.1" *** *)
a (fc_tac [inst_type_rule [(î'aÆ, î'bÆ), (î'bÆ, î'aÆ)] evalaf_increasing_lemma]);
a (spec_nth_asm_tac 1 ¨tÆ THEN fc_tac [get_spec ¨IncreasingÆ]);
a (POP_ASM_T ante_tac THEN rewrite_tac [get_spec¨StOÆ,get_spec¨RvOÆ,
	get_spec ¨DerivedOrderÆ] THEN strip_tac);
a (LIST_SPEC_NTH_ASM_T 1 [¨(s,x)Æ, ¨(s,y)Æ] ante_tac
	THEN rewrite_tac[]
	THEN strip_tac);
(* *** Goal "1.2" *** *)
a (cases_tac ¨IsCf tÆ THEN asm_rewrite_tac[]);
(* *** Goal "1.2.1" *** *)
a (rewrite_tac ((map get_spec [¨PwÆ, ¨XâgÆ, ¨EvalCfÆ])@[let_def]));
a (strip_tac THEN FC_T bc_tac [get_spec ¨IncreasingÆ]);
a (rewrite_tac [get_spec ¨SetOÆ] THEN REPEAT strip_tac);
(* *** Goal "1.2.1.1" *** *)
a (GET_NTH_ASM_T 4 (strip_asm_tac o (rewrite_rule [get_spec ¨FunImageÆ])));
a (∂_tac ¨EvalForm (c, r, s, y) a (IsOverRide v x')Æ
	THEN strip_tac);
(* *** Goal "1.2.1.1.1" *** *)
a (∂_tac ¨EvalForm (c, r, s, y) aÆ);
a (∂_tac ¨vÆ THEN asm_rewrite_tac[get_spec ¨FunImageÆ]);
a (∂_tac ¨aÆ THEN asm_rewrite_tac[]);
(* *** Goal "1.2.1.1.2" *** *)
a (asm_rewrite_tac[]);
a (GET_NTH_ASM_T 1 (rewrite_thm_tac o eq_sym_rule));
a (lemma_tac ¨tc ScPrec a tÆ);
(* *** Goal "1.2.1.1.2.1" *** *)
a (fc_tac [scprec_fc_clauses]);
a (all_fc_tac [is_fc_clauses2]);
a (all_fc_tac [scprec_fc_clauses2]);
a (fc_tac [tc_incr_thm]);
(* *** Goal "1.2.1.1.2.2" *** *)
a (all_asm_fc_tac[]);
a (fc_tac[get_spec ¨IncreasingÆ]);
a (GET_NTH_ASM_T 1 ante_tac THEN rewrite_tac [get_spec ¨RvIsOÆ, get_spec ¨RvOÆ]
	THEN STRIP_T (fn x => fc_tac[x]));
a (POP_ASM_T ante_tac THEN rewrite_tac [get_spec ¨MonoEvalFormÆ, get_spec ¨PwÆ]
	THEN STRIP_T rewrite_thm_tac);
(* *** Goal "1.2.1.2" *** *)
a (GET_NTH_ASM_T 4 (strip_asm_tac o (rewrite_rule [get_spec ¨FunImageÆ])));
a (∂_tac ¨EvalForm (c, r, s, x) a (IsOverRide v x')Æ
	THEN strip_tac);
(* *** Goal "1.2.1.2.1" *** *)
a (∂_tac ¨EvalForm (c, r, s, x) aÆ);
a (∂_tac ¨vÆ THEN asm_rewrite_tac[get_spec ¨FunImageÆ]);
a (∂_tac ¨aÆ THEN asm_rewrite_tac[]);
(* *** Goal "1.2.1.2.2" *** *)
a (asm_rewrite_tac[]);
a (GET_NTH_ASM_T 1 (rewrite_thm_tac o eq_sym_rule));
a (lemma_tac ¨tc ScPrec a tÆ);
(* *** Goal "1.2.1.2.2.1" *** *)
a (fc_tac [scprec_fc_clauses]);
a (all_fc_tac [is_fc_clauses2]);
a (all_fc_tac [scprec_fc_clauses2]);
a (fc_tac [tc_incr_thm]);
(* *** Goal "1.2.1.2.2.2" *** *)
a (all_asm_fc_tac[]);
a (fc_tac[get_spec ¨IncreasingÆ]);
a (GET_NTH_ASM_T 1 ante_tac THEN rewrite_tac [get_spec ¨RvIsOÆ, get_spec ¨RvOÆ]
	THEN STRIP_T (fn x => fc_tac[x]));
a (POP_ASM_T ante_tac THEN rewrite_tac [get_spec ¨MonoEvalFormÆ, get_spec ¨PwÆ]
	THEN STRIP_T rewrite_thm_tac);
(* *** Goal "1.2.2" *** *)
a (fc_tac [inst_type_rule [(î'aÆ, î'bÆ), (îGS ≠ 'b + BOOLÆ, î'aÆ)] pw_crpou_thm]);
a (fc_tac [crpou_fc_clauses] THEN asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a (fc_tac [inst_type_rule [(î'aÆ, î'bÆ), (îGS ≠ 'b + BOOLÆ, î'aÆ)] pw_crpou_thm]);
a (fc_tac [crpou_fc_clauses] THEN asm_rewrite_tac[]);
val monoevalform_increasing_lemma = pop_thm ();

set_goal([], ¨µ c r s g
     ∑ CRpoU r ± Increasing (SetO r) r c
         ¥ Increasing (RvIsO r) (RvO r) (Ãris∑EvalForm (c, r, s, ris) g)Æ);
a (REPEAT µ_tac);
a (lemma_tac ¨(Ãris∑EvalForm (c, r, s, ris) g) = MonoEvalForm (c, r, s, g)Æ
	THEN1 rewrite_tac [ext_thm, get_spec ¨MonoEvalFormÆ]);
a (asm_rewrite_tac[monoevalform_increasing_lemma]);
val evalform_increasing_thm = save_pop_thm "evalform_increasing_thm";
=TEX
}%ignore

\newpage
\section{SET THEORY}

We now narrow our interest to just one theory, set theory.
This will be treated using the above formalisation of infinitary logic, and will be the infinitary language with just two binary relations, equality and membership.

We consider set theory as the theory of extensions.
The `naive' approach to this is the theory with equality and membership which has equality and extensionality axioms and the principle of set comprehension, according to which to every formula with one free variable there is a set whose extension is those elements for which the formula will be true if the free variable denotes that element.
This theory unfortunately is inconsistent, but, more than one century after this discovery we still have neither a wholly satisfactory explanation of why this is the case, nor a theory which can be argued to be a maximal consistent weakening of that ontological principle.
Of course, there may be no such theory, but it is our purpose here to look further into this matter.

This will be done by looking for maximal subsets of the infinitarily definable properties which can be realised in a consistent set theory.
The definition of infinitary first order logic above stipulated a class of properties relative to some give relational structure, and tells us the meaning of these formulae.
We will be seeking subsets of the formulae which provide an interpretation of set theory.

This will be done by formulating the semantics of set theory as a functor operating on the relational structure for which the existence of a fixed point determines the required interpretation.

We are seeking a functor which when supplied with membership and equality relations will deliver new relationships at least as detailed as the original (they are partial relationships).
This is what we now define.

We define a functor which takes a relational structure containing a membership and an equality relation, over a domain which is some unspecified subset of the formulae of infinitary logic defined above, and computes a new similar structure.
The new structure will be that of the sets infinitarily definable in the first structure by formulae in the domain of discourse.
This functor may be view as the giving a semantics to the language of infinitary first order set theory, which is does by adding the the semantics of the logic above, an account of the meaning of the membership and equality relations.
This account is recursive and is therefore expressed as a functor, and will be well-defined only if the functor has a fixed point.
The functor will be monotone and will therefore have a fixed point, but this will be in general a pair of partial relations, and we will be seeking particular subsets of the language for which there is a definite fixed point such that the relations are everywhere either true or false.
From such a definite fixed point an interpretation of the classical two-valued set theory may be constructed.

\subsection{Packing and Unpacking Relationship Pairs}

The format of a structure, as used in the specification of infinitary logic above, supports arbitrary structures as indexed sets.
The definitions in this section provide for conversion between indexed sets and pairs of relationships.

=SML
declare_type_abbrev ("BR", ["'a", "'b"], î'a ≠ 'a ≠ 'bÆ);
declare_type_abbrev ("PR", ["'a", "'b"], î('a, 'b) BR ∏ ('a, 'b) BRÆ);
=TEX


πHOLCONST
‹ €PackBinRel›: ('a, 't DPO) BR ≠ ('a, 't DPO) RV
˜¸¸¸¸¸¸¸¸¸
‹ µ r∑ PackBinRel r = Ãisp: 'a IS∑
‹	if IsDom isp = {Natâg 0; Natâg 1} ± IsOd isp = {}
‹	then r (dpoV (isp (Natâg 0))) (dpoV (isp (Natâg 1)))
‹	else if IsOd isp = {} then dpoB else dpoT
∞

For the monotonicity proof it is useful to define the following ordering over binary relations:

πHOLCONST
‹ €BrO›: ('t, BOOL) BR ≠ (('a,'t) BR, BOOL)BR
˜¸¸¸¸¸¸¸¸¸¸¸
‹ µ r∑ BrO r = Pw (Pw r)
∞

=GFT
€packbinrel_increasing_lemma› =
   Ù µ r∑ Rpo (Universe, r) ¥ Increasing (BrO r) (RvO r) PackBinRel
=TEX

\ignore{
=SML
set_goal([], ¨µr∑ RpoU r ¥ RpoU (BrO r)Æ);
a (rewrite_tac[get_spec ¨BrOÆ] THEN REPEAT strip_tac);
a (bc_tac [pw_rpou_lemma]);
a (bc_tac [pw_rpou_lemma]);
a (strip_tac);
val bro_rpou_lemma = pop_thm();

set_goal([], ¨µr∑ Rpo (Universe, r) ¥ Increasing (BrO r) (RvO r) PackBinRelÆ);
a (rewrite_tac [get_spec ¨IncreasingÆ, get_spec ¨PackBinRelÆ, get_spec ¨PwÆ,
	get_spec ¨RvOÆ, get_spec ¨BrOÆ]
	THEN REPEAT strip_tac);
a (fc_tac [rpou_fc_clauses]);
a (cases_tac ¨IsDom x' = {Natâg 0; Natâg 1} ± IsOd x' = {}Æ
	THEN_TRY asm_rewrite_tac[]);
val packbinrel_increasing_lemma = pop_thm ();
=TEX
}%ignore

πHOLCONST
‹ €UnpackBinRel› : ('a, 't) RV ≠ ('a, 't) BR
˜¸¸¸¸¸¸¸¸¸¸¸
‹ µ rv∑ UnpackBinRel rv = Ãx y∑ rv
‹	(Ãp∑
‹		if p = Natâg 0
‹		then dpoE x
‹		else
‹			if p = Natâg 1
‹			then dpoE y
‹			else dpoB)
∞

=GFT
€unpackbinrel_increasing_lemma› =
   Ù µ r∑ Increasing (RvO r) (BrO r) UnpackBinRel
=TEX

\ignore{
=SML
set_goal([], ¨µr∑ Increasing (RvO r) (BrO r) UnpackBinRelÆ);
a (rewrite_tac [get_spec ¨IncreasingÆ, get_spec ¨UnpackBinRelÆ, get_spec ¨PwÆ,
	get_spec ¨RvOÆ, get_spec ¨BrOÆ]
	THEN REPEAT strip_tac
	THEN asm_rewrite_tac[]);
val unpackbinrel_increasing_lemma = pop_thm ();
=TEX
}%ignore


πHOLCONST
‹ €PackRelPair› : ('a, 't DPO) PR ≠ ('a, 't DPO) RV IS
˜¸¸¸¸¸¸¸¸¸¸¸
‹ µrp∑ PackRelPair rp =
‹	let ($=âv, $çâv) = rp in
‹	Ãrn∑
‹	if rn = Natâg 0 then dpoE (PackBinRel $=âv)
‹	else if rn = Natâg 1 then dpoE (PackBinRel $=âv)
‹	else dpoB
∞

Here is the relevant ordering on pairs of binary relations:

πHOLCONST
‹ €PbrO›: ('t, BOOL)BR ≠ (('a, 't) PR, BOOL) BR
˜¸¸¸¸¸¸¸¸¸¸¸
‹ µ r∑ PbrO r = PrO (BrO r) (BrO r)
∞

=GFT
€pbro_crpou_thm› =
   Ù µ r∑ CRpoU r ¥ CRpoU (PbrO r)crpou_increasing_lfp_lemma2 =
   Ù µ r f∑ CRpoU r ± Increasing r r f ¥ IsLfp r f (Lfpâc r f)

€pbro_ºâtâ4_crpou_thm› =
   Ù CRpoU (PbrO $ºâtâ4)

€packrelpair_increasing_lemma› =
   Ù µ r
     ∑ Rpo (Universe, r)
         ¥ Increasing (PbrO r) (RvIsO r) PackRelPair
=TEX

\ignore{
=SML
set_goal([], ¨µr∑ CRpoU r ¥ CRpoU (PbrO r)Æ);
a (rewrite_tac [get_spec ¨PbrOÆ, get_spec ¨BrOÆ] THEN REPEAT strip_tac);
a (bc_tac [pro_crpou_thm]);
a (bc_tac [pw_crpou_thm]);
a (bc_tac [pw_crpou_thm]);
a strip_tac;
val pbro_crpou_thm = save_pop_thm "pbro_crpou_thm";

set_goal([], ¨CRpoU (PbrO $ºâtâ4)Æ);
a (bc_tac [pbro_crpou_thm]);
a (accept_tac ºâtâ4_crpou_thm);
val pbro_ºâtâ4_crpou_thm = save_pop_thm "pbro_ºâtâ4_crpou_thm";

set_goal([], ¨µr∑ Rpo (Universe, r)
	¥ Increasing (PbrO r) (RvIsO r) PackRelPairÆ);
a (rewrite_tac [get_spec ¨IncreasingÆ, get_spec ¨PackRelPairÆ, get_spec ¨PwÆ, let_def,
	get_spec ¨PbrOÆ, get_spec ¨BrOÆ,
	get_spec ¨RvIsOÆ, get_spec ¨PrOÆ, get_spec ¨IsEOÆ, get_spec ¨DpoEOÆ, get_spec ¨RvOÆ]
	THEN REPEAT_N 7 strip_tac);
a (cases_tac ¨x' = Natâg 0Æ THEN asm_rewrite_tac[]);
(* *** Goal "1" *** *)
a (∂_tac ¨PackBinRel (Fst x)Æ THEN ∂_tac ¨PackBinRel (Fst y)Æ
	THEN asm_rewrite_tac[get_spec ¨PackBinRelÆ]
	THEN strip_tac);
a (cases_tac ¨IsDom x'' = {Natâg 0; Natâg 1} ± IsOd x'' = {}Æ
	THEN asm_rewrite_tac[]
	THEN (FC_T rewrite_tac [rpou_fc_clauses]));
(* *** Goal "2" *** *)
a (REPEAT strip_tac);
a (∂_tac ¨dpoV (if x' = Natâg 1 then dpoE (PackBinRel (Fst x)) else dpoB)Æ
	THEN ∂_tac ¨dpoV (if x' = Natâg 1 then dpoE (PackBinRel (Fst y)) else dpoB)Æ);
a (lemma_tac ¨x' = Natâg 1Æ
	THEN1 (DROP_NTH_ASM_T 2 ante_tac THEN asm_rewrite_tac[get_spec ¨dpoUdefÆ]
		THEN once_rewrite_tac [prove_rule [] ¨µA B∑ ≥ A ¥ B § ≥ B ¥ AÆ]
		THEN strip_tac
		THEN_TRY asm_rewrite_tac[])
	THEN asm_rewrite_tac[]
	THEN strip_tac);
a (FC_T (MAP_EVERY ante_tac) [packbinrel_increasing_lemma]);
a (rewrite_tac[get_spec ¨IncreasingÆ, get_spec ¨PwÆ, get_spec ¨RvOÆ, get_spec ¨BrOÆ]);
a (strip_tac);
a (asm_fc_tac[] THEN asm_rewrite_tac[]);
val packrelpair_increasing_lemma = pop_thm ();
=TEX
}%ignore


πHOLCONST
‹ €UnpackRelPair› : ('a, 't DPO) RV IS ≠ ('a, 't DPO) PR
˜¸¸¸¸¸¸¸¸¸¸¸
‹ µrvis:('a, 't DPO) RV IS∑ UnpackRelPair rvis =
‹	let f = (Ãn∑
‹			if dpoOdef (rvis n)
‹			then (Ã x y∑ dpoT)
‹			else
‹				if dpoUdef (rvis n)
‹				then (Ãx y∑ dpoB)
‹				else UnpackBinRel (dpoV (rvis n)))
‹	in (f (Natâg 0), f (Natâg 1))
∞

=GFT
€unpackrelpair_increasing_lemma› =
   Ù Increasing (RvIsO Dpo) (PbrO Dpo) UnpackRelPair
=TEX

\ignore{
=SML
set_goal([], ¨Increasing (RvIsO Dpo) (PbrO Dpo) UnpackRelPairÆ);
a (rewrite_tac [get_spec ¨RvIsOÆ, get_spec ¨IncreasingÆ, get_spec ¨UnpackRelPairÆ, get_spec ¨PbrOÆ, 		get_spec ¨IsEOÆ, get_spec ¨PrOÆ, get_spec ¨DpoEOÆ, get_spec ¨PwÆ, let_def]
	THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a (cases_tac ¨dpoOdef (x (Natâg 0))Æ THEN asm_rewrite_tac[]);
(* *** Goal "1.1" *** *)
a (cases_tac ¨dpoOdef (y (Natâg 0))Æ THEN asm_rewrite_tac[]);
(* *** Goal "1.1.1" *** *)
a (asm_tac (inst_type_rule [(î'bÆ, î'aÆ)] dpo_rpou_lemma));
a (fc_tac [bro_rpou_lemma]);
a (lemma_tac ¨µ x:'a ≠ 'a ≠ 'b + BOOL∑ BrO Dpo x xÆ THEN1 fc_tac [rpou_fc_clauses2]);
a (asm_rewrite_tac[]);
(* *** Goal "1.1.2" *** *)
a (lemma_tac ¨≥ dpoUdef (x (Natâg 0))Æ
	THEN1 (GET_NTH_ASM_T 2 ante_tac
		THEN rewrite_tac[get_spec ¨dpoUdefÆ, get_spec ¨dpoOdefÆ]
		THEN STRIP_T rewrite_thm_tac));
a (spec_nth_asm_tac 4 ¨Natâg 0Æ);
a (DROP_NTH_ASM_T 6 ante_tac THEN asm_rewrite_tac[get_spec ¨dpoOdefÆ]);
(* *** Goal "1.2" *** *)
a (cases_tac ¨dpoOdef (y (Natâg 0))Æ THEN asm_rewrite_tac[]);
(* *** Goal "1.2.1" *** *)
a (rewrite_tac (map get_spec [¨BrOÆ, ¨PwÆ, ¨DpoÆ]));
(* *** Goal "1.2.2" *** *)
a (cases_tac ¨dpoUdef (x (Natâg 0))Æ THEN asm_rewrite_tac[]);
(* *** Goal "1.2.2.1" *** *)
a (rewrite_tac (map get_spec [¨BrOÆ, ¨PwÆ, ¨DpoÆ]));
(* *** Goal "1.2.2.2" *** *)
a (spec_nth_asm_tac 4 ¨Natâg 0Æ);
a (asm_rewrite_tac (map get_spec [¨BrOÆ, ¨PwÆ, ¨DpoÆ]));
a (FC_T (MAP_EVERY ante_tac) [
rewrite_rule (map get_spec [¨IncreasingÆ, ¨BrOÆ, ¨PwÆ, ¨DpoÆ]) unpackbinrel_increasing_lemma]);
a (rewrite_tac [get_spec ¨DpoÆ]);
(* *** Goal "2" *** *)
a (cases_tac ¨dpoOdef (x (Natâg 1))Æ THEN asm_rewrite_tac[]);
(* *** Goal "2.1" *** *)
a (cases_tac ¨dpoOdef (y (Natâg 1))Æ THEN asm_rewrite_tac[]);
(* *** Goal "2.1.1" *** *)
a (asm_tac (inst_type_rule [(î'bÆ, î'aÆ)] dpo_rpou_lemma));
a (fc_tac [bro_rpou_lemma]);
a (fc_tac [rpou_fc_clauses2] THEN asm_rewrite_tac[]);
(* *** Goal "2.1.2" *** *)
a (lemma_tac ¨≥ dpoUdef (x (Natâg 1))Æ
	THEN1 (GET_NTH_ASM_T 2 ante_tac
		THEN rewrite_tac[get_spec ¨dpoUdefÆ, get_spec ¨dpoOdefÆ]
		THEN STRIP_T rewrite_thm_tac));
a (spec_nth_asm_tac 4 ¨Natâg 1Æ);
a (DROP_NTH_ASM_T 6 ante_tac THEN asm_rewrite_tac[get_spec ¨dpoOdefÆ]);
(* *** Goal "2.2" *** *)
a (cases_tac ¨dpoOdef (y (Natâg 1))Æ THEN asm_rewrite_tac[]);
(* *** Goal "2.2.1" *** *)
a (rewrite_tac (map get_spec [¨BrOÆ, ¨PwÆ, ¨DpoÆ]));
(* *** Goal "2.2.2" *** *)
a (cases_tac ¨dpoUdef (x (Natâg 1))Æ THEN asm_rewrite_tac[]);
(* *** Goal "2.2.2.1" *** *)
a (rewrite_tac (map get_spec [¨BrOÆ, ¨PwÆ, ¨DpoÆ]));
(* *** Goal "2.2.2.2" *** *)
a (spec_nth_asm_tac 4 ¨Natâg 1Æ);
a (asm_rewrite_tac (map get_spec [¨BrOÆ, ¨PwÆ, ¨DpoÆ]));
a (FC_T (MAP_EVERY ante_tac) [
rewrite_rule (map get_spec [¨IncreasingÆ, ¨BrOÆ, ¨PwÆ, ¨DpoÆ]) unpackbinrel_increasing_lemma]);
a (rewrite_tac [get_spec ¨DpoÆ]);
val unpackbinrel_increasing_lemma = pop_thm();
=TEX
}%ignore

\subsection{Recasting of EvalForm}

We now recast {\it EvalForm} for the special case that the structure relative to which formulae are evaluated is a pair of binary relations.

πHOLCONST
‹ €EvalFormPr› : ('t DPO) CFE ∏ ('t DPO) REL ∏ 'a SET ∏ GS
‹			≠ ('a, 't DPO) PR ≠ ('a, 't DPO) RV
˜¸¸¸¸¸¸¸¸¸¸¸
‹ µp∑ EvalFormPr p = (MonoEvalForm p) o PackRelPair
∞

=GFT
evalformpr_increasing_thm =
   Ù µ c r s g
     ∑ CRpoU r ± Increasing (SetO r) r c
         ¥ Increasing (PbrO r) (RvO r) (EvalFormPr (c, r, s, g))
=TEX

\ignore{
=SML
set_goal([], ¨µc r (s:'b SET) g∑ CRpoU r ± Increasing (SetO r) r c
	¥ Increasing (PbrO r) (RvO r) (EvalFormPr (c, r, s, g))Æ);
a (rewrite_tac (map get_spec [¨EvalFormPrÆ]) THEN REPEAT strip_tac);
a (strip_asm_tac (list_µ_elim [¨cÆ, ¨rÆ, ¨sÆ, ¨gÆ] monoevalform_increasing_lemma));
a (lemma_tac ¨Rpo (Universe, r)Æ 
	THEN1 (fc_tac [get_spec ¨CRpoUÆ]
		THEN fc_tac [get_spec ¨CRpoÆ]));
a (all_fc_tac [inst_type_rule [(î'aÆ, î'bÆ), (î'bÆ, î'aÆ)] packrelpair_increasing_lemma]);
a (strip_asm_tac (list_µ_elim [¨PbrO rÆ, ¨RvIsO rÆ, ¨RvO rÆ] increasing_funcomp_thm));
a (asm_fc_tac[]);
a (asm_fc_tac[]);
val evalformpr_increasing_thm = save_pop_thm "evalformpr_increasing_thm";
=TEX
}%ignore

\subsection{Membership and Equality}

πHOLCONST
‹ €ParamZero› : GS ≠ GS IS
˜¸¸¸¸¸¸¸¸¸¸¸
‹ µp∑ ParamZero p = Ãx∑ if x = Natâg 0 then dpoE p else dpoB
∞

All the above material is generic in the type of truth values.
The following material is specific to particular sets of truth values.

=SML
declare_infix (301, "€çâv›");
declare_infix (301, "€=âv›");
=TEX

In the following definitions, we are working with four truth values, which may be thought of as true. false, neither or both.
So that the definitions are monotonic, the criteria for truth and falsity are given independently so that it may be possible for both truth values to apply.

πHOLCONST
‹ €MemRel› : GS SET ≠ (GS, FTV) PR ≠ (GS, FTV) BR
˜¸¸¸¸¸¸¸¸¸¸¸
‹ µ V (pr: (GS, FTV) PR)∑ MemRel V pr =
	   let ($=âv, $çâv) = pr
	   in Ãv w∑
		if v ç V ± w ç V
		then EvalFormPr (EvalCf_tf4, $ºâtâ4, V, w) pr (ParamZero v)
		else fB
∞

=GFT
€memrel_increasing_lemma› =
   Ù µ V∑ Increasing (PbrO $ºâtâ4) (BrO $ºâtâ4) (MemRel V)

€memrel_increasing_lemma2› =
   Ù µ V x y∑ PbrO $ºâtâ4 x y ¥ BrO $ºâtâ4 (MemRel V x) (MemRel V y)
=TEX

\ignore{
=SML
set_goal([], ¨µ V∑ Increasing (PbrO $ºâtâ4) (BrO $ºâtâ4) (MemRel V)Æ);
a (rewrite_tac ((map get_spec [¨IncreasingÆ, ¨MemRelÆ, ¨BrOÆ, ¨PwÆ])@[let_def])
	THEN REPEAT strip_tac);
a (CASES_T ¨x' ç V ± x'' ç VÆ rewrite_thm_tac);
a (asm_tac ºâtâ4_crpou_thm);
a (asm_tac evalcf_tf4_increasing_lemma);
a (strip_asm_tac (list_µ_elim [¨EvalCf_tf4Æ, ¨$ºâtâ4Æ, ¨VÆ, ¨x''Æ]
	(evalformpr_increasing_thm)));
a (POP_ASM_T ante_tac THEN rewrite_tac (map get_spec [¨IncreasingÆ, ¨RvOÆ, ¨PwÆ])
	THEN strip_tac);
a (ALL_ASM_FC_T rewrite_tac []);
val memrel_increasing_lemma = pop_thm ();

val memrel_increasing_lemma2 = rewrite_rule [get_spec ¨IncreasingÆ] memrel_increasing_lemma;

=IGN
set_goal([], ¨µV pr∑ let mem = MemRel V pr in
	µz x y∑ x ç V ± y ç V ± z ç V
	± (µv∑ v ç V ¥ (fTrue ºâtâ4 (Snd pr) v x § fTrue ºâtâ4 (Snd pr) v y))
	± fTrue ºâtâ4 mem x z
	¥ fTrue ºâtâ4 mem y zÆ);
a (REPEAT µ_tac THEN rewrite_tac [let_def] THEN µ_tac );
a (sc_induction_tac ¨zÆ);
a (rewrite_tac ((map get_spec [¨MemRelÆ, ¨EvalFormPrÆ, ¨MonoEvalFormÆ])
		@[let_def, evalformfunct_thm2]));
a (REPEAT strip_tac);
val memrel_extensional_lemma = pop_thm();
=TEX
}%ignore

πHOLCONST
‹ €EqRel› : GS SET ≠ (GS, FTV) PR ≠ (GS, FTV) BR
˜¸¸¸¸¸¸¸¸¸¸¸
‹ µ V pr∑ EqRel V pr =
	   let ($=âv, $çâv) = pr
	   in 
	      (Ãv w∑
	if ≥ v ç V ≤ ≥ w ç V then v =âv w
	else if v = w then fTrue
	else if ∂x∑ x ç V ± (x çâv v = fT ≤ x çâv w = fT) then fT
	else if ∂x∑ x ç V ± (x çâv v = fTrue ± x çâv w = fFalse
				≤ x çâv w = fTrue ± x çâv v = fFalse) then fFalse
	else if ∂x∑ x ç V ± (x çâv v = fB ≤ x çâv w = fB) then fB
	else fTrue)
∞

The following version may be better.

πHOLCONST
‹ €EqRel2› : GS SET ≠ (GS, FTV) BR ≠ (GS, FTV) BR
˜¸¸¸¸¸¸¸¸¸¸¸
‹ µ V  $çâv∑ EqRel2 V $çâv = (Ãv w∑ Lub $ºâtâ4 {t | 
	v = w ± t = fTrue
	≤ (∂x∑ x ç V ± (fTrue ºâtâ4 x çâv v ± fFalse ºâtâ4 x çâv w
				≤ fFalse ºâtâ4 x çâv v ± fTrue ºâtâ4 x çâv w))
		± t = fFalse
	≤ (µx∑ (x ç V ¥ fTrue ºâtâ4 x çâv v ± fTrue ºâtâ4 x çâv w
				≤ fFalse ºâtâ4 x çâv v ± fFalse ºâtâ4 x çâv w)
		± t = fTrue)
	})
∞

=GFT
€eqrel_increasing_lemma› =
   Ù µ V∑ Increasing (PbrO $ºâtâ4) (BrO $ºâtâ4) (EqRel V)

€eqrel_increasing_lemma2› =
   Ù µ V x y∑ PbrO $ºâtâ4 x y ¥ BrO $ºâtâ4 (EqRel V x) (EqRel V y)

€eqrel_refl_lemma› =
   Ù µ V pr x∑ x ç V ¥ EqRel V pr x x = fTrue

€eqrel_sym_lemma› =
   Ù µ V pr x y∑ x ç V ± y ç V ¥ EqRel V pr x y = EqRel V pr y x

€eqrel_ftrue_lemma› =
   Ù µ V pr x y
     ∑ x ç V ± y ç V
         ¥ (EqRel V pr x y = fTrue
           § x = y
             ≤ (µ z
             ∑ z ç V
                 ¥ Snd pr z x = fTrue ± Snd pr z y = fTrue
                   ≤ Snd pr z x = fFalse ± Snd pr z y = fFalse))

€eqrel_trans_lemma› =
   Ù µ V pr x y z
     ∑ x ç V ± y ç V ± z ç V
         ¥ EqRel V pr x y = fTrue ± EqRel V pr y z = fTrue
         ¥ EqRel V pr x z = fTrue

€eqrel2_increasing_lemma› =
   Ù µ V∑ Increasing (BrO $ºâtâ4) (BrO $ºâtâ4) (EqRel2 V)
=TEX

\ignore{
=SML
set_goal([], ¨µ V∑ Increasing (PbrO $ºâtâ4) (BrO $ºâtâ4) (EqRel V)Æ);
a (rewrite_tac ((map get_spec [¨IncreasingÆ, ¨EqRelÆ, ¨BrOÆ, ¨PwÆ])@[let_def])
	THEN REPEAT strip_tac);
a (CASES_T ¨≥ x' ç V ≤ ≥ x'' ç VÆ rewrite_thm_tac
	THEN1 (POP_ASM_T ante_tac THEN rewrite_tac [get_spec ¨PbrOÆ,
		get_spec ¨PrOÆ, get_spec¨BrOÆ, get_spec ¨PwÆ]
		THEN REPEAT strip_tac THEN asm_rewrite_tac[]));
a (cases_tac ¨x'=x''Æ THEN asm_rewrite_tac[]);
a (CASES_T ¨∂ x'''∑ x''' ç V ± (Snd x x''' x' = fT ≤ Snd x x''' x'' = fT)Æ asm_tac
	THEN asm_rewrite_tac[]);
(* *** Goal "1" *** *)
a (LEMMA_T ¨∂ x'''∑ x''' ç V ± (Snd y x''' x' = fT ≤ Snd y x''' x'' = fT)Æ rewrite_thm_tac);
a (POP_ASM_T (STRIP_THM_THEN asm_tac));
a (GET_NTH_ASM_T 3 ante_tac THEN rewrite_tac (map get_spec [¨PbrOÆ, ¨PrOÆ, ¨BrOÆ, ¨PwÆ])
	THEN strip_tac);
a (∂_tac ¨x'''Æ THEN asm_rewrite_tac[] THEN contr_tac);
a (DROP_NTH_ASM_T 5 strip_asm_tac);
(* *** Goal "1.1" *** *)
a (DROP_NTH_ASM_T 4 ante_tac THEN rewrite_tac[]);
a (bc_tac [±_left_elim (µ_elim ¨Snd y x''' x'Æ ft_fb_thm)]);
a (lemma_tac ¨fT ºâtâ4 Snd x x''' x'Æ THEN1 asm_rewrite_tac[]);
a (list_spec_nth_asm_tac 5 [¨x'''Æ, ¨x'Æ]);
a (all_fc_tac [ºâtâ4_trans_thm]);
(* *** Goal "1.2" *** *)
a (DROP_NTH_ASM_T 3 ante_tac THEN rewrite_tac[]);
a (bc_tac [±_left_elim (µ_elim ¨Snd y x''' x'Æ ft_fb_thm)]);
a (lemma_tac ¨fT ºâtâ4 Snd x x''' x''Æ THEN1 asm_rewrite_tac[]);
a (list_spec_nth_asm_tac 5 [¨x'''Æ, ¨x''Æ]);
a (all_fc_tac [ºâtâ4_trans_thm]);
(* *** Goal "2" *** *)
a (POP_ASM_T strip_asm_tac);
a (GET_NTH_ASM_T 3 ante_tac THEN rewrite_tac (map get_spec [¨PbrOÆ, ¨PrOÆ, ¨BrOÆ, ¨PwÆ])
	THEN strip_tac);
a (CASES_T ¨∂ x'''∑ x''' ç V ± (Snd y x''' x' = fT ≤ Snd y x''' x'' = fT)Æ asm_tac
	THEN asm_rewrite_tac[]);
a (POP_ASM_T strip_asm_tac);
a (CASES_T ¨∂ x'''
                 ∑ x''' ç V
                     ± (Snd x x''' x' = fTrue ± Snd x x''' x'' = fFalse
                       ≤ Snd x x''' x'' = fTrue ± Snd x x''' x' = fFalse)Æ asm_tac
	THEN asm_rewrite_tac[]);
(* *** Goal "2.1" *** *)
a (POP_ASM_T strip_asm_tac);
(* *** Goal "2.1.1" *** *)
a (spec_nth_asm_tac 4 ¨x'''Æ);
a (LEMMA_T ¨∂ x'''
                 ∑ x''' ç V
                     ± (Snd y x''' x' = fTrue ± Snd y x''' x'' = fFalse
                       ≤ Snd y x''' x'' = fTrue ± Snd y x''' x' = fFalse)Æ rewrite_thm_tac
	THEN1 (∂_tac ¨x'''Æ THEN asm_rewrite_tac[]));
a (list_spec_nth_asm_tac 7 [¨x'''Æ, ¨x'Æ]);
a (list_spec_nth_asm_tac 8 [¨x'''Æ, ¨x''Æ]);
a (POP_ASM_T ante_tac THEN POP_ASM_T ante_tac);
a (rewrite_tac [asm_rule ¨Snd x x''' x' = fTrueÆ, asm_rule ¨Snd x x''' x'' = fFalseÆ]);
a (REPEAT_N 4 (POP_ASM_T ante_tac)
	THEN strip_asm_tac (µ_elim ¨Snd y x''' x''Æ ftv_cases_thm)
	THEN_TRY asm_rewrite_tac[]);
a (strip_asm_tac (µ_elim ¨Snd y x''' x'Æ ftv_cases_thm)
	THEN_TRY asm_rewrite_tac[]);
(* *** Goal "2.1.2" *** *)
a (spec_nth_asm_tac 4 ¨x'''Æ);
a (LEMMA_T ¨∂ x'''
                 ∑ x''' ç V
                     ± (Snd y x''' x' = fTrue ± Snd y x''' x'' = fFalse
                       ≤ Snd y x''' x'' = fTrue ± Snd y x''' x' = fFalse)Æ rewrite_thm_tac
	THEN1 (∂_tac ¨x'''Æ THEN asm_rewrite_tac[]));
a (list_spec_nth_asm_tac 7 [¨x'''Æ, ¨x'Æ]);
a (list_spec_nth_asm_tac 8 [¨x'''Æ, ¨x''Æ]);
a (POP_ASM_T ante_tac THEN POP_ASM_T ante_tac);
a (rewrite_tac [asm_rule ¨Snd x x''' x' = fFalseÆ, asm_rule ¨Snd x x''' x'' = fTrueÆ]);
a (REPEAT_N 4 (POP_ASM_T ante_tac)
	THEN strip_asm_tac (µ_elim ¨Snd y x''' x''Æ ftv_cases_thm)
	THEN_TRY asm_rewrite_tac[]);
a (strip_asm_tac (µ_elim ¨Snd y x''' x'Æ ftv_cases_thm)
	THEN_TRY asm_rewrite_tac[]);
(* *** Goal "2.2" *** *)
a (POP_ASM_T strip_asm_tac);
a (CASES_T ¨∂ x'''∑ x''' ç V ± (Snd x x''' x' = fB ≤ Snd x x''' x'' = fB)Æ asm_tac
	THEN asm_rewrite_tac[]);
a (POP_ASM_T strip_asm_tac);
a (LEMMA_T ¨≥ ∂ x'''
                 ∑ x''' ç V
                     ± (Snd y x''' x' = fTrue ± Snd y x''' x'' = fFalse
                       ≤ Snd y x''' x'' = fTrue ± Snd y x''' x' = fFalse)Æ rewrite_thm_tac
	THEN1 REPEAT strip_tac);
(* *** Goal "2.2.1" *** *)
a (spec_nth_asm_tac 3 ¨x'''Æ);
a (spec_nth_asm_tac 10 ¨x'''Æ);
a (list_spec_nth_asm_tac 10 [¨x'''Æ, ¨x''Æ]);
a (list_spec_nth_asm_tac 11 [¨x'''Æ, ¨x'Æ]);
a (REPEAT_N 2 (POP_ASM_T ante_tac)
	THEN rewrite_tac[asm_rule ¨Snd y x''' x' = fTrueÆ, asm_rule ¨Snd y x''' x'' = fFalseÆ]);
a (REPEAT_N 4 (POP_ASM_T ante_tac)
	THEN strip_asm_tac (µ_elim ¨Snd x x''' x'Æ ftv_cases_thm)
	THEN asm_rewrite_tac[]);
a (strip_asm_tac (µ_elim ¨Snd x x''' x''Æ ftv_cases_thm)
	THEN asm_rewrite_tac[]);
a (spec_nth_asm_tac 6 ¨x'''Æ);
(* *** Goal "2.2.2" *** *)
a (spec_nth_asm_tac 3 ¨x'''Æ);
a (spec_nth_asm_tac 10 ¨x'''Æ);
a (list_spec_nth_asm_tac 10 [¨x'''Æ, ¨x'Æ]);
a (list_spec_nth_asm_tac 11 [¨x'''Æ, ¨x''Æ]);
a (REPEAT_N 2 (POP_ASM_T ante_tac)
	THEN rewrite_tac[asm_rule ¨Snd y x''' x'' = fTrueÆ, asm_rule ¨Snd y x''' x' = fFalseÆ]);
a (REPEAT_N 4 (POP_ASM_T ante_tac)
	THEN strip_asm_tac (µ_elim ¨Snd x x''' x'Æ ftv_cases_thm)
	THEN asm_rewrite_tac[]);
a (strip_asm_tac (µ_elim ¨Snd x x''' x''Æ ftv_cases_thm)
	THEN asm_rewrite_tac[]);
a (spec_nth_asm_tac 6 ¨x'''Æ);
(* *** Goal "2.2.3" *** *)
a (LEMMA_T ¨≥ ∂ x'''∑ x''' ç V ± (Snd y x''' x' = fB ≤ Snd y x''' x'' = fB)Æ rewrite_thm_tac );
a (REPEAT strip_tac);
(* *** Goal "2.2.3.1" *** *)
a (spec_nth_asm_tac 2 ¨x'''Æ);
a (list_spec_nth_asm_tac 7 [¨x'''Æ, ¨x'Æ]);
a (POP_ASM_T ante_tac THEN rewrite_tac [asm_rule ¨Snd y x''' x' = fBÆ]);
a (DROP_NTH_ASM_T 2 ante_tac
	THEN strip_asm_tac (µ_elim ¨Snd x x''' x'Æ ftv_cases_thm)
	THEN asm_rewrite_tac[]);
(* *** Goal "2.2.3.2" *** *)
a (spec_nth_asm_tac 2 ¨x'''Æ);
a (list_spec_nth_asm_tac 7 [¨x'''Æ, ¨x''Æ]);
a (POP_ASM_T ante_tac THEN rewrite_tac [asm_rule ¨Snd y x''' x'' = fBÆ]);
a (DROP_NTH_ASM_T 2 ante_tac
	THEN strip_asm_tac (µ_elim ¨Snd x x''' x''Æ ftv_cases_thm)
	THEN asm_rewrite_tac[]);
val eqrel_increasing_lemma = pop_thm();

val eqrel_increasing_lemma2 = rewrite_rule [get_spec ¨IncreasingÆ] eqrel_increasing_lemma;

set_goal ([], ¨µV pr x∑ x ç V ¥ EqRel V pr x x = fTrueÆ);
a (rewrite_tac [get_spec ¨EqRelÆ, let_def] THEN REPEAT strip_tac
	THEN asm_rewrite_tac[]);
val eqrel_refl_lemma = pop_thm ();

set_goal ([], ¨µV pr x y∑ x ç V ± y ç V ¥ EqRel V pr x y = EqRel V pr y xÆ);
a (rewrite_tac [get_spec ¨EqRelÆ, let_def] THEN REPEAT strip_tac THEN asm_rewrite_tac[]);
a (cases_tac ¨x = yÆ THEN_TRY asm_rewrite_tac[]);
a (SYM_ASMS_T rewrite_tac);
a (rewrite_tac [prove_rule []
	¨µx'∑(Snd pr x' y = fT ≤ Snd pr x' x = fT) = (Snd pr x' x = fT ≤ Snd pr x' y = fT)Æ]);
a (rewrite_tac [prove_rule []
	¨µx'∑ (Snd pr x' x = fTrue ± Snd pr x' y = fFalse
                       ≤ Snd pr x' y = fTrue ± Snd pr x' x = fFalse)
	§ (Snd pr x' y = fTrue ± Snd pr x' x = fFalse
                       ≤ Snd pr x' x = fTrue ± Snd pr x' y = fFalse)Æ]);
a (rewrite_tac [prove_rule []
	¨µx'∑ (Snd pr x' x = fB ≤ Snd pr x' y = fB)
	§ (Snd pr x' y = fB ≤ Snd pr x' x = fB)Æ]);
val eqrel_sym_lemma = pop_thm ();

set_goal ([], ¨µV pr x y∑ x ç V ± y ç V ¥ (EqRel V pr x y = fTrue §
	x = y ≤ µz∑ z ç V ¥
		Snd pr z x = fTrue ± Snd pr z y = fTrue
		≤ Snd pr z x = fFalse ± Snd pr z y = fFalse)Æ);
a (rewrite_tac [get_spec ¨EqRelÆ, let_def] THEN REPEAT µ_tac THEN strip_tac);
a (cases_tac ¨x = yÆ THEN asm_rewrite_tac[]);
a (CASES_T ¨∂ x'∑ x' ç V ± (Snd pr x' x = fT ≤ Snd pr x' y = fT)Æ asm_tac
	THEN asm_rewrite_tac[]);
(* *** Goal "1" *** *)
a (REPEAT strip_tac);
a (POP_ASM_T (STRIP_THM_THEN asm_tac));
a (∂_tac ¨x'Æ
	THEN POP_ASM_T strip_asm_tac
	THEN asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a (CASES_T ¨∂ x'
                   ∑ x' ç V
                       ± (Snd pr x' x = fTrue ± Snd pr x' y = fFalse
                         ≤ Snd pr x' y = fTrue ± Snd pr x' x = fFalse)Æ asm_tac
	THEN asm_rewrite_tac[]);
(* *** Goal "2.1" *** *)
a (POP_ASM_T (STRIP_THM_THEN asm_tac));
a (strip_tac THEN ∂_tac ¨x'Æ
	THEN POP_ASM_T strip_asm_tac
	THEN asm_rewrite_tac[]);
(* *** Goal "2.2" *** *)
a (CASES_T ¨∂ x'∑ x' ç V ± (Snd pr x' x = fB ≤ Snd pr x' y = fB)Æ asm_tac
	THEN asm_rewrite_tac[]);
(* *** Goal "2.2.1" *** *)
a (POP_ASM_T (STRIP_THM_THEN asm_tac));
a (strip_tac THEN ∂_tac ¨x'Æ
	THEN POP_ASM_T strip_asm_tac
	THEN asm_rewrite_tac[]);
(* *** Goal "2.2.2" *** *)
a (REPEAT µ_tac);
a (REPEAT_N 3 (DROP_NTH_ASM_T 3 strip_asm_tac));
a (strip_tac);
a (spec_nth_asm_tac 4 ¨zÆ);
a (spec_nth_asm_tac 4 ¨zÆ);
a (SPEC_NTH_ASM_T 7 ¨zÆ ante_tac THEN rewrite_tac [asm_rule ¨z ç VÆ]);
a (ante_tac (µ_elim ¨Snd pr z xÆ ftv_cases_thm) THEN asm_rewrite_tac[]);
a (ante_tac (µ_elim ¨Snd pr z yÆ ftv_cases_thm) THEN asm_rewrite_tac[]);
a (prove_tac[]);
val eqrel_ftrue_lemma = pop_thm();

set_goal ([], ¨µV pr x y z∑
	x ç V ± y ç V ± z ç V
	¥ EqRel V pr x y = fTrue ± EqRel V pr y z = fTrue
	¥ EqRel V pr x z = fTrueÆ);
a (REPEAT µ_tac THEN strip_tac);
a (rewrite_tac [rewrite_rule [asm_rule ¨x ç VÆ, asm_rule ¨y ç VÆ]
	(list_µ_elim [¨VÆ, ¨prÆ, ¨xÆ, ¨yÆ] eqrel_ftrue_lemma)]);
a (rewrite_tac [rewrite_rule [asm_rule ¨z ç VÆ, asm_rule ¨y ç VÆ]
	(list_µ_elim [¨VÆ, ¨prÆ, ¨yÆ, ¨zÆ] eqrel_ftrue_lemma)]);
a (rewrite_tac [rewrite_rule [asm_rule ¨z ç VÆ, asm_rule ¨x ç VÆ]
	(list_µ_elim [¨VÆ, ¨prÆ, ¨xÆ, ¨zÆ] eqrel_ftrue_lemma)]);
a (strip_tac THEN_TRY asm_rewrite_tac[]);
(* *** Goal "1" *** *)
a (REPEAT_N 4 strip_tac THEN var_elim_nth_asm_tac 3);
a (SPEC_NTH_ASM_T 3 ¨z'Æ ante_tac THEN rewrite_tac [asm_rule ¨z' ç VÆ]);
(* *** Goal "2" *** *)
a (REPEAT_N 4 strip_tac);
a (SPEC_NTH_ASM_T 3 ¨z'Æ ante_tac THEN rewrite_tac [asm_rule ¨z' ç VÆ]);
a (SPEC_NTH_ASM_T 4 ¨z'Æ ante_tac THEN rewrite_tac [asm_rule ¨z' ç VÆ]);
a (prove_tac[]);
(* *** Goal "2.1" *** *)
a (DROP_NTH_ASM_T 11 ante_tac THEN rewrite_tac [asm_rule ¨Snd pr z' y = fFalseÆ]);
(* *** Goal "2.2" *** *)
a (DROP_NTH_ASM_T 11 ante_tac THEN rewrite_tac [asm_rule ¨Snd pr z' y = fTrueÆ]);
val eqrel_trans_lemma = pop_thm ();

set_goal([], ¨µ V∑ Increasing (BrO $ºâtâ4) (BrO $ºâtâ4) (EqRel2 V)Æ);
a (rewrite_tac ((map get_spec [¨IncreasingÆ, ¨EqRel2Æ, ¨BrOÆ, ¨PwÆ])@[let_def])
	THEN REPEAT strip_tac);
a (asm_tac ºâtâ4_crpou_thm);
a (fc_tac [lub_increasing2_lemma3]);
a (bc_tac [asm_rule ¨µ x y∑ SetO2 $ºâtâ4 x y ¥ Lub $ºâtâ4 x ºâtâ4 Lub $ºâtâ4 yÆ]);
a (rewrite_tac [get_spec ¨SetO2Æ] THEN REPEAT strip_tac
	THEN_TRY asm_rewrite_tac[]);
(* *** Goal "1" *** *)
a (∂_tac ¨fTrueÆ THEN rewrite_tac[]);
(* *** Goal "2" *** *)
a (∂_tac ¨fFalseÆ THEN asm_rewrite_tac[] THEN REPEAT strip_tac);
a (lemma_tac ¨fTrue ºâtâ4 y x'''' x'Æ
	THEN1 (list_spec_nth_asm_tac 7 [¨x''''Æ, ¨x'Æ] THEN all_asm_fc_tac [ºâtâ4_trans_thm]));
a (lemma_tac ¨fFalse ºâtâ4 y x'''' x''Æ
	THEN1 (list_spec_nth_asm_tac 8 [¨x''''Æ, ¨x''Æ] THEN all_asm_fc_tac [ºâtâ4_trans_thm]));
a (∂_tac ¨x''''Æ THEN asm_rewrite_tac[]);
(* *** Goal "3" *** *)
a (∂_tac ¨fFalseÆ THEN asm_rewrite_tac[] THEN REPEAT strip_tac);
a (lemma_tac ¨fTrue ºâtâ4 y x'''' x''Æ
	THEN1 (list_spec_nth_asm_tac 7 [¨x''''Æ, ¨x''Æ] THEN all_asm_fc_tac [ºâtâ4_trans_thm]));
a (lemma_tac ¨fFalse ºâtâ4 y x'''' x'Æ
	THEN1 (list_spec_nth_asm_tac 8 [¨x''''Æ, ¨x'Æ] THEN all_asm_fc_tac [ºâtâ4_trans_thm]));
a (∂_tac ¨x''''Æ THEN asm_rewrite_tac[]);
(* *** Goal "4" *** *)
a (∂_tac ¨fTrueÆ THEN asm_rewrite_tac[]);
a (cases_tac ¨x' = x''Æ THEN asm_rewrite_tac[]);
a (REPEAT_N 2 strip_tac);
a (spec_nth_asm_tac 3 ¨x''''Æ);
(* *** Goal "4.1" *** *)
a (lemma_tac ¨fTrue ºâtâ4 y x'''' x'Æ
	THEN1 (list_spec_nth_asm_tac 9 [¨x''''Æ, ¨x'Æ] THEN all_asm_fc_tac [ºâtâ4_trans_thm]));
a (lemma_tac ¨fTrue ºâtâ4 y x'''' x''Æ
	THEN1 (list_spec_nth_asm_tac 10 [¨x''''Æ, ¨x''Æ] THEN all_asm_fc_tac [ºâtâ4_trans_thm]));
a (asm_rewrite_tac[]);
(* *** Goal "4.2" *** *)
a (lemma_tac ¨fFalse ºâtâ4 y x'''' x'Æ
	THEN1 (list_spec_nth_asm_tac 9 [¨x''''Æ, ¨x'Æ] THEN all_asm_fc_tac [ºâtâ4_trans_thm]));
a (lemma_tac ¨fFalse ºâtâ4 y x'''' x''Æ
	THEN1 (list_spec_nth_asm_tac 10 [¨x''''Æ, ¨x''Æ] THEN all_asm_fc_tac [ºâtâ4_trans_thm]));
a (asm_rewrite_tac[]);
val eqrel2_increasing_lemma = pop_thm ();
=TEX
}%ignore

\subsubsection{Extensionalisation}

If we make a semantic functor naively from the above two definitions of membership and equality it is not easy to show (and may be false) that the fixedpoints of the functor are extensional in the sense required.
It will be necessary for membership to respect term equality, not just that sets with the same extension be equal. 

It might be possible to elaborate the definition of membership above to have the desired effect, but instead a separate enhancement to the membership relation will be incorporated into the semantic functor.
This I call ``extensionalisation''.

The idea is to take an arbitrary pair of relations (understood as equality and membership) and to obtain from them the ``smallest'' pair of relations in which membership respects equality and is extensional.
This is done by defining a membership enhancer, combining this with the definition of equality above, and then taking a least fixed point of the resulting relationship.

The membership enhancer simply takes account of equality.

πHOLCONST
‹ €ExtMem› : GS SET ≠ (GS, FTV) PR ≠ (GS, FTV) BR
˜¸¸¸¸¸¸¸¸¸¸¸
‹ µ V pr∑ ExtMem V pr = let ($=âv, $çâv) = pr in
‹	Ãx y∑ if x ç V ± y ç V
‹	then Lub $ºâtâ4 {t |
‹		∂ v w∑ v ç V ± w ç V
‹		± (fTrue ºâtâ4 v =âv x ≤ v = x)
‹		± (fTrue ºâtâ4 w =âv y ≤ w = y)
‹		± t ºâtâ4 v çâv w}
‹	else x çâv y 
∞

=GFT
€extmem_increasing_lemma› =
   Ù µ V∑ Increasing (PbrO $ºâtâ4) (BrO $ºâtâ4) (ExtMem V)
=TEX

\ignore{
=SML
set_goal([], ¨µ V∑ Increasing (PbrO $ºâtâ4) (BrO $ºâtâ4) (ExtMem V)Æ);
a (rewrite_tac ((map get_spec [¨IncreasingÆ, ¨ExtMemÆ, ¨BrOÆ, ¨PwÆ])@[let_def])
	THEN REPEAT strip_tac);
a (asm_tac ºâtâ4_crpou_thm);
a (fc_tac [lub_increasing2_lemma3]);
a (CASES_T ¨≥ (x' ç V ± x'' ç V)Æ rewrite_thm_tac
	THEN1 (DROP_ASM_T ¨PbrO $ºâtâ4 x yÆ ante_tac THEN rewrite_tac [get_spec ¨PbrOÆ,
		get_spec ¨PrOÆ, get_spec¨BrOÆ, get_spec ¨PwÆ]
		THEN REPEAT strip_tac THEN asm_rewrite_tac[]));
a (bc_tac [asm_rule ¨µ x y∑ SetO2 $ºâtâ4 x y ¥ Lub $ºâtâ4 x ºâtâ4 Lub $ºâtâ4 yÆ]);
a (rewrite_tac [get_spec ¨SetO2Æ]);
a (strip_tac THEN STRIP_T (STRIP_THM_THEN (STRIP_THM_THEN asm_tac)));
a (∂_tac ¨Snd x v wÆ THEN asm_rewrite_tac[]);
a (∂_tac ¨vÆ THEN ∂_tac ¨wÆ THEN asm_rewrite_tac[]);
a (GET_NTH_ASM_T 4 ante_tac
	THEN rewrite_tac [get_spec ¨PbrOÆ, get_spec ¨PrOÆ, get_spec ¨BrOÆ,
	get_spec ¨PwÆ]
	THEN REPEAT strip_tac
	THEN_TRY asm_rewrite_tac[]);
(* *** Goal "1" *** *)
a (list_spec_nth_asm_tac 3 [¨vÆ, ¨x'Æ]);
a (lemma_tac ¨fTrue ºâtâ4 Fst x v x' ≤ v = x'Æ THEN1 asm_rewrite_tac[]);
a (all_asm_fc_tac [ºâtâ4_trans_thm]);
(* *** Goal "2" *** *)
a (list_spec_nth_asm_tac 3 [¨wÆ, ¨x''Æ]);
a (lemma_tac ¨fTrue ºâtâ4 Fst x w x'' ≤ w = x''Æ THEN1 asm_rewrite_tac[]);
a (all_asm_fc_tac [ºâtâ4_trans_thm]);
val extmem_increasing_lemma = save_pop_thm "extmem_increasing_lemma";
=IGN
set_goal([], ¨µ V∑ Upward (PbrO $ºâtâ4) (FunRight (ExtMem V))Æ);
a (rewrite_tac ((map get_spec [¨PbrOÆ, ¨PrOÆ, ¨BrOÆ, ¨UpwardÆ, ¨FunRightÆ,
			¨PwÆ, ¨ExtMemÆ])@[let_def]));
a (REPEAT strip_tac);
a (cases_tac ¨x' ç V ± x'' ç VÆ THEN asm_rewrite_tac[]);


=TEX
}%ignore

The combination of {\it ExtMem} with {\it EqMem} is:

πHOLCONST
‹ €ExtEqMem› : GS SET ≠ (GS, FTV) PR ≠ (GS, FTV) PR
˜¸¸¸¸¸¸¸¸¸¸¸
‹ µ V∑ ExtEqMem V = FunRight (ExtMem V) o FunLeft (EqRel V)
∞

=GFT
€exteqmem_increasing_lemma› =
   Ù µ V∑ Increasing (PbrO $ºâtâ4) (PbrO $ºâtâ4) (ExtEqMem V)
=TEX

\ignore{
=SML
set_goal([], ¨µV∑ Increasing (PbrO $ºâtâ4) (PbrO $ºâtâ4) (ExtEqMem V)Æ);
a (rewrite_tac [get_spec ¨ExtEqMemÆ] THEN REPEAT strip_tac);
a (bc_tac [increasing_funcomp_thm]);
a (∂_tac ¨PbrO $ºâtâ4Æ THEN rewrite_tac [get_spec ¨PbrOÆ] THEN strip_tac);
(* *** Goal "1" *** *)
a (bc_tac [funleft_increasing_thm]);
a (rewrite_tac [rewrite_rule [get_spec ¨PbrOÆ] eqrel_increasing_lemma]);
(* *** Goal "2" *** *)
a (bc_tac [funright_increasing_thm]);
a (rewrite_tac [rewrite_rule [get_spec ¨PbrOÆ] extmem_increasing_lemma]);
val exteqmem_increasing_lemma = save_pop_thm "exteqmem_increasing_lemma";
=TEX
}%ignore

Another property turns out to be useful (?) for which I don't know the proper name.

πHOLCONST
‹ €Upward› : ('a, BOOL) BR ≠ ('a ≠ 'a) ≠ BOOL
˜¸¸¸¸¸¸¸¸¸¸¸
‹ µ $<< f∑ Upward $<< f § µx∑ x << f x
∞

=GFT
=TEX

\ignore{
=IGN
set_goal([], ¨µV∑ Upward (PbrO $ºâtâ4) (ExtEqMem V)Æ);
a (rewrite_tac (map get_spec [¨UpwardÆ, ¨ExtEqMemÆ, ¨PbrOÆ, ¨PrOÆ,
	¨BrOÆ, ¨PwÆ, ¨FunRightÆ, ¨FunLeftÆ])
	THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a (rewrite_tac[get_spec ¨EqRelÆ, let_def]);
a (cases_tac ¨≥ x' ç V ≤ ≥ x'' ç VÆ THEN asm_rewrite_tac []);

=TEX
}%ignore

\subsection{The Semantic Functor}

We now define a monotone functor of which the least fixed point is a partial interpretation of set theory.

πHOLCONST
‹ €SemanticFunctor› : GS SET ≠ (GS, FTV) PR ≠ (GS, FTV) PR
˜¸¸¸¸¸¸¸¸¸¸¸
‹ µ V∑ SemanticFunctor V = (ExtEqMem V) o (FunRight (MemRel V))
∞

=GFT
€semanticfunctor_increasing_thm› =
   Ù µ V∑ Increasing (PbrO $ºâtâ4) (PbrO $ºâtâ4) (SemanticFunctor V)

€sf_lfp_lemma1› =
   Ù µ V
     ∑ IsLfp
         (PbrO $ºâtâ4)
         (SemanticFunctor V)
         (Lfpâc (PbrO $ºâtâ4) (SemanticFunctor V))

€sf_gfp_lemma1› =
   Ù µ V
     ∑ IsGfp
         (PbrO $ºâtâ4)
         (SemanticFunctor V)
         (Gfpâc (PbrO $ºâtâ4) (SemanticFunctor V))
=TEX

\ignore{
=SML
set_goal([], ¨µV∑ Increasing (PbrO $ºâtâ4) (PbrO $ºâtâ4) (SemanticFunctor V)Æ);
a (rewrite_tac [get_spec ¨SemanticFunctorÆ]
	THEN strip_tac THEN bc_tac [increasing_funcomp_thm]);
a (∂_tac ¨PbrO $ºâtâ4Æ THEN rewrite_tac [get_spec ¨PbrOÆ] THEN strip_tac);
(* *** Goal "1" *** *)
a (bc_tac [funright_increasing_thm]);
a (rewrite_tac [rewrite_rule [get_spec ¨PbrOÆ] memrel_increasing_lemma]);
(* *** Goal "2" *** *)
a (bc_tac [funleft_increasing_thm]);
a (rewrite_tac [rewrite_rule [get_spec ¨PbrOÆ] exteqmem_increasing_lemma]);
val semanticfunctor_increasing_thm = save_pop_thm "semanticfunctor_increasing_thm";

set_goal([], ¨µV∑ IsLfp (PbrO $ºâtâ4) (SemanticFunctor V)
			(Lfpâc (PbrO $ºâtâ4) (SemanticFunctor V))Æ);
a (strip_tac THEN bc_tac [crpou_increasing_lfp_lemma2]
	THEN rewrite_tac [pbro_ºâtâ4_crpou_thm, semanticfunctor_increasing_thm]);
val sf_lfp_lemma1 = pop_thm ();

set_goal([], ¨µV∑ IsGfp (PbrO $ºâtâ4) (SemanticFunctor V)
			(Gfpâc (PbrO $ºâtâ4) (SemanticFunctor V))Æ);
a (strip_tac THEN bc_tac [crpou_increasing_gfp_lemma2]
	THEN rewrite_tac [pbro_ºâtâ4_crpou_thm, semanticfunctor_increasing_thm]);
val sf_gfp_lemma1 = pop_thm ();
=TEX
}%ignore

\section{INFINITARILY DEFINABLE MEMBERSHIP STRUCTURES}

We are now able to identify and analyse a large class of interpretations of set theory.

Every fixedpoint of the semantic functor which is total, i.e. in which the equality and membership relations over the domain (the V parameter to the semantic functor) gives only true and false (not underdefined or overdefined) yields a membership structure in the usual sense, and this structure is extensional (i.e. satisfies the axiom of extensionality).

In order to define this class of structures it is necessary to prove some facts about total fixedpoints of the semantic functor.
We need to know first that the equality relation in such a fixed point will be an equivalence relation (the equivalence classes will be the elements in the domain of the structure).
This enables us to define the class of structures, and our next objective is to prove that they are indeed extensional.

From there we intend to proceed by identifying consistent constraints on the fixed points which effectively place lower bounds on the richness of the ontology and permit the proof of progressively stronger ontological principles, which may be thought of as an axiomatisation of a strong non-well-founded set theory.
In this way we seek to approach a maximal theory of comprehension, i.e. of sets construed as the extensions of properties.

First we define the notion of a total fixed point of the semantic functor, and then prove various properties of these fized points.

πHOLCONST
‹ €TotalOver› : 'a SET ≠ ('a, FTV)BR ≠ BOOL
˜¸¸¸¸¸¸¸¸¸¸¸
‹ µ V r∑ TotalOver V r § µx y∑
‹	if x ç V ± y ç V
‹	then r x y = fTrue ≤ r x y = fFalse
‹	else r x y = fB
∞

=GFT
=TEX

\ignore{
=IGN
set_goal([], ¨µV∑ Upward r f ¥ µx∑ TotalOver V (f x) ¥ Æ);

set_goal([], ¨µV pr∑ TotalOver V (ExtMem V pr) ¥
	µx y∑ x ç V ± y ç V ¥
		(ExtMem V x y § )Æ);


=TEX
}%ignore

πHOLCONST
‹ €PrTotalOver› : 'a SET ≠ ('a, FTV)PR ≠ BOOL
˜¸¸¸¸¸¸¸¸¸¸¸
‹ µ V pr∑ PrTotalOver V pr § TotalOver V (Fst pr) ± TotalOver V (Snd pr)
∞

=GFT
€total_upward_lemma1› =
   Ù µ V r f
     ∑ Upward (BrO $ºâtâ4) f ± TotalOver V r ± TotalOver V (f r)
         ¥ (µ x y∑ x ç V ± y ç V ¥ f r x y = r x y)
=TEX

\ignore{
=SML
set_goal([], ¨µV r f∑ Upward (BrO $ºâtâ4) f ± TotalOver V r ± TotalOver V (f r)
		¥ µx y∑ x ç V ± y ç V ¥ f r x y = r x yÆ);
a (rewrite_tac (map get_spec [¨UpwardÆ, ¨TotalOverÆ, ¨BrOÆ, ¨PwÆ]));
a (REPEAT strip_tac);
a (spec_nth_asm_tac 5 ¨rÆ);
a (LIST_SPEC_NTH_ASM_T 5 [¨xÆ, ¨yÆ]
	(strip_asm_tac o (rewrite_rule [asm_rule ¨x ç VÆ, asm_rule ¨y ç VÆ]))
	THEN LIST_SPEC_NTH_ASM_T 5 [¨xÆ, ¨yÆ]
		(strip_asm_tac o (rewrite_rule [asm_rule ¨x ç VÆ, asm_rule ¨y ç VÆ]))
	THEN_TRY asm_rewrite_tac[]);
(* *** Goal "1" *** *)
a (list_spec_nth_asm_tac 3 [¨xÆ, ¨yÆ]);
a (POP_ASM_T (strip_asm_tac o (rewrite_rule[asm_rule
	¨r x y = fTrueÆ, asm_rule ¨f r x y = fFalseÆ  ])));
(* *** Goal "2" *** *)
a (list_spec_nth_asm_tac 3 [¨xÆ, ¨yÆ]);
a (POP_ASM_T (strip_asm_tac o (rewrite_rule[asm_rule
	¨r x y = fFalseÆ, asm_rule ¨f r x y = fTrueÆ  ])));
val total_upward_lemma1 = pop_thm ();
=IGN

set_goal([], ¨µV pr f∑ PrTotalOver V pr ± Upward (PbrO $ºâtâ4) f ¥ f pr = prÆ);
a (rewrite_tac (map get_spec [¨PrTotalOverÆ, ¨UpwardÆ, ¨FunLeftÆ,
	¨FunRightÆ, ¨TotalOverÆ]));
a (REPEAT strip_tac);
a (SPEC_NTH_ASM_T 1 ¨prÆ ante_tac
	THEN rewrite_tac (map get_spec [¨PbrOÆ, ¨PrOÆ, ¨BrOÆ, ¨PwÆ])
	THEN strip_tac);
a (rewrite_tac [ext_thm]);
 ¥
	let ($=âv, $çâ) = pr in
	
Æ);

=TEX
}%ignore


πHOLCONST
‹ €SFFixp› : GS SET ∏ (GS, FTV)PR ≠ BOOL
˜¸¸¸¸¸¸¸¸¸¸¸
‹ µp∑ SFFixp p = SemanticFunctor (Fst p) (Snd p) = (Snd p)
∞

=GFT
=TEX


πHOLCONST
‹ €BoolRel› : (GS, FTV)BR ≠ (GS, BOOL)BR
˜¸¸¸¸¸¸¸¸¸¸¸
‹ µr∑ BoolRel r = Ãx y∑ r x y = fTrue
∞

=GFT
€eqrel_equiv_lemma› =
   Ù µ V pr∑ TotalOver V (EqRel V pr) ¥ Equiv (V, BoolRel (EqRel V pr))
=TEX

\ignore{
=SML
set_goal([], ¨µV pr∑ TotalOver V (EqRel V pr) ¥ Equiv (V, BoolRel (EqRel V pr))Æ);
a (PC_T1 "hol1" rewrite_tac [get_spec ¨TotalOverÆ, get_spec ¨BoolRelÆ, get_spec ¨EquivÆ]
	THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a (rewrite_tac [get_spec ¨ReflÆ, eqrel_refl_lemma]);
(* *** Goal "2" *** *)
a (rewrite_tac [get_spec ¨SymÆ] THEN REPEAT strip_tac);
a (POP_ASM_T ante_tac);
a (ALL_FC_T rewrite_tac [eqrel_sym_lemma]);
(* *** Goal "3" *** *)
a (rewrite_tac [get_spec ¨TransÆ] THEN REPEAT strip_tac);
a (all_asm_fc_tac [eqrel_trans_lemma]);
val eqrel_equiv_lemma = pop_thm ();
=IGN

set_goal([], ¨µV r $=âv∑ PrTotalOver V ($=âv, r) ± Equiv (V, BoolRel $=âv)
	¥ ((BoolRel (ExtMem V ($=âv, r))) Respects (BoolRel $=âv)) VÆ);
a (rewrite_tac (map get_spec [¨PrTotalOverÆ, ¨TotalOverÆ, ¨$RespectsÆ, ¨ExtMemÆ, ¨BoolRelÆ]));
a (REPEAT strip_tac);
a (asm_rewrite_tac [ext_thm, let_def]);
a (strip_tac);
a (LEMMA_T ¨{t
                     |x' ç V
                         ± (∂ v w
                         ∑ v ç V
                             ± w ç V
                             ± fTrue ºâtâ4 v =âv x
                             ± fTrue ºâtâ4 w =âv x'
                             ± t ºâtâ4 r v w)}
  =
{t
                     |x' ç V
                         ± (∂ v w
                         ∑ v ç V
                             ± w ç V
                             ± fTrue ºâtâ4 v =âv y
                             ± fTrue ºâtâ4 w =âv x'
                             ± t ºâtâ4 r v w)}Æ rewrite_thm_tac);
a (rewrite_tac [sets_ext_clauses]
	THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a (∂_tac ¨vÆ THEN ∂_tac ¨wÆ THEN asm_rewrite_tac[]);

a (LEMMA_T ¨Æ
=TEX
}%ignore

=GFT
€eqrel_totalmem_extensional_lemma› =
   Ù µ V $=âv $çâv
     ∑ TotalOver V $çâv
         ¥ (µ x y
         ∑ x ç V ± y ç V
             ¥ EqRel V ($=âv, $çâv) x y
               = (if µ z∑ z ç V ¥ z çâv x = z çâv y then fTrue else fFalse))
=TEX

\ignore{
=SML
set_goal([], ¨µV $=âv $çâv∑ TotalOver V $çâv ¥
	µx y∑ x ç V ± y ç V ¥ EqRel V ($=âv, $çâv) x y =
		if µz∑ z ç V ¥ z çâv x = z çâv y
		then fTrue
		else fFalseÆ);
a (REPEAT µ_tac THEN rewrite_tac [get_spec ¨EqRelÆ,
	get_spec ¨PrTotalOverÆ, let_def]
	THEN REPEAT strip_tac);
a (asm_tac (rewrite_rule [get_spec ¨TotalOverÆ] (asm_rule ¨TotalOver V $çâvÆ)));
a (cases_tac ¨x=yÆ THEN_TRY asm_rewrite_tac[]);
a (LEMMA_T ¨≥ ∂ x'∑ x' ç V ± (x' çâv x = fT ≤ x' çâv y = fT)Æ rewrite_thm_tac
	THEN1 REPEAT_N 3 strip_tac);
(* *** Goal "1" *** *)
a strip_tac;
a (cases_tac ¨x' ç VÆ THEN asm_rewrite_tac[]);
a (LIST_SPEC_NTH_ASM_T 3 [¨x'Æ, ¨yÆ]
		(strip_asm_tac o (rewrite_rule [asm_rule ¨x' ç VÆ, asm_rule ¨y ç VÆ]))
	THEN asm_rewrite_tac[]
	THEN LIST_SPEC_NTH_ASM_T 4 [¨x'Æ, ¨xÆ]
		(strip_asm_tac o (rewrite_rule [asm_rule ¨x' ç VÆ, asm_rule ¨x ç VÆ]))
	THEN asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a (CASES_T ¨µ z∑ z ç V ¥ z çâv x = z çâv yÆ
	(fn x => TRY (rewrite_thm_tac x) THEN strip_asm_tac x));
(* *** Goal "2.1" *** *)
a (LEMMA_T ¨≥ ∂ x'∑ x' ç V ± (x' çâv x = fB ≤ x' çâv y = fB)Æ rewrite_thm_tac
	THEN1 REPEAT_N 4 strip_tac);
(* *** Goal "2.1.1" *** *)
a (cases_tac ¨x' ç VÆ THEN asm_rewrite_tac[]);
a (LIST_SPEC_NTH_ASM_T 4 [¨x'Æ, ¨yÆ]
		(strip_asm_tac o (rewrite_rule [asm_rule ¨x' ç VÆ, asm_rule ¨y ç VÆ]))
	THEN asm_rewrite_tac[]
	THEN LIST_SPEC_NTH_ASM_T 5 [¨x'Æ, ¨xÆ]
		(strip_asm_tac o (rewrite_rule [asm_rule ¨x' ç VÆ, asm_rule ¨x ç VÆ]))
	THEN asm_rewrite_tac[]);
(* *** Goal "2.1.2" *** *)
a (LEMMA_T ¨≥∂ x'
                 ∑ x' ç V
                     ± (x' çâv x = fTrue ± x' çâv y = fFalse
                       ≤ x' çâv y = fTrue ± x' çâv x = fFalse)Æ
	rewrite_thm_tac);
a (REPEAT_N 3 strip_tac);
a (cases_tac ¨x' ç VÆ THEN asm_rewrite_tac[]);
a (SPEC_NTH_ASM_T 2 ¨x'Æ
		(strip_asm_tac o (rewrite_rule [asm_rule ¨x' ç VÆ, asm_rule ¨y ç VÆ]))
	THEN asm_rewrite_tac[]);
a (LIST_SPEC_NTH_ASM_T 5 [¨x'Æ, ¨yÆ]
		(strip_asm_tac o (rewrite_rule [asm_rule ¨x' ç VÆ, asm_rule ¨y ç VÆ]))
	THEN asm_rewrite_tac[]);
(* *** Goal "2.2" *** *)
a (LEMMA_T ¨≥ ∂ x'∑ x' ç V ± (x' çâv x = fB ≤ x' çâv y = fB)Æ rewrite_thm_tac
	THEN1 REPEAT_N 3 strip_tac);
(* *** Goal "2.2.1" *** *)
a strip_tac;
a (cases_tac ¨x' ç VÆ THEN asm_rewrite_tac[]);
a (LIST_SPEC_NTH_ASM_T 5 [¨x'Æ, ¨yÆ]
		(strip_asm_tac o (rewrite_rule [asm_rule ¨x' ç VÆ, asm_rule ¨y ç VÆ]))
	THEN asm_rewrite_tac[]
	THEN LIST_SPEC_NTH_ASM_T 6 [¨x'Æ, ¨xÆ]
		(strip_asm_tac o (rewrite_rule [asm_rule ¨x' ç VÆ, asm_rule ¨x ç VÆ]))
	THEN asm_rewrite_tac[]);
(* *** Goal "2.2.2" *** *)
a (LEMMA_T ¨∂ x'
                 ∑ x' ç V
                     ± (x' çâv x = fTrue ± x' çâv y = fFalse
                       ≤ x' çâv y = fTrue ± x' çâv x = fFalse)Æ
	rewrite_thm_tac);
a (∂_tac ¨zÆ THEN asm_rewrite_tac[]);
a (LIST_SPEC_NTH_ASM_T 4 [¨zÆ, ¨yÆ]
		(strip_asm_tac o (rewrite_rule [asm_rule ¨z ç VÆ, asm_rule ¨y ç VÆ]))
	THEN asm_rewrite_tac[]
	THEN LIST_SPEC_NTH_ASM_T 5 [¨zÆ, ¨xÆ]
		(strip_asm_tac o (rewrite_rule [asm_rule ¨z ç VÆ, asm_rule ¨x ç VÆ]))
	THEN asm_rewrite_tac[]
	THEN (DROP_ASM_T ¨≥ z çâv x = z çâv yÆ ante_tac)
	THEN asm_rewrite_tac[]);
val eqrel_totalmem_extensional_lemma = pop_thm ();
=IGN

set_goal([], ¨µV $=âv $çâv∑ PrTotalOver V ($=âv, $çâv) ¥
	µx y v  w∑ x ç V ± y ç V ± v ç V ± w ç V ± fTrue ºâtâ4 x =âv v ± fTrue ºâtâ4 y =âv w
		¥ (fTrue ºâtâ4 ExtMem V ($=âv, $çâv) x y § fTrue ºâtâ4 ExtMem V ($=âv, $çâv) v w)Æ);
a (REPEAT µ_tac THEN rewrite_tac [get_spec ¨ExtMemÆ,
	get_spec ¨PrTotalOverÆ, let_def]
	THEN REPEAT_N 6 strip_tac);
(* *** Goal "1" *** *)
a (asm_tac (rewrite_rule [get_spec ¨TotalOverÆ] (asm_rule ¨TotalOver V $çâvÆ)));
a (cases_tac ¨x=yÆ THEN_TRY asm_rewrite_tac[]);
a (LEMMA_T ¨≥ ∂ x'∑ x' ç V ± (x' çâv x = fT ≤ x' çâv y = fT)Æ rewrite_thm_tac
	THEN1 REPEAT_N 3 strip_tac);
(* *** Goal "1" *** *)
a strip_tac;
a (cases_tac ¨x' ç VÆ THEN asm_rewrite_tac[]);
a (list_spec_nth_asm_tac 3 [¨x'Æ, ¨yÆ]
	THEN asm_rewrite_tac[]
	THEN list_spec_nth_asm_tac 4 [¨x'Æ, ¨xÆ]
	THEN asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a (CASES_T ¨µ z∑ z ç V ¥ z çâv x = z çâv yÆ
	(fn x => TRY (rewrite_thm_tac x) THEN strip_asm_tac x));
(* *** Goal "2.1" *** *)
a (LEMMA_T ¨≥ ∂ x'∑ x' ç V ± (x' çâv x = fB ≤ x' çâv y = fB)Æ rewrite_thm_tac
	THEN1 REPEAT_N 4 strip_tac);
(* *** Goal "2.1.1" *** *)
a (cases_tac ¨x' ç VÆ THEN asm_rewrite_tac[]);
a (list_spec_nth_asm_tac 4 [¨x'Æ, ¨xÆ]
	THEN asm_rewrite_tac []
	THEN list_spec_nth_asm_tac 5 [¨x'Æ, ¨yÆ]
	THEN asm_rewrite_tac []);
(* *** Goal "2.1.2" *** *)
a (LEMMA_T ¨≥∂ x'
                 ∑ x' ç V
                     ± (x' çâv x = fTrue ± x' çâv y = fFalse
                       ≤ x' çâv y = fTrue ± x' çâv x = fFalse)Æ
	rewrite_thm_tac);
a (REPEAT_N 3 strip_tac);
a (cases_tac ¨x' ç VÆ THEN asm_rewrite_tac[]);
a (spec_nth_asm_tac 2 ¨x'Æ THEN asm_rewrite_tac[]);
a (list_spec_nth_asm_tac 5 [¨x'Æ, ¨yÆ] THEN asm_rewrite_tac[]);
(* *** Goal "2.2" *** *)
a (LEMMA_T ¨≥ ∂ x'∑ x' ç V ± (x' çâv x = fB ≤ x' çâv y = fB)Æ rewrite_thm_tac
	THEN1 REPEAT_N 3 strip_tac);
(* *** Goal "2.2.1" *** *)
a strip_tac;
a (cases_tac ¨x' ç VÆ THEN asm_rewrite_tac[]);
a (list_spec_nth_asm_tac 5 [¨x'Æ, ¨yÆ]
	THEN asm_rewrite_tac[]
	THEN list_spec_nth_asm_tac 6 [¨x'Æ, ¨xÆ]
	THEN asm_rewrite_tac[]);
(* *** Goal "2.2.2" *** *)
a (LEMMA_T ¨∂ x'
                 ∑ x' ç V
                     ± (x' çâv x = fTrue ± x' çâv y = fFalse
                       ≤ x' çâv y = fTrue ± x' çâv x = fFalse)Æ
	rewrite_thm_tac);
a (∂_tac ¨zÆ THEN asm_rewrite_tac[]);
a (list_spec_nth_asm_tac 4 [¨zÆ, ¨yÆ]
	THEN asm_rewrite_tac[]
	THEN list_spec_nth_asm_tac 5 [¨zÆ, ¨xÆ]
	THEN asm_rewrite_tac[]
	THEN (DROP_ASM_T ¨≥ z çâv x = z çâv yÆ ante_tac)
	THEN asm_rewrite_tac[]);
val eqrel_totalmem_extensional_lemma = pop_thm ();
=TEX
}%ignore

πHOLCONST
‹ €SFTotalFixp› : GS SET ∏ (GS, FTV)PR ≠ BOOL
˜¸¸¸¸¸¸¸¸¸¸¸
‹ µp∑ SFTotalFixp p § SFFixp p ± PrTotalOver (Fst p) (Snd p)
∞

=GFT
=TEX

\ignore{
=IGN
set_goal([], ¨Æ);


=TEX
}%ignore

\subsubsection{Extensionality of Equality}

For our purposes it is helpful to define the following notion of extensionality which applies to functions which operate on four-valued membership relations and yield four-valued relations.

The idea is that a function is extensional if its value for any pair of elements depends only on the extension of the two elements.
Since we are working with four truth values, the extensions under consideration are not sets, they are four-valued characteristic functions.
However, if the characteristic functions yield the undefined truth value anywhere in the domain under consideration, they are not really knowm to be equal so we require that these characteristic functions are everywhere defined (or overdefined).


πHOLCONST
‹ €FtvExtensional› : 'a SET ≠ (('a, FTV) BR ≠ ('a, FTV) BR) ≠ BOOL
˜¸¸¸¸¸¸¸¸¸¸¸
‹ µ V f∑ FtvExtensional V f = µ$çâv x y z∑ x ç V ± y ç V ± z ç V
‹	± TotalOver V $çâv ± (µv∑ v ç V ¥ v çâv x = v çâv y)
‹	¥ f $çâv x z = f $çâv y z ± f $çâv z x = f $çâv z y
∞

We now show that {\it EqRel} is in this sense extensional.

=GFT
€eqrel_ftvextensional_lemma› =
   Ù µ V $=âv∑ FtvExtensional V (Ã $çâv∑ EqRel V ($=âv, $çâv))
=TEX

\ignore{
=SML
set_goal([], ¨µV $=âv∑ FtvExtensional V (Ã$çâv∑ EqRel V ($=âv, $çâv))Æ);
a (rewrite_tac [get_spec ¨FtvExtensionalÆ, let_def]
	THEN REPEAT_N 8 strip_tac);
(* *** Goal "1" *** *)
a (strip_asm_tac (list_µ_elim [¨VÆ, ¨$=âvÆ, ¨$çâvÆ] eqrel_totalmem_extensional_lemma));
a (list_spec_nth_asm_tac 1 [¨xÆ, ¨zÆ]);
a (list_spec_nth_asm_tac 2 [¨yÆ, ¨zÆ]);
a (asm_rewrite_tac[]);
a (CASES_T ¨µ z'∑ z' ç V ¥ z' çâv x = z' çâv zÆ asm_tac
	THEN_TRY asm_rewrite_tac[]);
(* *** Goal "1.1" *** *)
a (LEMMA_T ¨µ z'∑ z' ç V ¥ z' çâv y = z' çâv zÆ rewrite_thm_tac
	THEN1 REPEAT strip_tac THEN ASM_FC_T (fn tl => TRY (rewrite_tac tl)) []);
a (spec_nth_asm_tac 2 ¨z'Æ THEN POP_ASM_T ante_tac);
a (spec_nth_asm_tac 6 ¨z'Æ THEN POP_ASM_T rewrite_thm_tac);
(* *** Goal "1.2" *** *)
a (LEMMA_T ¨≥ µ z'∑ z' ç V ¥ z' çâv y = z' çâv zÆ rewrite_thm_tac
	THEN1 REPEAT strip_tac THEN ASM_FC_T (fn tl => TRY (rewrite_tac tl)) []);
a (POP_ASM_T strip_asm_tac);
a (∂_tac ¨z'Æ THEN asm_rewrite_tac[]);
a (swap_nth_asm_concl_tac 1);
a (spec_nth_asm_tac 6 ¨z'Æ THEN asm_rewrite_tac []);
(* *** Goal "2" *** *)
a (strip_asm_tac (list_µ_elim [¨VÆ, ¨$=âvÆ, ¨$çâvÆ] eqrel_totalmem_extensional_lemma));
a (list_spec_nth_asm_tac 1 [¨zÆ, ¨xÆ]);
a (list_spec_nth_asm_tac 2 [¨zÆ, ¨yÆ]);
a (asm_rewrite_tac[]);
a (CASES_T ¨µ z'∑ z' ç V ¥ z' çâv z = z' çâv xÆ asm_tac
	THEN_TRY asm_rewrite_tac[]);
(* *** Goal "2.1" *** *)
a (LEMMA_T ¨µ z'∑ z' ç V ¥ z' çâv z = z' çâv yÆ rewrite_thm_tac
	THEN1 REPEAT strip_tac THEN ASM_FC_T (fn tl => TRY (rewrite_tac tl)) []);
(* *** Goal "2.2" *** *)
a (LEMMA_T ¨≥ µ z'∑ z' ç V ¥ z' çâv z = z' çâv yÆ rewrite_thm_tac
	THEN1 REPEAT strip_tac THEN ASM_FC_T (fn tl => TRY (rewrite_tac tl)) []);
a (POP_ASM_T strip_asm_tac);
a (∂_tac ¨z'Æ THEN asm_rewrite_tac[]);
a (swap_nth_asm_concl_tac 1);
a (spec_nth_asm_tac 6 ¨z'Æ THEN asm_rewrite_tac []);
val eqrel_ftvextensional_lemma = pop_thm ();
=TEX
}%ignore


=GFT
€totalfixp_extensional_lemma› =
   Ù µ V eq mem $=âv $çâv
     ∑ SFTotalFixp (V, eq, mem)
         ¥ (let $=âv = BoolRel eq and $çâv = BoolRel mem
         in µ x y
         ∑ x ç V ± y ç V ¥ (x =âv y § (µ z∑ z ç V ¥ (z çâv x § z çâv y))))
=TEX

\ignore{
=IGN
set_goal([], ¨µV eq mem∑ SFTotalFixp (V, eq, mem) ¥
	let $=âv = BoolRel eq and $çâv = BoolRel mem
	in µx y∑ x ç V ± y ç V ¥ (x =âv y ¥ µz∑ z ç V ¥ (z çâv x § z çâv y))Æ);


set_goal([], ¨µV eq mem∑ SFTotalFixp (V, eq, mem) ¥
	let $=âv = BoolRel eq and $çâv = BoolRel mem
	in µx y∑ x ç V ± y ç V ¥ (x =âv y § µz∑ z ç V ¥ (z çâv x § z çâv y))Æ);
a (rewrite_tac (map get_spec [¨SFTotalFixpÆ, ¨BoolRelÆ, ¨SFFixpÆ, ¨SemanticFunctorÆ,
	¨FunLeftÆ, ¨FunRightÆ]));
a (rewrite_tac [let_def]);
a (REPEAT strip_tac);
(* *** Goal "1" *** *)
a (ante_tac (list_µ_elim [¨VÆ, ¨(eq, mem)Æ, ¨x'Æ, ¨yÆ] eqrel_ftrue_lemma));
a (asm_rewrite_tac[]);
a (strip_tac);
(* *** Goal "1.1" *** *)
a (var_elim_asm_tac ¨x' = yÆ);
(* *** Goal "1.2" *** *)
a (SPEC_NTH_ASM_T 1 ¨zÆ ante_tac);
a (rewrite_tac[]);
a (strip_tac);
a (DROP_NTH_ASM_T 2 ante_tac THEN asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a (ante_tac (list_µ_elim [¨VÆ, ¨(eq, mem)Æ, ¨x'Æ, ¨yÆ] eqrel_ftrue_lemma));
a (asm_rewrite_tac[]);
a (strip_tac);
(* *** Goal "2.1" *** *)
a (var_elim_asm_tac ¨x' = yÆ);
(* *** Goal "2.2" *** *)
a (SPEC_NTH_ASM_T 1 ¨zÆ ante_tac);
a (rewrite_tac[]);
a (strip_tac);
a (DROP_NTH_ASM_T 1 ante_tac THEN asm_rewrite_tac[]);
(* *** Goal "3" *** *)
a (ante_tac (list_µ_elim [¨VÆ, ¨(eq, mem)Æ, ¨x'Æ, ¨yÆ] eqrel_ftrue_lemma));
a (asm_rewrite_tac[]);
a (STRIP_T rewrite_thm_tac);
a (REPEAT_N 4 strip_tac);
a (fc_tac [get_spec ¨PrTotalOverÆ]);
a (fc_tac [get_spec ¨TotalOverÆ]);
a (SPEC_NTH_ASM_T 7 ¨zÆ (rewrite_thm_tac o (rewrite_rule [asm_rule ¨z ç VÆ])));
a (DROP_NTH_ASM_T 2 (asm_tac o (rewrite_rule[])));
a (lemma_tac ¨mem z y = fFalse ≤ mem z y = fTrueÆ
	THEN1 (LIST_SPEC_NTH_ASM_T 1 [¨zÆ, ¨yÆ] ante_tac
		THEN rewrite_tac [asm_rule ¨z ç VÆ, asm_rule ¨y ç VÆ]
		THEN prove_tac[])
	THEN asm_rewrite_tac[]);
a (lemma_tac ¨mem z x' = fFalse ≤ mem z x' = fTrueÆ
	THEN1 (LIST_SPEC_NTH_ASM_T 2 [¨zÆ, ¨x'Æ] ante_tac
		THEN rewrite_tac [asm_rule ¨z ç VÆ, asm_rule ¨x' ç VÆ]
		THEN prove_tac[])
	THEN asm_rewrite_tac[]);
a (all_asm_fc_tac[]);
a (POP_ASM_T ante_tac THEN asm_rewrite_tac[]);
val totalfixp_extensional_lemma = save_pop_thm "totalfixp_extensional_lemma";

=IGN
set_goal([], ¨µV eq mem $=âv $çâv∑ SFTotalFixp (V, eq, mem) ¥
	let $=âv = BoolRel eq and $çâv = BoolRel mem
	in µx y∑ x ç V ± y ç V ¥ (x =âv y ¥ µz∑ z ç V ¥ (x çâv z § y çâv z))Æ);
a (rewrite_tac (map get_spec [¨SFTotalFixpÆ, ¨BoolRelÆ, ¨SFFixpÆ, ¨SemanticFunctorÆ,
	¨FunLeftÆ, ¨FunRightÆ, ¨ExtEqMemÆ, ¨ExtMemÆ]));
a (rewrite_tac [let_def]);
a (REPEAT_N 4 strip_tac);
a (DROP_NTH_ASM_T 2 (asm_tac o (rewrite_rule[asm_rule ¨EqRel V (eq, mem) = eqÆ])));
(* *** Goal "1" *** *)
a (ante_tac (list_µ_elim [¨VÆ, ¨(eq, mem)Æ, ¨x'Æ, ¨yÆ] eqrel_ftrue_lemma));
a (asm_rewrite_tac[]);
a (strip_tac);
(* *** Goal "1.1" *** *)
a (var_elim_asm_tac ¨x' = yÆ);
(* *** Goal "1.2" *** *)
a (SPEC_NTH_ASM_T 1 ¨zÆ ante_tac);
a (rewrite_tac[]);
a (strip_tac);
(* *** Goal "1.2.1" *** *)
a (DROP_NTH_ASM_T 3 (asm_tac o (rewrite_rule[])));

=TEX
}%ignore

πHOLCONST
‹ €MSfromSFF› : GS SET ∏ (GS, FTV) PR ≠ GS SET SET ∏ (GS SET, BOOL) BR
˜¸¸¸¸¸¸¸¸¸¸¸
‹ µ (V:GS SET) (pr:(GS, FTV) PR)∑ MSfromSFF (V, pr) =
‹	let ($=âv, $çâv) = (BoolRel (Fst pr), BoolRel (Snd pr)) in
‹	(QuotientSet V $=, Ãs t∑ µx y∑ x ç s ± y ç t ¥ x çâv y)		 
∞

=GFT
=TEX

=SML
new_parent "membership";
=TEX

\ignore{
=IGN
set_goal([], ¨µ(V, $=âv, $çâv)∑ SFFixp (V, ($=âv, $çâv)) ± PrTotalOver V ($=âv, $çâv)
		¥ extensional (MSfromSFF (V, ($=âv, $çâv)))Æ);
a (rewrite_tac [let_def, get_spec ¨SFFixpÆ, get_spec ¨MSfromSFFÆ, get_spec ¨extensionalÆ,
	get_spec ¨BoolRelÆ, get_spec ¨PrTotalOverÆ]
	THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a (var_elim_asm_tac ¨s = tÆ);
a (all_asm_fc_tac[]);
(* *** Goal "2" *** *)
a (var_elim_asm_tac ¨s = tÆ);
a (all_asm_fc_tac[]);
(* *** Goal "3" *** *)
a (DROP_NTH_ASM_T 5 ante_tac THEN rewrite_tac [sets_ext_clauses] THEN strip_tac);
a (DROP_NTH_ASM_T 5 ante_tac THEN rewrite_tac [sets_ext_clauses] THEN strip_tac);
a (strip_tac);
a (swap_nth_asm_concl_tac 6);
a (rewrite_tac (map get_spec [¨SemanticFunctorÆ, ¨FunLeftÆ, ¨FunRightÆ, ¨MemRelÆ, ¨EqRelÆ]));
eqrel_ftrue_lemma;

=TEX
}%ignore


\subsubsection{Proof Contexts}

=SML
add_pc_thms "'ifol" [];
commit_pc "'ifol";

force_new_pc "€ifol›";
merge_pcs ["hol", "'GS1", "'ifol"] "ifol";
commit_pc "ifol";

force_new_pc "€ifol1›";
merge_pcs ["hol1", "'GS1", "'ifol"] "ifol1";
commit_pc "ifol1";
=TEX

{\let\Section\section
\newcounter{ThyNum}
\def\section#1{\Section{#1}
\addtocounter{ThyNum}{1}\label{Theory\arabic{ThyNum}}}
\include{ifol.th}
}  %\let

\twocolumn[\section{INDEX}\label{index}]
{\small\printindex}

\end{document}
