=IGN
$Id: t024.doc,v 1.2 2007/12/01 15:53:40 rbj01 Exp $
open_theory "ifol";
set_merge_pcs ["hol1", "'GS1", "'ifol"];
=TEX
\documentclass[11pt,a4paper]{article}
\usepackage{latexsym}
\usepackage{ProofPower}
\ftlinepenalty=9999
\usepackage{A4}

%\def\ExpName{\mbox{{\sf exp}
%\def\Exp#1{\ExpName(#1)}

\tabstop=0.4in
\newcommand{\ignore}[1]{}

\title{Infinitarily Definable Non-Well-Founded Sets}
\makeindex
\usepackage[unicode,pdftex]{hyperref}
\hypersetup{pdfauthor={Roger Bishop Jones}}
\hypersetup{colorlinks=true, urlcolor=black, citecolor=black, filecolor=black, linkcolor=black}

\author{Roger Bishop Jones}
\date{\ }

\begin{document}
\begin{titlepage}
\maketitle
\begin{abstract}
This paper is my second approach to set theory conceived as a maximal consistent theory of set comprehension.
The principle innovation in this version is to simplify the syntax by removing comprehension, so that the syntactic category of term is no longer required.
\end{abstract}

\vfill

\begin{centering}

{\footnotesize

Created: 2006/11/29

Last Change $ $Date: 2007/12/01 15:53:40 $ $

\href{http://www.rbjones.com/rbjpub/pp/doc/t021.pdf}
{http://www.rbjones.com/rbjpub/pp/doc/t021.pdf}

$ $Id: t024.doc,v 1.2 2007/12/01 15:53:40 rbj01 Exp $ $

\copyright\ Roger Bishop Jones; Licenced under Gnu LGPL

}%footnotesize

\end{centering}

\thispagestyle{empty}
\end{titlepage}
\newpage
\addtocounter{page}{1}
%\section{DOCUMENT CONTROL}
%\subsection{Contents list}
{\parskip=0pt\tableofcontents}
%\newpage
%\subsection{Document cross references}

\subsection*{To Do}
\begin{itemize}
\item 
\item 
\end{itemize}

{\raggedright
\bibliographystyle{fmu}
\bibliography{rbj,fmu}
} %\raggedright

\newpage
\section{INTRODUCTION}

See t021 for previous discussion.
I will put something better here if it works out.

=SML
open_theory "GS";
force_new_theory "€ifol›";
new_parent "U_orders";
force_new_pc "€'ifol›";
merge_pcs ["'savedthm_cs_∂_proof"] "'ifol";
set_merge_pcs ["hol1", "'GS1", "'ifol"];
=TEX

\section{MISCELLANEA}

\newpage
\section{INFINITARY LOGIC}
\subsection{Syntax}

\subsubsection{Constructors, Discriminators and Destructors}

Preliminary to presenting the inductive definition of the required classes we define the nuts and bolts operations on the required syntactic entities (some of which will be used in the inductive definition).

A constructor puts together some syntactic entity from its constituents, discriminators distinguist between the different kinds of entity and destructors take them apart.


``Atomic'' formulae consist of a relation name together with an indexed collection of arguments.
The relation name may be any set.
The indexed set of arguments is any set which is a function, i.e. a many-one relation represented as a set of (Wiener-Kuratovski) ordered pairs.
The distinction between atomic and compound formulae is made by tagging the former with the ordinal zero and the latter with the ordinal 1, a tagged value in this  case being an ordered pair of which the left element is the tag and the right element is the value.


πHOLCONST
‹ €MkAf› : GS ∏ GS ≠ GS
˜¸¸¸¸¸¸¸¸¸¸¸
‹ µlr∑ MkAf lr = (Natâg 0) Ìâg ((Fst lr) Ìâg (Snd lr))
∞

πHOLCONST
‹ €IsAf› : GS ≠ BOOL
˜¸¸¸¸¸¸¸¸¸¸¸
‹    µt∑ IsAf t = fst t = (Natâg 0)
∞

πHOLCONST
‹ €AfRel› : GS ≠ GS
˜¸¸¸¸¸¸¸¸¸¸¸
‹  AfRel = Ãx∑ fst(snd x)
∞

πHOLCONST
‹ €AfPars› : GS ≠ GS
˜¸¸¸¸¸¸¸¸¸¸¸
‹  AfPars = Ãx∑ snd(snd x)
∞

πHOLCONST
‹ €MkCf› : GS ∏ GS ≠ GS
˜¸¸¸¸¸¸¸¸¸¸¸
‹ µvc∑ MkCf vc = (Natâg 1) Ìâg ((Fst vc) Ìâg (Snd vc))
∞

πHOLCONST
‹ €IsCf› : GS ≠ BOOL
˜¸¸¸¸¸¸¸¸¸¸¸
‹    µt∑ IsCf t = fst t = (Natâg 1)
∞

πHOLCONST
‹ €CfVars› : GS ≠ GS
˜¸¸¸¸¸¸¸¸¸¸¸
‹  CfVars = Ãx∑ fst(snd x)
∞

πHOLCONST
‹ €CfForms› : GS ≠ GS
˜¸¸¸¸¸¸¸¸¸¸¸
‹  CfForms = Ãx∑ snd(snd x)
∞

=GFT
€Is_clauses› =
   Ù (µ x∑ IsAf (MkAf x))
       ± (µ x∑ ≥ IsAf (MkCf x))
       ± (µ x∑ ≥ IsCf (MkAf x))
       ± (µ x∑ IsCf (MkCf x))

€Is_not_fc_clauses› =
   Ù (µ x∑ IsAf x ¥ ≥ IsCf x) ± (µ x∑ IsCf x ¥ ≥ IsAf x)
=TEX

\ignore{
=SML
set_goal([], ¨(µx∑ IsAf (MkAf x))
	± (µx∑ ≥ IsAf (MkCf x))
	± (µx∑ ≥ IsCf (MkAf x))
	± (µx∑ IsCf (MkCf x))
	Æ);
a (rewrite_tac [get_spec ¨IsAfÆ,
	get_spec ¨MkAfÆ,
	get_spec ¨IsCfÆ,
	get_spec ¨MkCfÆ]);
a (contr_tac THEN FC_T (MAP_EVERY ante_tac) [natg_one_one_thm] 
	THEN PC_T1 "lin_arith" prove_tac[]);
val Is_clauses = pop_thm();

add_pc_thms "'ifol" (map get_spec [] @ [ord_nat_thm, Is_clauses]);
set_merge_pcs ["hol1", "'GS1", "'ifol"];

set_goal ([], ¨
	(µx∑ IsAf x ¥ ≥ IsCf x)
±	(µx∑ IsCf x ¥ ≥ IsAf x)
Æ);
a (rewrite_tac (map get_spec [¨IsAfÆ, ¨IsCfÆ]));
a (REPEAT strip_tac THEN asm_rewrite_tac[]
	THEN contr_tac THEN FC_T (MAP_EVERY ante_tac) [natg_one_one_thm]
	THEN PC_T1 "lin_arith" rewrite_tac[]);
val Is_not_fc_clauses = save_pop_thm "Is_not_fc_clauses";
=TEX

}%ignore

Some derived syntax:

πHOLCONST
‹ €MkNot› : GS ≠ GS
˜¸¸¸¸¸¸¸¸¸¸¸
‹ µf∑ MkNot f = MkCf (öâg, Pair f f)
∞

\subsubsection{The Inductive Definition of Syntax}

This is accomplished by defining the required closure condition (closure under the above constructors for arguments of the right kind) and then taking the intersection of all sets which satisfy the closure condition.

The closure condition is:

πHOLCONST
‹ €RepClosed›: GS SET ≠ BOOL
˜¸¸¸¸¸¸¸¸¸¸¸
‹ µ s∑ RepClosed s §
‹	(µ n is∑ fun is ¥ MkAf (n, is) ç s)
‹±	(µ vars fs∑ Xâg fs Ä s ¥ MkCf (vars, fs) ç s)
∞

The well-formed syntax is then the smallest set closed under these constructions.

πHOLCONST
‹ €Syntax› : GS SET
˜¸¸¸¸¸¸¸¸¸¸¸
‹ Syntax = •{x | RepClosed x}
∞

=GFT
€syntax_Ä_repclosed_thm› =
	Ù µ s∑ RepClosed s ¥ Syntax Ä s
=TEX

\ignore{
=SML
set_goal([], ¨µs∑ RepClosed s ¥ Syntax Ä sÆ);
a (rewrite_tac [get_spec ¨SyntaxÆ]
	THEN REPEAT strip_tac THEN asm_fc_tac[]);
val syntax_Ä_repclosed_thm = pop_thm ();
=TEX
}%ignore

This is an ``inductive datatype'' so we should expect the usual kinds of theorems.

Informally these should say:

\begin{itemize}
\item Syntax is closed under the two constructors.
\item The syntax constructors are injections, have disjoint ranges, and partition the syntax. 
\item Any syntactic property which is preserved by the constructors (i.e. is true of any construction if it is true of all its syntactic constituents) is true of everything in syntax (this is an induction principle).
\end{itemize}

=GFT
€repclosed_syntax_lemma› =
	Ù RepClosed Syntax

€repclosed_syntax_thm› =
	Ù (µ n is∑ fun is ¥ MkAf (n, is) ç Syntax)
       ± (µ vars fs
       ∑ (µ x∑ x ç Xâg fs ¥ x ç Syntax) ¥ MkCf (vars, fs) ç Syntax)

€repclosed_syntax_lemma1› =
	Ù µ s∑ RepClosed s ¥ Syntax Ä s

€repclosed_syntax_lemma2› =
	Ù µ p∑ RepClosed {x|p x} ¥ (µ x∑ x ç Syntax ¥ p x)
=TEX

\ignore{
=SML
set_goal([], ¨RepClosed SyntaxÆ);
a (rewrite_tac (map get_spec [¨RepClosedÆ])
	THEN strip_tac);
(* *** Goal "1" *** *)
a (rewrite_tac (map get_spec [¨RepClosedÆ, ¨SyntaxÆ])
	THEN REPEAT strip_tac THEN asm_fc_tac [] THEN asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a (rewrite_tac (map get_spec [ ¨SyntaxÆ])
	THEN REPEAT strip_tac
	THEN all_asm_fc_tac[]);
a (fc_tac [get_spec ¨RepClosedÆ]);
a (lemma_tac ¨µ x∑ x ç Xâg fs ¥ x ç sÆ
	THEN1 (REPEAT strip_tac THEN all_asm_fc_tac[]));
a (all_asm_fc_tac[]);
a (asm_rewrite_tac[]);
val repclosed_syntax_lemma = pop_thm ();

val repclosed_syntax_thm = save_thm ("repclosed_syntax_thm",
	rewrite_rule [get_spec ¨RepClosedÆ] repclosed_syntax_lemma);

set_goal([], ¨µs∑ RepClosed s ¥ Syntax Ä sÆ);
a (rewrite_tac [get_spec ¨SyntaxÆ]
	THEN prove_tac[]);
val repclosed_syntax_lemma1 = save_pop_thm "repclosed_syntax_lemma1";

set_goal([], ¨µp∑ RepClosed {x | p x} ¥ µx∑ x ç Syntax ¥ p xÆ);
a (rewrite_tac [get_spec ¨SyntaxÆ] THEN REPEAT strip_tac);
a (asm_fc_tac[]);
val repclosed_syntax_lemma2 = save_pop_thm "repclosed_syntax_lemma2";
=TEX
}%ignore

We need to be able to define functions by recursion over this syntax.
To do that we need to prove that the syntax of comprehensions is well-founded.
This is itself equivalent to an induction principle, so we can try and derive it using the induction principles already available.

We must first define the relation of priority over the syntax, i.e. the relation between an element of the syntax and its constitutents.

πHOLCONST
‹ €ScPrec› : GS ≠ GS ≠ BOOL
˜¸¸¸¸¸¸¸¸¸¸¸
‹ µ¡ «∑ ScPrec ¡ « §
‹	∂ord fs∑ ¡ çâg fs ± {¡; «} Ä Syntax ± « = MkCf (ord, fs)
∞

=GFT
€ScPrec_tc_ç_thm› =
	Ù µ x y∑ ScPrec x y ¥ tc $çâg x y

€well_founded_ScPrec_thm› =
	Ù well_founded ScPrec

€well_founded_tcScPrec_thm› =
	Ù well_founded (tc ScPrec)
=TEX

\ignore{
=SML
set_goal([], ¨µx y∑ ScPrec x y ¥ tc $çâg x yÆ);
a (rewrite_tac (map get_spec [¨ScPrecÆ, ¨MkCfÆ]));
a (REPEAT strip_tac THEN asm_rewrite_tac [Ì_tc_thm]);
a (lemma_tac ¨tc $çâg fs (ord Ìâg fs) ± tc $çâg (ord Ìâg fs) (Natâg 1 Ìâg ord Ìâg fs)Æ
	THEN1 rewrite_tac [Ì_tc_thm]);
a (all_fc_tac [tc_incr_thm]);
a (all_fc_tac [tran_tc_thm2]);
a (all_fc_tac [tran_tc_thm2]);
val ScPrec_tc_ç_thm = pop_thm ();

set_goal ([], ¨well_founded ScPrecÆ);
a (rewrite_tac [get_spec ¨well_foundedÆ]);
a (REPEAT strip_tac);
a (asm_tac (µ_elim ¨sÆ gs_cv_ind_thm));
a (lemma_tac ¨µ x∑ (µ y∑ tc $çâg y x ¥ s y) ¥ s xÆ
	THEN1 REPEAT strip_tac);
(* *** Goal "1" *** *)
a (lemma_tac ¨µ y∑ ScPrec y x ¥ s yÆ
	THEN1 (REPEAT strip_tac THEN all_fc_tac [ScPrec_tc_ç_thm]
		THEN asm_fc_tac []));
a (asm_fc_tac[]);
(* *** Goal "2" *** *)
a (asm_fc_tac[]);
a (asm_rewrite_tac[]);
val well_founded_ScPrec_thm =  save_pop_thm "well_founded_ScPrec_thm";

set_goal([], ¨well_founded (tc ScPrec)Æ);
a (asm_tac well_founded_ScPrec_thm);
a (fc_tac [wf_tc_wf_thm]);
val well_founded_tcScPrec_thm = save_pop_thm ("well_founded_tcScPrec_thm");
=TEX

}%ignore

=SML
val €SC_INDUCTION_T› = WF_INDUCTION_T well_founded_ScPrec_thm;
val €sc_induction_tac› = wf_induction_tac well_founded_ScPrec_thm;
=TEX

The set Syntax gives us the syntactically well-formed phrases of our language.
It will be useful to have some predicates which incorporate well-formedness, which are defined here.

=GFT
€syntax_disj_thm› =
   Ù µ x
     ∑ x ç Syntax
         ¥ (∂ r pars∑ fun pars ± x = MkAf (r, pars))
           ≤ (∂ vars fs∑ (µ y∑ y çâg fs ¥ y ç Syntax) ± x = MkCf (vars, fs))

€syntax_cases_thm› =
   Ù µ x∑ x ç Syntax ¥ IsAf x ≤ IsCf x

€is_fc_clauses› =
   Ù µ x
     ∑ x ç Syntax
         ¥ (IsAf x ¥ (∂ r pars∑ fun pars ± x = MkAf (r, pars)))
           ± (IsCf x
             ¥ (∂ vars fs
             ∑ (µ y∑ y çâg fs ¥ y ç Syntax) ± x = MkCf (vars, fs)))

€syn_proj_clauses› =
    Ù (µ l r∑ AfRel (MkAf (l, r)) = l)
       ± (µ l r∑ AfPars (MkAf (l, r)) = r)
       ± (µ v f∑ CfVars (MkCf (v, f)) = v)
       ± (µ v f∑ CfForms (MkCf (v, f)) = f)

€is_fc_clauses2› =
   Ù µ x∑ x ç Syntax ¥ IsCf x ¥ (µ y∑ y çâg CfForms x ¥ y ç Syntax)

€stn_con_neq_clauses› =
   Ù µ x y∑ ≥ MkAf x = MkCf y

€syn_comp_fc_clauses› =
   Ù µ v f∑ MkCf (v, f) ç Syntax ¥ (µ y∑ y çâg f ¥ y ç Syntax)

€scprec_fc_clauses› =
   Ù µ ¡ « vars fs∑ « ç Syntax ¥ « = MkCf (vars, fs) ± ¡ çâg fs ¥ ScPrec ¡ «

€scprec_fc_clauses2› =
   Ù µ t∑ t ç Syntax ¥ IsCf t ¥ (µ f∑ f çâg CfForms t ¥ ScPrec f t)
=TEX

\ignore{
=SML
set_goal([], ¨µx∑	x ç Syntax
¥	(∂r pars∑ fun pars ± x = MkAf (r,pars))
  ≤	(∂vars fs∑ (µy∑ y çâg fs ¥ y ç Syntax) ± x = MkCf (vars, fs))
Æ);
a (contr_tac);
a (lemma_tac ¨RepClosed (Syntax \ {x})Æ
	THEN1 (rewrite_tac [get_spec ¨RepClosedÆ]
		THEN strip_tac));
(* *** Goal "1" *** *)
a (strip_tac THEN strip_tac THEN strip_tac
	THEN all_fc_tac [repclosed_syntax_thm]
	THEN_TRY asm_rewrite_tac[]);
a (spec_nth_asm_tac 4 ¨nÆ);
a (spec_nth_asm_tac 1 ¨isÆ THEN1 asm_fc_tac[]);
a (swap_nth_asm_concl_tac 1 THEN (SYM_ASMS_T rewrite_tac));
(* *** Goal "2" *** *)
a (REPEAT_N 3 strip_tac);
a (spec_nth_asm_tac 2 ¨varsÆ);
a (DROP_NTH_ASM_T 2 ante_tac THEN rewrite_tac [get_spec ¨XâgÆ]
	THEN strip_tac);
a (lemma_tac ¨µ y∑ y çâg fs ¥ y ç SyntaxÆ
	THEN1 (REPEAT strip_tac THEN all_asm_fc_tac[]));
a (all_fc_tac [rewrite_rule [get_spec ¨XâgÆ] repclosed_syntax_thm]);
a (asm_rewrite_tac[]);
a (spec_nth_asm_tac 4 ¨fsÆ);
(* *** Goal "2.1" *** *)
a (asm_fc_tac[]);
(* *** Goal "2.2" *** *)
a (swap_nth_asm_concl_tac 1 THEN asm_rewrite_tac[]);
(* *** Goal "3" *** *)
a (asm_tac repclosed_syntax_lemma1);
a (spec_nth_asm_tac 1 ¨Syntax \ {x}Æ);
a (spec_nth_asm_tac 1 ¨xÆ);
val syntax_disj_thm = save_pop_thm "syntax_disj_thm";

set_goal([], ¨µx∑ x ç Syntax ¥ IsAf x ≤ IsCf xÆ);
a (REPEAT_N 2 strip_tac THEN fc_tac [syntax_disj_thm]
	THEN asm_rewrite_tac[]);
val syntax_cases_thm = save_pop_thm "syntax_cases_thm";

set_goal([], ¨µx∑	x ç Syntax
¥	(IsAf x ¥ ∂r pars∑ fun pars ± x = MkAf (r, pars))
±	(IsCf x ¥ ∂vars fs∑ (µy∑ y çâg fs ¥ y ç Syntax) ± x = MkCf (vars, fs))
Æ);
a (REPEAT_N 2 strip_tac);
a (asm_tac (syntax_disj_thm));
a (asm_fc_tac[] THEN asm_rewrite_tac [Is_clauses]);
(* *** Goal "1" *** *)
a (∂_tac ¨rÆ THEN ∂_tac ¨parsÆ THEN asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a (∂_tac ¨varsÆ THEN ∂_tac ¨fsÆ THEN asm_rewrite_tac[]);
val is_fc_clauses = save_pop_thm "is_fc_clauses";

set_goal([], ¨(µl r∑ AfRel (MkAf (l, r)) = l)
	±	(µl r∑ AfPars (MkAf (l, r)) = r)
	±	(µv f∑ CfVars (MkCf (v, f)) = v)
	±	(µv f∑ CfForms (MkCf (v, f)) = f)
Æ);
a (rewrite_tac (map get_spec [
	¨MkAfÆ, ¨MkCfÆ,
	¨AfRelÆ, ¨AfParsÆ, ¨CfVarsÆ, ¨CfFormsÆ]));
val syn_proj_clauses = save_pop_thm "syn_proj_clauses";

add_pc_thms "'ifol" [syn_proj_clauses];
set_merge_pcs ["hol1", "'GS1", "'ifol"];

set_goal([], ¨µx∑	x ç Syntax
¥	(IsCf x ¥ (µy∑ y çâg (CfForms x) ¥ y ç Syntax))
Æ);
a (REPEAT strip_tac
	THEN all_fc_tac [is_fc_clauses]
	THEN GET_NTH_ASM_T 1 (var_elim_asm_tac o concl)
	THEN_TRY asm_rewrite_tac[]);
a (DROP_NTH_ASM_T 2 (asm_tac o (rewrite_rule[]))
	THEN all_asm_fc_tac[]);
val is_fc_clauses2 = save_pop_thm "is_fc_clauses2";

set_goal([], ¨µx y∑ ≥ MkAf x = MkCf yÆ);
a (rewrite_tac (map get_spec [¨MkAfÆ, ¨MkCfÆ]));
a (contr_tac THEN FC_T (MAP_EVERY ante_tac) [natg_one_one_thm]
	THEN (PC_T1 "lin_arith" rewrite_tac[]));
val syn_con_neq_clauses = save_pop_thm "syn_con_neq_clauses";

add_pc_thms "'ifol" [syn_con_neq_clauses];
set_merge_pcs ["hol1", "'GS1", "'ifol"];

set_goal([], ¨
	(µv f∑ MkCf (v, f) ç Syntax ¥ (µy∑ y çâg f ¥ y ç Syntax))Æ);
a (REPEAT strip_tac
	THEN FC_T (MAP_EVERY (strip_asm_tac o (rewrite_rule []))) [is_fc_clauses2]
	THEN asm_fc_tac[]);
val syn_comp_fc_clauses = save_pop_thm "syn_comp_fc_clauses";

set_goal([], ¨µ¡ « vars fs∑ « ç Syntax ¥
		(« = MkCf (vars, fs) ± ¡ çâg fs) ¥ ScPrec ¡ «
Æ);
a (rewrite_tac [get_spec ¨ScPrecÆ]);
a (REPEAT µ_tac THEN strip_tac THEN strip_tac);
a (∂_tac ¨varsÆ THEN ∂_tac ¨fsÆ THEN asm_rewrite_tac[]);
a (REPEAT strip_tac THEN var_elim_nth_asm_tac 1);
(* *** Goal "1" *** *)
a (var_elim_nth_asm_tac 2);
a (fc_tac [syn_comp_fc_clauses]);
a (asm_fc_tac[]);
(* *** Goal "2" *** *)
a (var_elim_nth_asm_tac 2);
val scprec_fc_clauses = save_pop_thm "scprec_fc_clauses";

set_goal ([], ¨µt∑ t ç Syntax ¥ 
	(IsCf t ¥ µf∑ f çâg CfForms t ¥ ScPrec (f) t)Æ);
a (REPEAT strip_tac
	THEN all_fc_tac [is_fc_clauses]
	THEN DROP_NTH_ASM_T 3 ante_tac
	THEN asm_rewrite_tac[]
	THEN strip_tac
	THEN all_fc_tac [scprec_fc_clauses]
	THEN POP_ASM_T ante_tac
	THEN_TRY asm_rewrite_tac []);
val scprec_fc_clauses2 = save_pop_thm "scprec_fc_clauses2";
=TEX
}%ignore

\subsection{Semantics}

The semantics of infinitary first order logic is given by defining ``truth in an interpretation''.

The following type abbreviations are introduced:

\begin{description}
\item{TV}
Truth value - we use three truth values and a monotone semantics to help in locating fixed points. 
\item{IS}
Indexed set - some collection of any type indexed by values of type GS; used in the representation of  variable assignments, relations and structures.
\item{RV}
Relation Value - the arguments to a relation can be represented by indexed sets (think of the indices as parameter names), and a relation is then a truth valued function over these indexed sets (a set of indexed sets won't do because we have three truth values).
Note that relations need not have a definite arity, and the function representing a relation must be total over the entire type of indexed sets.
There are questions about how best ordinary n-ary relations should be represented, one obvious choice would be to make the truth value undefined for any indexed sets which do not have exactly the right number of numerical indices.
\item{ST}
Structure = a structure is a domain of disccourse (a set) together with an indexed set of relations over that domain.
Ordinals are used for relation names as well as for variable names (no ambiguity arises) and a collection of relations can therefore be modelled in the same way as a relation valued variable assignment.
\end{description}

=SML
declare_type_abbrev("€OPT›", ["'a"], î'a + ONEÆ);
declare_type_abbrev("€TV›", [], îBOOL OPTÆ);
declare_type_abbrev("€IS›", ["'a"], îGS ≠ 'a OPTÆ);
declare_type_abbrev("€RV›", ["'a"], î'a IS ≠ TVÆ);
declare_type_abbrev("€ST›", ["'a"], î'a SET ∏ ('a RV) ISÆ);
=TEX

\subsubsection{Manipulating Valuations}

In this syntax, by contrast with that in \cite{rbjt021}, we do not require variables to be ordinals, they may be arbitrary sets, since no steps are necessary to avoid variable capture.
There was no need even in \cite{rbjt021}, the use of a transfinite version of DeBriujn indices was a hang over from the PolySets where something of the kind really was needed.

The only manipulation of variable valuations which I expect to be necessary here is to override the values for variables which are being quantified over, and the functional override operator from \cite{rbjt023}, $´âg$, will suffice for this purpose.


πHOLCONST
‹ €IsRan› : 'a IS ≠ 'a SET
˜¸¸¸¸¸¸¸¸¸¸¸
‹ µis∑ IsRan is = {v | ∂¡∑ InL v = is ¡}
∞

πHOLCONST
‹ €IsDom› : 'a IS ≠ GS SET
˜¸¸¸¸¸¸¸¸¸¸¸
‹ µis∑ IsDom is = {i | IsL (is i)}
∞

πHOLCONST
‹ €InsertVars› : 'a IS ≠ 'a IS ≠ 'a IS
˜¸¸¸¸¸¸¸¸¸¸¸
‹ µis1 is2∑ InsertVars is1 is2 =
‹	Ãi∑ if IsL (is2 i) then is2 i else is2 i 
∞

πHOLCONST
‹ €VarComp› : GS ≠ 'a IS ≠ 'a IS
˜¸¸¸¸¸¸¸¸¸¸¸
‹ µm is∑ VarComp m is = 
‹	Ãv∑ if v çâg dom m then is (m âg v) else InR One 
∞

\subsubsection{Truth Values}

πHOLCONST
‹ €pTrue› : TV
˜¸¸¸¸¸¸¸¸¸¸¸
‹ pTrue = InL T
∞

πHOLCONST
‹ €pFalse› : TV
˜¸¸¸¸¸¸¸¸¸¸¸
‹ pFalse = InL F
∞

πHOLCONST
‹ €pU› : TV
˜¸¸¸¸¸¸¸¸¸¸¸
‹ pU = InR One
∞

=GFT
€tv_cases_thm› =
	Ù µ x∑ x = pTrue ≤ x = pFalse ≤ x = pU

€tv_distinct_clauses› =
	Ù ≥ pTrue = pFalse
             ± ≥ pTrue = pU
             ± ≥ pFalse = pTrue
             ± ≥ pFalse = pU
             ± ≥ pU = pTrue
             ± ≥ pU = pFalse
=TEX

\ignore{
=SML
set_goal([], ¨µx∑ x = pTrue ≤ x = pFalse ≤ x = pUÆ);
a (rewrite_tac (map get_spec [¨pTrueÆ, ¨pFalseÆ, ¨pUÆ]) THEN prove_tac[]);
a (strip_asm_tac (µ_elim ¨xÆ sum_cases_thm));
(* *** Goal "1" *** *)
a (POP_ASM_T ante_tac);
a (LEMMA_T ¨y = T ≤ y = FÆ (STRIP_THM_THEN asm_tac) THEN1 prove_tac[]
	THEN var_elim_nth_asm_tac 1
	THEN strip_tac);
(* *** Goal "2" *** *)
a (asm_rewrite_tac[one_def]);
val tv_cases_thm = save_pop_thm "tv_cases_thm";

set_goal([], ¨≥ pTrue = pFalse
	± ≥ pTrue = pU
	± ≥ pFalse = pTrue
	± ≥ pFalse = pU
	± ≥ pU = pTrue
	± ≥ pU = pFalse
Æ);
a (rewrite_tac (map get_spec [¨pTrueÆ, ¨pFalseÆ, ¨pUÆ]) THEN prove_tac[]);
val tv_distinct_clauses = save_pop_thm "tv_distinct_clauses";

add_pc_thms "'ifol" (map get_spec [] @ [tv_distinct_clauses]);
set_merge_pcs ["hol1", "'GS1", "'ifol"];
=TEX
}%ignore

\subsubsection{Formula Evaluation}

Now we define the evaluation of formulae, i.e. for the notion of truth in an structure given a variable assignment.

There are two cases in the syntax, atomic and compound formulae.
The truth values of the atomic formulae are obtained from an infinitary structure given the values of the arguments, which are always variables.
The truth conditions of compound formulae are defined relative to a structure, and a variable valuation.

πHOLCONST
‹ €EvalAf› : GS ≠ 'a ST ≠ 'a RV
˜¸¸¸¸¸¸¸¸¸¸¸
‹ µ(at:GS) (st:'a ST) (va:'a IS)∑ EvalAf at st va =
‹	let r = AfRel at
‹	and pars = AfPars at
‹	in
‹		let rv = (Snd st) r
‹		in if IsL rv then OutL rv (VarComp pars va) else InR One
∞

The following definition shows how the truth values of the constituents of a compound expression determine the truth value of the expression.

πHOLCONST
‹ €EvalCf_tf› : TV SET ≠ TV
˜¸¸¸¸¸¸¸¸¸¸¸
‹ µresults∑ EvalCf_tf results = 
‹	if results Ä {pTrue} then pFalse
‹		else if (pFalse) ç results then pTrue
‹		else pU
∞

This definition shows how the set of truth values of instances of the constituents is obtained from the denotations of the constituent formulae.

πHOLCONST
‹ €EvalCf› : GS ≠ 'a ST ≠ 'a RV SET ≠ 'a RV
˜¸¸¸¸¸¸¸¸¸¸¸
‹ µf∑ EvalCf f = Ãst rvs va∑ 
‹	let Œ = CfVars f
‹	and V = Fst st
‹	in EvalCf_tf {pb | ∂rv v∑
‹		  rv ç rvs
‹		± IsDom v = Xâg Œ
‹		± IsRan v Ä V
‹		± pb = rv (InsertVars v va)}
∞

Now we define a parameterised functor of which the semantic function is a fixed point.

πHOLCONST
‹ €EvalFormFunct› : 'a ST ≠ (GS ≠ 'a RV) ≠ (GS ≠ 'a RV)
˜¸¸¸¸¸¸¸¸¸¸¸
‹ µst∑ EvalFormFunct st = Ãef f∑
‹	if f ç Syntax
‹	then if IsAf f
‹	     then EvalAf f st
‹	     else
‹		if IsCf f
‹		then let rvs = FunImage ef (Xâg(CfForms f))
‹		     in  EvalCf f st rvs
‹		else ≈x∑T
‹	else ≈x∑T
∞

πHOLCONST
‹ €EvalForm› : 'a ST ≠ GS ≠ 'a RV
˜¸¸¸¸¸¸¸¸¸¸¸
‹ µst∑ EvalForm st = fix (EvalFormFunct st)
∞

To use this definition we need to show that there exists a fixed point, for which we must show that the functor respects some well-founded relation.

=GFT
€evalformfunct_respect_thm› =
   Ù µ (V, r)∑ EvalFormFunct (V, r) respects ScPrec

€evalformfunct_fixp_lemma› =
   Ù µ st∑ EvalForm st = EvalFormFunct st (EvalForm st)

€evalformfunct_thm› =
   Ù µ st
     ∑ EvalForm st
         = (Ã f
         ∑ if f ç Syntax
           then
             if IsAf f
             then EvalAf f st
             else if IsCf f
             then
               let rvs = FunImage (EvalForm st) (Xâg (CfForms f))
               in EvalCf f st rvs
             else ≈ x∑ T
           else ≈ x∑ T)

€evalformfunct_thm2› =
   Ù µ st f
     ∑ EvalForm st f
         = (if f ç Syntax
           then
             if IsAf f
             then EvalAf f st
             else if IsCf f
             then
               let rvs = FunImage (EvalForm st) (Xâg (CfForms f))
               in EvalCf f st rvs
             else ≈ f∑ T
           else ≈ f∑ T)
=TEX

\ignore{
=SML
set_merge_pcs ["hol", "'GS1", "'ifol"];

set_goal([], ¨µst∑ (EvalFormFunct st) respects ScPrecÆ);
a (rewrite_tac [get_spec ¨EvalFormFunctÆ, get_spec ¨$respectsÆ]
	THEN REPEAT strip_tac);
a (cases_tac ¨IsAf xÆ THEN asm_rewrite_tac[]);
a (cases_tac ¨IsCf xÆ THEN asm_rewrite_tac[]);
a (cases_tac ¨x ç SyntaxÆ THEN asm_rewrite_tac[]);
a (lemma_tac ¨FunImage g (Xâg (CfForms x)) = FunImage h (Xâg (CfForms x))Æ
	THEN_TRY asm_rewrite_tac[get_spec ¨XâgÆ]);
a (PC_T1 "hol1" rewrite_tac [get_spec ¨FunImageÆ]
	THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a (all_fc_tac [scprec_fc_clauses2]);
a (all_asm_fc_tac[tc_incr_thm]);
a (all_asm_fc_tac[]);
a (∂_tac ¨aÆ THEN asm_rewrite_tac[]);
a (POP_ASM_T (fn x => rewrite_thm_tac (eq_sym_rule x)));
a (asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a (all_fc_tac [scprec_fc_clauses2]);
a (all_asm_fc_tac[tc_incr_thm]);
a (all_asm_fc_tac[]);
a (∂_tac ¨aÆ THEN asm_rewrite_tac[]);
val evalformfunct_respect_thm = save_pop_thm "evalformfunct_respect_thm";

set_goal([], ¨µ st∑ EvalForm st = EvalFormFunct st (EvalForm st)Æ);
a (asm_tac well_founded_ScPrec_thm);
a (asm_tac evalformfunct_respect_thm);
a (strip_tac);
a (spec_nth_asm_tac 1 ¨stÆ);
a (all_fc_tac [µ_elim ¨ScPrecÆ (µ_elim ¨EvalFormFunct stÆ (get_spec ¨fixÆ))]);
a (rewrite_tac [get_spec ¨EvalFormÆ]);
a (asm_rewrite_tac[]);
val evalformfunct_fixp_lemma = save_pop_thm "evalformfunct_fixp_lemma";

val evalformfunct_thm = save_thm ("evalformfunct_thm",
	rewrite_rule [get_spec ¨EvalFormFunctÆ] evalformfunct_fixp_lemma);

set_goal([], ¨µ st f
     ∑ EvalForm st f
         = if f ç Syntax
             then
               if IsAf f
               then EvalAf f st
               else if IsCf f
               then
                 let rvs = FunImage (EvalForm st) (Xâg (CfForms f))
                 in EvalCf f st rvs
               else ≈ f∑ T
             else ≈ f∑ TÆ);
a (REPEAT strip_tac THEN rewrite_tac[rewrite_rule [](once_rewrite_rule [ext_thm] evalformfunct_thm)]);
val evalformfunct_thm2 = save_pop_thm "evalformfunct_thm2";
=TEX
}%ignore



\newpage
\section{FUNCTORS OVER SRUCTURES}

\subsection{Membership and Equality}

=SML
declare_infix (300, "€çâv›");
declare_infix (300, "€=âv›");
=TEX

Note that in the evaluation of formulae above {\it EvalForm} atomic membership and equality relations are evaluated by reference to given membership and equality relationships.

We are seeking a functor which when supplied with membership and equality relations will deliver new relationships at least as detailed as the original (they are partial relationships).
This is what we now define.

\section{THE EXISTENCE OF FIXED POINTS}

When I began working with infinitary comprehension the idea was to use it for interpretations of the usual first order language of set theory.
This was to have been realised by identifying large subsets V of {\it WfComp} for which there exists a fixed point of the functor {\it SemanticFunctor V} in which the equality and membership relations are total over V.
It is easy to believe that there are such subsets which include copies of the well-founded sets we started out with, and also, for example, all the PolySets and many other useful non-well-founded sets.

Before reaching the stage at which reasoning about such fixed points could be undertaken it occurred to me that for my intended application, the classical set theories might well be dispensed with, possibly resulting in significant savings.

The intended application was to languages suitable for the formal computer assisted development of mathematics and its applications, and the next stage in the construction of such languages was to be an illative lambda calculus.
An illative lambda calculus must be effectively a many valued logic, for there is no type system or other means which prevents the consideration of arbitrary lambda terms as propositions.
For application in this context, the effort of coming up with a two-valued membership relation may not be beneficial.
There must still be a system of type assignment which allows the user to work with subdomains better behaved than the whole ontology, and if this works as well as it needs to work, then the presence of sets which are not really sets in the classical sense will not be problematic, and effort directed toward their elimination may prove not to be beneficial.

I therefore propose at least initially to explore the option of going straight from partial fixed points (meaning in this case, fixed points, over the whole of {\it WfComp}, which are partial membership and equality relations) to an illative lambda calculus whose domain of discourse is a partition of the whole of {\it WfComp}.

At this stage it is not clear whether any old fixed point will do or whether we have to be more fussy than that, so I will start with an arbitrary fixed point and see how far I get.
To do this I do have to prove that there does exist a fixed point, and this is to be realised by demonstrating that the semantic functor is monotone and therefore has a least fixed point.

\subsection{Monotonicity}

To establish the existence of fixed points it is helpful to show that the semantic functor is monotonic.

It is therefore necessary to define the ordering relative to which it is monotonic.

=SML
declare_type_abbrev("€R›", ["'a"], î'a ≠ 'a ≠ TVÆ);
declare_type_abbrev("€PR›", ["'a"], î'a R ∏ 'a RÆ);
=TEX

=SML
declare_infix(300, "ºât");
declare_infix(300, "ºâtâs");
declare_infix(300, "ºâr");
declare_infix(300, "ºâpâr");
=TEX

First an ordering on the ``truth values'' is defined.

πHOLCONST
‹ €$ºât› : TV ≠ TV ≠ BOOL
˜¸¸¸¸¸¸¸¸¸¸¸
‹ µ t1 t2∑ 
‹	t1 ºât t2 § t1 = t2 ≤ t1 = pU	
∞

=GFT
€ºât_refl_thm› =
	Ù µ x∑ x ºât x

€ºât_trans_thm› =
	Ù µ x y z∑ x ºât y ± y ºât z ¥ x ºât z

€ºât_clauses› =
   Ù pU ºât pTrue
       ± pU ºât pFalse
       ± ≥ pTrue ºât pU
       ± ≥ pFalse ºât pU
       ± ≥ pFalse ºât pTrue
       ± ≥ pTrue ºât pFalse
=TEX

\ignore{
=SML
set_goal([], ¨µx∑ x ºât xÆ);
a (rewrite_tac [get_spec ¨$ºâtÆ]);
val ºât_refl_thm = save_pop_thm "ºât_refl_thm";

set_goal([], ¨µx y z∑ x ºât y ± y ºât z ¥ x ºât zÆ);
a (rewrite_tac [get_spec ¨$ºâtÆ]
	THEN REPEAT strip_tac
	THEN_TRY asm_rewrite_tac[]);
a (all_var_elim_asm_tac);
val ºât_trans_thm = save_pop_thm "ºât_trans_thm";

set_goal([], ¨(µx∑ pU ºât x)
	± ≥ pTrue ºât pU
	± ≥ pFalse ºât pU
	± ≥ pFalse ºât pTrue
	± ≥ pTrue ºât pFalseÆ);
a (rewrite_tac [get_spec ¨$ºâtÆ] THEN prove_tac[]);
val ºât_clauses = save_pop_thm "ºât_clauses";

add_pc_thms "'ifol" (map get_spec [] @ [ºât_refl_thm, ºât_clauses]);
set_merge_pcs ["hol1", "'GS1", "'ifol"];
=TEX
}%ignore

Then an ordering on partial relations over term values.

πHOLCONST
‹ €$ºâr› : 'a R ≠ 'a R ≠ BOOL
˜¸¸¸¸¸¸¸¸¸¸¸
‹ µ r1 r2∑ 
‹	r1 ºâr r2 § µx y∑ (r1 x y) ºât (r2 x y)	
∞

and an ordering over pairs of partial relations (membership and equality partial relations).

πHOLCONST
‹ €$ºâpâr› : 'a PR ≠ 'a PR ≠ BOOL
˜¸¸¸¸¸¸¸¸¸¸¸
‹ µ r12 s12∑ 
‹	r12 ºâpâr s12 § (Fst r12) ºâr (Fst s12) ± (Snd r12) ºâr (Snd s12)	
∞

Our aim is to prove the monotonicity of the semantic functor for every domain which is a subset of the well formed comprehensions.
The relevant notion of monotonicity is defined here.

πHOLCONST
‹ €MonoFunct› : ('a PR ≠ 'a PR) ≠ BOOL
˜¸¸¸¸¸¸¸¸¸¸¸
‹ µ f∑  MonoFunct f § µv w x y∑ (v,w) ºâpâr (x,y) ¥ (f (v,w)) ºâpâr (f (x,y))
∞

In order to prove monotonicity of the semantic functor various lemmas about the functions used in defining the semantic functor are needed, often expressing monotonicity of objects of various types.

\subsubsection{EvalAtom}

The required characteristic of {\\it EvalAtom} is straightforward to define and prove.

The following is the property of partial truth predicates parameterised by pairs of partial relations of being monotonic with respect to those relations.

πHOLCONST
‹ €MonoPprF› : ('a PR ≠ 'a ≠ TV) ≠ BOOL
˜¸¸¸¸¸¸¸¸¸¸¸
‹ µf∑ MonoPprF f § µ v w x y∑
‹	(v, w) ºâpâr (x, y) ¥ µz:'a∑ f (v, w) z ºât f (x, y) z
∞

=GFT
€evalaf_monotone_lemma› =
   Ù µ v w x y
     ∑ $ºâpâr (v, w) (x, y) ¥ (µ z∑ EvalAf (v, w) z ºât EvalAf (x, y) z)
=TEX

\ignore{
=IGN
set_goal([], ¨µ v w x y
           ∑ $ºâpâr (v, w) (x, y)
               ¥ (µ z∑ EvalAf (v, w) z ºât EvalAf (x, y) z)Æ);
a (rewrite_tac (map get_spec [¨MonoPprFÆ, ¨EvalAtomÆ,
	¨$ºârÆ, ¨$ºâpârÆ])
	THEN REPEAT strip_tac);
a (cases_tac ¨IsEq (Snd z)Æ
	THEN asm_rewrite_tac []);
val evalatom_monotone_lemma = save_pop_thm "evalatom_monotone_lemma";
=TEX
}%ignore

\subsubsection{Monotonicity of Membership and Equality}

The following are lemmas specific to the definitions of {\it EqRel} and {\it MemRel}.

=GFT
€eqrel_mono_thm› =
   Ù µ V v w x y
     ∑ $ºâpâr (x, y) (v, w) ¥ $ºâr (EqRel (V, x, y)) (EqRel (V, v, w))

€monpprf_memrel_lemma1› =
   Ù µ V
     ∑ MonoPprF (Ã (m, e)∑ EvalForm (V, m, e))
         ¥ MonoPprF (Ã (m, e) (l, r)∑ MemRel (V, m, e) l r)
=TEX

\ignore{
=IGN
set_goal ([], ¨µV∑ µv w x y∑ $ºâpâr (x,y) (v,w) ¥ $ºâr (EqRel (V,x,y)) (EqRel (V,v,w))Æ);
a (rewrite_tac (map get_spec [¨EqRelÆ, ¨$ºârÆ])
	THEN REPEAT strip_tac);
a (cases_tac ¨x' ç V ± y' ç VÆ THEN asm_rewrite_tac[get_spec ¨$ºâtÆ]);
a (fc_tac [get_spec ¨$ºâpârÆ]);
a (FC_T (MAP_EVERY (asm_tac o (rewrite_rule[]))) [get_spec ¨$ºârÆ]);
a (CASES_T ¨∂ c∑ c ç V ± (x c x' = pU ≤ x c y' = pU)Æ asm_tac
	THEN_TRY asm_rewrite_tac[]);
a (CASES_T ¨∂ c∑ c ç V ± (v c x' = pU ≤ v c y' = pU)Æ asm_tac
	THEN_TRY asm_rewrite_tac[]);
(* *** Goal "1" *** *)
a (POP_ASM_T ante_tac THEN POP_ASM_T ante_tac
	THEN REPEAT strip_tac);
(* *** Goal "1.1" *** *)
a (spec_nth_asm_tac 3 ¨cÆ);
a (list_spec_nth_asm_tac 6 [¨cÆ, ¨x'Æ]);
a (fc_tac [get_spec ¨$ºâtÆ]);
a (DROP_NTH_ASM_T 4 ante_tac THEN asm_rewrite_tac[]);
(* *** Goal "1.2" *** *)
a (spec_nth_asm_tac 3 ¨cÆ);
a (list_spec_nth_asm_tac 6 [¨cÆ, ¨y'Æ]);
a (fc_tac [get_spec ¨$ºâtÆ]);
a (DROP_NTH_ASM_T 3 ante_tac THEN asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a (DROP_NTH_ASM_T 1 ante_tac THEN strip_tac);
a (DROP_NTH_ASM_T 2 ante_tac THEN strip_tac);
a (LEMMA_T ¨≥ (if (Ã c∑ c ç V ± ≥ x c x' = pU) = (Ã c∑ c ç V ± ≥ x c y' = pU)
                 then pTrue
                 else pFalse)
               = pUÆ rewrite_thm_tac
	THEN1 (cases_tac ¨(Ã c∑ c ç V ± ≥ x c x' = pU) = (Ã c∑ c ç V ± ≥ x c y' = pU)Æ
		THEN asm_rewrite_tac[]));
a (LEMMA_T ¨(Ã c∑ c ç V ± ≥ x c x' = pU) = (Ã c∑ c ç V ± ≥ x c y' = pU)
	§ (Ã c∑ c ç V ± ≥ v c x' = pU) = (Ã c∑ c ç V ± ≥ v c y' = pU)Æ
	rewrite_thm_tac);
a (rewrite_tac [ext_thm]
	THEN contr_tac
	THEN asm_fc_tac[]);
val eqrel_mono_thm = save_pop_thm "eqrel_mono_thm";

set_goal ([], ¨µ V∑ MonoPprF(Ã(m, e)∑ EvalForm (V,m,e))
			¥ MonoPprF (Ã(m, e) (l,r)∑ MemRel (V, m, e) l r)Æ);
a (rewrite_tac [get_spec ¨MonoPprFÆ, get_spec ¨MemRelÆ, let_def]
	THEN REPEAT strip_tac);
a (asm_fc_tac[]);
a (asm_rewrite_tac[]);
val monpprf_memrel_lemma1 = save_pop_thm "monpprf_memrel_lemma1";
=TEX
}%ignore

\subsubsection{Monotonicity of EvalTf}

This result is more difficult.
Because {\it EvalTf} participates in the recursion over the syntactic structure of comprehensions which is used to define evaluation of formulae, it is supplied with an evaluation function on whose behaviour its monotonicity depends.

The definition of {\it EvalTf} has been split into three parts to break up the proof.
The first part obtains a set of ``truth values'' (true, false or unknown) and we here define an ordering over these sets. 

πHOLCONST
‹ €$ºâtâs› : (TV SET) ≠ (TV SET) ≠ BOOL
˜¸¸¸¸¸¸¸¸¸¸¸
‹ µ m n∑ 
‹	m ºâtâs n §
‹		(µx∑ x ç m ¥ ∂y∑ y ç n ± x ºât y)
‹	±	(µy∑ y ç n ¥ ∂x∑ x ç m ± x ºât y)
∞

=GFT
€ºtâtâs_clauses› =
   Ù µ s t
     ∑ $ºâtâs s t
         ¥ pTrue ç s
         ¥ pTrue ç t ± pFalse ç s
         ¥ pFalse ç t ± pU ç t
         ¥ pU ç s ± (s = {} § t = {})

€mono_evaltf_ºâtâs_lemma1› =
   Ù µ s t∑ $ºâtâs s t ¥ s Ä {pTrue} ¥ s Ä {pTrue}

€mono_evaltftf_lemma› =
   Ù µ res1 res2∑ $ºâtâs res1 res2 ¥ EvalTf_tf res1 ºât EvalTf_tf res2
=TEX

\ignore{
=IGN
set_goal([], ¨µrs∑ $ºâtâs rs rsÆ);
a (rewrite_tac [get_spec ¨$ºâtâsÆ]
	THEN REPEAT strip_tac);
a (∂_tac ¨xÆ THEN asm_rewrite_tac[]);
a (∂_tac ¨yÆ THEN asm_rewrite_tac[]);
val ºâtâs_refl_thm = save_pop_thm "ºâtâs_refl_thm";

add_pc_thms "'ifol" (map get_spec [] @ [ºâtâs_refl_thm]);
set_merge_pcs ["hol1", "'GS1", "'ifol"];

set_goal([], ¨µs t∑ $ºâtâs s t ¥
		(pTrue ç s ¥ pTrue ç t)
	± 	(pFalse ç s ¥ pFalse ç t)
	± 	(pU ç t ¥ pU ç s)
	±	(s = {} § t = {})Æ);
a (rewrite_tac [get_spec ¨$ºâtâsÆ]
	THEN REPEAT strip_tac
	THEN_TRY asm_rewrite_tac[]);
(* *** Goal "1" *** *)
a (spec_nth_asm_tac 3 ¨pTrueÆ);
a (POP_ASM_T ante_tac THEN rewrite_tac [get_spec ¨$ºâtÆ]);
a (STRIP_T rewrite_thm_tac THEN strip_tac);
(* *** Goal "2" *** *)
a (spec_nth_asm_tac 3 ¨pFalseÆ);
a (POP_ASM_T ante_tac THEN rewrite_tac [get_spec ¨$ºâtÆ]);
a (STRIP_T rewrite_thm_tac THEN strip_tac);
(* *** Goal "3" *** *)
a (spec_nth_asm_tac 2 ¨pUÆ);
a (POP_ASM_T ante_tac THEN rewrite_tac [get_spec ¨$ºâtÆ]);
a strip_tac;
a (var_elim_nth_asm_tac 1);
(* *** Goal "4" *** *)
a (POP_ASM_T ante_tac THEN rewrite_tac [sets_ext_clauses]
	THEN contr_tac);
a (spec_nth_asm_tac 3 ¨xÆ);
a (POP_ASM_T ante_tac THEN rewrite_tac [get_spec ¨$ºâtÆ]);
a (spec_nth_asm_tac 3 ¨x'Æ);
(* *** Goal "5" *** *)
a (POP_ASM_T ante_tac THEN rewrite_tac [sets_ext_clauses]
	THEN contr_tac);
a (REPEAT (asm_fc_tac[]));
val ºâtâs_fc_clauses = save_pop_thm "ºâtâs_fc_clauses";

set_goal([], ¨µs t∑ $ºâtâs s t ¥
		(s Ä {pTrue} ¥ t Ä {pTrue})Æ);
a (REPEAT strip_tac);
a (cases_tac ¨s = {}Æ);
(* *** Goal "1" *** *)
a (all_fc_tac [ºâtâs_fc_clauses]);
a (asm_rewrite_tac []);
(* *** Goal "2" *** *)
a (lemma_tac ¨≥ t = {}Æ THEN1 FC_T1 fc_§_canon (MAP_EVERY asm_tac) [ºâtâs_fc_clauses]);
a (GET_NTH_ASM_T 5 ante_tac THEN asm_rewrite_tac[]);
a (fc_tac [get_spec ¨$ºâtâsÆ]);
a (rewrite_tac [sets_ext_clauses]);
a (contr_tac);
a (strip_asm_tac (µ_elim ¨xÆ tv_cases_thm));
(* *** Goal "2.2.1" *** *)
a (swap_nth_asm_concl_tac 3 THEN asm_rewrite_tac[] THEN contr_tac);
a (spec_nth_asm_tac 5 ¨pFalseÆ);
a (GET_NTH_ASM_T 10 ante_tac THEN rewrite_tac [sets_ext_clauses]
	THEN contr_tac);
a (spec_nth_asm_tac 1 ¨x'Æ);
a (swap_nth_asm_concl_tac 3 THEN asm_rewrite_tac[]);
(* *** Goal "2.2.2" *** *)
a (swap_nth_asm_concl_tac 3 THEN asm_rewrite_tac[] THEN contr_tac);
a (spec_nth_asm_tac 5 ¨pUÆ);
a (GET_NTH_ASM_T 10 ante_tac THEN rewrite_tac [sets_ext_clauses]
	THEN contr_tac);
a (spec_nth_asm_tac 1 ¨x'Æ);
a (swap_nth_asm_concl_tac 3 THEN asm_rewrite_tac[]);
val mono_evaltf_ºâtâs_lemma1 = save_pop_thm "mono_evaltf_ºâtâs_lemma1";

set_goal([], ¨µres1 res2∑ $ºâtâs res1 res2
	¥ EvalTf_tf res1 ºât EvalTf_tf res2Æ);
a (rewrite_tac [get_spec ¨EvalTf_tfÆ]
	THEN REPEAT strip_tac);
a (cases_tac ¨res1 Ä {pTrue}Æ THEN asm_rewrite_tac[]);
(* a (strip_asm_tac (list_µ_elim [¨res1Æ, ¨res2Æ] mono_evaltf_ºâtâs_lemma1)
	THEN asm_rewrite_tac[]); *)
(* *** Goal "1" *** *)
a (all_asm_fc_tac [mono_evaltf_ºâtâs_lemma1]
	THEN asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a (lemma_tac ¨pFalse ç res1 ¥ pFalse ç res2Æ
	THEN1 (strip_tac THEN all_fc_tac [ºâtâs_fc_clauses])
	THEN asm_rewrite_tac[]);
a (lemma_tac ¨≥ res2 Ä {pTrue}Æ
	THEN1 (rewrite_tac [sets_ext_clauses]
		THEN REPEAT strip_tac
		THEN ∂_tac ¨pFalseÆ
		THEN asm_rewrite_tac[])
	THEN asm_rewrite_tac[]);
a (cases_tac ¨pFalse ç res1Æ THEN asm_rewrite_tac[]);
val mono_evaltftf_lemma = save_pop_thm "mono_evaltftf_lemma";

set_goal([], ¨µ V∑ MonoPprF(Ã(m, e)∑ EvalForm (V,m,e))Æ);
a (rewrite_tac [get_spec ¨MonoPprFÆ]
	THEN REPEAT_N 6 strip_tac);
a (lemma_tac ¨µg va∑ EvalForm (V, v, w) (va, g) ºât EvalForm (V, x, y)  (va, g)Æ
	THEN1 strip_tac);
(* *** Goal "1" *** *)
a (sc_induction_tac ¨gÆ);
a (strip_tac THEN rewrite_tac [evalformfunct_thm2]
	THEN REPEAT strip_tac);
a (cases_tac ¨t ç WfFormsÆ THEN asm_rewrite_tac[]);
a (cases_tac ¨IsEq t ≤ IsMem tÆ
	THEN asm_rewrite_tac[]
	THEN fc_tac [evalatom_monotone_lemma]
	THEN_TRY asm_rewrite_tac[]);
a (fc_tac [formula_cases_thm]);
a (rewrite_tac [get_spec ¨EvalTfÆ, let_def]);
a (LEMMA_T ¨∂res1 res2∑ res1 = EvalTf_results V (EvalForm (V, v, w)) (va, t)
	± res2 = EvalTf_results V (EvalForm (V, x, y)) (va, t)Æ
	(REPEAT_TTCL STRIP_THM_THEN
	(fn x => (rewrite_thm_tac o map_eq_sym_rule) x THEN strip_asm_tac x)
	)
	THEN1 prove_∂_tac);
a (lemma_tac ¨$ºâtâs res1 res2Æ
	THEN1 (asm_rewrite_tac [get_spec ¨$ºâtâsÆ]
		THEN REPEAT_N 2 strip_tac));
(* *** Goal "1.1" *** *)
a (lemma_tac ¨µ c∑ c çâg TfForms t ¥
	µ va∑ EvalForm (V, v, w) (va, c) ºât EvalForm (V, x, y) (va, c)Æ
	THEN1 (REPEAT strip_tac));
(* *** Goal "1.1.1" *** *)
a (fc_tac [ft_syntax_thm]);
a (lemma_tac ¨tc ScPrec c tÆ
	THEN1 (all_fc_tac [scprec_fc_clauses2]
		THEN fc_tac [tc_incr_thm]));
a (all_asm_fc_tac[] THEN asm_rewrite_tac[]);
(* *** Goal "1.1.2" *** *)
a (rewrite_tac [get_spec ¨EvalTf_resultsÆ, let_def]);
a (strip_tac);
a (all_asm_fc_tac[]);
a (∂_tac ¨EvalForm (V, x, y) (InsertVars (TfVars t, v') va, f')Æ);
a (strip_tac);
(* *** Goal "1.1.2.1" *** *)
a (∂_tac ¨v'Æ THEN ∂_tac ¨f'Æ THEN asm_rewrite_tac[]);
(* *** Goal "1.1.2.2" *** *)
a (asm_rewrite_tac[]);
(* *** Goal "1.2" *** *)
a (lemma_tac ¨µ c∑ c çâg TfForms t ¥
	µ va∑ EvalForm (V, v, w) (va, c) ºât EvalForm (V, x, y) (va, c)Æ
	THEN1 (REPEAT strip_tac));
(* *** Goal "1.2.1" *** *)
a (fc_tac [ft_syntax_thm]);
a (lemma_tac ¨tc ScPrec c tÆ
	THEN1 (all_fc_tac [scprec_fc_clauses2]
		THEN fc_tac [tc_incr_thm]));
a (all_asm_fc_tac[] THEN asm_rewrite_tac[]);
(* *** Goal "1.2.2" *** *)
a (rewrite_tac [get_spec ¨EvalTf_resultsÆ, let_def]);
a (strip_tac);
a (all_asm_fc_tac[]);
a (∂_tac ¨EvalForm (V, v, w) (InsertVars (TfVars t, v') va, f')Æ);
a (strip_tac);
(* *** Goal "1.2.2.1" *** *)
a (∂_tac ¨v'Æ THEN ∂_tac ¨f'Æ THEN asm_rewrite_tac[]);
(* *** Goal "1.2.2.2" *** *)
a (asm_rewrite_tac[]);
(* *** Goal "1.3" *** *)
a (GET_NTH_ASM_T 1 ante_tac THEN rewrite_tac [get_spec ¨$ºâtâsÆ] THEN strip_tac);
a (lemma_tac ¨res1 = {pTrue} ¥ res2 = {pTrue}Æ
	THEN1 (rewrite_tac [sets_ext_clauses] THEN REPEAT strip_tac));
(* *** Goal "1.3.1" *** *)
a (all_asm_fc_tac[]);
a (all_asm_fc_tac[]);
a (DROP_NTH_ASM_T 6 ante_tac THEN asm_rewrite_tac[get_spec ¨$ºâtÆ]);
a (STRIP_T rewrite_thm_tac);
(* *** Goal "1.3.2" *** *)
a (POP_ASM_T ante_tac THEN SYM_ASMS_T rewrite_tac
	THEN strip_tac);
a (all_asm_fc_tac[]);
a (POP_ASM_T ante_tac
	THEN rewrite_tac [get_spec ¨$ºâtÆ]);
a strip_tac;
a (var_elim_nth_asm_tac 1);
a (var_elim_nth_asm_tac 3);
(* *** Goal "1.3.3" *** *)
a (all_fc_tac [mono_evaltftf_lemma]);
(* *** Goal "1.3.4" *** *)
a (all_fc_tac [mono_evaltftf_lemma]);
(* *** Goal "2" *** *)
a (strip_tac);
a (list_spec_nth_asm_tac 1 [¨Snd zÆ, ¨Fst zÆ]);
a (POP_ASM_T ante_tac THEN rewrite_tac[]);
val evalform_mono_thm = save_pop_thm "evalform_mono_thm";
=TEX
}%ignore

\subsubsection{The Semantic Functor}

=GFT
mono_semanticfunct_lemma1 =
   Ù µ V
     ∑ MonoPprF (Ã (m, e)∑ EvalForm (V, m, e))
         ¥ MonoFunct (SemanticFunctor V) 

mono_semanticfunctor_thm =
   Ù µ V∑ MonoFunct (SemanticFunctor V)
=TEX

\ignore{
=IGN
set_goal ([], ¨µ V∑ MonoPprF (Ã(m, e)∑ EvalForm (V,m,e))
		¥ MonoFunct (SemanticFunctor V)Æ);
a (rewrite_tac (map get_spec [¨MonoFunctÆ, ¨SemanticFunctorÆ] @ [let_def])
	THEN REPEAT strip_tac);
a (fc_tac [monpprf_memrel_lemma1]);
a (DROP_NTH_ASM_T 3 discard_tac);
a (asm_tac eqrel_mono_thm);
a (FC_T (MAP_EVERY (ante_tac o (rewrite_rule[]))) [get_spec ¨MonoPprFÆ]
	THEN_TRY rewrite_tac []
	THEN REPEAT strip_tac);
a (all_asm_fc_tac[]);
a (asm_rewrite_tac [get_spec ¨$ºâpârÆ]);
a (asm_rewrite_tac [get_spec ¨$ºârÆ]);
a (REPEAT µ_tac);
a (SPEC_NTH_ASM_T 2 ¨(x', y')Æ (rewrite_thm_tac o (rewrite_rule [])));
val mono_semanticfunct_lemma1 = save_pop_thm "mono_semanticfunct_lemma1";

set_goal([], ¨µV∑ MonoFunct (SemanticFunctor V)Æ);
a strip_tac;
a (asm_tac evalform_mono_thm);
a (spec_nth_asm_tac 1 ¨VÆ);
a (fc_tac [mono_semanticfunct_lemma1]);
val mono_semanticfunctor_thm = save_pop_thm "mono_semanticfunctor_thm";
=TEX
}%ignore

\subsection{The Least Partial Fixed Point}

Having established the monotonicity of the semantic functor we can obtain a fixed point for any class V.
This will not immediately yield an interpretation of first order set theory because the fixed point will be a pair of relations which are not total over V.

To obtain interpretations of first order set theory we must chose V so as to omit sets which are problematic, and we may view this as seeking a notion of consistency appropriate to this context, i.e. a notion of when a property is consistently reifiable.

The partial fixed points may however be independently useful in applications where the systems of interest are not first order set theories, as in our case where an illative lamdba calculus is sought.

In order to obtain a least fixed point we must define the greatest lower bound of a set of pairs of relations.

For this purpose we need to know the greatest lower bound of a set of truth values.

πHOLCONST
‹ €glbâtâs› : TV SET ≠ TV
˜¸¸¸¸¸¸¸¸¸¸¸
‹ µ tvs∑ glbâtâs tvs =
‹	if tvs = {pTrue} then pTrue
‹	else if tvs= {pFalse} then pFalse
‹	else pU
∞

We need to know that this is indeed the greatest lower bound, and to express this claim we define the relevan notion of lower bound.

πHOLCONST
‹ €IsLbâtâs› : TV SET ≠ TV ≠ BOOL
˜¸¸¸¸¸¸¸¸¸¸¸
‹ µ tvs lb∑ IsLbâtâs tvs lb =
‹	µtv∑ tv ç tvs ¥ lb ºât tv
∞

=GFT
€glbâtâs_thm› =
   Ù µ tvs
     ∑ (∂ tv∑ tv ç tvs)
         ¥ IsLbâtâs tvs (glbâtâs tvs)
           ± (µ tv∑ IsLbâtâs tvs tv ¥ tv ºât glbâtâs tvs)
=TEX

\ignore{
=IGN
set_goal([], ¨µtvs∑ (∂tv∑ tv ç tvs) ¥	
	IsLbâtâs tvs (glbâtâs tvs)
	± µtv∑ IsLbâtâs tvs tv ¥ tv ºât (glbâtâs tvs)Æ);
a (rewrite_tac [get_spec ¨IsLbâtâsÆ, get_spec ¨glbâtâsÆ] THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a (cases_tac ¨tvs = {pTrue}Æ THEN asm_rewrite_tac[]);
(* *** Goal "1.1" *** *)
a (var_elim_nth_asm_tac 1 THEN asm_rewrite_tac[]);
(* *** Goal "1.2" *** *)
a (cases_tac ¨tvs = {pFalse}Æ THEN asm_rewrite_tac[]);
a (var_elim_nth_asm_tac 1 THEN asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a (cases_tac ¨tvs = {pTrue}Æ THEN asm_rewrite_tac[]);
(* *** Goal "2.1" *** *)
a (var_elim_nth_asm_tac 1 THEN spec_nth_asm_tac 1 ¨pTrueÆ);
(* *** Goal "2.2" *** *)
a (cases_tac ¨tvs = {pFalse}Æ THEN asm_rewrite_tac[]);
(* *** Goal "2.2.1" *** *)
a (var_elim_nth_asm_tac 1 THEN spec_nth_asm_tac 2 ¨pFalseÆ);
(* *** Goal "2.2.2" *** *)
a (rewrite_tac [get_spec ¨$ºâtÆ]);
a (asm_fc_tac[]);
a (strip_asm_tac (µ_elim ¨tv'Æ tv_cases_thm));
(* *** Goal "2.2.2.1" *** *)
a (var_elim_nth_asm_tac 1);
a (DROP_NTH_ASM_T 3 (strip_asm_tac o (rewrite_rule [sets_ext_clauses])));
a (spec_nth_asm_tac 5 ¨xÆ);
a (POP_ASM_T ante_tac THEN rewrite_tac [get_spec ¨$ºâtÆ]);
a (swap_nth_asm_concl_tac 1 THEN asm_rewrite_tac[]);
(* *** Goal "2.2.2.1.2" *** *)
a (var_elim_nth_asm_tac 2);
a (DROP_NTH_ASM_T 2 (strip_asm_tac o (rewrite_rule [get_spec ¨$ºâtÆ])));
a (POP_ASM_T (asm_tac o (conv_rule eq_sym_conv)));
a (var_elim_nth_asm_tac 1);
(* *** Goal "2.2.2.2" *** *)
a (var_elim_nth_asm_tac 1);
a (DROP_NTH_ASM_T 2 (strip_asm_tac o (rewrite_rule [sets_ext_clauses])));
(* *** Goal "2.2.2.2.1" *** *)
a (spec_nth_asm_tac 5 ¨xÆ);
a (POP_ASM_T ante_tac THEN rewrite_tac [get_spec ¨$ºâtÆ]);
a (swap_nth_asm_concl_tac 1 THEN asm_rewrite_tac[]);
(* *** Goal "2.2.2.2.2" *** *)
a (var_elim_nth_asm_tac 2);
a (DROP_NTH_ASM_T 2 (strip_asm_tac o (rewrite_rule [get_spec ¨$ºâtÆ])));
a (POP_ASM_T (asm_tac o (conv_rule eq_sym_conv)));
a (var_elim_nth_asm_tac 1);
val glbâtâs_thm = save_pop_thm "glbâtâs_thm";
=TEX
}%ignore

The greatest lower bound of a set of partial relations is:

πHOLCONST
‹ €glbârâs› : 'a R SET ≠ 'a R
˜¸¸¸¸¸¸¸¸¸¸¸
‹ µ spr∑ glbârâs spr =
‹	Ãx y∑ glbâtâs {tv | ∂pr∑ pr ç spr ± pr x y = tv}	
∞

The relevant notion of lower bound is:

πHOLCONST
‹ €IsLbârâs› : 'a R SET ≠ 'a R ≠ BOOL
˜¸¸¸¸¸¸¸¸¸¸¸
‹ µ prs lb∑ IsLbârâs prs lb =
‹	µpr∑ pr ç prs ¥ lb ºâr pr 
∞

=GFT
=TEX

\ignore{
=IGN
set_goal([], ¨µprs∑ (∂pr∑ pr ç prs) ¥	
	IsLbârâs prs (glbârâs prs)
	± µpr∑ IsLbârâs prs pr ¥ $ºâr pr (glbârâs prs)Æ);
a (rewrite_tac [get_spec ¨IsLbârâsÆ, get_spec ¨glbârâsÆ]
	THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a (rewrite_tac [get_spec ¨$ºârÆ] THEN REPEAT strip_tac);
a (asm_tac glbâtâs_thm);
a (spec_nth_asm_tac 1 ¨{tv|∂ pr∑ pr ç prs ± pr x y = tv}Æ);
(* *** Goal "1.1" *** *)
a (spec_nth_asm_tac 1 ¨pr x yÆ);
a (spec_nth_asm_tac 1 ¨prÆ);
(* *** Goal "1.2" *** *)

=TEX
}%ignore

The greatest lower bound of a set of pairs of partial relations is then:

πHOLCONST
‹ €glbâsâpâr› : 'a PR SET ≠ 'a PR
˜¸¸¸¸¸¸¸¸¸¸¸
‹ µ sppr∑ glbâsâpâr sppr =
‹	(glbârâs {pr | ∂ppr∑ ppr ç sppr ± pr = Fst ppr},
‹	 glbârâs {pr | ∂ppr∑ ppr ç sppr ± pr = Snd ppr})	
∞

and the least fixed point of a functor over pairs of partial relations is:

πHOLCONST
‹ €lfpâpâr› : ('a PR ≠ 'a PR) ≠ 'a PR
˜¸¸¸¸¸¸¸¸¸¸¸
‹ µ f∑ lfpâpâr f =
‹	glbâsâpâr {ppr | $ºâpâr (f ppr) ppr}
∞

=GFT
=TEX

\ignore{
=IGN
set_goal([], ¨Æ)


set_goal([], ¨µf∑ MonoFunct f ¥ f(lfpâr f) = (lfpâr f)Æ);
a (REPEAT strip_tac THEN asm_fc_tac [get_spec ¨MonoFunctÆ]);
a (lemma_tac ¨$ºâpâr (f (lfpâr f)) (lfpâr f)Æ);
(* *** Goal "1" *** *)
a (rewrite_tac (map get_spec [¨$ºâpârÆ])
	THEN REPEAT µ_tac);
a (rewrite_tac (map get_spec [¨$ºârÆ])
	THEN REPEAT µ_tac);
a (rewrite_tac (map get_spec [¨$ºârÆ, ¨$ºâtÆ])
	THEN REPEAT µ_tac);
(* *** Goal "1.1" *** *)
a (lemma_tac ¨$ºâpâr (lfpâr f) Æ);

=TEX
}%ignore

\subsection{Alternative Definition of Least Fixed Point}

The proof that the above definition does yield a least fixed point is eluding me, so I thought I would try harder to make use of the fixed point result already available 


\subsubsection{Proof Contexts}

=SML
add_pc_thms "'ifol" [];
commit_pc "'ifol";

force_new_pc "€ifol›";
merge_pcs ["hol", "'GS1", "'ifol"] "ifol";
commit_pc "ifol";

force_new_pc "€ifol1›";
merge_pcs ["hol1", "'GS1", "'ifol"] "ifol1";
commit_pc "ifol1";
=TEX

{\let\Section\section
\newcounter{ThyNum}
\def\section#1{\Section{#1}
\addtocounter{ThyNum}{1}\label{Theory\arabic{ThyNum}}}
\include{ifol.th}
}  %\let

\twocolumn[\section{INDEX}\label{index}]
{\small\printindex}

\end{document}
