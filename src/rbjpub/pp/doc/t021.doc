=IGN
$Id: t021.doc,v 1.10 2007/10/21 19:54:19 rbj01 Exp $
open_theory "ICsyn";
set_merge_pcs ["hol1", "'GS1", "'ICsyn"];
open_theory "ICsem";
set_merge_pcs ["hol", "'GS1", "'ICsyn", "'ICsem"];
=TEX
\documentclass[11pt,a4paper]{article}
\usepackage{latexsym}
\usepackage{ProofPower}
\ftlinepenalty=9999
\usepackage{A4}

%\def\ExpName{\mbox{{\sf exp}
%\def\Exp#1{\ExpName(#1)}

\tabstop=0.4in
\newcommand{\ignore}[1]{}

\title{Set Theory as Consistent Infinitary Comprehension}
\makeindex
\usepackage[unicode,pdftex]{hyperref}
\hypersetup{pdfauthor={Roger Bishop Jones}}
\hypersetup{colorlinks=true, urlcolor=black, citecolor=black, filecolor=black, linkcolor=black}

\author{Roger Bishop Jones}
\date{\ }

\begin{document}
\begin{titlepage}
\maketitle
\begin{abstract}
This paper is concerned with set theory conceived as a maximal consistent theory of set comprehension.
This is interpreted by looking for large subdomains of a notation for infinitary comprehension, and the theory is developed from such interpretations.
\end{abstract}

\vfill

\begin{centering}

{\footnotesize

Created: 2006/11/29

Last Change $ $Date: 2007/10/21 19:54:19 $ $

\href{http://www.rbjones.com/rbjpub/pp/doc/t021.pdf}
{http://www.rbjones.com/rbjpub/pp/doc/t021.pdf}

$ $Id: t021.doc,v 1.10 2007/10/21 19:54:19 rbj01 Exp $ $

\copyright\ Roger Bishop Jones; Licenced under Gnu LGPL

}%footnotesize

\end{centering}

\thispagestyle{empty}
\end{titlepage}
\newpage
\addtocounter{page}{1}
%\section{DOCUMENT CONTROL}
%\subsection{Contents list}
{\parskip=0pt\tableofcontents}
%\newpage
%\subsection{Document cross references}

\subsection*{To Do}
\begin{itemize}
\item 
\item 
\end{itemize}

{\raggedright
\bibliographystyle{fmu}
\bibliography{rbj,fmu}
} %\raggedright

\newpage
\section{INTRODUCTION}

The idea is to come up with a set theory whose subject matter combines the well-founded sets of the cumulative heirarchy with a similarly rich non-well-founded ontology.

The well-founded ontology is based on a simple ontological principle embodied in the following informal definition (transfinite, inductive) of ``well-founded set'':
{\quote a well-founded set is any definite collection of well-founded sets}

Analysis and futher explication of this definition is worthwhile, but is not our present purpose, for which we will assume that the above description suffices and proceed to the non-well-founded sets.

There are different conceptions of well-founded-set from which we may chose, and I do not know of any single all encompassing conception.
Probably the single most prominent conception comes from the idea of set comprehension, viz. that to some useful subset of the properties of sets there correspond sets which are the extensions of the properties.
In the beginnings, Frege allowed unrestrained comprehension, which resulted in inconsistency.
A variety of set theories may then be regarded as limitations on the ideal of unrestrained comprehension sufficient to avoid incoherence.
One of these yields the well-founded sets (or some of them).

If the incoherence of unrestricted comprehension could be located in specific properties then sets correponding to their extension could be omitted from the the domain of discourse and a maximal consistent theory of set comprehension might result.
There is however no obvious way to do this.
The properties are themselves all equally coherent, it is only when we attempt to realise an ontology of sets whose extensions correpond to the properties that we run into trouble, and when this happens it is not so easy to say which properties are at fault.
Nevertheless, this is what we are going to attempt here.

There is another problem which must be mentioned here.
When we seek a full theory of comprehension, we are looking for a set theory in which the set properties of sets is the same as the set of sets itself.
There is a problem of cardinality here, which forces us to limit our selection of properties.
This problem we address by taking, instead of the notion of property in general, the notion of definable property or rule will be used.
The number of such definable properties depends upon the language in which the definition takes place, and we arrange for the cardinality of the syntax of this language to be the same as the cardinality of the domain of our set theory (which will also be the cardinality of the well-founded part of the domain).
This effect can be achieved by coding up the properties in an infinitary language whose syntax is made from well-founded sets.
The language will have sufficent syntax for every well-founded set to correspond to a definable property as well as the non-well-founded sets, and we therefore by means of this infinitary syntax assimilate both non well-founded and well-founded sets, but also the notion of set as graph an set as rule.

The plan is:

\begin{itemize}

\item Define using the ontology of a well-founded set theory (GS) a notation for infinitary comprehension (this will be a transfinite inductive definition of a way of coding up set comprehension in an infinitary language for set theory).

\item Give a semantics to this notation as a functor which transforms pairs of partial equality and membership relations over closed comprehensions.

\item Find maximal subsets of the class of closed comprehensions over which the functor has a fixed point, and consider the theory which arises when these subsets with the fixedpoint semantics are taken as interpretations of set theory.

\end{itemize}

\newpage

=SML
open_theory "GS";
force_new_theory "ICsyn";
new_parent "U_orders";
force_new_pc "'ICsyn";
merge_pcs ["'savedthm_cs_¶_proof"] "'ICsyn";
set_merge_pcs ["hol1", "'GS1", "'ICsyn"];
=TEX

\section{MISCELLANEA}

I am at present using a set theory based on an old version of the theory of well-foundedness and well-founded recursion.

Some definitions are supplied here which patch over the differences between the new and old treatments of well-foundedness.

\subsection{Naming the Natural Numbers}

It will be useful to be able to have names for the finite ordinals, which are used as tags in the syntax:

¹HOLCONST
Ü ÛNat‰gÝ: î ­ GS
÷üüüüüüüüüüü
Ü       Nat‰g 0 = š‰g
Ü ± µn· Nat‰g (n+1) = suc‰o (Nat‰g n)
°

We will need to know that these are all distinct ordinals.

=GFT
ord_nat_thm =
	ô µ n· ordinal (Nat‰g n)

not_suc_nat_zero_thm =
	ô µ n· ³ suc‰o (Nat‰g n) = š‰g

less_sum_thm =
	ô µ x y· x ¼ y ´ (¶ z· x + z = y)

natg_mono_thm =
	ô µ x y· Nat‰g x ¼‰o Nat‰g (x + y)
=TEX

\ignore{
=SML
set_goal([], ¬µn· ordinal (Nat‰g n)®);
a (strip_tac);
a (induction_tac ¬n®);
a (rewrite_tac [get_spec ¬Nat‰g®, ordinal_š‰g]);
a (rewrite_tac [get_spec ¬Nat‰g®]);
a (fc_tac [ord_suc_ord_thm]);
val ord_nat_thm = save_pop_thm "ord_nat_thm";

set_goal([], ¬µn· ³ suc‰o (Nat‰g n) = š‰g®);
a (asm_tac ord_nat_thm);
a (strip_asm_tac š‰g_not_suc‰o_thm);
a strip_tac;
a (spec_nth_asm_tac 1 ¬Nat‰g n®);
val not_suc_nat_zero_thm = save_pop_thm "not_suc_nat_zero_thm";

set_goal([], ¬µx y:î· x ¼ y ´ ¶z· x + z = y®);
a (REPEAT µ_tac);
a (induction_tac ¬y®);
(* *** Goal "1" *** *)
a (strip_tac THEN ¶_tac ¬0® THEN asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a (strip_tac THEN ¶_tac ¬0®
	THEN (PC_T1 "lin_arith" asm_prove_tac[]));
(* *** Goal "3" *** *)
a (strip_tac THEN ¶_tac ¬z + 1®
	THEN (PC_T1 "lin_arith" asm_prove_tac[]));
val less_sum_thm = save_pop_thm "less_sum_thm";

set_goal([], ¬µx y:î· Nat‰g x ¼‰o Nat‰g (x + y)®);
a (REPEAT µ_tac);
a (induction_tac ¬y®);
(* *** Goal "1" *** *)
a (rewrite_tac [leo_lo_thm, ord_nat_thm]);
(* *** Goal "2" *** *)
a (rewrite_tac [get_spec ¬Nat‰g®,
	pc_rule1 "lin_arith" prove_rule [] ¬x + y + 1 = (x + y) + 1®]);
a (asm_tac leo_suc_thm);
a (asm_tac ord_nat_thm);
a (spec_nth_asm_tac 1 ¬x+y®);
a (asm_fc_tac []);
a (all_asm_fc_tac [leo_trans_thm]);
val natg_mono_thm = save_pop_thm "natg_mono_thm";

set_goal([], ¬µx y· Nat‰g x = Nat‰g y ´ x = y®);
a (REPEAT µ_tac);
a (strip_asm_tac (list_µ_elim [¬x®, ¬y®] ¼_cases_thm));
(* *** Goal "1" *** *)
a (fc_tac [less_sum_thm]);
a (POP_ASM_T ante_tac THEN induction_tac ¬z®);
(* *** Goal "1.1" *** *)
a (rewrite_tac[] THEN REPEAT strip_tac);
(* *** Goal "1.2" *** *)
a (strip_tac);
a (SYM_ASMS_T rewrite_tac);
a (lemma_tac ¬Nat‰g x ¼‰o Nat‰g (x + z)®
	THEN1 rewrite_tac [natg_mono_thm]);
a (lemma_tac ¬Nat‰g (x + z) <‰o Nat‰g (x + z + 1)®);
(* *** Goal "1.2.1" *** *)
a (rewrite_tac [pc_rule1 "lin_arith" prove_rule [] ¬x + z + 1 = (x + z) + 1®]);
a (rewrite_tac [get_spec ¬Nat‰g®]);
a (asm_tac (µ_elim ¬x+z® ord_nat_thm));
a (FC_T rewrite_tac [lo_suc_thm]);
(* *** Goal "1.2.2" *** *)
a (all_fc_tac [leo_lo_trans_thm]);
a (POP_ASM_T ante_tac
	THEN (rewrite_tac [get_spec ¬$<‰o®])
	THEN REPEAT strip_tac);
a (swap_nth_asm_concl_tac 1);
a (asm_rewrite_tac [wf_l1]);
(* *** Goal "1.3" *** *)
a (asm_rewrite_tac[]);
(* *** Goal "1.4" *** *)
a (asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a (fc_tac [less_sum_thm]);
a (POP_ASM_T ante_tac THEN induction_tac ¬z®);
(* *** Goal "2.1" *** *)
a (rewrite_tac[] THEN REPEAT strip_tac THEN asm_rewrite_tac[]);
(* *** Goal "2.2" *** *)
a (strip_tac);
a (SYM_ASMS_T rewrite_tac);
a (lemma_tac ¬Nat‰g y ¼‰o Nat‰g (y + z)®
	THEN1 rewrite_tac [natg_mono_thm]);
a (lemma_tac ¬Nat‰g (y + z) <‰o Nat‰g (y + z + 1)®);
(* *** Goal "2.2.1" *** *)
a (rewrite_tac [pc_rule1 "lin_arith" prove_rule [] ¬y + z + 1 = (y + z) + 1®]);
a (rewrite_tac [get_spec ¬Nat‰g®]);
a (asm_tac (µ_elim ¬y+z® ord_nat_thm));
a (FC_T rewrite_tac [lo_suc_thm]);
(* *** Goal "2.2.2" *** *)
a (all_fc_tac [leo_lo_trans_thm]);
a (POP_ASM_T ante_tac
	THEN (rewrite_tac [get_spec ¬$<‰o®])
	THEN REPEAT strip_tac);
a (swap_nth_asm_concl_tac 1);
a (asm_rewrite_tac [wf_l1]);
(* *** Goal "2.3" *** *)
a (asm_rewrite_tac[]);
(* *** Goal "2.4" *** *)
a (asm_rewrite_tac[]);
val natg_one_one_thm = save_pop_thm "natg_one_one_thm";

=IGN
set_goal([], ¬µx y· Nat‰g (x+y) = (Nat‰g x) +‰o (Nat‰g y)®);
a (REPEAT µ_tac);
a (induction_tac ¬y®);
a (rewrite_tac[get_spec ¬$+‰o®, get_spec ¬Nat‰g®]);
a (rewrite_tac [pc_rule1 "lin_arith" prove_rule [] ¬x + y + 1 = (x + y) + 1®]);
a (asm_rewrite_tac[get_spec¬Nat‰g®]);
=TEX
}%ignore

\subsection{Some Synonyms}

=GFT
tc_TranClsr_thm =
	ô µ r· (Universe, tc r) = TranClsr (Universe, r)
=TEX

\ignore{
=SML
set_goal([], ¬µr· (Universe, tc r) = TranClsr (Universe, r)®);
a (rewrite_tac (map get_spec [
	¬tc®,
	¬TranClsr®,
	¬trans®,
	¬Trans®]));
val tc_TranClsr_thm = save_pop_thm "tc_TranClsr_thm";
=TEX
}%ignore

\section{SYNTAX}

Here is an abstract syntax:

=GFT
term    ::= ordinal
	 | SetComp formula

formula ::= term = term
          | term  term
          | tf ordinal (ð formula)
=TEX

The ordinals here are used as variables, and Von Neumann ordinals are required.
They are in fact used like De Bruijn indices, so comprehension always binds the variable zero at the outermost level, and binds a higher numbered variable in inner scopes.
A single constructor is provided for truth functional expressions and is to be understood as the negation of the universal quantification of the conjunction of a set (of any cardinality) of formulae.
This quantified simultaneously quantifies over any number of variables.

The following define realisations of the constructors for the abstract syntax:


¹HOLCONST
Ü ÛMkVarÝ : GS ­ GS
÷üüüüüüüüüüü
Ü    µv· MkVar v = (Nat‰g 0) í‰g v
°

¹HOLCONST
Ü ÛIsVarÝ : GS ­ BOOL
÷üüüüüüüüüüü
Ü    µt· IsVar t = fst t = (Nat‰g 0)
°

¹HOLCONST
Ü ÛVarNumÝ : GS ­ GS
÷üüüüüüüüüüü
Ü    VarNum = snd
°

¹HOLCONST
Ü ÛMkCompÝ : GS ­ GS
÷üüüüüüüüüüü
Ü    µf· MkComp f = (Nat‰g 1) í‰g f
°

¹HOLCONST
Ü ÛIsCompÝ : GS ­ BOOL
÷üüüüüüüüüüü
Ü    µt· IsComp t = fst t = (Nat‰g 1)
°

¹HOLCONST
Ü ÛCompBodyÝ : GS ­ GS
÷üüüüüüüüüüü
Ü    CompBody = snd
°

¹HOLCONST
Ü ÛMkEqÝ : GS ¸ GS ­ GS
÷üüüüüüüüüüü
Ü µlr· MkEq lr = (Nat‰g 2) í‰g ((Fst lr) í‰g (Snd lr))
°

¹HOLCONST
Ü ÛIsEqÝ : GS ­ BOOL
÷üüüüüüüüüüü
Ü    µt· IsEq t = fst t = (Nat‰g 2)
°

¹HOLCONST
Ü ÛMkMemÝ : GS ¸ GS ­ GS
÷üüüüüüüüüüü
Ü µ lr·  MkMem lr = (Nat‰g 3) í‰g ((Fst lr) í‰g (Snd lr))
°

¹HOLCONST
Ü ÛIsMemÝ : GS ­ BOOL
÷üüüüüüüüüüü
Ü µt· IsMem t = fst t = (Nat‰g 3)
°

¹HOLCONST
Ü ÛAtomLhsÝ : GS ­ GS
÷üüüüüüüüüüü
Ü  AtomLhs = Ìx· fst(snd x)
°

¹HOLCONST
Ü ÛAtomRhsÝ : GS ­ GS
÷üüüüüüüüüüü
Ü  AtomRhs = Ìx· snd(snd x)
°

¹HOLCONST
Ü ÛMkTfÝ : GS ¸ GS ­ GS
÷üüüüüüüüüüü
Ü µvc· MkTf vc = (Nat‰g 4) í‰g ((Fst vc) í‰g (Snd vc))
°

¹HOLCONST
Ü ÛIsTfÝ : GS ­ BOOL
÷üüüüüüüüüüü
Ü    µt· IsTf t = fst t = (Nat‰g 4)
°

¹HOLCONST
Ü ÛTfVarsÝ : GS ­ GS
÷üüüüüüüüüüü
Ü  TfVars = Ìx· fst(snd x)
°

¹HOLCONST
Ü ÛTfFormsÝ : GS ­ GS
÷üüüüüüüüüüü
Ü  TfForms = Ìx· snd(snd x)
°

=GFT
=TEX

\ignore{
=SML
set_goal([], ¬(µv· IsVar (MkVar v))
	± (µf· ³ IsVar (MkComp f))
	± (µlr· ³ IsVar (MkEq lr))
	± (µlr· ³ IsVar (MkMem lr))
	± (µvc· ³ IsVar (MkTf vc))®);
a (rewrite_tac [get_spec ¬IsVar®,
	get_spec ¬MkVar®,
	get_spec ¬MkComp®,
	get_spec ¬MkEq®,
	get_spec ¬MkMem®,
	get_spec ¬MkTf®]);
a (contr_tac THEN FC_T (MAP_EVERY ante_tac) [natg_one_one_thm] 
	THEN PC_T1 "lin_arith" prove_tac[]);
val IsVar_clauses = save_pop_thm "IsVar_clauses";

set_goal([], ¬(µv· ³ IsComp (MkVar v))
	± (µf· IsComp (MkComp f))
	± (µlr· ³ IsComp (MkEq lr))
	± (µlr· ³ IsComp (MkMem lr))
	± (µvc· ³ IsComp (MkTf vc))®);
a (rewrite_tac [get_spec ¬IsComp®,
	get_spec ¬MkVar®,
	get_spec ¬MkComp®,
	get_spec ¬MkEq®,
	get_spec ¬MkMem®,
	get_spec ¬MkTf®]);
a (contr_tac THEN FC_T (MAP_EVERY ante_tac) [natg_one_one_thm] 
	THEN PC_T1 "lin_arith" prove_tac[]);
val IsComp_clauses = save_pop_thm "IsComp_clauses";

set_goal([], ¬(µv· ³ IsEq (MkVar v))
	± (µf· ³ IsEq (MkComp f))
	± (µlr· IsEq (MkEq lr))
	± (µlr· ³ IsEq (MkMem lr))
	± (µvc· ³ IsEq (MkTf vc))®);
a (rewrite_tac [get_spec ¬IsEq®,
	get_spec ¬MkVar®,
	get_spec ¬MkComp®,
	get_spec ¬MkEq®,
	get_spec ¬MkMem®,
	get_spec ¬MkTf®]);
a (contr_tac THEN FC_T (MAP_EVERY ante_tac) [natg_one_one_thm] 
	THEN PC_T1 "lin_arith" prove_tac[]);
val IsEq_clauses = save_pop_thm "IsEq_clauses";

set_goal([], ¬(µv· ³ IsMem (MkVar v))
	± (µf· ³ IsMem (MkComp f))
	± (µlr· ³ IsMem (MkEq lr))
	± (µlr· IsMem (MkMem lr))
	± (µvc· ³ IsMem (MkTf vc))®);
a (rewrite_tac [get_spec ¬IsMem®,
	get_spec ¬MkVar®,
	get_spec ¬MkComp®,
	get_spec ¬MkEq®,
	get_spec ¬MkMem®,
	get_spec ¬MkTf®]);
a (contr_tac THEN FC_T (MAP_EVERY ante_tac) [natg_one_one_thm] 
	THEN PC_T1 "lin_arith" prove_tac[]);
val IsMem_clauses = save_pop_thm "IsMem_clauses";

set_goal([], ¬(µv· ³ IsTf (MkVar v))
	± (µf· ³ IsTf (MkComp f))
	± (µlr· ³ IsTf (MkEq lr))
	± (µlr· ³ IsTf (MkMem lr))
	± (µvc· IsTf (MkTf vc))®);
a (rewrite_tac [get_spec ¬IsTf®,
	get_spec ¬MkVar®,
	get_spec ¬MkComp®,
	get_spec ¬MkEq®,
	get_spec ¬MkMem®,
	get_spec ¬MkTf®]);
a (contr_tac THEN FC_T (MAP_EVERY ante_tac) [natg_one_one_thm] 
	THEN PC_T1 "lin_arith" prove_tac[]);
val IsTf_clauses = save_pop_thm "IsTf_clauses";

val Is_clauses = list_±_intro [IsVar_clauses, IsComp_clauses, IsEq_clauses, IsMem_clauses, IsTf_clauses];

add_pc_thms "'ICsyn" (map get_spec [] @ [ord_nat_thm, Is_clauses]);
set_merge_pcs ["hol1", "'GS1", "'ICsyn"];

=SML
set_goal ([], ¬
	(µx· IsVar x ´ ³ IsComp x ± ³ IsEq x ± ³ IsMem x ± ³ IsTf x)
±	(µx· IsComp x ´ ³ IsVar x ± ³ IsEq x ± ³ IsMem x ± ³ IsTf x)
±	(µx· IsEq x ´ ³ IsComp x ± ³ IsVar x ± ³ IsMem x ± ³ IsTf x)
±	(µx· IsMem x ´ ³ IsComp x ± ³ IsVar x ± ³ IsEq x ± ³ IsTf x)
±	(µx· IsTf x ´ ³ IsComp x ± ³ IsVar x ± ³ IsEq x ± ³ IsMem x)
®);
a (rewrite_tac (map get_spec [¬IsVar®, ¬IsComp®, ¬IsEq®, ¬IsMem®, ¬IsTf®]));
a (REPEAT strip_tac THEN asm_rewrite_tac[]
	THEN contr_tac THEN FC_T (MAP_EVERY ante_tac) [natg_one_one_thm]
	THEN PC_T1 "lin_arith" rewrite_tac[]);
val Is_not_fc_clauses = save_pop_thm "Is_not_fc_clauses";
=TEX

}%ignore

Some derived syntax:

¹HOLCONST
Ü ÛMkNotÝ : GS ­ GS
÷üüüüüüüüüüü
Ü µf· MkNot f = MkTf (š‰g, Pair f f)
°

¹HOLCONST
Ü ÛIsTermÝ : GS ­ BOOL
÷üüüüüüüüüüü
Ü    µt· IsTerm t ¤ IsVar t ² IsComp t
°

¹HOLCONST
Ü ÛTermsÝ : GS SET ­ GS SET
÷üüüüüüüüüüü
Ü    µs· Terms s = {x | x  s ± IsTerm x}
°

=GFT
terms_mono_thm =
	ô µ s t· s € t ´ Terms s € Terms t
=TEX

\ignore{
=SML
set_goal([], ¬µs t· s € t ´ Terms s € Terms t®);
a (rewrite_tac [get_spec ¬Terms®] THEN REPEAT strip_tac);
a (asm_fc_tac[]);
val terms_mono_thm = save_pop_thm "terms_mono_thm";
=TEX
}%ignore


¹HOLCONST
Ü ÛIsFormÝ : GS ­ BOOL
÷üüüüüüüüüüü
Ü    µx· IsForm x ¤ IsMem x ² IsEq x ² IsTf x
°

¹HOLCONST
Ü ÛFormulasÝ : GS SET ­ GS SET
÷üüüüüüüüüüü
Ü    µs· Formulas s = {x | x  s ± IsForm x}
°

=GFT
formulas_mono_thm =
	ô µ s t· s € t ´ Formulas s € Formulas t
=TEX

\ignore{
=SML
set_goal([], ¬µs t· s € t ´ Formulas s € Formulas t®);
a (rewrite_tac [get_spec ¬Formulas®]
	THEN REPEAT strip_tac
	THEN asm_fc_tac[]);
val formulas_mono_thm = save_pop_thm "formulas_mono_thm";
=TEX
}%ignore


¹HOLCONST
Ü ÛRepClosedÝ: GS SET ­ BOOL
÷üüüüüüüüüüü
Ü µ s· RepClosed s ¤
	(µ ord·  ordinal ord ´ MkVar ord  s)
±	(µ f· f  Formulas s ´ MkComp f  s)
±	(µ t1 t2· t1  Terms s ± t2  Terms s
		´ MkEq (t1, t2)  s
           	± MkMem (t1, t2)  s)
±	(µ ord fs· ordinal ord ± X‰g fs € Formulas s
         ´ MkTf (ord, fs)  s)
°

The syntax is then the smallest set closed under these constructions.

¹HOLCONST
Ü ÛSyntaxÝ : GS SET
÷üüüüüüüüüüü
Ü Syntax = ¥{x | RepClosed x}
°

=GFT
syntax_€_repclosed_thm =
	ô µ s· RepClosed s ´ Syntax € s
repclosed_term_thm =
	ô µ t· RepClosed t ´ Terms Syntax € Terms t
reclosed_forn_thm =
	ô µ t· RepClosed t ´ Formulas Syntax € Formulas t
=TEX

\ignore{
=SML
set_goal([], ¬µs· RepClosed s ´ Syntax € s®);
a (rewrite_tac [get_spec ¬Syntax®]
	THEN REPEAT strip_tac THEN asm_fc_tac[]);
val syntax_€_repclosed_thm = save_pop_thm "syntax_€_repclosed_thm";

val repclosed_term_thm = save_thm ("repclosed_term_thm",
all_µ_intro (´_trans_rule
(µ_elim ¬t:GS SET® syntax_€_repclosed_thm)
(list_µ_elim [¬Syntax®, ¬t:GS SET®] terms_mono_thm)));

val repclosed_form_thm = save_thm ("repclosed_form_thm",
all_µ_intro (´_trans_rule
(µ_elim ¬t:GS SET® syntax_€_repclosed_thm)
(list_µ_elim [¬Syntax®, ¬t:GS SET®] formulas_mono_thm)));
=TEX
}%ignore

This is an ``inductive datatype'' so we should expect the usual kinds of theorem.

Informally these should say:

\begin{itemize}
\item Everything in Syntax is either a Term or a Formula.
\item Syntax is closed under the five syntactic constructors.
\item The syntax constructors are all injections, have disjoint ranges, and partition the syntax. 
\item Any syntactic property which is preserved by the constructors (i.e. is true of any construction if it is true of all its syntactic constituents) is true of everything in syntax (this is an induction principle).
\end{itemize}

Formally these may be given thus:

=GFT
Syntax = Formulas Syntax À Terms Syntax

RepClosed Syntax
=TEX

=GFT
repclosed_syntax_thm =
	ô RepClosed Syntax

repclosed_syntax_thm1 =
   ô (µ ord· ordinal ord ´ MkVar ord  Syntax)
       ± (µ f· f  Formulas Syntax ´ MkComp f  Syntax)
       ± (µ t1 t2
       · t1  Terms Syntax ± t2  Terms Syntax
           ´ MkEq (t1, t2)  Syntax ± MkMem (t1, t2)  Syntax)
       ± (µ ord fs
       · ordinal ord ± (µ x· x  X‰g fs ´ x  Formulas Syntax)
           ´ MkTf (ord, fs)  Syntax)

syntax_induction_thm =
	ô µ s· RepClosed s ´ Syntax € s

syntax_induction_thm2 =
	ô µ p· RepClosed {x|p x} ´ (µ x· x  Syntax ´ p x)
=TEX

\ignore{
=SML
set_goal([], ¬RepClosed Syntax®);
a (rewrite_tac (map get_spec [¬RepClosed®])
	THEN strip_tac);
a (rewrite_tac (map get_spec [¬RepClosed®, ¬Syntax®])
	THEN REPEAT strip_tac
	THEN all_asm_fc_tac[]);
a (REPEAT strip_tac);
a (rewrite_tac (map get_spec [¬Syntax®])
	THEN REPEAT strip_tac
	THEN fc_tac [repclosed_form_thm]);
a (asm_fc_tac[get_spec ¬RepClosed®]);
a (asm_fc_tac[]);
(* *** Goal "2.2" *** *)
a (rewrite_tac (map get_spec [¬Syntax®])
	THEN REPEAT strip_tac
	THEN fc_tac [repclosed_term_thm]);
a (asm_fc_tac[get_spec ¬RepClosed®]);
a (all_asm_fc_tac[]);
(* *** Goal "2.3" *** *)
a (rewrite_tac (map get_spec [¬Syntax®])
	THEN REPEAT strip_tac
	THEN fc_tac [repclosed_term_thm]);
a (asm_fc_tac[get_spec ¬RepClosed®]);
a (all_asm_fc_tac[]);
(* *** Goal "2.4" *** *)
a (rewrite_tac (map get_spec [¬Syntax®])
	THEN REPEAT strip_tac
	THEN fc_tac [repclosed_form_thm]);
a (asm_fc_tac[get_spec ¬RepClosed®]);
a (lemma_tac ¬µ x· x  X‰g fs ´ x  Formulas s®
	THEN1 (REPEAT strip_tac
		THEN asm_prove_tac[]));
a (all_asm_fc_tac[]);
val repclosed_syntax_thm = save_pop_thm "repclosed_syntax_thm";

val repclosed_syntax_thm1 = save_thm ("repclosed_syntax_thm1",
	rewrite_rule [get_spec ¬RepClosed®] repclosed_syntax_thm);

set_goal([], ¬µs· RepClosed s ´ Syntax € s®);
a (rewrite_tac [get_spec ¬Syntax®]
	THEN prove_tac[]);
val syntax_induction_thm1 = save_pop_thm "syntax_induction_thm1";

set_goal([], ¬µp· RepClosed {x | p x} ´ µx· x  Syntax ´ p x®);
a (rewrite_tac [get_spec ¬Syntax®] THEN REPEAT strip_tac);
a (asm_fc_tac[]);
val syntax_induction_thm2 = save_pop_thm "syntax_induction_thm2";

set_goal([], ¬µx· x  Syntax ´ IsTerm x ² IsForm x®);
a (asm_tac (µ_elim ¬{x | IsTerm x ² IsForm x}® syntax_induction_thm1));
a (lemma_tac ¬RepClosed {x|IsTerm x ² IsForm x}®
	THEN1 (rewrite_tac (map get_spec [
	¬RepClosed®, ¬IsTerm®, ¬IsForm®, ¬MkVar®, ¬IsVar®, ¬MkComp®, ¬IsComp®,
	¬MkEq®, ¬IsEq®, ¬MkMem®, ¬IsMem®, ¬MkTf®, ¬IsTf®])));
a (rewrite_tac [get_spec ¬Syntax®] THEN REPEAT strip_tac);
a (asm_fc_tac[]);
val term_or_formula_thm = save_pop_thm "term_or_formula_thm";
=TEX
}%ignore

We need to be able to define functions by recursion over the syntax of comprehensions.
For this we need a recursion theorem.
We have a recursion theorem for well founded recursion already, so we can build on that.
To use that recursion theorem we need to prove that the syntax of comprehensions is well-founded.
This is itself equivalent to an induction principle, so we can try and derive it using the induction principles already available for the syntax of comprehension.

We must first define the relation of priority over the syntax, i.e. the relation between an element of the syntax and its constitutents.

¹HOLCONST
Ü ÛScPrecÝ : GS ­ GS ­ BOOL
÷üüüüüüüüüüü
Ü µÁ Ç· ScPrec Á Ç ¤
Ü ¶ord fs Â· {Á; Â; Ç} € Syntax ± Á ‰g fs
Ü  ±	(	Ç = MkComp Á
Ü  	²	Ç = MkEq (Á, Â)
Ü  	²	Ç = MkEq (Â, Á)
Ü  	²	Ç = MkMem (Á, Â)
Ü  	²	Ç = MkMem (Â, Á)
Ü  	²	Ç = MkTf (ord, fs))
°

=GFT
well_founded_ScPrec_thm =
	ô well_founded ScPrec
=TEX

\ignore{
=SML
set_goal([], ¬µx y· ScPrec x y ´ tc $‰g x y®);
a (rewrite_tac (map get_spec [¬ScPrec®, ¬MkComp®, ¬MkEq®, ¬MkMem®, ¬MkTf®]));
a (REPEAT strip_tac THEN asm_rewrite_tac [í_tc_thm]);
(* *** Goal "1" *** *)
a (lemma_tac ¬tc $‰g x (x í‰g Â) ± tc $‰g (x í‰g Â) (Nat‰g 2 í‰g x í‰g Â)®
	THEN1 rewrite_tac [í_tc_thm]);
a (all_fc_tac [tran_tc_thm2]);
(* *** Goal "2" *** *)
a (lemma_tac ¬tc $‰g x (Â í‰g x) ± tc $‰g (Â í‰g x) (Nat‰g 2 í‰g Â í‰g x)®
	THEN1 rewrite_tac [í_tc_thm]);
a (all_fc_tac [tran_tc_thm2]);
(* *** Goal "3" *** *)
a (lemma_tac ¬tc $‰g x (x í‰g Â) ± tc $‰g (x í‰g Â) (Nat‰g 3 í‰g x í‰g Â)®
	THEN1 rewrite_tac [í_tc_thm]);
a (all_fc_tac [tran_tc_thm2]);
(* *** Goal "4" *** *)
a (lemma_tac ¬tc $‰g x (Â í‰g x) ± tc $‰g (Â í‰g x) (Nat‰g 3 í‰g Â í‰g x)®
	THEN1 rewrite_tac [í_tc_thm]);
a (all_fc_tac [tran_tc_thm2]);
(* *** Goal "5" *** *)
a (lemma_tac ¬tc $‰g fs (ord í‰g fs) ± tc $‰g (ord í‰g fs) (Nat‰g 4 í‰g ord í‰g fs)®
	THEN1 rewrite_tac [í_tc_thm]);
a (all_fc_tac [tran_tc_thm2, tc_incr_thm]);
a (all_fc_tac [tran_tc_thm2, tc_incr_thm]);
val ScPrec_tc__thm = pop_thm ();

set_goal ([], ¬well_founded ScPrec®);
a (rewrite_tac [get_spec ¬well_founded®]);
a (REPEAT strip_tac);
a (asm_tac (µ_elim ¬s® gs_cv_ind_thm));
a (lemma_tac ¬µ x· (µ y· tc $‰g y x ´ s y) ´ s x®
	THEN1 REPEAT strip_tac);
(* *** Goal "1" *** *)
a (lemma_tac ¬µ y· ScPrec y x ´ s y®
	THEN1 (REPEAT strip_tac THEN all_fc_tac [ScPrec_tc__thm]
		THEN asm_fc_tac []));
a (asm_fc_tac[]);
(* *** Goal "2" *** *)
a (asm_fc_tac[]);
a (asm_rewrite_tac[]);
val well_founded_ScPrec_thm =  save_pop_thm "well_founded_ScPrec_thm";
=TEX

}%ignore

=SML
val SC_INDUCTION_T = WF_INDUCTION_T well_founded_ScPrec_thm;
val sc_induction_tac = wf_induction_tac well_founded_ScPrec_thm;
=TEX


¹HOLCONST
Ü ÛDefFormsÝ : GS SET
÷üüüüüüüüüüü
Ü DefForms = Formulas Syntax
°

¹HOLCONST
Ü ÛDefTermsÝ : GS SET
÷üüüüüüüüüüü
Ü DefTerms = Terms Syntax
°

=GFT
syntax_disj_thm =
   ô µ x
     · x  Syntax
         ´ (¶ ord· ordinal ord ± x = MkVar ord)
           ² (¶ f· f  DefForms ± x = MkComp f)
           ² (¶ t1 t2· t1  DefTerms ± t2  DefTerms ± x = MkEq (t1, t2))
           ² (¶ t1 t2· t1  DefTerms ± t2  DefTerms ± x = MkMem (t1, t2))
           ² (¶ ord fs· ordinal ord ± X‰g fs € DefForms ± x = MkTf (ord, fs))

is_fc_clauses =
   ô µ x
     · x  Syntax
         ´ (IsVar x ´ (¶ ord· ordinal ord ± x = MkVar ord))
           ± (IsComp x ´ (¶ f· f  DefForms ± x = MkComp f))
           ± (IsEq x
             ´ (¶ t1 t2· t1  DefTerms ± t2  DefTerms ± x = MkEq (t1, t2)))
           ± (IsMem x
             ´ (¶ t1 t2· t1  DefTerms ± t2  DefTerms ± x = MkMem (t1, t2)))
           ± (IsTf x
             ´ (¶ ord fs
             · ordinal ord ± X‰g fs € DefForms ± x = MkTf (ord, fs)))

syn_proj_clauses =
    ô (µ ord· VarNum (MkVar ord) = ord)
       ± (µ f· CompBody (MkComp f) = f)
       ± (µ l r· AtomLhs (MkEq (l, r)) = l)
       ± (µ l r· AtomRhs (MkEq (l, r)) = r)
       ± (µ l r· AtomLhs (MkMem (l, r)) = l)
       ± (µ l r· AtomRhs (MkMem (l, r)) = r)
       ± (µ v f· TfVars (MkTf (v, f)) = v)
       ± (µ v f· TfForms (MkTf (v, f)) = f)
=TEX

\ignore{
=SML
set_goal([], ¬µx·	x  Syntax
´	(¶ord· ordinal ord ± x = MkVar ord)
  ²	(¶f· f  DefForms ± x = MkComp f)
  ²	(¶t1 t2· t1  DefTerms ± t2  DefTerms ± x = MkEq (t1,t2))
  ²	(¶t1 t2· t1  DefTerms ± t2  DefTerms ± x = MkMem (t1,t2))
  ²	(¶ord fs· ordinal ord ± (X‰g fs) € DefForms ± x = MkTf (ord, fs))
®);
a (contr_tac);
a (lemma_tac ¬RepClosed (Syntax \ {x})®
	THEN1 (rewrite_tac [get_spec ¬RepClosed®]
		THEN strip_tac));
(* *** Goal "1" *** *)
a (strip_tac THEN strip_tac
	THEN asm_fc_tac [repclosed_syntax_thm1]
	THEN asm_rewrite_tac[]);
a (spec_nth_asm_tac 8 ¬ord®);
a (swap_nth_asm_concl_tac 1 THEN asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a (strip_tac);
(* *** Goal "2.1" *** *)
a (strip_tac THEN strip_tac);
a (lemma_tac ¬f  Formulas (Syntax)®
	THEN1(POP_ASM_T ante_tac
		THEN rewrite_tac [get_spec ¬Formulas®]
		THEN prove_tac[]));
a (ALL_FC_T rewrite_tac [repclosed_syntax_thm1]);
a (spec_nth_asm_tac 6 ¬f®);
a (swap_nth_asm_concl_tac 1);
a (rewrite_tac [get_spec ¬DefForms®]);
a (strip_tac);
a (swap_nth_asm_concl_tac 1);
a (asm_rewrite_tac[]);
(* *** Goal "2.2" *** *)
a strip_tac;
a (REPEAT µ_tac THEN strip_tac);
a (lemma_tac ¬t1  Terms (Syntax) ± t2  Terms (Syntax)®
	THEN1(POP_ASM_T ante_tac
		THEN POP_ASM_T ante_tac
		THEN rewrite_tac [get_spec ¬Terms®]
		THEN prove_tac[]));
a (ALL_FC_T rewrite_tac [repclosed_syntax_thm1]);
a (spec_nth_asm_tac 7 ¬t1®);
a (swap_nth_asm_concl_tac 1);
a (rewrite_tac [get_spec ¬DefTerms®]);
a (swap_nth_asm_concl_tac 1);
a (spec_nth_asm_tac 1 ¬t2®);
a (swap_nth_asm_concl_tac 1 THEN asm_rewrite_tac[]);
(* *** Goal "2.2.1.2" *** *)
a (spec_nth_asm_tac 7 ¬t1®);
a (swap_nth_asm_concl_tac 1);
a (rewrite_tac [get_spec ¬DefTerms®]);
a (swap_nth_asm_concl_tac 1);
a (spec_nth_asm_tac 1 ¬t2®);
a (POP_ASM_T ante_tac THEN asm_rewrite_tac[]);
(* *** Goal "2.2.2" *** *)
a (REPEAT strip_tac);
(* *** Goal "2.2.2.1" *** *)
a (lemma_tac ¬µ x· x  X‰g fs ´ x  Formulas Syntax®);
a (POP_ASM_T ante_tac);
a (rewrite_tac [get_spec ¬Formulas®]);
a (REPEAT strip_tac THEN asm_fc_tac[]);
a (ALL_FC_T rewrite_tac [repclosed_syntax_thm1]);
(* *** Goal "2.2.2.2" *** *)
a (LEMMA_T ¬X‰g fs € DefForms® asm_tac
	THEN1 (rewrite_tac [get_spec ¬DefForms®]
		THEN POP_ASM_T ante_tac
		THEN rewrite_tac [get_spec ¬Formulas®]
		THEN REPEAT strip_tac
		THEN asm_fc_tac[]));
a (spec_nth_asm_tac 4 ¬ord®);
a (SPEC_NTH_ASM_T 1 ¬fs® ante_tac);
a (GET_NTH_ASM_T 4 rewrite_thm_tac);
a (GET_NTH_ASM_T 2 (rewrite_thm_tac o (rewrite_rule[])));
a (strip_tac);
a (swap_nth_asm_concl_tac 1 THEN asm_rewrite_tac[]);
(* *** Goal "3" *** *)
a (asm_tac syntax_induction_thm1);
a (spec_nth_asm_tac 1 ¬Syntax \ {x}®);
a (spec_nth_asm_tac 1 ¬x®);
val syntax_disj_thm = save_pop_thm "syntax_disj_thm";

set_goal([], ¬µx·	x  Syntax
´	(IsVar x ´ ¶ord· ordinal ord ± x = MkVar ord)
±	(IsComp x ´ ¶f· f  DefForms ± x = MkComp f)
±	(IsEq x ´ ¶t1 t2· t1  DefTerms ± t2  DefTerms ± x = MkEq (t1,t2))
±	(IsMem x ´ ¶t1 t2· t1  DefTerms ± t2  DefTerms ± x = MkMem (t1,t2))
±	(IsTf x ´ ¶ord fs· ordinal ord ± (X‰g fs) € DefForms ± x = MkTf (ord, fs))
®);
a (REPEAT_N 2 strip_tac);
a (asm_tac syntax_disj_thm);
a (asm_fc_tac[] THEN asm_rewrite_tac [Is_clauses]);
(* *** Goal "1" *** *)
a (¶_tac ¬ord® THEN asm_rewrite_tac[]);
a (¶_tac ¬f® THEN asm_rewrite_tac[]);
a (¶_tac ¬t1® THEN ¶_tac ¬t2® THEN asm_rewrite_tac[]);
a (¶_tac ¬t1® THEN ¶_tac ¬t2® THEN asm_rewrite_tac[]);
a (¶_tac ¬ord® THEN ¶_tac ¬fs® THEN asm_rewrite_tac[]);
val is_fc_clauses = save_pop_thm "is_fc_clauses";

set_goal([], ¬(µord· VarNum (MkVar ord) = ord)
	±	(µf· CompBody (MkComp f) = f)
	±	(µl r· AtomLhs (MkEq (l, r)) = l)
	±	(µl r· AtomRhs (MkEq (l, r)) = r)
	±	(µl r· AtomLhs (MkMem (l, r)) = l)
	±	(µl r· AtomRhs (MkMem (l, r)) = r)
	±	(µv f· TfVars (MkTf (v, f)) = v)
	±	(µv f· TfForms (MkTf (v, f)) = f)
®);
a (rewrite_tac (map get_spec [
	¬VarNum®, ¬MkVar®, ¬CompBody®, ¬MkComp®,
	¬AtomLhs®, ¬AtomRhs®, ¬MkEq®, ¬MkMem®,
	¬TfVars®, ¬MkTf®, ¬TfForms®]));
val syn_proj_clauses = save_pop_thm "syn_proj_clauses";

=IGN
set_goal ([], ¬µt· t  Syntax ´ IsComp t ´ ScPrec (CompBody t) t®);
a (REPEAT strip_tac);
a (rewrite_tac [get_spec ¬ScPrec®]);

a (all_fc_tac [is_fc_clauses]);
a (asm_rewrite_tac [syn_proj_clauses]);

set_goal ([], ¬µt· t  Syntax ´ IsComp t ´ tc $‰g (CompBody t) t®);
a (REPEAT strip_tac);
a (all_fc_tac [is_fc_clauses]);
a (asm_rewrite_tac [syn_proj_clauses]);

get_spec ¬Syntax®;
=TEX
}%ignore

\subsection{Proof Context}

=SML
=TEX

\section{SEMANTICS}

=SML
open_theory "ICsyn";
force_new_theory "ICsem";
force_new_pc "'ICsem";
merge_pcs ["'savedthm_cs_¶_proof"] "'ICsem";
set_merge_pcs ["hol", "'GS1", "'ICsyn", "'ICsem"];
=TEX

The semantics will be defined as a functor which transforms partial membership and equality relations, and is parameterised by a domain set (which gives the range of the quantifiers).

We want to be able to evaluate membership claims between closed comprehensions.
This is done by substituting the comprehension on the left for the variable zero in the body of the comprehension on the right and evaluating the result.
Alternatively, evaluating the body of the comprehension on the right in a context which consists just of the assignment to variable zero of the comprehsion on the left.
When we reach atomic equations and membership claims during this evaluation we look them up using the initial values for the equality and membership relations.
We can only do this with closed comprehensions, so at this point, if not before we must substitute values from the context for the free variables in the comprehensions (these variables will be bound by quantifiers so we will be doing this substitution for every comprehension in turn).

So we need to be able to evaluate and to instantiate, evaluation taking place down to the level of atomic formulae and instantiation below that level (note that the terms in an atomic formulae will usually be comprehesions and hence may contain non-atomic formulae).

\subsection{In SML}

=IGN
datatype Term = Var of int
	|	Comp of Formula
and Formula = Eq of Term * Term
	|	Mem of Term * Term
	|	Tf of int * (Formula list);

fun tsubst s (Var i) = s i
|   tsubst s (Comp f) = Comp (fsubst s f)

and fsubst s (Eq (l,r)) = Eq (tsubst s l, tsubst s r)
|   fsubst s (Mem (l,r)) = Mem (tsubst s l, tsubst s r)
|   fsubst s (Tf (n, fl)) = Tf (n, (map (fsubst s) fl));

fun feval (er, mr) s (Eq (l,r)) = er (tsubst s l, tsubst s r)
|   feval (er, mr) s (Mem (l,r)) = mr (tsubst s l, tsubst s r)
|   feval (er, mr) s (Tf (n, fl)) = not (all (map (feval (er,mr) s) fl) (fn x => x))
;

fun emfunc (er, mr) = (
		fn x => y => feval (er, mr) (fn x => (Var x)) (Eq(x, y)),
		fn x => y => feval (er, mr) (fn x => (Var x)) (Mem(x, y))
);

fun er (x, y) = 

=TEX

\subsection{Substitution}

This will be an inductive definition over the relevant syntactic structures, but the definition is given in pieces.

First substitution into terms:

=SML
declare_type_abbrev("TV", [], ”GS®);
declare_type_abbrev("VA", [], ”GS ¸ (GS ­ TV)®);
declare_type_abbrev("TD", [], ”VA ­ TV®);
declare_type_abbrev("FD", [], ”VA ­ (BOOL + ONE)®);
declare_type_abbrev("PR", [], ”GS ­ GS ­ (BOOL + ONE)®);
=TEX

To define the semantics of comprehension we need to be able to modify a variable assignment.
The modification required is to insert a new value for variable zero shifting all the existing values up one variable number.

¹HOLCONST
Ü ÛInsertVarÝ : VA ­ TV ­ VA
÷üüüüüüüüüüü
Ü µd f tv· InsertVar (d, f) tv = 
Ü	(suc‰o d, ÌÂ· if Â = š‰g then tv else f (Â --‰o (Nat‰g 1)))
°

This one concatenates two variable assignments.

¹HOLCONST
Ü ÛInsertVarsÝ : VA ­ VA ­ VA
÷üüüüüüüüüüü
Ü µÁ Â f1 f2· InsertVars (Á, f1) (Â, f2) = 
Ü	(Á +‰o Â, ÌÇ· if Ç <‰o Á then f1 Ç else f2 (Ç --‰o Á))
°

We now define the operation of substituting into a term or formula values for free variables as specified by an assignment.
The substitution is for free variables and the operator requires as an argument the number of bound variables for any particular context (the numbers of the free variables a shifted upwards as bound variables are introduced.

¹HOLCONST
Ü ÛSubstTermÝ : ((GS ¸ VA) ¸ GS ­ GS) ­ (GS ¸ VA) ­ GS ­ GS
÷üüüüüüüüüüü
Ü SubstTerm = Ìsf (Á, (Â, f)) t·
Ü	if t  DefTerms
Ü	then	if IsVar t
Ü		then if Á ¼‰o VarNum t ± VarNum t ¼‰o (Á +‰o Â)
Ü		     then MkComp (f ((VarNum t) --‰o Á))
Ü	    	     else t
Ü		else sf ((Á, (InsertVar (Â, f) š‰g)), CompBody t)
Ü	else t
°

The following gives us a well-founded ordering on the parameters to SubstForm which will be useful in proving its well-definedness.

¹HOLCONST
Ü ÛSubOrderÝ : ('a ¸ GS) ­ ('a ¸ GS) ­ BOOL
÷üüüüüüüüüüü
Ü µs t u v· SubOrder (s, t) (u, v) = tc $‰g t v
°

The following results will be useful later in proving the existence of a fixed point.

First some points about the constituents of terms.

=GFT
SubOrder_í_lemma =
   ô µ v s t· SubOrder (v, s) (v, s í‰g t) ± SubOrder (v, t) (v, s í‰g t)
=TEX

\ignore{
=SML
set_goal([], ¬µv s t· SubOrder (v, s) (v, s í‰g t) ± SubOrder (v, t) (v, s í‰g t)®);
a (rewrite_tac [get_spec ¬SubOrder®, í_tc_thm]);
val SubOrder_í_lemma = pop_thm();
=IGN
stop;
set_goal([], ¬µsf1 sf2 (t:GS)· (µ Á Â_f ·
	(µ y:GS· tc SubOrder ((Á, Â_f), y) ((Á, Â_f), t) ´ sf1 ((Á, Â_f), y) = sf2 ((Á, Â_f), y)))
		´ (µ Á Â_f ·SubstTerm sf1 (Á, Â_f) t = SubstTerm sf2 (Á, Â_f) t)®);
a (rewrite_tac [get_spec ¬SubstTerm®] THEN REPEAT strip_tac);
a (cases_tac ¬t  DefTerms® THEN asm_rewrite_tac[]);
a (cases_tac ¬IsVar t® THEN asm_rewrite_tac[]);
a (DROP_NTH_ASM_T 2 (strip_asm_tac o (rewrite_rule (map get_spec
	[¬DefTerms®, ¬Terms®, ¬IsTerm®]))));
a (lemma_tac ¬SubOrder ((Á, InsertVar Â_f š‰g), CompBody t) ((Á, InsertVar Â_f š‰g), t)®);
(* *** Goal "1" *** *)
a (rewrite_tac [get_spec ¬SubOrder®]);



a (lemma_tac ¬µÔ· tc
               (Ì ((Á_1, va_1), f1) ((Á_2, va_2), f2)· f1 ‰g f2)
               ((Á, InsertVar (Â, f) š‰g), snd Ô)
               ((Á, Â, f), Ô)®);
a (spec_nth_asm_tac 1 ¬((Á, InsertVar (Â, f) š‰g), snd (snd t))®);
=TEX
}%ignore



Substitution over formulae is defined by recursion over the syntax and is thefore as the fixed point of a functor.

¹HOLCONST
Ü ÛSubstFormFunctÝ : ((GS ¸ VA) ¸ GS ­ GS) ­ ((GS ¸ VA) ¸ GS ­ GS)
÷üüüüüüüüüüü
Ü SubstFormFunct = Ìsf ((Á, va), f)·
Ü    (fst f í‰g
Ü	let fb = snd f
Ü	in 
Ü		if IsEq fb ² IsMem fb
Ü		then (fst fb í‰g (
Ü			(SubstTerm sf (Á, va) (AtomLhs fb) í‰g
Ü			 SubstTerm sf (Á, va) (AtomRhs fb)))
Ü		     )
Ü		else (	let Î = TfVars fb
Ü			and fs = TfForms fb
Ü			in (fst fb í‰g
Ü			    (Î í‰g (Imagep (Ìf· sf ((Á, va), f)) fs))
Ü			   )
Ü		     )
Ü    )
°

¹HOLCONST
Ü ÛSubstFormÝ : (GS ¸ VA) ¸ GS ­ GS
÷üüüüüüüüüüü
Ü SubstForm = fix SubstFormFunct
° 

\ignore{
=IGN
stop;
set_goal([], ¬SubstFormFunct respects (Ì((Á_1, va_1), f1) ((Á_2, va_2), f2)· f1 ‰g f2)®);
a (rewrite_tac [get_spec ¬$respects®, get_spec ¬SubstFormFunct®]
	THEN REPEAT strip_tac);

=TEX
}%ignore


\subsection{Evaluation}

Now we define the evaluation of formulae.
The definition assumes that partial relations for the atomic formulae are available, and is the main part of the definition of a functor which transforms membership and equality relations.
Interpretations of non-well-founded set theories are then sought as fixed points of this functor over subsets of the infinitary comprehensions.

=SML
declare_infix (300, "‰v");
declare_infix (300, "=‰v");
=TEX

¹HOLCONST
Ü ÛEvalFormÝ : (GS ¸ PR ¸ PR) ­ VA ­ GS ­ BOOL + ONE
÷üüüüüüüüüüü
Ü µV ($‰v:PR) ($=‰v:PR)· EvalForm (V, $‰v, $=‰v) = fix (Ìef va f· 
Ü	let fb = snd f
Ü	in 
Ü		if IsEq fb
Ü		then 
Ü		  (SubstTerm SubstForm (š‰g, va) (AtomLhs fb))
Ü		  =‰v
Ü		  (SubstTerm SubstForm (š‰g, va) (AtomRhs fb))
Ü		else  if IsMem fb
Ü		      then 
Ü			(SubstTerm SubstForm (š‰g, va) (AtomLhs fb))
Ü			‰v
Ü			(SubstTerm SubstForm (š‰g, va) (AtomRhs fb))
Ü		      else
Ü	(let Î = TfVars fb
Ü	 and fs = TfForms fb
Ü	 in let results = {pb | ¶v f· f ‰g fs ± pb = ef (InsertVars (Î, v) va) f}
Ü	    in
Ü		if results = {InL T} then InL F
Ü		else if (InL F)  results then InL T
Ü		else InR One
Ü	)
Ü			)
°

\newpage

\subsection{Membership and Equality}

Note that in the evaluation of formulae above {\it EvalForm} atomic membership and equality relations are evaluated by reference to given membership and equality relationships.

We are seeking a functor which when supplied with membership and equality relations will deliver new relationships at least as detailed as the original (they are partial relationships).
This is what we now define.

¹HOLCONST
Ü ÛMemRelÝ : (GS ¸ PR ¸ PR) ­ PR
÷üüüüüüüüüüü
Ü µV ($‰v:PR) ($=‰v:PR) e s· 
Ü	MemRel (V, $‰v, $=‰v) e s =
Ü		let va = (Nat‰g 1, Ìv· e)
Ü		in EvalForm (V, $‰v, $=‰v) va (snd s)
°

The equality of two closed comprehensions is determined here by evaluating the formula in which the bodies of the two comprehensions are first combined into an equivalence and then universally quantified over the common variable.

¹HOLCONST
Ü ÛEqRelÝ : (GS ¸ PR ¸ PR) ­ PR
÷üüüüüüüüüüü
Ü µV ($‰v:PR) ($=‰v:PR) l r·
Ü	EqRel (V, $‰v, $=‰v) l r =
Ü		let va = (š‰g, Ìv·v)
Ü		and lb = snd l
Ü		and rb = snd r
Ü		in let nl = MkNot lb
Ü		   and nr = MkNot rb
Ü		   in  let nlnr = MkTf (š‰g, Pair l nr)
Ü		       and nrnl = MkTf (š‰g, Pair r nl)
Ü		       in let nallneqr = MkTf (Nat‰g 1, Pair nlnr nrnl)
Ü                           in let allneqr = MkNot nallneqr
Ü		              in EvalForm (V, $‰v, $=‰v) va allneqr
°

The semantics of equality and membership are to be combined into a parameterised functor of which we seek fixed points.
These fixed points yield interpretations of non-well-founded set theories (or as a special and easy test case an image of our well-founded set theory).

\section{SEMANTICS}

Now meaning is attached to the representatives.
This is done in such a way as to yield a functor from one membership structure to another, of which we will then be seeking useful partial fixed points. 

This functor will be compounded from maps for individual constructs which, parameterised by the incoming structure, return the extension of the interpreted construct in that context.
These extensions are collected to give both a new membership relation and an equivalence relative to which that relation is extensional.

The membership relations concerned are over equivalance classes of representatives, and the domains of the structures are partial partitions of the set of representations.

The semantics is therefore defined in a piecemeal way for each constructor in turn and then sewn together to give the required functor.

The fact that we have inter-defined membership and equality relationships, and also that we are expecting at best partial fixed points, together hint that we might benefit from working in the more general context of ``Boolean Values Models'' (see, for example, \cite{Jech2002}), so I propose to begin in that more general context and see how it goes.
i.e. the equality and membership relations will be functions yielding values in an arbitrary boolean algebra rather than classical relationships, and the relationship between them will be as prescribed for boolean valued models unless a problem is found with this.

\section{FUNCTOR TYPES}

The details of how to code up infinitary first order set theory are unimportant, and I want to talk about this method, so I'm going to just assume that the syntax has been encoded and that the semantics has been formalised in the manner discussed.

=SML
open_theory "GS";
force_new_theory "ICS";
new_parent "ordered_sets";
=TEX

The following is expected to be the type of abstract syntax trees for sets definable in an infinitary first order language of set theory, i.e. one with just two predicates, equality and membership.
For present purposes we do not need to have this defined,

=SML
new_type ("SETREP", 0);
=TEX

The following declaration shows the type of functor which one might use as a recursive definition of the equality and membership relations over SETREP.
It is parameterised by a subdomain of the set representatives, since the semantics will make the extension of some sets sensitive to the universe.

=SML
new_const ("sf1", ”(SETREP ­ BOOL)
	­ (SETREP ­ SETREP ­ BOOL) ¸ (SETREP ­ SETREP ­ BOOL)
	­ (SETREP ­ SETREP ­ BOOL) ¸ (SETREP ­ SETREP ­ BOOL)®);
=TEX

We don't have a recursion theorem which will work with that kind of functor, so we will need the functor to be converted in to one which operates on a single function, and the function will have to be uncurried.
The two relations are therefore thought of as a function over ordered pairs which delivers an ordered pair of truth values.

=SML
new_const ("sf2", ”(SETREP ­ BOOL)
	­ (SETREP ¸ SETREP ­ BOOL ¸ BOOL)
	­ (SETREP ¸ SETREP ­ BOOL ¸ BOOL)®);
=TEX

Our recursion theorem has the form:

=GFT
recursion_theorem
   ô µ (X, $<<) G
     · FunctRespects G (X, $<<) ± WellFounded (X, $<<) ´ UniquePartFixp X G

=TEX

Where X is some set and $<<$ a well founded relation over it.
Note that the relation is over pairs of SETREPs and so this does not require that membership be well-founded.

{\it UniquePartFixp} asserts the existence of a unique partial fixed point of G over X.

We can classify SETREPs according to how solidly defined they are under the semantics (sf2).
The strongest case is that in which the extension of the set represented by the SETREP is completely unchangeable.
This is true of representatives of the empty set.

If we allow this to be conditional we may obtain a monotone operator on subsets of SETREP of which the least fixed point gives a non-trivial interpretation of set theory.
So we want to talk about a set having a fixed extension in every subset whioh includes some particular set of SETREPS.

¹HOLCONST
  op1: SETREP ð ­ SETREP ð
÷
  µssr sr· sr  op1 ssr ¤
	µsr2· sr2  op1 ssr ´ T 
°

{\let\Section\section
\newcounter{ThyNum}
\def\section#1{\Section{#1}
\addtocounter{ThyNum}{1}\label{Theory\arabic{ThyNum}}}
\include{ICsyn.th}
\include{ICsem.th}
}  %\let

\twocolumn[\section{INDEX}\label{index}]
{\small\printindex}

\end{document}
