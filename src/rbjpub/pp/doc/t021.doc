=IGN
$Id: t021.doc,v 1.8 2007/09/22 20:47:22 rbj01 Exp $
open_theory "";
set_merge_pcs ["hol1", "'savedthm_cs_¶_proof"];
=TEX
\documentclass[11pt,a4paper]{article}
\usepackage{latexsym}
\usepackage{ProofPower}
\ftlinepenalty=9999
\usepackage{A4}

\def\ExpName{\mbox{{\sf exp}
\def\Exp#1{\ExpName(#1)}

\tabstop=0.4in
\newcommand{\ignore}[1]{}

\title{Interpretations of Set Theory}
\makeindex
\usepackage[unicode,pdftex]{hyperref}
\hypersetup{pdfauthor={Roger Bishop Jones}}
\hypersetup{colorlinks=true, urlcolor=black, citecolor=black, filecolor=black, linkcolor=black}

\author{Roger Bishop Jones}
\date{\ }

\begin{document}
\begin{titlepage}
\maketitle
\begin{abstract}
This paper continues the line of thought which lead to the PolySet interpretation of set theory, and is essentially a discussion of how to extend the method used for the PolySets so that a fuller ontology can be realised.
It contains a sketch of a general method, written down while I am still on this topic with a view to deeper exploration at some later date.
\end{abstract}

\vfill

\begin{centering}

{\footnotesize

Created: 2006/11/29

Last Change $ $Date: 2007/09/22 20:47:22 $ $

\href{http://www.rbjones.com/rbjpub/pp/doc/t021.pdf}
{http://www.rbjones.com/rbjpub/pp/doc/t021.pdf}

$ $Id: t021.doc,v 1.8 2007/09/22 20:47:22 rbj01 Exp $ $

\copyright\ Roger Bishop Jones; Licenced under Gnu LGPL

}%footnotesize

\end{centering}

\thispagestyle{empty}
\end{titlepage}
\newpage
\addtocounter{page}{1}
%\section{DOCUMENT CONTROL}
%\subsection{Contents list}
{\parskip=0pt\tableofcontents}
%\newpage
%\subsection{Document cross references}

\subsection*{To Do}
\begin{itemize}
\item 
\item 
\end{itemize}

{\raggedright
\bibliographystyle{fmu}
\bibliography{rbj,fmu}
} %\raggedright

\newpage
\section{INTRODUCTION}

It is the purpose of this document to discuss some general methods for obtaining models for non-well founded set theories.
It may be thought of as broadly similar to the ``Church-Oswald'' constructions decribed by Forster in \cite{forster92,forster2005}, in that it works from an interpretation of a well-founded set theory and constructs non-well-founded interpretations from them in which a copy of the original interpretation may be found.

This follows on from \emph{PolySet} theory \cite{rbjt020} in which an interpretation of set theory is arrived at via an intuition based on the polymorphic functions in standard ML.
After thinking about PolySet theory for a while I concluded that it would indeed give the ML-polymorphic functions (integrated into a full well-founded classical set theory), and hence, might lead to a foundation for formal mathematics with an ML-like let clause.
But it seemed, contrary to my first thoughts, unlikely to meet my other desiderata relating to abstract algebra, and in general the use of context in formal methematical developments.

So I turned my mind to larger ontologies.

The construction of PolySets was quite simple, because of the motivating intuition about the kinds of extra sets to be added.
It seemed to be (though this remains to be formally established) feasible to define the membership relationship over the representatives for PolySets without taking care to make it extensional, since it seemed (and still does seem) probable that taking a quotient after the definition of membership was comeplete would permit the membership to be upgraded to an extensional one.
It seemed however, as soon as I decided that they PolySets would not suffice, that the same method would be unlikely to suffice.

The first objective therefore of this essay is to adapt the method used in the construction of the PolySets so that it can be applied for a wider range of less placid methods of set constructions, particularly ones which cannot properly be defined on representatives without knowing which represenatatives are equivalent.
Of these the simplest to understand is the operation of set complement.
Given a set of representatives of a equivalence classes, it is not possible to compute a complete set of representatives for the excluded equivalence classes without actually knowing what the equivalence relationship is,

The definition of membership over the PolySets was very simple.
Only the definition of instantiation involves recursion and this is well-founded with respect to the original membership relationship.
The definition of membership is not then recursive. 

Once you need to talk about membership in the new structure while defining that membership relationship, or to talk about equivalence (i.e. when two representatives represent the same set) then recursion comes in, and there may not be any obvious well-founded relationship to show that such recursion terminates.

My aim here is to hit this problem head on, and adopt a method which copes with an account of the semantics of the new sets (i.e. a definition of the new membership relationship) which is not known to be well-founded.

There is not a lot of proof in this document, I need to kick around some specifications before I decide whether any proofs are worth attempting.
Until then it will be a study in proof evasion.

\subsection{Outline of The Method}

The following stages are involved.

\begin{enumerate}
\item Identify informally a {\it kind} of properties (of sets) whose extensions will be the extensions of the new sets.
\item Chose a way of representing these properties using well-founded sets (I like something that looks like an infinitary language defined like a recursive datatype).
i.e. code up the syntax of an infinitary first order set theory as well-founded sets.
\item Define the semantics of these notations by assigning to each set an extension.
To allow for the recursive elements mentioned above, this is done relative to some arbitrary given membership structure, subject only to the constraint that the domain of the relationship is a partition of a subset of the representatives chosen for the new sets.
\item Note that the membership relationship will bring with it a notion of extensional equality.
\item The partial fixed points of this functor will yield interpretation of set theory.
A general investigation of these partial fixed points will help in chosing which partial fixed point to use.
I am inclined to define some notion of maximal partial fixed point and work with a loosely defined interpretation based on that.
\end{enumerate}

\newpage
\section{SYNTAX A}

=SML
open_theory "GS";
force_new_theory "t021sa";
set_merge_pcs ["hol1", "'savedthm_cs_¶_proof", "'GS1"];
=TEX

The idea is to chose a substantial collection of pure well-founded sets as a starting material (V($\alpha$) for suitable $\alpha$), and to use these to represent some more encompassing notion of sethood, in such a way as to keep a copy of the originals alongside the newly introduced exotica.

It may be useful to think of this as a kind of infinitary language in which arbitrary sets are terms and denote themselves, however, though I did at first have such infinitary set displays these do now have to be rendered as set abstractions.

The set display $\{1,2,3\}$, can alternatively be rendered as the abstraction "$\{x | x=1 ² x=2 ² x=3\}$" and by nesting such abstractions terms can be constructed representing arbitrary well founded sets provided that we are allowed infinitary disjunctions of sufficiently unreasonable cardinality.
In the language which we adopt there are infinitary disjunctions, and also infinitary quantifiers allowing that there may be excessive numbers of variables quantified over in the body of an abstraction (formulae are defined only for use in set abstractions).

The language allows also for sets which are not well-founded, and we may think of this as effecting a merge between a concept of set as explicit extensional graph and that of a set as a rule of some kind, in which a prospective member is checked-out in a manner more sophisticated than literal identity comparisons.

The use of rules rather than graphs helps us round a difficulty which appears as soon as we admit non-well-founded sets, in the form of Cantor's theorem.
We are allowing functions whose domain is the entire domain of discourse (which includes these functions) but we can't have them all, there are too many.
Having a language of rules allows you to cap the number of sets or functions admitted in a systematic way.
It replaces the so-called limitation of size principle, which is helpfull in the context of well-founded sets in determining which belong to the interpretation in question, with a liberal limitation on the size of the description of a set.
If you imagine even the largest well-founded sets as being explicitly described by an infinitary structure, then descriptions even of ill-founded sets which are of that size will be admitted.

However, cardinality is not the end of the problems.
Though V isn't one of them, there are sets which you just can't have.
The concept of a barber who shaves everyone who doesn't shave himself, is too problematic to have an extension.
So either on their own, or in combination, ontological principles may be inconsistent.

I intend here to explore the possiblity that the first stages in the construction can be done recklessly, encompassing a collection of properties of sets which is in itself incoherent, and then restricted to obtain coherent interpretations.
For this reason I will formalise for exploration an interpretation in which nominally appear a transfinite extrapolation of the complete range of first order properties of sets (which will not of course yield an interpretation without being trimmed back).
I would have been inclined to extend the construction for the PolySets but the purpose here is exploratory and methodological, and it will probably be faster and easier to understand if I forget about the PolySets for now.
In principle, if there is an interpretation for NF, then it ought to be obtainable in this way (which doesn't mean that it would facilitate any proof of coherence).

I'm going to use a fairly crude way of capuring the notion of definability of sets in an infinitary first order set theory.
We imagine a formula built up using the infinitary terms with variables in them, equality, membership, negation conjunction, universal quantification and comprehension.

Here is an abstract syntax:

=GFT
term    ::= ordinal
	 | SetComp formula

formula ::= term = term
          | term  term
          |  ordinal (ð formula)
=TEX

The ordinals here are used as variables, and Von Neumann ordinals are required.
They are in fact used like De Bruijn indices, so comprehension always binds the variable zero at the outermost level, and binds a higher numbered variable in inner scopes.
A single constructor is provided for formulae () and is to be understood as the negation of the universal quantification of the conjunction of a set (of any cardinality) of formulae.
This quantified simultaneously quantifies over any number of variables.

I'm going to hand-crank an appropriate recursive datatype.

It will be useful to be able to have names for the finite ordinals, which are used as tags in the syntax:

¹HOLCONST
Ü ÛSuccgÝ: GS ­ GS
÷üüüüüüüüüüü
Ü µn· Succg n = Cg {z | z g n ² z = n}
°

¹HOLCONST
Ü ÛNatgÝ: î ­ GS
÷üüüüüüüüüüü
Ü       Natg 0 = Cg {}
Ü ± µn· Natg (n+1) = Succg (Natg n)
°

The following define realisations of the constructors for the abstract syntax:

¹HOLCONST
Ü ÛTermÝ : GS ­ GS
÷üüüüüüüüüüü
Ü    µt· Term t = (Natg 0) íg t
°

¹HOLCONST
Ü ÛTermsÝ : GS SET ­ GS SET
÷üüüüüüüüüüü
Ü    µs· Terms s = {x | ¶t· x = Term t ± x  s}
°

¹HOLCONST
Ü ÛFormulaÝ : GS ­ GS
÷üüüüüüüüüüü
Ü    µf· Formula f = (Natg 1) íg f
°

¹HOLCONST
Ü ÛFormulasÝ : GS SET ­ GS SET
÷üüüüüüüüüüü
Ü    µs· Formulas s = {x | ¶f· x = Formula f ± x  s}
°

¹HOLCONST
Ü ÛVarÝ : GS ­ GS
÷üüüüüüüüüüü
Ü    µord· Var ord = (Natg 0) íg ord
°

¹HOLCONST
Ü ÛSetCmpÝ : GS ­ GS
÷üüüüüüüüüüü
Ü    µf· SetCmp f = (Natg 1) íg f
°

¹HOLCONST
Ü ÛEqÝ : GS ¸ GS ­ GS
÷üüüüüüüüüüü
Ü µl r· Eq (l,r) = (Natg 0) íg (l íg r)
°

¹HOLCONST
Ü ÛMemÝ : GS ¸ GS ­ GS
÷üüüüüüüüüüü
Ü µ l r·  Mem (l, r) = (Natg 1) íg (l íg r)
°

¹HOLCONST
Ü ÛÝ : GS ¸ GS ­ GS
÷üüüüüüüüüüü
Ü µvars conjs·  (vars, conjs) = (Natg 2) íg (vars íg conjs)
°

¹HOLCONST
Ü ÛRepClosedÝ: GS SET ­ BOOL
÷üüüüüüüüüüü
Ü µ s· RepClosed s ¤
Ü µord f fs t1 t2 ·
Ü	Ordinal ord
Ü  ±	(Xg fs À {f})  (Formulas s)
Ü  ±	{t1; t2}  (Terms s)
Ü  ´	Term (Var ord)  s
Ü  ±    Term (SetCmp f)  s
Ü  ±	Formula (Eq (t1,t2))  s
Ü  ±	Formula (Mem (t1,t2))  s
Ü  ±	Formula ( (ord, fs))  s
°

The syntax is then the smallest set closed under these constructions.

¹HOLCONST
Ü ÛSyntaxÝ : GS SET
÷üüüüüüüüüüü
Ü Syntax = ¥{x | RepClosed x}
°

This is an ``inductive datatype'' so we should expect the usual kinds of theorem.

Informally these should say:

\begin{itemize}
\item Everything in Syntax is either a Term or a Formula.
\item Syntax is closed under the five syntactic constructors.
\item The syntax constructors are all injections, have disjoint ranges, and partition syntax. 
\item Any syntactic property which is preserved by the constructors (i.e. is true of any construction if it is true of all its syntactic constituents) is true of everything in syntax (this is an induction principle).
\end{itemize}

Formally these may be given thus:

=GFT
µx· x  Syntax ´ Term x ² Formula x

RepClosed Syntax
=TEX

\ignore{
=IGN

=TEX
}%ignore


¹HOLCONST
Ü ÛDefFormsÝ : GS SET
÷üüüüüüüüüüü
Ü DefForms = Formulas Syntax
°

¹HOLCONST
Ü ÛDefTermsÝ : GS SET
÷üüüüüüüüüüü
Ü DefTerms = Terms Syntax
°

\ignore{
=IGN
open_theory "t021sa";
set_goal([], ¬RepClosed (DefForms À DefTerms)®);
a (rewrite_tac (map get_spec [¬RepClosed®, ¬DefForms®, ¬DefTerms®]));

=TEX
}

\section{SEMANTICS A}

The semantics will be defined as a functor which transforms partial membership and equality relations, and is parameterised by a domain set (which gives the range of the quantifiers).

We want to be able to evaluate membership claims between closed comprehensions.
This is done by substituting the comprehension on the left for the variable zero in the body of the comprehension on the right and evaluating the result.
Alternatively, evaluating the body of the comprehension on the right in a context which consists just of the assignment to variable zero of the comprehsion on the left.
When we reach atomic equations and membership claims during this evaluation we look them up using the initial values for the equality and membership relations.
We can only do this with closed comprehensions, so at this point, if not before we must substitute values from the context for the free variables in the comprehensions (these variables will be bound by quantifiers so we will be doing this substitution for every comprehension in turn).

So we need to be able to evaluate and to instantiate, evaluation taking place down to the level of atomic formulae and instantiation below that level (note that the terms in an atomic formulae will usually be comprehesions and hence may contain non-atomic formulae).

\subsec{Substitution}

This will be an inductive definition over the relevant syntactic structures, but the definition is given in pieces.

First substitution into terms:

=SML
declare_type_abbrev("TV", [], GS®);
declare_type_abbrev("VA", [], GS ­ TV®);
declare_type_abbrev("TD", [], VA ­ TV®);
declare_type_abbrev("FD", [], VA ­ (BOOL + ONE)®);
=TEX

To define the semantics of comprehension we need to be able to modify a variable assignment.
The modification required is to insert a new value for variable zero shifting all the existing values up one variable number.

¹HOLCONST
Ü ÛInsertVarÝ : VA ­ TV ­ VA
÷üüüüüüüüüüü
Ü µva td ord· InsertVar va td ord = 
Ü	if ord = Natg 0 then td else va (Succg ord)
°

This one concatenates two variable assignments.
[placeholder]

¹HOLCONST
Ü ÛInsertVarsÝ : VA ­ VA ­ VA
÷üüüüüüüüüüü
Ü µva1 va2· InsertVars va1 va2 = 
Ü	va1
°

¹HOLCONST
Ü ÛSubstVarÝ : VA ­ GS ­ GS
÷üüüüüüüüüüü
Ü µva ord· SubstVar va ord = va ord
°

¹HOLCONST
Ü ÛSubstCompÝ : (VA ­ GS ­ GS) ­ VA ­ GS ­ GS
÷üüüüüüüüüüü
Ü µsf va comp· SubstComp sf va comp = sf (InsertVar 0g va) comp
°

¹HOLCONST
Ü ÛSubstTermÝ : (VA ­ GS ­ GS) ­ VA ­ GS ­ GS
÷üüüüüüüüüüü
Ü µsf va t· SubstTerm sf va t =
	if Fstg t = 0
	then 
	else
°

¹HOLCONST
Ü ÛSubstEqÝ : (VA ­ GS ­ GS) ­ VA ­ GS ­ GS
÷üüüüüüüüüüü
Ü µsf va comp· SubstComp sf va comp = sf (InsertVar 0g va) comp
°

=SML
stop;
=TEX


We now define functions which give the semantics of each indivual constructor as transformations over these denotations.

¹HOLCONST
Ü ÛVarSemÝ : GS ­ TD
÷üüüüüüüüüüü
Ü µord va· VarSem ord va = va ord
°

A comprehension denotes itself?
Or should we substitute in the values for the free variables?
We'll pass on this one till we see whether we need anything here.

The atomic formula just refer to the prior membership and equality relations.
So only the compound formala constructor has a substantive semantics.


¹HOLCONST
Ü ÛSemÝ : GS SET ¸ GS SET ¸ FD SET ­ FD
÷üüüüüüüüüüü
Ü µV vars fds va· Sem (V, vars, fds) va = 
Ü	¶va2 fd· dom va2 = vars
	± ran va2  V
	± fd  fds
°



\newpage
\section{SYNTAX B}

This version of the syntax is parameterised by a (well-founded) membership relationship.

The general pattern followed is to use relationships rather than functions, because no assumptions are made about the closure properties of the membership relationship.

We make use of the Wiener-Kuratovski ordered pairs, defined as follows.

=SML
open_theory "hol";
force_new_theory "t021sb";
set_merge_pcs ["hol1", "'savedthm_cs_¶_proof"];
declare_type_abbrev ("MR", ["MR"], 'a ­ 'a ­ BOOL®);
=TEX

To simplify talking about sets as determined by some membership relation the following function yields the extension of some set according to some membership relation.

¹HOLCONST
Ü ÛXÝ: 'a MR ­ 'a ­ 'a SET 
÷üüüüüüüüüüü
Ü µr s· X r s = {y | r y s}
°

¹HOLCONST
Ü ÛXXÝ: 'a MR ­ 'a ­ 'a SET SET
÷üüüüüüüüüüü
Ü µr s· XX r s = {y | ¶z· r z s ± y = X r z}
°

¹HOLCONST
Ü ÛWkpÝ: 'a MR ­ ('a ¸ 'a ¸ 'a) ­ BOOL 
÷üüüüüüüüüüü
Ü µm l r p· Wkp m (l, r, p) ¤ XX m p = {{l;r};{l}}
°

The first thing we do with the ordered pairs is make some natural numbers for use as tags.

¹HOLCONST
Ü ÛEsÝ: 'a MR ­ 'a ­ BOOL 
÷üüüüüüüüüüü
Ü µm s· Es m s ¤ XX m s = {}
°

¹HOLCONST
Ü ÛDUnionÝ: 'a MR ­ ('a ¸ 'a) ­ BOOL 
÷üüüüüüüüüüü
Ü µm s u·  DUnion m (s, u) ¤ X m u = Þ(XX m s)
°

¹HOLCONST
Ü ÛBUnionÝ: 'a MR ­ ('a ¸ 'a ¸ 'a) ­ BOOL 
÷üüüüüüüüüüü
Ü µm s t u·  BUnion m (s, t, u) ¤ X m u = (X m s) À (X m t)
°

¹HOLCONST
Ü ÛSuccÝ: 'a MR ­ ('a ¸ 'a) ­ BOOL 
÷üüüüüüüüüüü
Ü µm n s·  Succ m (n, s) ¤ X m s = (X m n) À {n} 
°

¹HOLCONST
Ü ÛRnatÝ: 'a MR ­ î ­ 'a ­ BOOL 
÷üüüüüüüüüüü
Ü µm·	Rnat m 0 = (Ìs:'a· Es m s)
Ü ±	µn· Rnat m (n + 1) = (Ìs:'a· ¶t:'a· Rnat m n t ± Succ m (t,s))
°

We now define the property of being an ordinal under a membership relationship.
There will be some conditions on the relationship needed to ensure that the class of ordinals defined here is good (which I have not yet worked out).

¹HOLCONST
Ü ÛOrdÝ: 'a MR ­ 'a ­ BOOL 
÷üüüüüüüüüüü
Ü µm n·  Ord m n = µs· (µt u v· X m t  s ± X m u = Þ (XX m t) ± Succ m (u, v) ´ v  s) ´ n  s
°

Now we define the syntactic structures in our notation for sets definable by infinitary comprehension.

Here is the syntax informally:

=GFT
<term> ::= Var <ordinal>
	| Comp <formula>

<formula> ::=
	  Eq <term><term>
	| In <term><term>
	| Tf <ordinal> (<formula> Set)
=TEX

Where ``Tf'' is an infinitary negated existentially quantified disjunction (any cardinality of variables, any cardinality of disjuncts).

Phrases will be ordered pairs of which the left is the phrase type, zero for a term one for a formula.

The following predicate checks the type of a phrase.

¹HOLCONST
Ü ÛPhraseTypeÝ: 'a MR ­ î ­ 'a ­ BOOL 
÷üüüüüüüüüüü
Ü µm n t·  PhraseType m n t = ¶u v· Rnat m n u ± Wkp m (u, v, t)
°

This one check both the type and the value.

¹HOLCONST
Ü ÛPhraseÝ: 'a MR ­ î ­ 'a ­ 'a ­ BOOL 
÷üüüüüüüüüüü
Ü µm n p t·  Phrase m n p t = ¶u· Rnat m n u ± Wkp m (u, p, t)
°

Now we have one relation for each constructor.

¹HOLCONST
Ü ÛVarÝ: 'a MR ­ 'a ­ 'a ­ BOOL
÷üüüüüüüüüüü
Ü µm ord t·  Var m ord t ¤ Phrase m 0 ord t
°

¹HOLCONST
Ü ÛCompÝ: 'a MR ­ 'a ­ 'a ­ BOOL
÷üüüüüüüüüüü
Ü µm c t·  Comp m c t ¤ Phrase m 1 c t
°

¹HOLCONST
Ü ÛEqÝ: 'a MR ­ ('a ¸ 'a) ­ 'a ­ BOOL 
÷üüüüüüüüüüü
Ü µm t1 t2 f·  Eq m (t1, t2) f ¤ ¶p· Wkp m (t1, t2, p) ± Phrase m 0 p f
°

¹HOLCONST
Ü ÛInÝ: 'a MR ­ ('a ¸ 'a) ­ 'a ­ BOOL 
÷üüüüüüüüüüü
Ü µm t1 t2 f·  In m (t1, t2) f ¤ ¶p· Wkp m (t1, t2, p) ± Phrase m 1 p f
°

¹HOLCONST
Ü ÛTfÝ: 'a MR ­ ('a ¸ 'a) ­ 'a ­ BOOL 
÷üüüüüüüüüüü
Ü µm t1 t2 f·  Tf m (t1, t2) f ¤ ¶p· Wkp m (t1, t2, p) ± Phrase m 1 p f
°

To obtain the class of syntactic structures we take the intersection of classes closed under the five constructors.

¹HOLCONST
Ü ÛSynClosedÝ: 'a MR ­ ('a ­ BOOL) ­ BOOL 
÷üüüüüüüüüüü
Ü µm c· SynClosed m c ¤
Ü	(µord· Ord m ord ´ ¶v· Var m ord v ± c v)
Ü  ±
	µt1 t2 ord f1 fs·
		c t1 ± PhraseType m 0 t1
	±	c t2 ± PhraseType m 0 t1
	±	Ord m ord
	±	c f1 ± PhraseType m 1 f1
	±	(µf· m f fs ´ c f ± PhraseType m 1 f)

    ´		(¶comp· c comp ± Comp m f1 comp)
	±	(¶eq· c eq ± Eq m (t1, t2) eq)
	±	(¶inn· c inn ± In m (t1, t2) inn)
	±	(¶tf· c tf ± Tf m (ord, fs) tf)
°

¹HOLCONST
Ü ÛSynClosureÝ: 'a MR ­ ('a ­ BOOL) 
÷üüüüüüüüüüü
Ü µm c· SynClosure m c ¤
Ü	µp· SynClosed m p ´ p c
°

\newpage
\section{SEMANTICS}

Now meaning is attached to the representatives.
This is done in such a way as to yield a functor from one membership structure to another, of which we will then be seeking useful partial fixed points.

This functor will be compounded from maps for individual constructs which, parameterised by the incoming structure, return the extension of the interpreted construct in that context.
These extensions are collected to give both a new membership relation and an equivalence relative to which that relation is extensional.

The membership relations concerned are over equivalance classes of representatives, and the domains of the structures are partial partitions of the set of representations.

The semantics is therefore defined in a piecemeal way for each constructor in turn and then sewn together to give the required functor.

The fact that we have inter-defined membership and equality relationships, and also that we are expecting at best partial fixed points, together hint that we might benefit from working in the more general context of ``Boolean Values Models'' (see, for example, \cite{Jech2002}), so I propose to begin in that more general context and see how it goes.
i.e. the equality and membership relations will be functions yielding values in an arbitrary boolean algebra rather than classical relationships, and the relationship between them will be as prescribed for boolean valued models unless a problem is found with this.

\section{PLAN B}

The details of how to code up infinitary first order set theory are unimportant, and I want to talk about this method, so I'm going to just assume that the syntax has been encoded and that the semantics has been formalised in the manner discussed.

=SML
open_theory "GS";
force_new_theory "ICS";
new_parent "ordered_sets";
=TEX
The following is expected to be the type of abstract syntax trees for sets definable in an infinitary first order language of set theory, i.e. one with just two predicates, equality and membership.
For present purposes we do not need to have this defined,
=SML
new_type ("SETREP", 0);
=TEX
The following declaration shows the type of functor which one might use as a recursive definition of the equality and membership relations over SETREP.
It is parameterised by a subdomain of the set representatives, since the semantics will make the extension of some sets sensitive to the universe.
=SML
new_const ("sf1", (SETREP ­ BOOL)
	­ (SETREP ­ SETREP ­ BOOL) ¸ (SETREP ­ SETREP ­ BOOL)
	­ (SETREP ­ SETREP ­ BOOL) ¸ (SETREP ­ SETREP ­ BOOL)®);
=TEX
We don't have a recursion theorem which will work with that kind of functor, so we will need the functor to be converted in to one which operates on a single function, and the function will have to be uncurried.
The two relations are therefore thought of as a function over ordered pairs which delivers an ordered pair of truth values.
=SML
new_const ("sf2", (SETREP ­ BOOL)
	­ (SETREP ¸ SETREP ­ BOOL ¸ BOOL)
	­ (SETREP ¸ SETREP ­ BOOL ¸ BOOL)®);
=TEX
Our recursion theorem has the form:
=GFT
recursion_theorem
   ô µ (X, $<<) G
     · FunctRespects G (X, $<<) ± WellFounded (X, $<<) ´ UniquePartFixp X G

=TEX
Where X is some set and $<<$ a well founded relation over it.
Note that the relation is over pairs of SETREPs and so this does not require that membership be well-founded.

{\it UniquePartFixp} asserts the existence of a unique partial fixed point of G over X.

We can classify SETREPs according to how solidly defined they are under the semantics (sf2).
The strongest case is that in which the extension of the set represented by the SETREP is completely unchangeable.
This is true of representatives of the empty set.

If we allow this to be conditional we may obtain a monotone operator on subsets of SETREP of which the least fixed point gives a non-trivial interpretation of set theory.
So we want to talk about a set having a fixed extension in every subset whioh includes some particular set of SETREPS.

¹HOLCONST
  op1: SETREP ð ­ SETREP ð
÷
  µssr sr· sr  op1 ssr ¤
	µsr2· sr2  op1 ssr ´ T 
°

\section{SEMANTICS B}

This approach to semantics is specific to SYNTAX B.

The semantics is rendered as a functor over partial assignments of meaning to membership and equality relations over comprehensions.

We introduce a type abbreviation for these partial relations:

=SML
open_theory "t021sb";
set_merge_pcs ["hol1", "'savedthm_cs_¶_proof"];
declare_type_abbrev ("VA", ["VA"], 'a ­ 'a + ONE®);
declare_type_abbrev ("PMA", ["PMA"], 'a ¸ 'a ­ BOOL + ONE®);
=TEX


\subsection{Constructor Definitions}

We begin with the definitions of semantics for the individual constructors.
These have in common that they are supplied:

\begin{enumerate}
\item A syntactic domain
\item The subset of that domain which are deemed valid comprehensions
\item A partial membership relation over the comprehensions
\item A partial equivalence relation over the comprehensions
\end{enumerate}

In addition there will be constructor specific parameters corresponding to the semantics of the constituent components.

The type of the semantic values are as follows.
Terms are partial functions over variable assignments, yielding sets of comprehensions
Formulae are partial functions over variable assignments yielding truth values.

¹HOLCONST
  VarCon: 'a ­ 'a VA ­ ('a + ONE)
÷
  µord va· VarCon ord va = va ord
°

To specify comprehension we need an auxiliary function which shifts left a variable assignment and adds in a new value for zero.


¹HOLCONST
  EqCon: 'a PMA ­ ('a ¸ 'a) ­ 'a VA ­ (BOOL + ONE)
÷
  µeq l r va· EqCon eq (l, r) va = eq (l, r)
°

¹HOLCONST
  MemCon: 'a PMA ­ ('a ¸ 'a) ­ 'a VA ­ (BOOL + ONE)
÷
  µmem l r va· MemCon mem (l, r) va = mem (l, r)
°

\subsection{The Semantic Functor}

The functor defined below takes a seed membership relation, a partial equality over the infinitary comprehensions generated from that relation, and a partial membership relation over those comprehensions, and yields a new membership relation.
The new equality relation will be obtained from the new membership relation.

¹HOLCONST
  new_mem: 'a MR ­ 'a PMA ­ 'a PMA ­ 'a PMA
÷
  µr eq mem c1 c2· new_mem r eq mem (c1, c2) = InR One
°

{\let\Section\section
\newcounter{ThyNum}
\def\section#1{\Section{#1}
\addtocounter{ThyNum}{1}\label{Theory\arabic{ThyNum}}}
\include{defsets.th}
}  %\let

\twocolumn[\section{INDEX}\label{index}]
{\small\printindex}

\end{document}
