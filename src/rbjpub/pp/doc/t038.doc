=TEX
\def\rbjidtADIdoc{$$Id: t038.doc,v 1.3 2011/02/12 09:14:19 rbj Exp $$}

The following presentation of Higher Order Logic is undertaken using the interactive proof assistant {\Product}.
The first part of the presentation (Sections \ref{ST}-\ref{STT}) closely follows Church's paper \cite{church40}, and the remainder accounts for the subsequent developments which are relevant to an understanding of documents produced using {\Product}.

Church's formulation of the simple theory of types is distinguished by its simplicity, which is made possible by basing the theory upon the typed lambda calculus.
This makes it possible to define as higher order constants all but a very few of thee logical connectives.

Because of its great simplicity there is no better place to start than with Church's system.
Once this is described the modest adjustments and extensions which help to make STT into a practical language for developing mathematics with a proof tool are readily understood.

It is not always easy for those who have spent a lifetime working with these ideas to understand which parts will prove hard to grasp for people coming to this with a different background.
I have assumed some familiarity with modern symbolic logic, and an acquaintance with the idea of programming languages.
Beyond that I suspect that the idea of higher order functions, which is pervasive, will be the largest stumbling block for any readers whc are not previously acquainted with it. and so I have made an attempt to make that clear.

I hesitate to say that I anticipate a wide audience for this material, but whatever my expectations on that score, it is written to accompany my work on the application of formal methods using {\Product} to problems in philosophy and elsewhere.
It is therefore written with the aim of making it possible for some philosophers to read and understand that kind of formal material, without daring to hope that any other philosopher might adopt the methods.

\subsection{Abstract and Concrete Syntax}

When Church wrote his paper \emph{Abstract} syntax had not been invented.
I first came across this idea when I came to `denotation semantics', an approach to the semantics of programming languages concocted by a computer scientics (Strachey) and a set theorist (Scott) collaborating at Oxford.
It is beneficial when working in the design of complex programming languages, simplifying the task by separating out the details and difficulties of the concrete presentation of the language from the underlying abstract structure both of syntax and of semantics.

In presenting Higher Order Logic here, the emphasis is on the underlying abstract structures.
Where examples are given, of necessity they must be presented using some concrete syntax, and this will be the concrete syntax adopted in {\Product-HOL}.

\section{Simple Types}\label{ST}

Simple types, as presented by Church in his paper presenting \emph{A Formulation of The Simple Theory of Types}\cite{church40}, consist of the set of types obtainable from two primitive types, that of individuals ($…$) and that of propositions ($Ö$) by repeated application of the function type construction.
The function type is written by Church as juxtaposition of the two types from which it is formed codomain first, the whole enclosed in brackets.
Thus $(Ö…)$ is a type of propositional functions, functions whose domain is the individuals and whose codomain is the propositions.
These may be thought of as first-order predicates.

We will work henceforth with the type system as is appears in {\Product-HOL}.
The differences in the type systems insofar as they bear upon the present section are, firstly that the type of individuals is called \emph{IND} rather than $…$ and secondly that the instead of a type of \emph{propositions} {\Product} has a type of \emph{truth values}, \emph{BOOL}.%
\footnote{In Church the axiom of excluded middle is left optional, so that the logic need not be `classical'.
In {\Product-HOL} the axiom of exluded middle is stated as the assertion that there are just two truth values, $T$ and $F$.}
For illustrative purposes we work as if the primitive types were the natural numbers, $Ó$ and the truth values \emph{BOOL}.

Types will normally be shown in ``Quine corners'' thus: îÓÆ is the type of natural numbers and îBOOLÆ the type of truth values.
We work with a ``meta-language'' which is a functional programming language, and which allows us to manipulate syntax using a computer, and provides facilities for constructing and checking formal proofs.
The text will be interspersed with short scripts which should be understood as being submitted to an interactive proof tool in sequence.

For example:
=SML
val one = 1;
=TEX

gives the name $one$ to the number 1.
We may also sometimes show the response of the tool to such an input.
Thus, to the input:

=SML
one+one;
=TEX

the system will now respond:

=GFT ProofPower output
val it = 2 : int
=TEX

showing that {\Product} has evaluated the expression \emph{one + one} and concluded that its value is the integer 2.

Standard ML (SML) is itself closely related to the typed lambda calculus which is our subject matter, so we have similar type systems and facilities for functional abstraction both in our metalanguage and in our object language.
In order to talk about the object language type system in our metalanguage we have in SML a type \emph{TYPE} which has a structure corresponding to that of the types of the object language.
When an expression is entered in the type quote brackets $î$ and $Æ$ it is construed as an object of type TYPE representing a type of the object language, and can then be manipulated as such.

The exchange:

=SML
îÓÆ;
=TEX

=GFT ProofPower output
val it = îÓÆ : TYPE
=TEX

shows that {\Product} has recognised the type we entered as a type.

Function types may be written in the object language using the infix function type constructor $≠$, or may be computed using the metalanguage function $mk\_≠\_type$.
Thus a truth-valued function may have type:

=SML
îÓ ≠ BOOLÆ;
=TEX

which may also be obtained by the following computation:

=SML
mk_≠_type (îÓÆ, îBOOLÆ);
=TEX

=GFT ProofPower Output
val it = îÓ ≠ BOOLÆ : TYPE
=TEX

Thus the heirarchy of types is the set of types which are obtainable from $îÓÆ$ and $îBOOLÆ$ by use of the metalanguage function $mk\_≠\_type$ or the object language infix type constructor $≠$.

\section{The Simply Typed Lambda Calculus}\label{TSTLC}

The simple types are introduced to serve as a type system for a typed $lambda-calculus$.

The lambda-calculus is the simplest imaginable notation for functional abstraction and application.

Functional abstraction is the process of obtaining a function from some expression containing variable symbols.

A function is a mapping from argument values to result values.
When a function is to be defined using an expression, such as $¨x + x * xÆ$ the idea is that the value of the function for some argument is obtained by substituting the value of the argument for the variable in the expression and the resulting expression is then evaluated to give the value of the function for that argument.
However, we want to be able to do this with expressions which contain more than one variable, and we then need to be able to stipulate which variable is to be used for the argument value.

Typically this might be done as follows:

=GFT
f(x) = x + x*x
=TEX

\section{Church's Simple Theory of Types}\label{STT}

=SML
infix ≠;
datatype Type = Ö | i | op ≠ of Type * Type;
=IGN
Ö ≠ i;
=TEX

=SML
fun	print_Type Ö = "Ö"
|	print_Type i = "i"
|	print_Type (f ≠ a) = concat [if f = Ö orelse f = i then print_Type f else concat ["(", print_Type f, ")"], "≠", print_Type a]
;
=TEX

=IGN
fun def_const consts (h::t) = find consts (fn c => fst(dest_const c) = h)
		handle _ => def_const consts t; 

fun def_consts consts (h::t) = (((h, get_spec (def_const consts h))
			:: (def_consts consts t)) handle _ => def_consts consts t)
|   def_consts consts [] = [];

fun get_specs thy = def_consts (get_consts thy) (map fst (get_defns thy));

get_specs "Ø";
get_consts "Ó";
get_defns "Ó";
map fst (get_defns "one");
=TEX



=SML
infix õÎ;
fun a õÎ 0 = a |
    a õÎ n =	let val a' = a  õÎ (n - 1)
		in (a' ≠ a') ≠ (a' ≠ a')
		end;

infix âa;
datatype Term =	V of string * Type
		| C of string * Type
		| op âa of Term * Term
		| Ã of string * Type * Term;
=TEX
=SML
fun	atomic_Term (V (s, t)) = true
|	atomic_Term (C (s, t)) = true
|	atomic_Term x = false;

fun print_Term (V (s, t)) = concat["(", s, ":", print_Type t, ")"]
|	print_Term (C (s, t)) = concat["(", s, "::", print_Type t, ")"]
|	print_Term (f âa a) = concat[
		print_Term f,
		if atomic_Term a then print_Term a else concat["(", print_Term a, ")"]]
|	print_Term (Ã (s, ty, tm)) = concat ["Ã", s, ":", print_Type ty, print_Term tm];

=TEX

=SML
infix 8 âa;
=IGN
datatype Term = op âv of string * Type
	| op âc of string * Type
	| op âa of Term * Term	
	| Ã of string * Type * Term;
=SML
exception Ill_typed_term of string;

fun typ_of (V(s, t)) = t
|   typ_of (C(s, t)) = t
|   typ_of (Ã (s,ty,te)) = ty ≠ (typ_of te)
|   typ_of (f âa a) = let val (tfd ≠ tfc) = typ_of f
		     and ta = typ_of a
	 	     in	if tfd = ta
			then tfc
			else raise Ill_typed_term (concat[
				"function:", print_Term f, " :", print_Type (tfd ≠ tfc), " ",
				"argument:", print_Term a, " :", print_Type (ta)])
		     end;

typ_of ((C ("a", i ≠ Ö)) âa (V ("a", i)));
=TEX

=SML
fun ~ A = C("N", (Ö ≠ Ö)) âa A;
infix ≤;
fun A ≤ B = C("A", Ö ≠ Ö ≠ Ö) âa A âa B;
infix ±;
fun A ± B = ~(~ A ≤ ~ B);
infix ‰;
fun A ‰ B = (~ A ≤ B);
infix È;
fun A È B = (A ‰ B) ± (B ‰ A);
fun µ A = C("ê", ((typ_of A) ≠ Ö)) âa A;
fun ∂ A = ~ (µ (~ A));
fun … A = let val ta = typ_of A
	in C("…", ta ≠ Ö) âa A
	end;
infix Q;
fun A Q B =
	let	val ft = (typ_of A) ≠ Ö;
		val f = V("f", ft)
	in µ (Ã("f", ft, f âa A ‰ f âa B))
	end;
infix Ω;
fun A Ω B = ~ (A Q B);
fun Iât a = Ã("x", a, V ("x", a));
fun I A = (Iât (typ_of A)) âa A;
fun Kât a1 a2 = Ã("x", a1, Ã("y", a2, V ("x", a1)));
fun K A B = Kât (typ_of A) (typ_of B) âa A âa B;
fun Zât a = Ã("f", a ≠ a, Iât a);
fun Natât a n = Ã("f", a ≠ a, Ã("x", a, fun_pow n (fn t => V("f", a ≠ a) âa t) (V("x", a))));
fun Sucât a = 
	let val f = V("f", a ≠ a);
	    val n = V("n", a õÎ 1);
	    val x = V("x", a)
	in Ã("n", a õÎ 1, Ã("f", a ≠ a, Ã("x", a, (f âa (n âa f âa x)))))
	end; 
fun Suc A = (Sucât (typ_of A)) âa A;
fun Nât a = Ã("n", a õÎ 1,
	µ (Ã("f", ((a õÎ 1) ≠ Ö),
	  (V ("f", (a õÎ 1) ≠ Ö) âa (Zât a))
	  ‰ (µ	(Ã("x", a õÎ 1,
		  (V("f", (a õÎ 1) ≠ Ö) âa (V("x", a õÎ 1)))
		  ‰ (V("f", (a õÎ 1) ≠ Ö) âa Suc(V("x", a õÎ 1)))
		) )
	  ‰ (V("f", (a õÎ 1) ≠ Ö) âa (V("n", a õÎ 1))
	    )
	))));
=IGN
typ_of (Suc("x" âv (i õÎ 1)));
typ_of ((Nât i));
=TEX


\section{Higher Order Logic}\label{HOL}

\section{HOL}

\section{ProofPower}

\section{Conclusions}
