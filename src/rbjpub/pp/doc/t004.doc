=IGN
$Id: t004.doc,v 1.6 2006/09/25 20:00:47 rbj01 Exp $
=TEX
\documentclass[11pt,a4paper]{article}
\usepackage{latexsym}
\usepackage{ProofPower}
\ftlinepenalty=9999
\tabstop=0.25in
\usepackage{A4}
\def\N{\mathbb{N}}
\def\D{\mathbb{D}}
\def\B{\mathbb{B}}
\def\R{\mathbb{R}}
\def\Z{\mathbb{Z}}
\def\Q{\mathbb{Q}}

\newcommand{\ignore}[1]{}
\def\Hide#1{\relax}
\def\pindex#1{#1\index{#1}}

\title{Membership Structures}
\author{Roger Bishop Jones}
\date{$ $Date: 2006/09/25 20:00:47 $ $}
\makeindex
\usepackage[pdftex]{hyperref}
\begin{document}
\vfill
\maketitle
\begin{abstract}
A queer way of doing set theory in HOL (together with some queer reasons for doing it that way).
\end{abstract}
\vfill
\begin{centering}
http://www.rbjones.com/rbjpub/pp/doc/t004.pdf
\end{centering}
\newpage
\tableofcontents
\newpage
%%%%
%%%%
\subsection*{To Do}
\begin{itemize}

\item

\end{itemize}

{\raggedright
\bibliographystyle{fmu}
\bibliography{rbj,fmu}
} %\raggedright

%%%%
%%%%
\section{INTRODUCTION}

\subsection{Indexing Tests}

hello \index{hello}

hellol2 \index{hello!level2}

hellol3 \index{hello!level2!level3}

bold \index{bold@\textbf{bold}}

boldpp \index{bold|textbf}

\subsection{Introduction Proper}

This document explores a way of doing set theory in higher order logic.

It is in fact rather more concerned with philosophy than with the brute technical development, and I don't really expect the formal development to get far enough to be valuable in itself.

The philosophy is concerned with set theory as a foundation for abstract semantics, and with the question how set theory can be made sufficiently definite in its meaning to serve well in that role.

Create new theory ``membership''.
=SML
set_flag("pp_use_alias", true);
open_theory "€rbjmisc›";
force_new_theory "€membership›";
new_parent "ordered_sets";
new_parent "bin_rel";
set_merge_pcs["hol1", "'˙", "'savedthm_cs_∂_proof"];
open RbjTactics1;
=TEX

\section{SET THEORY AS SEMANTIC FOUNDATION SYSTEM}

Set theory is considered here primarily as a candidate universal foundation for semantics, i.e. as a language in which the abstract semantics of any other language may be given and to which, by such means, logical truth in its broadest sense, may be reduced.

Logical truth in its broadest sense I take to be {\it analyticity} which I also identify with necessary truth.
Very briefly my rationale in this is as follows.
In the first identification I am simply disinclined to follow the novelty of the twentieth century in using the notion of logical truth in as narrow and arbitrary a manner as has become common.
You may regard this if you like as an terminological eccentricity (which is how I regard modern usage in this matter).
On the identification of analyticity with necessity I have more interesting reasons for rejecting the possibility of necessity {\it de re} (which I take to be any necessity which is not {\it de dicto}, necessity de dicto being analyticity).
If we were free to take any account of the semantics of a language, including some otherwise correct but substantively incomplete account, as the basis for defining the notion of analyticity then we could of course easily contrive examples of necessity {\it de re}.
Take for example the content free semantics for a language, which tells us nothing about which sentences are true or false, and relative to the notion of analyticity (or necessity {\it de dicto}) which flows from that account all necessity is {\it de re}.
This is of course absurd.
To make a judgement about kinds of necessity one must of course judge necessity {\it de dicto} against a semantics which is complete, at least in its account of the truth conditions for a language.
A necessary proposition must however be true {\it under all conditions}.
Any complete account of the truth conditions of the relevant language must of course tell us whenever a statement is unconditionally true.
If any statement is judged necessary {\it de re} it must be that the denial of its being necessary {\it de re} is based upon an incomplete account of the truth conditions of the language.

\section{BASIC PROPERTIES OF MEMBERSHIP RELATIONS}

The following types are used:
\begin{itemize}
\item[MS] membership structure
\item[PMS] property of membership structure
\end{itemize}

A membership structure is a set together with a binary relation over that set.
This constitutes an interpretation of the language of first order set theory, though not necessarily a model for any particular axiomatisation of set theory such as ZFC.

We are interested in properties of membership structures.
We are not exclusively interested in any particular kinds of properties, but we will introduce various classifications of these properties, the first of which will be those which are captured by sentences of first order set theory.

=SML
declare_type_abbrev ("€MS›", ["'a"], î'a SET ∏ ('a ≠ 'a ≠ BOOL)Æ);
declare_type_abbrev ("€PMS›", ["'a"], î'a MS ≠ BOOLÆ);
=TEX
=SML
declare_infix (305, "çâr");
=TEX

The interest in first order properties is rather subsidiary, the real point of this approach to set theory is to escape from being constrained to first order properties.
There is some interest in showing why this is a good thing, and the notion of first order property is defined primarily in order to be able to show that interesting properties of membership structures often are not first order.

I don't know whether that will prove feasible, its not so hard to prove that properties are first order, but it will probably be a lot harder to prove that properties are not.
The most obvious example of a property which is not first order is well-foundedness.
The obvious way to prove that well-foundedness is not first order is to prove that if it were we would could get from first order set theory a complete arithmetic.
This route however presupposes a proof of the incompleteness of arithmetic, which is not so easy.

The term ``membership relation'' is use purely to indicate motivation, this is not a non trivial subclass of binary relationships.

The following are key properties which yield our broadest classification of membersip relations:

\begin{enumerate}
\item extensionality
\item purity
\item well-foundedness
\end{enumerate}

None of these properties is essential for a membership relation.
The one which is perhaps most conspiciously characteristic of set membership is extensionality, but constructive set theories are likely not to be extensional.

A set theory is ``pure'' if everything in the domain of discourse is a set.

We are concerned here only with relations whose type is some instance of $î'a ≠ 'a ≠ BOOLÆ$ and so there is only one type of entity in the domain of discourse, and so in some sense everything is a set.
However, if extensionality is weakened there may be any number of sets which have no members, and we may think of the extra ones as urelements.
If well-foundedness is absent or qualified then Quine's trick of treating urlements as their own unit set allows full extensionality to be retained in a system in which some things are not thought of as sets.

πHOLCONST
‹ €extensional›: 'a PMS
˜¸¸¸¸¸¸
‹ µ (X, $çâr)∑ extensional (X, $çâr) § µs t∑ s ç X ± t ç X ¥
‹	(s = t § (µ u∑ u ç X ¥ (u çâr s § u çâr t)))
∞

\ignore{
=SML
val extensional_def = get_spec ¨extensionalÆ;
set_goal([], ¨µ ms:'a MS∑ extensional ms § µs t:'a∑ s ç Fst ms ± t ç Fst ms ¥
	(s = t § µ u:'a∑ u ç Fst ms ¥ (Snd ms u s § Snd ms u t))Æ);
a (strip_tac THEN once_rewrite_tac [prove_rule [] ¨ms = (Fst ms, Snd ms)Æ]
	THEN rewrite_tac[extensional_def]
	THEN REPEAT strip_tac
	THEN TRY (all_asm_fc_tac[]));
val extensional_thm = save_pop_thm "extensional_thm";
=TEX
}%ignore

The definition of well-foundedness used here is the concept {\it WellFounded} from the theory ``ordered\_sets''.

Set theories whose intuition is based in the cumulative or iterative heirarchy are both extensional and well-founded, and I will be concerned for the time being with just these kinds of membersbip relation.
These two properties can be thought of as telling us what kind of thing a set is, and the rest of the axioms in a systems like ZFC, possibly with large cardinal axioms, are trying to maximise the how many of the things with these properties can be shown to be in the domain of discourse.

This explanation connects with the usual description of the cumulative heirarchy, in which the formation of the domain of discourse of set theory is presented as occurring in stages.
At each stage one adds to the cumulative hierarchy all the sets which can be formed from those already obtained (the first ``all'') and then we are to understand that one goes through as many stages as one possibly can (the second ``all''), thereby aggregating all the pure well-founded collections.
Unfortunately, if one ever could complete this process the result would be a well-founded collection which would not contain itself, and so we must suppose that the construction cannot be completed.

My present interest is therefore, at present, in considering how to formalise the description of larger and larger parts of this incompletable construction.

The decomposition of the ``all'' in the intuitive concept suggests that the formalisation may be able to treat these two ``all''s separately.
The idea is that we can say that at each stage all possible new subsets are created, and then consider how to say that the number of stages is very large, separating questions of width and height.
A clean separation turns out not to be possible in a first order axiomatisation, but in the present context, i.e. in a higher order logic construed under the standard semantics, it is possible (though perhaps more by theft than honest toil, the relevant notion of ``all'' being readily expressed under the standard semantics).

However, there are some preliminaries which seem to be necessary to adeqately address either ``all''.
To get ``full-width'' we want to say that at each stage all the subsets of the previous stage become sets.
For this we need to be able to talk about the stages.
The stages can be ordered using ordinals, and so first we need a concept of ordinal number.
In fact, we can think of ordinals in terms of width, for the ordinals are among the membership relations of least width (which are those in which only one new set is introduced at each stage).

There are two kinds of ordinals of interest here.
The first kind of ordinal is an element in the domain of a membership relation.
The second is a membership relation of which the domain as a whole is an ordinal (and may be thought of as the class of ordinals in its domain).

Throughout the treatment of ordinals and cardinals adopted here we want to talk both about relations as being ordinals and about elements in the domain of relations as being ordinals.
These notions are connected in that an element is an ordinal element iff the restriction of the membership relation in whose domain it appears to the members of that relation is an ordinal relation, and these two entities may be thought of as representing the same ordinal.

Postfix subscripts are used to distinguish properties of ordinal relations from the corresponding property of ordinal elements.

πHOLCONST
‹ €ordinal_relation›: 'a MS ≠ 'a ≠ 'a MS
˜¸¸¸¸¸¸
‹ µ (X, $çâr):'a MS; a:'a∑ ordinal_relation (X, $çâr) a = ({x:'a | x çâr a} ° X, $çâr)
∞

A {\it relation} is ``ordinal'' iff it is a transitive strict well-ordering.
The concept of {\it WellOrdering} in $ordered\_sets$ does not require strictness so we define an ordinal using $WellFounded$ and $LinearOrder$

πHOLCONST
‹ €ordinal›: 'a PMS
˜¸¸¸¸¸¸
‹ µ mr∑ ordinal mr § LinearOrder mr ± Trans mr ± WellFounded mr
∞

We now introduce the idea that a membership relation is in the domain of some other membership domain, which may be though of as asserting that the class of sets under one membership relation is a set in the domain of the other.

=SML
declare_infix (305, "çâa");
declare_infix (305, "çâb");
=TEX
πHOLCONST
‹ €homomorphism›: ('a MS ∏ ('b MS)) ≠ ('a ≠ 'b) ≠ BOOL
˜¸¸¸¸¸¸
‹ µ (X, $çâa):'a MS; (Y, $çâb):'b MS; f:'a ≠ 'b∑
‹	homomorphism ((X, $çâa), (Y, $çâb)) f §  µs t:'a∑ s çâa t ¥ (f s) çâb (f t)
∞
πHOLCONST
‹ €embedding›: ('a MS ∏ 'b MS) ≠ ('a ≠ 'b) ≠ BOOL
˜¸¸¸¸¸¸
‹ µ msa msb f∑ embedding (msa, msb) f § 
‹	homomorphism (msa, msb) f
‹	± OneOne f
∞

=SML
declare_infix (310, "Úâm");
=TEX

πHOLCONST
‹ $€Úâm›: ('a ≠ BOOL) ≠ 'a MS ≠ 'a MS
˜¸¸¸¸¸¸
‹ µ P (X, $çâa) ∑ P Úâm (X, $çâa) = (X ° {x | P x}, $çâa)
∞

\section{FIRST ORDER PROPERTIES}

In order to define the notion of a ``first order property'' we need to mimic the satisfaction relation.
Sentences define sets of interpretations, but formulae only do so in the context of an assignment to the free variables in the formula.
The operators we define therefore operate over parameterised properties of interpretations.

It proves desirable to make this theory polymorphic not only in the type of the sets involved, but also in the notion of variable (sometimes we may wish to work with assignments to terms).
An assignment to free variables is modelled as a function from objects of type î'vÆ (a type variable) to elements in the domain of the relation (here î'sÆ).

=SML
declare_type_abbrev ("€VA›", ["'s", "'v"], î'v ≠ 'sÆ);
=TEX

πHOLLABPROD PPMS¸¸¸¸¸
‹ pms : ('s, 'v) VA ≠ 's PMS
∞¸¸¸¸¸¸¸¸¸¸¸¸¸¸

Various operators over properties of membership relations are now defined.

The language of set theory which we consider has the following simplifying characteristics:

\begin{enumerate}
\item the only terms are variables
\item the relations are equality and membership
\item the propositional connectives are conjunction and negation
\item there is just one, existential, quantifier
\end{enumerate}

Membership statements are parameterised by the names of the two variables between which membership is predicated, and the parameterised property of membership relations which they denote is:

=SML
declare_infix (305, "çâp");
=TEX

πHOLCONST
‹ $€çâp›: 'v ≠ 'v ≠ ('s, 'v) PPMS
˜¸¸¸¸¸¸
‹ µ s t:'v∑ (s çâp t) = MkPPMS (Ãva: ('s, 'v) VA; (X, $çâr):'s MS∑
‹	(va s) çâr (va t))
∞

Equality is defined similarly.

=SML
declare_infix (305, "=âp");
=TEX

πHOLCONST
‹ $€=âp›: 'v ≠ 'v ≠ ('s, 'v) PPMS
˜¸¸¸¸¸¸
‹ µ s t:'v∑ s =âp t = MkPPMS(Ã va:('s, 'v) VA; (X, $çâr): 's MS∑
‹	(va s) = (va t))
∞

Conjunction denotes a binary operation over PPMS's.

=SML
declare_infix (302, "±âp");
=TEX

πHOLCONST
‹ $€±âp›: ('s, 'v) PPMS ≠ ('s, 'v) PPMS ≠ ('s, 'v) PPMS
˜¸¸¸¸¸¸
‹ µ l r∑ l ±âp r = MkPPMS(Ãva (X, $çâr)∑ (pms l va (X, $çâr)) ± (pms r va (X, $çâr)))
∞

Negation denotes a monadic operator.

πHOLCONST
‹ €≥âp›: ('s, 'v) PPMS ≠ ('s, 'v) PPMS
˜¸¸¸¸¸¸
‹ µ f∑ ≥âp f = MkPPMS(Ãva (X, $çâr)∑ ≥ (pms f va (X, $çâr)))
∞

The existential quantifier binds a variable and its value depends upon assigning values to that variable in a variable assignment.
The following function modifies a variable assignment.

πHOLCONST
‹ €assign›:  's ≠ 'v ≠ ('s, 'v) VA ≠ ('s, 'v) VA
˜¸¸¸¸¸¸
‹ µ a s va t ∑ assign a s va t = if t = s then a else va t
∞

Finally the existential quantifier, which is parameterised by the name of the variable it binds and the value of the formula it quantifies over.

πHOLCONST
‹ €∂âp›: 'v ≠ ('s, 'v) PPMS ≠ ('s, 'v) PPMS
˜¸¸¸¸¸¸
‹ µ s f∑ ∂âp s f = MkPPMS(Ãva (X, $çâr)∑ ∂a∑ a ç X ± pms f (assign a s va) (X, $çâr))
∞

\ignore{
=SML
val PPMS_def = get_spec ¨MkPPMSÆ;
val eqâp_def = get_spec ¨$=âpÆ;
val eqâp_def = get_spec ¨$=âpÆ;
val çâp_def = get_spec ¨$çâpÆ;
val ≥âp_def = get_spec ¨≥âpÆ;
val ±âp_def = get_spec ¨$±âpÆ;
val assign_def = get_spec ¨assignÆ;
val ∂âp_def = get_spec ¨∂âpÆ;
=TEX
}%ignore

Next we define the set of parameterised properties which can be constructed by these operators and then take their closures to eliminate the parameters.

πHOLCONST
‹ €fof›: ('s, 'v) PPMS ≠ BOOL
˜¸¸¸¸¸¸
‹ µppms∑ fof ppms §
‹	µpppms∑ (µs1 s2 p1 p2 ∑
‹		pppms (s1 çâp s2)
‹		± pppms (s1 =âp s2)
‹		± 
‹		(pppms p1 ± pppms p2
‹		¥ pppms (p1 ±âp p2)
‹		± pppms (≥âp p1)
‹		± pppms (∂âp s1 p1)))
‹	¥ pppms ppms
∞

Finally we define the property of properties of membership structures which consists in being definable by a set of sentences of first order set theory.

First we define the closure of a first order formula.
Note that this function serves to convert a paramaterised property of membership structures into a plain property of membership structures, and this is its primary purpose.
The fact that it also effectively undertakes a universal closure is a side effect (though this will simplify some demonstrations), since it is primarily intended for application to closed formulae.

An awkwardness arises here in dealing with the possibility of empty structures.
An interpretation of a first order language must be non-empty, but for present purposes it is convenient for the notion of a first order property of structures to take into account the possibility of empty structures.

πHOLCONST
‹ €foc›: ('s, 'v) PPMS ≠ 's PMS
˜¸¸¸¸¸¸
‹ µppms (X, $çâm)∑ foc ppms (X, $çâm) = µva∑ X = {} ≤ (µv∑ va v ç X)
‹		¥ pms ppms va (X, $çâm)
∞

The concept of first order sentence, as here presented using semantic rather than syntactic entities, is in fact the property of being a property of membership structures which can be expressed by a sentence in the language of first order set theory.
The name {\it fop} for {\it first order property} is therefore chosen rather than {\it fos} for {\it first order sentence}.

This property is independent of the type of variables, but is defined in terms of entities which are polymorphic in the type of variables.
For the definition to be conservative we have to parameterise it with a variable, which is ignored.
In applications this definition can be instantiated to the application type to yield a property.

πHOLCONST
‹ €fop›: 'v ≠ 's PMS ≠ BOOL
˜¸¸¸¸¸¸
‹ µpmr v∑ fop v pmr § ∂f: ('s, 'v) PPMS∑ fof f ± pmr = foc f
∞

For convenience the following derived constructors are defined:

=SML
declare_infix (298, "≤âp");
declare_infix (295, "¥âp");
declare_infix (290, "§âp");
=TEX

πHOLCONST
‹ $€≤âp› : ('s, 'v) PPMS ≠ ('s, 'v) PPMS ≠ ('s, 'v) PPMS
˜¸¸¸¸¸¸
‹  µl r∑ l ≤âp r = ≥âp (≥âp l ±âp ≥âp r)
∞

πHOLCONST
‹ $€¥âp› : ('s, 'v) PPMS ≠ ('s, 'v) PPMS ≠ ('s, 'v) PPMS
˜¸¸¸¸¸¸
‹  µl r∑ l ¥âp r = r ≤âp ≥âp l
∞

πHOLCONST
‹ $€§âp› : ('s, 'v) PPMS ≠ ('s, 'v) PPMS ≠ ('s, 'v) PPMS
˜¸¸¸¸¸¸
‹  µl r∑ l §âp r = (l ¥âp r) ±âp (r ¥âp l)
∞

πHOLCONST
‹ €µâp›: 'v ≠ ('s, 'v) PPMS ≠ ('s, 'v) PPMS
˜¸¸¸¸¸¸
‹ µ s p ∑ µâp s p = ≥âp (∂âp s (≥âp p))
∞


\ignore{
=SML
val fof_def = get_spec ¨fofÆ;
val foc_def = get_spec ¨focÆ;
val fop_def = get_spec ¨fopÆ;
val ≤âp_def = get_spec ¨$≤âpÆ;
val ¥âp_def = get_spec ¨$¥âpÆ;
val §âp_def = get_spec ¨$§âpÆ;
val µâp_def = get_spec ¨µâpÆ;
=TEX

=SML
set_goal([], ¨µppms ms∑ foc ppms ms § µva∑ Fst ms = {} ≤ (µv∑ va v ç Fst ms) ¥ pms ppms va msÆ);
a (once_rewrite_tac [prove_rule [] ¨ms = (Fst ms, Snd ms)Æ]
	THEN rewrite_tac [foc_def]);
val foc_thm = save_pop_thm "foc_thm";
=TEX

=SML
set_goal([], ¨µs1 s2: 'v ∑
‹	  fof (s1 =âp s2)
‹	± fof (s1 çâp s2)Æ);
a (REPEAT strip_tac THEN TRY (rewrite_tac [fof_def]
	THEN REPEAT strip_tac
	THEN all_fc_tac [fof_def]
	THEN asm_rewrite_tac[]));
val fof_base_clauses = save_pop_thm "fof_base_clauses";
=TEX
=SML
set_goal([], ¨µs s1; p1 p2: ('s, 'v) PPMS ∑
‹	  (fof p1 ¥ fof (≥âp p1)
‹		± fof (∂âp s p1)
‹		± fof (µâp s p1))
‹	 ± (fof p1 ± fof p2 ¥
‹		  fof (p1 ±âp p2)
‹		± fof (p1 ≤âp p2)
‹		± fof (p1 ¥âp p2)
‹		± fof (p1 §âp p2))Æ);
a (REPEAT strip_tac THEN TRY (rewrite_tac
	[fof_def, ≤âp_def, ¥âp_def, §âp_def, µâp_def]
	THEN REPEAT strip_tac
	THEN all_fc_tac [fof_def]));
(* *** Goal "1" *** *)
a (REPEAT (all_asm_fc_tac[]));
(* *** Goal "2" *** *)
a (list_spec_nth_asm_tac 2 [¨sÆ, ¨sÆ, ¨p1Æ, ¨p1Æ]);
(* *** Goal "3" *** *)
a (lemma_tac ¨pppms (≥âp p1)Æ 
	THEN1 list_spec_nth_asm_tac 2 [¨sÆ, ¨sÆ, ¨p1Æ, ¨p1Æ]);
a (lemma_tac ¨pppms (∂âp s (≥âp p1))Æ 
	THEN1 list_spec_nth_asm_tac 3 [¨sÆ, ¨sÆ, ¨≥âp p1Æ, ¨p1Æ]);
a (REPEAT (all_asm_fc_tac[]));
(* *** Goal "4" *** *)
a (REPEAT (all_asm_fc_tac[]));
(* *** Goal "5" *** *)
a (lemma_tac ¨pppms (≥âp p1) ± pppms (≥âp p2)Æ
	THEN1 (strip_tac THEN REPEAT (all_asm_fc_tac[])));
a (lemma_tac ¨pppms (≥âp p1 ±âp ≥âp p2)Æ
	THEN1 (REPEAT (all_asm_fc_tac[])));
a (REPEAT (all_asm_fc_tac[]));
(* *** Goal "6" *** *)
a (lemma_tac ¨pppms (≥âp p1) ± pppms (≥âp p2)Æ
	THEN1 (strip_tac THEN REPEAT (all_asm_fc_tac[])));
a (lemma_tac ¨pppms (≥âp (≥âp p1))Æ
	THEN1 (REPEAT (all_asm_fc_tac[])));
a (list_spec_nth_asm_tac 6 [¨≈x:'v∑TÆ, ¨≈x:'v∑TÆ, ¨≥âp p2Æ, ¨≥âp (≥âp p1)Æ]);
a (list_spec_nth_asm_tac 11 [¨≈x:'v∑TÆ, ¨≈x:'v∑TÆ, ¨(≥âp p2) ±âp (≥âp (≥âp p1))Æ, ¨≥âp p2Æ]);
(* *** Goal "7" *** *)
a (lemma_tac ¨pppms (≥âp p1) ± pppms (≥âp p2)Æ
	THEN1 (strip_tac THEN REPEAT (all_asm_fc_tac[])));
a (lemma_tac ¨pppms (≥âp (≥âp p1)) ± pppms (≥âp (≥âp p2))Æ
	THEN1 (strip_tac THEN REPEAT (all_asm_fc_tac[])));
a (lemma_tac ¨pppms (≥âp p2 ±âp ≥âp (≥âp p1))Æ 
	THEN1 list_spec_nth_asm_tac 7 [¨≈x:'v∑TÆ, ¨≈x:'v∑TÆ, ¨≥âp p2Æ, ¨≥âp (≥âp p1)Æ]);
a (lemma_tac ¨pppms (≥âp p1 ±âp ≥âp (≥âp p2))Æ 
	THEN1 list_spec_nth_asm_tac 8 [¨≈x:'v∑TÆ, ¨≈x:'v∑TÆ, ¨≥âp p1Æ, ¨≥âp (≥âp p2)Æ]);
a (lemma_tac ¨pppms (≥âp (≥âp p2 ±âp ≥âp (≥âp p1)))Æ 
	THEN1 list_spec_nth_asm_tac 9 [¨≈x:'v∑TÆ, ¨≈x:'v∑TÆ, ¨≥âp p2 ±âp ≥âp (≥âp p1)Æ, ¨≥âp p2Æ]);
a (lemma_tac ¨pppms (≥âp (≥âp p1 ±âp ≥âp (≥âp p2)))Æ 
	THEN1 list_spec_nth_asm_tac 10 [¨≈x:'v∑TÆ, ¨≈x:'v∑TÆ, ¨≥âp p1 ±âp ≥âp (≥âp p2)Æ, ¨≥âp p2Æ]);
a (list_spec_nth_asm_tac 11 [¨≈x:'v∑TÆ, ¨≈x:'v∑TÆ, ¨≥âp (≥âp p2 ±âp ≥âp (≥âp p1))Æ,
	¨≥âp (≥âp p1 ±âp ≥âp (≥âp p2))Æ]);
val fof_step_clauses = save_pop_thm "fof_step_clauses";
=TEX

=SML
set_goal ([], ¨fof (µâp "x" (µâp "y" ("x" =âp "y" §âp µâp "z" ("z" çâp "x" §âp "z" çâp "y"))))Æ);
a (abc_tac [fof_step_clauses, fof_base_clauses]);
val fof_extensionality_lemma1 = pop_thm ();
=TEX

=SML
set_goal ([], ¨fof (µâp "x" (µâp "y" ( µâp "z" ("z" çâp "x" §âp "z" çâp "y") ¥âp "x" =âp "y")))Æ);
a (REPEAT (CHANGED_T (bc_tac (abc_canon fof_step_clauses)))
	THEN rewrite_tac [fof_base_clauses]);
val fof_extensionality_lemma1b = pop_thm ();
=TEX

=SML
set_goal ([], ¨fop "" (foc(µâp "x" (µâp "y" ("x" =âp "y" §âp µâp "z" ("z" çâp "x" §âp "z" çâp "y")))))Æ);
a (rewrite_tac [fop_def, foc_def]);
a (∂_tac ¨(µâp "x" (µâp "y" ("x" =âp "y" §âp µâp "z" ("z" çâp "x" §âp "z" çâp "y"))))Æ
	THEN rewrite_tac [fof_extensionality_lemma1]);
val fof_extensionality_lemma2 = pop_thm ();
=TEX

=SML
set_goal ([], ¨fop "" (foc(µâp "x" (µâp "y" (µâp "z" ("z" çâp "x" §âp "z" çâp "y") ¥âp "x" =âp "y"))))Æ);
a (rewrite_tac [fop_def, foc_def]);
a (∂_tac ¨µâp "x" (µâp "y" ( µâp "z" ("z" çâp "x" §âp "z" çâp "y") ¥âp "x" =âp "y"))Æ
	THEN rewrite_tac [fof_extensionality_lemma1b]);
val fof_extensionality_lemma2b = pop_thm ();
=TEX

=SML
set_goal([], ¨fop "" extensionalÆ);
a (rewrite_tac [fop_def]);
a (∂_tac ¨µâp "x" (µâp "y" ( µâp "z" ("z" çâp "x" §âp "z" çâp "y") ¥âp "x" =âp "y"))Æ
	THEN rewrite_tac [fof_extensionality_lemma1b]);
a (rewrite_tac[extensional_thm, foc_thm, eqâp_def, ∂âp_def, ≥âp_def,
	±âp_def, ≤âp_def, µâp_def, ¥âp_def, §âp_def, çâp_def, PPMS_def,
	assign_def]);
a (REPEAT strip_tac
	THEN TRY all_var_elim_asm_tac
	THEN TRY (list_spec_nth_asm_tac 5 [¨aÆ, ¨a'Æ]
		THEN (list_spec_nth_asm_tac 4 [¨uÆ])));
a (list_spec_nth_asm_tac 4 [¨Ãv:STRING∑ ≈y∑ y ç Fst xÆ]);
(* *** Goal "1" *** *)
a (swap_nth_asm_concl_tac 1
	THEN ≈_tac ¨≈ y∑ y ç Fst xÆ
	THEN1 (∂_tac ¨x'Æ THEN asm_rewrite_tac[]));
a (asm_rewrite_tac []);
(* *** Goal "2" *** *)
a (spec_nth_asm_tac 1 ¨sÆ);
a (spec_nth_asm_tac 1 ¨tÆ);
(* *** Goal "2.1" *** *)
a (all_asm_fc_tac []);
(* *** Goal "2.2" *** *)
a (spec_nth_asm_tac 6 ¨a''Æ);
val fop_extensional_thm = save_pop_thm "fop_extensional_thm";
=TEX

}%ignore

\subsection{Stratified Properties}

Some set theories, notably Quine's NF and NFU, are defined using \pindex{stratified\ comprehension} rather than the more usual {\it separation}.
Stratification is a syntactic constraint on the formulae of set theory which can be used to define a set.
This limited class of formulae defines a subset of the first order properties of membership structures, which we will call stratified first order properties.

The {\it semantics} of formulae is unaffected by this constraint, so in defining a stratified property exactly the same constuctors can be used as for non-stratified formulae.
However, when two properties are combined, there must be a check imposed to establish that the combined property is stratified.
This only happens in conjunction, so only one check need be specified.
The check is that there is a type assignment to the free variables of the formula, and this is best performed using a type assignment to the formulae to be combined.
The type assignments are therefore produced intially for the atomic formulae, and then elaborated by each syntactic construction, with a possibility of failure on conjunction.

\subsubsection{Type Assignments v1}

At present we have two different representations of type assignments.

A type assignment is an assignment of natural numbers to the free variables such that the operands of an equation have the same type and the left operand of a membership has a type one less than that on the right.
Since for any correct type assignment another can be obtained by adding any natural number to all the types, the absolute values have no significance, only the relative values.
We therefore represent a type assignment by a partial function from ordered pairs of variable names to integers, representing the partial function as a set of ordered pair of which the first is a pair of names and the second an integer.

The well-formedness conditions for a type assignment are as follows:

\begin{itemize}
\item the relation must be many one
\item the relation must have a kind of antisymmetry (change of order changes sign)
\item the relation must have a kind of transitivity (the type differences should add up)
\end{itemize}

=SML
new_parent "˙";
declare_type_abbrev("TA", [], î(('v ∏ 'v) ∏ ˙) Æ);
=TEX

πHOLCONST
‹ €TaManyOne›: TA ≠ BOOL
˜¸¸¸¸¸¸
‹ µ ta:TA∑ TaManyOne ta §
‹	(µx y:'v; v w:˙∑ ((x,y), v) ç ta ± ((x,y), w) ç ta ¥ v = w)
∞

πHOLCONST
‹ €TaAntiSym›: TA ≠ BOOL
˜¸¸¸¸¸¸
‹ µ ta:TA∑ TaAntiSym ta §
‹	(µx y:'v; z:˙∑ ((x,y), z) ç ta § ((y,x), ~ z) ç ta)
∞

πHOLCONST
‹ €TaTrans›: TA ≠ BOOL
˜¸¸¸¸¸¸
‹ µ ta:TA∑ TaTrans ta §
‹	(µv1 v2 v3:'v; t1 t2:˙∑
‹		((v1,v2), t1) ç ta ± ((v2,v3), t2) ç ta
‹		¥ ((v1,v3), t1 + t2) ç ta)
∞

πHOLCONST
‹ €WfTa›: TA ≠ BOOL
˜¸¸¸¸¸¸
‹ µ ta:TA∑ WfTa ta §
‹	TaManyOne ta
‹  ±	TaAntiSym ta
‹  ±	TaTrans ta
∞

This of course, does not state that the type assignment is correct, just that it is a type assignment.

Type assignments may be combined as followe:

=SML
declare_infix (290, "±âta");
=TEX

πHOLCONST
‹ $€±âta›: TA ≠ TA ≠ TA
˜¸¸¸¸¸¸
‹ µ a b∑ a ±âta b = • {ta | WfTa ta ± a Ä ta ± b Ä ta}
∞

Though defined as a total function, there may be no well-formed type assignment which combines two well-formed type assignments.
In that case the result will be the intersection of the empty set of sets, which is the {\it Universe} over the relevant type. and which is not a well formed type assignment.

We would like to demonstrate that the above definition does yield a correct type assignment where one exists (it obviously does give a minimal one in that case), for which purpose some additional definitions will be helpful.

We define the concepts of the domain of a type assignment and of the domain restriction of a type assignment for use in the proof.

πHOLCONST
‹ €DomTa›: TA ≠ 'v SET
˜¸¸¸¸¸¸
‹ µ ta∑ DomTa ta = {x | ∂y z∑ ((x,y),z) ç ta ≤ ((y,x),z) ç ta}
∞

=SML
declare_infix (300, "Úâta");
=TEX

πHOLCONST
‹ $€Úâta›: 'v SET ≠ TA ≠ TA
˜¸¸¸¸¸¸
‹ µta ss∑ ss Úâta ta = {((x,y),z) | ((x,y),z) ç ta ± {x; y} Ä DomTa ta}
∞

\ignore{
=SML
set_goal([], ¨µta ss∑ WfTa ta ¥ WfTa (ss Úâta ta)Æ);
a (REPEAT µ_tac
	THEN rewrite_tac (map get_spec [¨WfTaÆ, ¨$ÚâtaÆ, ¨TaManyOneÆ,
		¨TaAntiSymÆ, ¨TaTransÆ, ¨DomTaÆ])
	THEN (asm_prove_tac[]));
val WfTa_Ú_thm = save_pop_thm "WfTa_Ú_thm";

=IGN

set_goal([], ¨µa b∑ WfTa a ± WfTa b ± (∂ta∑ WfTa ta ± a ¿ b Ä ta) ¥ WfTa (a ±âta b)Æ);
a (rewrite_tac [get_spec¨$±âtaÆ] THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a (once_rewrite_tac [get_spec ¨WfTaÆ]
	THEN once_rewrite_tac [get_spec ¨TaManyOneÆ]
	THEN REPEAT strip_tac);
a (lemma_tac ¨WfTa (((DomTa a) ¿ (DomTa b)) Úâta ta)Æ
	THEN1 ALL_FC_T rewrite_tac [WfTa_Ú_thm]);
a (lemma_tac ¨µ ss∑ WfTa (ss Úâta (DomTa a ¿ DomTa b) Úâta ta)Æ
	THEN1 all_fc_tac [WfTa_Ú_thm]);
a (spec_nth_asm_tac 3 ¨((DomTa a) ¿ (DomTa b)) Úâta taÆ);
(* *** Goal "1.1" *** *)

a (REPEAT_N 2 (all_asm_fc_tac[]));

	THEN REPEAT_N 2 (all_asm_fc_tac[]))
	THEN_TRY asm_prove_tac[]
);

	THEN PC_T1 "˙_lin_arith" asm_prove_tac[]);
val WfTa_±_thm = save_pop_thm "WfTa_±_thm";
=TEX
}%ignore

=GFT

=TEX

We now define the type assignments for equality and membership assertions and the effect of existential quantification.

=SML
declare_infix (290, "=âta");
=TEX

πHOLCONST
‹ $€=âta›: 'v ≠ 'v ≠ TA
˜¸¸¸¸¸¸
‹ µ a b∑ a =âta b = {((a,a),Ó˙ 0); ((b,b),Ó˙ 0); ((a,b),Ó˙ 0); ((b,a),Ó˙ 0)}
∞

\ignore{
=SML
set_goal([], ¨µa b∑ WfTa (a =âta b)Æ);
a (rewrite_tac (map get_spec [¨WfTaÆ, ¨$=âtaÆ, ¨TaManyOneÆ, ¨TaAntiSymÆ, ¨TaTransÆ])
	THEN PC_T1 "˙_lin_arith" asm_prove_tac[]);
val WfTa_eq_thm = save_pop_thm "WfTa_eq_thm";
=TEX
}%ignore

=GFT
WfTa_eq_thm = Ù µ a b∑ WfTa (a =âta b)
=TEX

=SML
declare_infix (290, "çâta");
=TEX

πHOLCONST
‹ $€çâta›: 'v ≠ 'v ≠ TA
˜¸¸¸¸¸¸
‹ µ a b∑ a çâta b = {((a,a),Ó˙ 0); ((b,b),Ó˙ 0); ((a,b),Ó˙ 1); ((b,a), ~(Ó˙ 1))}
∞

\ignore{
=SML
set_goal([], ¨µa b∑ ≥ a = b ¥ WfTa (a çâta b)Æ);
a (REPEAT µ_tac
	THEN rewrite_tac (map get_spec [¨WfTaÆ, ¨$çâtaÆ, ¨TaManyOneÆ, ¨TaAntiSymÆ, ¨TaTransÆ])
	THEN REPEAT strip_tac
	THEN_TRY all_var_elim_asm_tac
	THEN_TRY asm_rewrite_tac[]
	THEN TRY (PC_T1 "˙_lin_arith" asm_prove_tac[]));
val WfTa_ç_thm = save_pop_thm "WfTa_ç_thm";
=TEX
}%ignore

=GFT
WfTa_ç_thm = Ù µ a b∑ ≥ a = b ¥ WfTa (a çâta b)
=TEX

πHOLCONST
‹ $€∂âta›: 'v ≠ TA ≠ TA
˜¸¸¸¸¸¸
‹ µ a ta∑ ∂âta a ta = {((l,r),t) | ((l,r),t) ç ta ± ≥ (l = a ≤ r = a)}
∞
\ignore{
=SML
set_goal([], ¨µa ta∑ WfTa ta ¥ WfTa (∂âta a ta)Æ);
a (REPEAT µ_tac THEN rewrite_tac (map get_spec [¨WfTaÆ, ¨∂âtaÆ, ¨TaManyOneÆ, ¨TaAntiSymÆ, ¨TaTransÆ])
	THEN prove_tac[]);
val WfTa_∂_thm = save_pop_thm "WfTa_∂_thm";
=TEX
}%ignore

=GFT
WfTa_∂_thm = Ù µ a ta∑ WfTa ta ¥ WfTa (∂âta a ta)
=TEX

Negation has no effect on type assignments.
We can now proceed to define the stratified properties.

For this purpose we need to upgrade our property of `parameterised membership systems' to a property of `typed parameterised membership systems'.
Lets just use an ordered pair for one of these.

=SML
declare_type_abbrev("TPPMS", ["'s", "'v"], î('s, 'v) PPMS ∏ TAÆ);
=TEX

πHOLCONST
‹ €sfof›: ('s, 'v)TPPMS ≠ BOOL
˜¸¸¸¸¸¸
‹ µtppms∑ sfof tppms §
‹	µptppms∑ (µs1 s2 p1 p2 ta1 ta2 ta3∑
‹		ptppms (s1 çâp s2, s1 çâta s2)
‹		± ptppms (s1 =âp s2, s1 =âta s2)
‹		± 
‹		(ptppms (p1, ta1) ± ptppms (p2, ta2)
‹		¥ ptppms (≥âp p1, ta1)
‹		± ptppms (∂âp s1 p1, ∂âta s1 ta1)
‹		± (ta3 = ta1 ±âta ta2 ± WfTa ta3 ¥ ptppms (p1 ±âp p2, ta3))
‹		))
‹	¥ ptppms tppms
∞

\subsubsection{Type Assignment v2}

This version differs from the above in the respects:

\begin{itemize}
\item A type assignment is represented as a set of lists of sets of variable names

\item The specification for a stratified property uses a single type assignment given ab initio rather than building up a type assignement as the property is built from the primitive relations.

\item The type assignment does not take account of bound variables, and this means that some terms in which the same variable is used more than once in quantifiers there may not be a type assignment adequate for these purpose.
In these cases it will be necessary to rename some bound variables before a type assignment becomes available.
Because the type assignment comes top down it must contain information about the types of bound variables, which was not the case in the previous version, and since we have not made provision for scoping such information a proper description of the types may not be possible where the same name is bound more than once.

\end{itemize}


=SML
declare_type_abbrev("TA", ["'v"], î(('v SET)LIST)SETÆ);
=TEX

In the type assignment each list is a list of sets of type-related variable names.
The members of each set all have the same type, the members of successive sets have successive types.
Separate lists are each independent of each other.
For example the formula ¨x ç y ± b ç y ± v = w ± w ç uÆ would have the type assignment ¨{[{x;b};{y}]; [{v;w};{u}]}Æ.

The well-formedness conditions are simply that no name occurs more than once, i.e. that the sets in each list are pairwise disjoint and the unions of the sets in each list are pairwise disjoint.
To test an atomic formula for correctness relative to a type assignment, restrict the assignment to the names in the formula, then you should have, for ¨a ç bÆ, ¨{[{a};{b}]}Æ and for a = b, ¨{[{a;b}]}Æ (bearing in mind that order in list displays is signficant but in set displays is not.

To check a formula you need only check each atom sentence which occurs in it.

Now we formalise this.

πHOLCONST
‹ €ListUnion›: 'a SET LIST ≠ 'a SET
˜¸¸¸¸¸¸
‹ µ ls∑ ListUnion ls = Fold $¿ ls {}
∞

πHOLCONST
‹ €Disjoint›: 'a SET LIST ≠ BOOL
˜¸¸¸¸¸¸
‹ (Disjoint [] § T)
‹  ± µ h t∑ Disjoint (Cons h t) § ((h ° (ListUnion t) = {}) ± Disjoint t)
∞

πHOLCONST
‹ €SetMap›: ('a ≠ 'b) ≠ 'a SET ≠ 'b SET
˜¸¸¸¸¸¸
‹ µ f s∑ SetMap f s = {x | ∂y∑ y ç s ± x = f y}
∞

πHOLCONST
‹ €TaDom›: 'v TA ≠ 'v SET
˜¸¸¸¸¸¸
‹ µ ta∑ TaDom ta = ﬁ (SetMap ListUnion ta)
∞

=SML
declare_infix (310, "Úâta");
=TEX

πHOLCONST
‹ $€Úâta›: 'v SET ≠ 'v TA ≠ 'v TA
˜¸¸¸¸¸¸
‹ µ vs ta∑ vs Úâta ta = SetMap (Ãl∑ Map ($° vs) l) ta
∞

We do not need functions to construct these type assignments, we need only to be able to check properties against them.
In fact we only need to check the atomic propositions.

πHOLCONST
‹ €Check_eq›: 'v TA ≠ 'v ≠ 'v ≠ BOOL
˜¸¸¸¸¸¸
‹ µ ta a b∑ Check_eq ta a b § {a; b} Úâta ta = {[{a;b}]}
∞

πHOLCONST
‹ €Check_ç›: 'v TA ≠ 'v ≠ 'v ≠ BOOL
˜¸¸¸¸¸¸
‹ µ ta a b∑ Check_ç ta a b § {a; b} Úâta ta = {[{a;b}]}
∞

=SML
declare_type_abbrev("UPPMS", ["'s", "'v"], î('s, 'v) PPMS ∏ TAÆ);
=TEX

πHOLCONST
‹ €wtfof›: ('s, 'v)UPPMS ≠ BOOL
˜¸¸¸¸¸¸
‹ µtppms∑ wffof ppms ta §
‹	µptppms∑ (µs1 s2 p1 p2 ta1 ta2 ta3∑
‹		ptppms (s1 çâp s2, s1 çâta s2)
‹		± ptppms (s1 =âp s2, s1 =âta s2)
‹		± 
‹		(ptppms (p1, ta1) ± ptppms (p2, ta2)
‹		¥ ptppms (≥âp p1, ta1)
‹		± ptppms (∂âp s1 p1, ∂âta s1 ta1)
‹		± (ta3 = ta1 ±âta ta2 ± WfTa ta3 ¥ ptppms (p1 ±âp p2, ta3))
‹		))
‹	¥ ptppms tppms
∞



%%%%
%%%%
{\let\Section\section
\def\section#1{\Section{#1}\label{TheoryListing}}
\include{membership.th}
}  %\let

\twocolumn[\section{INDEX}\label{INDEX}]
{\small\printindex}

\end{document}
=SML
output_theory{theory="membership", out_file="membership.th.doc"};
=IGN