=IGN
$Id: t004.doc,v 1.10 2006/10/15 20:39:25 rbj01 Exp $
open_theory "membership";
set_merge_pcs ["hol1", "'savedthm_cs_¶_proof"];
=TEX
\documentclass[11pt,a4paper]{article}
\usepackage{latexsym}
\usepackage{ProofPower}
\ftlinepenalty=9999
\tabstop=0.25in
\usepackage{A4}
\def\N{\mathbb{N}}
\def\D{\mathbb{D}}
\def\B{\mathbb{B}}
\def\R{\mathbb{R}}
\def\Z{\mathbb{Z}}
\def\Q{\mathbb{Q}}

\newcommand{\ignore}[1]{}
\def\Hide#1{\relax}
\def\pindex#1{#1\index{#1}}

\title{Membership Structures}
\author{Roger Bishop Jones}
\date{$ $Date: 2006/10/15 20:39:25 $ $}
\vfill

\makeindex
\usepackage[pdftex]{hyperref}

\begin{document}
\vfill
\maketitle
\begin{abstract}
A queer way of doing set theory in HOL (together with some queer reasons for doing it that way).
\end{abstract}
\vfill

\begin{centering}

Reference: rbjt004; $ $Revision: 1.10 $ $;

Location: \href{http://www.rbjones.com/rbjpub/pp/doc/t004.pdf}{http://www.rbjones.com/rbjpub/pp/doc/t004.pdf}


\end{centering}

\newpage
\tableofcontents
\newpage
%%%%
%%%%
\subsection*{To Do}
\begin{itemize}

\item

\end{itemize}

{\raggedright
\bibliographystyle{fmu}
\bibliography{rbj,fmu}} %\raggedright

%%%%
%%%%
\section{INTRODUCTION}

This document addresses aspects of what I now call ``the foundations of abstract semantics''.

It is concerned with what can be done formally to progress my understanding of the issues in this area.
It remains unclear whether any of the lines which I am considering has any potential.

A foundation for formal semantics is as I conceive it a language and a logic suitable for giving an abstract semantics to a broad range of other languages, and of enabling formal demonstration of truths which are relative to that semantics {\it analytic} or logically true.
The most obvious such language is that of set theory, so this topic is closely connected with the foundations of mathematics.

Here is an indication of some of the questions which seem to me to be of interest in this area and which it may be possibly to progress by formal methods:

\begin{itemize}

\item The relationship between languages L1 and L2 which obtains when the semantics of L1 is expressible in L2 is of particular interest.
Different such relationships will obtain according to what is held to constitute a semantics (e.g. a truth conditional semantics or a denotational semantics) and according to what counts as expressing a semantics in a language.
For the interesting particularisations of this class of partial orders it is of interest whether there is a universal language (in some class of languages under the relevant order) or class of languages (set theory is the most obvious candidate, and it is not immediately obvious whether it could be said to be universal either as a single or as a family of languages).

\item The question what are the key features of a language which makes it score high in expressiveness is of interest.
It is evident that the ontology of set theory, in particular the kind of entity involved as opposed to the particulars of which entities of that kind exist, is not crucial to expressiveness (other kinds of thing are equally suitable, e.g. functions).
On the other hand, it seems possible that the cardinality of the domain of discourse is important at least for sufficiently rich kinds of semantics.
But size surely cannot be all?

\end{itemize}

It is in fact rather more concerned with philosophy than with the brute technical development, and I don't really expect the formal development to get far enough to be valuable in itself.

The philosophy is concerned with set theory as a foundation for abstract semantics, and with the question how set theory can be made sufficiently definite in its meaning to serve well in that role.

Before starting on membership structures I have included an exploration of well-orderings, which may possibly be moved to a separate document at a later date.

\subsection{Set Theory as a Universal Semantic Foundation System}

Set theory is considered here primarily as a candidate universal foundation for semantics, i.e. as a language in which the abstract semantics of any other language may be given and to which, by such means, logical truth in its broadest sense, may be reduced.

\subsubsection{An Aside on Logical Truth}

Logical truth in its broadest sense I take to be {\it analyticity} which I also closely associate with necessary truth.
Very briefly my rationale in this is as follows.
In the first identification I am simply disinclined to follow the novelty of the twentieth century in using the notion of logical truth in as narrow and arbitrary a manner as has become common.
You may regard this if you like as an terminological eccentricity (which is how I regard modern usage in this matter).
On the relationship between of analyticity with necessity I have more interesting reasons for rejecting the possibility of necessity {\it de re} (which I take to be any necessity which is not {\it de dicto}, necessity de dicto being analyticity).
If we were free to take any account of the semantics of a language, including some otherwise correct but substantively incomplete account, as the basis for defining the notion of analyticity then we could of course easily contrive examples of necessity {\it de re}.
Take for example the content free semantics for a language, which tells us nothing about which sentences are true or false, and relative to the notion of analyticity (or necessity {\it de dicto}) which flows from that account all necessity is {\it de re}.
This is of course absurd.
To make a judgement about kinds of necessity one must of course judge necessity {\it de dicto} against a semantics which is complete, at least in its account of the truth conditions for a language.
A necessary proposition must however be true {\it under all conditions}.
Any complete account of the truth conditions of the relevant language must of course tell us whenever a statement is unconditionally true.
If any statement is judged necessary {\it de re} it must be that the denial of its being necessary {\it de re} is based upon an incomplete account of the truth conditions of the language.

There is however one distinction which I would draw between analyticity and necessity.
If we think of analyticity as truth in virtue of meaning, and think of propositions as the meanings of indicative sentences, then it is only sentences which can be analytic, which they are if they express a necessary proposition.

All this is far too much on this topic for this context.

\subsection{Set Theory Generalised}

The kind of ``generalisation'' which I have in mind here is {\it without reference to any specific axiomatisation}.
The idea is to consider not so much the consequences and the models of particular axiom systems, but rather to consider particular models and the question what properties they posess, and also the properties themselves (including properties which are not expressible in first order logic).

Thus, the interest is not so much in sets as they appear in some theory, but on membership structures and their properties, and how to construct membership structures meeting various desiderata.

\subsubsection{More Objectives}

I have so far poorly stated my objectives, so I will try harder here.

The idea of a semantic approach to set theory as universal semantic foundation system suggests to me that a relationship of interpretability is important.
This not the usual rather syntactic notion of interpretability as a relation between theories.
The differences I perceive are as follows:

\begin{itemize}

\item firstly, the required notion is not interpretability of theoremhood, which gives us an ordering in terms of proof theoretic strength, but of truth.
The interpretation must be truth preserving, not derivability preserving.

\item secondly, there is an interest in interpretations which not only respect truth, but which respect {\it meaning}.
One may for example complain of an interpretation of set theory in arithmetic, that even if it preserves truth it cannot preserve meaning, since it is of the essence of the meaning of set theory that it is concerned with collections of very large size, and that any interpretation in which all collections are countable (even if there is a paucity of demonstrable bijections to provide evidence of this) cannot be faithful to the meaning of set theory.

\item thirdly, all this talk of set {\it theory} is too syntactic, and wherever possible I am looking to eliminate sytactic in favour of semantics concepts.
How to do this remains to be seen, it may be appropriate to consider a language as some collection of properties of membership (or other) structures, and an interpretation as a mapping from properties over one kind of structure to properties of some other kind of structure.
\end{itemize}

This last point suggests, as is indeed the case, that I am not exclusively concerned with membership structures, though this particular document may remain dedicated to them.
I am interested in methods for transforming one foundational ontology into another, for example.

\section{MEMBERSHIP STRUCTURES}

Create new theory ``membership''.

=SML
set_flag("pp_use_alias", true);
open_theory "rbjmisc";
force_new_theory "ÛmembershipÝ";
new_parent "ordered_sets";
new_parent "bin_rel";
set_merge_pcs["hol1", "'ú", "'savedthm_cs_¶_proof"];
open RbjTactics1;
=IGN
open_theory "membership";
set_merge_pcs["hol1", "'ú", "'savedthm_cs_¶_proof"];
=TEX

The following types are used:
\begin{itemize}
\item[MS] membership structure
\item[PMS] property of membership structure
\end{itemize}

A membership structure is a set together with a binary relation over that set.
This constitutes an interpretation of the language of first order set theory, though not necessarily a model for any particular axiomatisation of set theory such as ZFC.

We are interested in properties of membership structures.
We are not exclusively interested in any particular kinds of properties, but we will introduce various classifications of these properties, the first of which will be those which are captured by sentences of first order set theory.

=SML
declare_type_abbrev ("ÛMSÝ", ["'a"], 'a SET ¸ ('a ­ 'a ­ BOOL)®);
declare_type_abbrev ("ÛPMSÝ", ["'a"], 'a MS ­ BOOL®);
=TEX
=SML
declare_infix (305, "ÛrÝ");
=TEX

The interest in first order properties is rather subsidiary, the real point of this approach to set theory is to escape from being constrained to first order properties.
There is some interest in showing why this is a good thing, and the notion of first order property is defined primarily in order to be able to show that interesting properties of membership structures often are not first order.

I don't know whether that will prove feasible, its not so hard to prove that properties are first order, but it will probably be a lot harder to prove that properties are not.
The most obvious example of a property which is not first order is well-foundedness.
The obvious way to prove that well-foundedness is not first order is to prove that if it were we would could get from first order set theory a complete arithmetic.
This route however presupposes a proof of the incompleteness of arithmetic, which is not so easy.

\section{BASIC PROPERTIES OF MEMBERSHIP RELATIONS}

The term ``membership relation'' is use purely to indicate motivation, this is not a non trivial subclass of binary relationships.

The following are key properties which yield our broadest classification of membersip relations:

\begin{enumerate}
\item extensionality
\item purity
\item well-foundedness
\end{enumerate}

\subsection{Extensionality}

None of these properties is essential for a membership relation.
The one which is perhaps most conspiciously characteristic of set membership is extensionality, but constructive set theories are likely not to be extensional, and set theories with urelements may have a qualified extensionality (as in NFU).

A set theory is ``pure'' if everything in the domain of discourse is a set.
This is connected with extensionality, since non-sets have no members and are therefore extensionally the same as the empty set (except for Quine atoms which are their own unit set, and permit something like urelements in a fully extensional theory).

We are concerned here only with relations whose type is some instance of $'a ­ 'a ­ BOOL®$ and so there is only one type of entity in the domain of discourse, and so in some sense everything is a set.
However, if extensionality is weakened there may be any number of sets which have no members, and we may think of the extra ones as urelements.
If well-foundedness is absent or qualified then Quine's trick of treating urlements as their own unit set allows full extensionality to be retained in a system in which some things are not thought of as sets.

¹HOLCONST
Ü ÛextensionalÝ: 'a PMS
÷üüüüüü
Ü µ (X, $r)· extensional (X, $r) ¤ µs t· s  X ± t  X ´
Ü	(s = t ¤ (µ u· u  X ´ (u r s ¤ u r t)))
°

The following weakend extensionality is satisfied by models of NFU:

¹HOLCONST
Ü Ûweakly_extensionalÝ: 'a PMS
÷üüüüüü
Ü µ (X, $r)· weakly_extensional (X, $r) ¤ µs t·
Ü	s  X ± t  X ± (¶v· v  X ± v r s) ´
Ü	(s = t ¤ (µ u· u  X ´ (u r s ¤ u r t)))
°

\ignore{
=SML
val extensional_def = get_spec ¬extensional®;
set_goal([], ¬µ ms:'a MS· extensional ms ¤ µs t:'a· s  Fst ms ± t  Fst ms ´
	(s = t ¤ µ u:'a· u  Fst ms ´ (Snd ms u s ¤ Snd ms u t))®);
a (strip_tac THEN once_rewrite_tac [prove_rule [] ¬ms = (Fst ms, Snd ms)®]
	THEN rewrite_tac[extensional_def]
	THEN REPEAT strip_tac
	THEN TRY (all_asm_fc_tac[]));
val extensional_thm = save_pop_thm "extensional_thm";
=TEX
}%ignore

Any membership relation can be collapsed into one which is extensional, though in the worst case it might be trivial, by forming equivalence classes and redefining the relationship over those classes.

We obtain the new membership structure by taking the domain to be equivalence classes of members under some equivalence relation and then defining a new membership operation over those classes as follows:

It is convenient to use the theory {\it equiv\_rel} in which equivalences are curried binary relations rather than  sets of ordered pairs (as in theory {\it bin\_rel}).
We need to take an intersection of a collection of such relations so this is defined first.

¹HOLCONST
Ü Û±rÝ: ('a ­ 'a ­ BOOL) SET ­ ('a ­ 'a ­ BOOL)
÷üüüüüü
Ü µ sr· ±r sr = Ìx y· µz· z  sr ´ z x y
°


Then {\it ExtQuot} gives the set of sets of elements which must be identified to give an extensional relationship. 

¹HOLCONST
Ü ÛExtQuotÝ: 'a MS ­ 'a SET SET
÷üüüüüü
Ü µ (X, $r)· ExtQuot (X, $r) =
Ü	QuotientSet X (±r {r : 'a ­ 'a ­ BOOL
Ü	   |  Equiv (X, r)
Ü	      ± µx y· x  X ± y  X ± ((µz· z r x ¤ z r y)
Ü		´ r x y)})
°

Finally we define the relationship:

¹HOLCONST
Ü ÛExtRelÝ: 'a MS ­ 'a SET MS 
÷üüüüüü
Ü µ (X, $r)· ExtRel (X, $r) =
Ü	let Y = ExtQuot (X, $r)
	in (Y, Ìl r· ¶u v· u  l ± v  r ± u r v)
°

\subsection{Well-Foundedness}

The definition of well-foundedness used here is the concept {\it WellFounded} from the theory ``ordered\_sets''.

Set theories whose intuition is based in the cumulative or iterative heirarchy are both extensional and well-founded, and I will be concerned for the time being with just these kinds of membersbip relation.
These two properties can be thought of as telling us what kind of thing a set is, and the rest of the axioms in a systems like ZFC, possibly with large cardinal axioms, are trying to maximise the how many of the things with these properties can be shown to be in the domain of discourse.

This explanation connects with the usual description of the cumulative heirarchy, in which the formation of the domain of discourse of set theory is presented as occurring in stages.
At each stage one adds to the cumulative hierarchy all the sets which can be formed from those already obtained (the first ``all'') and then we are to understand that one goes through as many stages as one possibly can (the second ``all''), thereby aggregating all the pure well-founded collections.
Unfortunately, if one ever could complete this process the result would be a well-founded collection which would not contain itself, and so we must suppose that the construction cannot be completed.

My present interest is therefore, at present, in considering how to formalise the description of larger and larger parts of this incompletable construction.

The decomposition of the ``all'' in the intuitive concept suggests that the formalisation may be able to treat these two ``all''s separately.
The idea is that we can say that at each stage all possible new subsets are created, and then consider how to say that the number of stages is very large, separating questions of width and height.
A clean separation turns out not to be possible in a first order axiomatisation, but in the present context, i.e. in a higher order logic construed under the standard semantics, it is possible (though perhaps more by theft than honest toil, the relevant notion of ``all'' being readily expressed under the standard semantics).

However, there are some preliminaries which seem to be necessary to adeqately address either ``all''.
To get ``full-width'' we want to say that at each stage all the subsets of the previous stage become sets.
For this we need to be able to talk about the stages.

\subsection{Ordinals and Cardinals}

[This is a mess!]

The reason for treating ordinals here is as follows.
One of the important properties of structures is their height.
Strong set theories are those with large cardinal axioms, which appear to be ensisting on the existence of very large sets, but which as is well know, do not succeed in their objective.
Set theories with large cardinal axioms still have countable models.
This is because {\it true} large cardinal properties are not expressible in first order logic, they are not first order properties of membership structures (as defined below).
This should be easy to prove.
So that we can talk about models which really do have large sets in them we need to define large cardinal {\it properties} as distinct from large cardinal axioms.
It is desirable to do this independently of any particular axiomatisation of set theory.
In our present context we could treat cardinals as equivalence classes of equipollent collections, but I propose nonetheless to follow more closely their treatment in well-founded set theories by taking them to be {\it alephs}, those ordinals which are larger than all their predecessors.

The stages can be ordered using ordinals, and so first we need a concept of ordinal number.
We can think of ordinals in terms of width, for the ordinals are among the membership relations of least width (which are those in which only one new set is introduced at each stage).

There are two kinds of (representation or realisation of) ordinals of interest here.
The first kind of ordinal is an element in the domain of a membership relation.
The second is a membership relation of which the domain as a whole is an ordinal (and may be thought of as the class of ordinals in its domain).

Throughout the treatment of ordinals and cardinals adopted here we want to talk both about relations as being ordinals and about elements in the domain of relations as being ordinals.
These notions are connected in obvious ways.
An element is an ordinal element iff the restriction of the membership relation in whose domain it appears to the members of that relation is an ordinal relation, and these two entities may be thought of as representing the same ordinal.

Postfix subscripts are used to distinguish properties of ordinal relations from the corresponding property of ordinal elements.

¹HOLCONST
Ü Ûordinal_relationÝ: 'a MS ­ 'a ­ 'a MS
÷üüüüüü
Ü µ (X, $r):'a MS; a:'a· ordinal_relation (X, $r) a = ({x:'a | x r a} ¡ X, $r)
°

A {\it relation} is ``ordinal'' iff it is a transitive strict well-ordering.
The concept of {\it WellOrdering} in $ordered\_sets$ does not require strictness so we define an ordinal using $WellFounded$ (which does require strictness) and $LinearOrder$.

¹HOLCONST
Ü ÛordinalÝ: 'a PMS
÷üüüüüü
Ü µ mr· ordinal mr ¤ LinearOrder mr ± Trans mr ± WellFounded mr
°

We now introduce the idea that a membership relation is in the domain of some other membership domain, which may be thought of as asserting that the class of sets under one membership relation is a set in the domain of the other.

¹HOLCONST
Ü Ûordinal_setÝ: 'a MS ­ 'a ­ BOOL
÷üüüüüü
Ü µ mr s· ordinal_set mr s ¤ ordinal (ordinal_relation mr s)
°

=SML
declare_infix (305, "a");
declare_infix (305, "b");
=TEX

¹HOLCONST
Ü ÛhomomorphÝ: ('a MS ¸ ('b MS)) ­ ('a ­ 'b) ­ BOOL
÷üüüüüü
Ü µ (X, $a):'a MS; (Y, $b):'b MS; f:'a ­ 'b·
Ü	homomorph ((X, $a), (Y, $b)) f ¤  µs t:'a· s a t ´ (f s) b (f t)
°

¹HOLCONST
Ü ÛembeddingÝ: ('a MS ¸ 'b MS) ­ ('a ­ 'b) ­ BOOL
÷üüüüüü
Ü µ msa msb f· embedding (msa, msb) f ¤ 
Ü	homomorph (msa, msb) f ± OneOne f
°

=SML
declare_infix (310, "òm");
=TEX

¹HOLCONST
Ü $ÛòmÝ: ('a ­ BOOL) ­ 'a MS ­ 'a MS
÷üüüüüü
Ü µ P (X, $a) · P òm (X, $a) = (X ¡ {x | P x}, $a)
°

Membership structures need not be extensional. and so there may not be a unique set with no elements.
It is convenient to be able to talk about the empty things.

¹HOLCONST
Ü $Ûms_Ý: 'a MS ­ 'a ­ BOOL
÷üüüüüü
Ü µ (X, $a) s· ms_ (X, $a) s
Ü	¤ s  X ± µz· z  X ´ ³ z a s 
°

\subsection{WK Ordered Pairs}

The following relation tells us when something in the domain of a relationship structure is an ordered pair.

¹HOLCONST
Ü $Ûms_pairÝ: 'a MS ­ ('a ¸ 'a) ­ 'a ­ BOOL
÷üüüüüü
Ü µ (X, $a) (l,r) p· ms_pair (X, $a) (l,r) p
Ü	¤ p  X ± µz· z  X ´ (z a p ¤ z = l ² z = r)
°

¹HOLCONST
Ü $Ûms_unitÝ: 'a MS ­ 'a ­ 'a ­ BOOL
÷üüüüüü
Ü µ ms s u· ms_unit ms s u
Ü	¤ ms_pair ms (s,s) u
°

¹HOLCONST
Ü $Ûms_wkpÝ: 'a MS ­ ('a ¸ 'a) ­ 'a ­ BOOL
÷üüüüüü
Ü µ ms (l,r) p· ms_wkp ms (l,r) p
Ü	¤ ¶s t:'a· ms_unit ms l s ± ms_pair ms (l, r) t ± ms_pair ms (s,t) p  
°

\subsection{Standard Models}

The use of {\it standard} here follows its use in the context of higher order logic, in which a standard model is one in which the power sets are complete.
In set theory this comes down to the idea that the standard models are the {\it V}(Á) for some ordinal Á.

We therefore define the relationship {\it V} between ordinals and standard models of rank Á.
The relationship is defined by transfinite recursion, and we therefore need to use a suitable recursion theorem to establish its consistency.

First of all we will have to defined certain elementary concepts.
The definition informally is:

=GFT
	V Á = Þè{Â < Á}ê ð(V Â)
=TEX

The universe of rank Á is the union of the power sets of the universes of all smaller ranks.

To formalise this we need to get it in the right shape for our recursion theorem, which comes from \cite{rbjt009} and is shown here for information:

=GFT
recursion_theorem =
   ô µ ((X : 'a SET), ($<< : 'a ­ 'a ­ BOOL)) (G : ('a ­ 'b) ­ 'a ­ 'b)·
	FunctRespects G (X, $<<) ± WellFounded (X, $<<)
         ´ UniquePartFixp X G : THM
=TEX


\ignore{
 ¹HOLCONST
Ü ÛVÝ: 'a MS ­ 'b MS ­ BOOL
 ÷üüüüüü
Ü µ (X, $a) (Y, $b) · Ordinal (X, $a) ± 
 °
}%ignore
\section{FIRST ORDER PROPERTIES}

In order to define the notion of a ``first order property'' we need to mimic the satisfaction relation.
Sentences define sets of interpretations, but formulae only do so in the context of an assignment to the free variables in the formula.
The operators we define therefore operate over parameterised properties of interpretations.

It proves desirable to make this theory polymorphic not only in the type of the sets involved, but also in the notion of variable (sometimes we may wish to work with assignments to terms).
An assignment to free variables is modelled as a function from objects of type 'v® (a type variable) to elements in the domain of the relation (here 's®).

=SML
declare_type_abbrev ("ÛVAÝ", ["'s", "'v"], 'v ­ 's®);
=TEX

¹HOLLABPROD ÛPPMSÝüüüüü
Ü ppms : ('s, 'v) VA ­ 's PMS
°üüüüüüüüüüüüüü

Various operators over properties of membership relations are now defined.

The language of set theory which we consider has the following simplifying characteristics:

\begin{enumerate}
\item the only terms are variables
\item the relations are equality and membership
\item the propositional connectives are conjunction and negation
\item there is just one, existential, quantifier
\end{enumerate}

Membership statements are parameterised by the names of the two variables between which membership is predicated, and the parameterised property of membership relations which they denote is:

=SML
declare_infix (305, "p");
=TEX

¹HOLCONST
Ü $ÛpÝ: 'v ­ 'v ­ ('s, 'v) PPMS
÷üüüüüü
Ü µ s t:'v· (s p t) = MkPPMS (Ìva: ('s, 'v) VA; (X, $r):'s MS·
Ü	(va s) r (va t))
°

Equality is defined similarly.

=SML
declare_infix (305, "=p");
=TEX

¹HOLCONST
Ü $Û=pÝ: 'v ­ 'v ­ ('s, 'v) PPMS
÷üüüüüü
Ü µ s t:'v· s =p t = MkPPMS(Ì va:('s, 'v) VA; (X, $r): 's MS·
Ü	(va s) = (va t))
°

Conjunction denotes a binary operation over PPMS's.

=SML
declare_infix (302, "±p");
=TEX

¹HOLCONST
Ü $Û±pÝ: ('s, 'v) PPMS ­ ('s, 'v) PPMS ­ ('s, 'v) PPMS
÷üüüüüü
Ü µ l r· l ±p r = MkPPMS(Ìva (X, $r)· (ppms l va (X, $r)) ± (ppms r va (X, $r)))
°

Negation denotes a monadic operator.

¹HOLCONST
Ü Û³pÝ: ('s, 'v) PPMS ­ ('s, 'v) PPMS
÷üüüüüü
Ü µ f· ³p f = MkPPMS(Ìva (X, $r)· ³ (ppms f va (X, $r)))
°

The existential quantifier binds a variable and its value depends upon assigning values to that variable in a variable assignment.
The following function modifies a variable assignment.

¹HOLCONST
Ü ÛassignÝ:  's ­ 'v ­ ('s, 'v) VA ­ ('s, 'v) VA
÷üüüüüü
Ü µ a s va t · assign a s va t = if t = s then a else va t
°

Finally the existential quantifier, which is parameterised by the name of the variable it binds and the value of the formula it quantifies over.

¹HOLCONST
Ü Û¶pÝ: 'v ­ ('s, 'v) PPMS ­ ('s, 'v) PPMS
÷üüüüüü
Ü µ s f· ¶p s f = MkPPMS(Ìva (X, $r)· ¶a· a  X ± ppms f (assign a s va) (X, $r))
°

\ignore{
=SML
val PPMS_def = get_spec ¬MkPPMS®;
val eqp_def = get_spec ¬$=p®;
val eqp_def = get_spec ¬$=p®;
val p_def = get_spec ¬$p®;
val ³p_def = get_spec ¬³p®;
val ±p_def = get_spec ¬$±p®;
val assign_def = get_spec ¬assign®;
val ¶p_def = get_spec ¬¶p®;
=TEX
}%ignore

Next we define the set of parameterised properties which can be constructed by these operators and then take their closures to eliminate the parameters.

¹HOLCONST
Ü ÛfofÝ: ('s, 'v) PPMS ­ BOOL
÷üüüüüü
Ü µppms1· fof ppms1 ¤
Ü	µpppms· (µs1 s2 p1 p2 ·
Ü		pppms (s1 p s2)
Ü		± pppms (s1 =p s2)
Ü		± (pppms p1 ± pppms p2
Ü			´ pppms (p1 ±p p2)
Ü			± pppms (³p p1)
Ü			± pppms (¶p s1 p1))
Ü		)
Ü		´ pppms ppms1
°

Finally we define the property of properties of membership structures which consists in being definable by a set of sentences of first order set theory.

First we define the closure of a first order formula.
Note that this function serves to convert a paramaterised property of membership structures into a plain property of membership structures, and this is its primary purpose.
The fact that it also effectively undertakes a universal closure is a side effect (though this will simplify some demonstrations), since it is primarily intended for application to closed formulae.

An awkwardness arises here in dealing with the possibility of empty structures.
An interpretation of a first order language must be non-empty, but for present purposes it is convenient for the notion of a first order property of structures to take into account the possibility of empty structures.

¹HOLCONST
Ü ÛfocÝ: ('s, 'v) PPMS ­ 's PMS
÷üüüüüü
Ü µppms1 (X, $m)· foc ppms1 (X, $m) ¤
Ü	µva· X = {} ² (µv· va v  X)
Ü		´ ppms ppms1 va (X, $m)
°

The concept of first order sentence, as here presented using semantic rather than syntactic entities, is in fact the property of being a property of membership structures which can be expressed by a sentence in the language of first order set theory.
The name {\it fop} for {\it first order property} is therefore chosen rather than {\it fos} for {\it first order sentence}.

This property is independent of the type of variables, but is defined in terms of entities which are polymorphic in the type of variables.
For the definition to be conservative we have to parameterise it with a variable, which is ignored.
In applications this definition can be instantiated to the application type to yield a property.

¹HOLCONST
Ü ÛfopÝ: 'v ­ 's PMS ­ BOOL
÷üüüüüü
Ü µpmr v· fop v pmr ¤ ¶f: ('s, 'v) PPMS· fof f ± pmr = foc f
°

For convenience the following derived constructors are defined:

=SML
declare_infix (298, "²p");
declare_infix (295, "´p");
declare_infix (290, "¤p");
=TEX

¹HOLCONST
Ü $Û²pÝ : ('s, 'v) PPMS ­ ('s, 'v) PPMS ­ ('s, 'v) PPMS
÷üüüüüü
Ü  µl r· l ²p r = ³p (³p l ±p ³p r)
°

¹HOLCONST
Ü $Û´pÝ : ('s, 'v) PPMS ­ ('s, 'v) PPMS ­ ('s, 'v) PPMS
÷üüüüüü
Ü  µl r· l ´p r = r ²p ³p l
°

¹HOLCONST
Ü $Û¤pÝ : ('s, 'v) PPMS ­ ('s, 'v) PPMS ­ ('s, 'v) PPMS
÷üüüüüü
Ü  µl r· l ¤p r = (l ´p r) ±p (r ´p l)
°

¹HOLCONST
Ü ÛµpÝ: 'v ­ ('s, 'v) PPMS ­ ('s, 'v) PPMS
÷üüüüüü
Ü µ s p · µp s p = ³p (¶p s (³p p))
°

\ignore{
=SML
val fof_def = get_spec ¬fof®;
val foc_def = get_spec ¬foc®;
val fop_def = get_spec ¬fop®;
val ²p_def = get_spec ¬$²p®;
val ´p_def = get_spec ¬$´p®;
val ¤p_def = get_spec ¬$¤p®;
val µp_def = get_spec ¬µp®;
=TEX

=SML
set_goal([], ¬µppms1 ms· foc ppms1 ms ¤ µva· Fst ms = {} ² (µv· va v  Fst ms) ´ ppms ppms1 va ms®);
a (once_rewrite_tac [prove_rule [] ¬ms = (Fst ms, Snd ms)®]
	THEN rewrite_tac [foc_def]);
val foc_thm = save_pop_thm "foc_thm";
=TEX

=SML
set_goal([], ¬µs1 s2: 'v ·
	  fof (s1 =p s2)
	± fof (s1 p s2)®);
a (REPEAT strip_tac THEN TRY (rewrite_tac [fof_def]
	THEN REPEAT strip_tac
	THEN all_fc_tac [fof_def]
	THEN asm_rewrite_tac[]));
val fof_base_clauses = save_pop_thm "fof_base_clauses";
=TEX
=SML
set_goal([], ¬µs s1; p1 p2: ('s, 'v) PPMS ·
	  (fof p1 ´ fof (³p p1)
		± fof (¶p s p1)
		± fof (µp s p1))
	 ± (fof p1 ± fof p2 ´
		  fof (p1 ±p p2)
		± fof (p1 ²p p2)
		± fof (p1 ´p p2)
		± fof (p1 ¤p p2))®);
a (REPEAT strip_tac THEN TRY (rewrite_tac
	[fof_def, ²p_def, ´p_def, ¤p_def, µp_def]
	THEN REPEAT strip_tac
	THEN all_fc_tac [fof_def]));
(* *** Goal "1" *** *)
a (REPEAT (all_asm_fc_tac[]));
(* *** Goal "2" *** *)
a (list_spec_nth_asm_tac 2 [¬s®, ¬s®, ¬p1®, ¬p1®]);
(* *** Goal "3" *** *)
a (lemma_tac ¬pppms (³p p1)® 
	THEN1 list_spec_nth_asm_tac 2 [¬s®, ¬s®, ¬p1®, ¬p1®]);
a (lemma_tac ¬pppms (¶p s (³p p1))® 
	THEN1 list_spec_nth_asm_tac 3 [¬s®, ¬s®, ¬³p p1®, ¬p1®]);
a (REPEAT (all_asm_fc_tac[]));
(* *** Goal "4" *** *)
a (REPEAT (all_asm_fc_tac[]));
(* *** Goal "5" *** *)
a (lemma_tac ¬pppms (³p p1) ± pppms (³p p2)®
	THEN1 (strip_tac THEN REPEAT (all_asm_fc_tac[])));
a (lemma_tac ¬pppms (³p p1 ±p ³p p2)®
	THEN1 (REPEAT (all_asm_fc_tac[])));
a (REPEAT (all_asm_fc_tac[]));
(* *** Goal "6" *** *)
a (lemma_tac ¬pppms (³p p1) ± pppms (³p p2)®
	THEN1 (strip_tac THEN REPEAT (all_asm_fc_tac[])));
a (lemma_tac ¬pppms (³p (³p p1))®
	THEN1 (REPEAT (all_asm_fc_tac[])));
a (list_spec_nth_asm_tac 6 [¬Åx:'v·T®, ¬Åx:'v·T®, ¬³p p2®, ¬³p (³p p1)®]);
a (list_spec_nth_asm_tac 11 [¬Åx:'v·T®, ¬Åx:'v·T®, ¬(³p p2) ±p (³p (³p p1))®, ¬³p p2®]);
(* *** Goal "7" *** *)
a (lemma_tac ¬pppms (³p p1) ± pppms (³p p2)®
	THEN1 (strip_tac THEN REPEAT (all_asm_fc_tac[])));
a (lemma_tac ¬pppms (³p (³p p1)) ± pppms (³p (³p p2))®
	THEN1 (strip_tac THEN REPEAT (all_asm_fc_tac[])));
a (lemma_tac ¬pppms (³p p2 ±p ³p (³p p1))® 
	THEN1 list_spec_nth_asm_tac 7 [¬Åx:'v·T®, ¬Åx:'v·T®, ¬³p p2®, ¬³p (³p p1)®]);
a (lemma_tac ¬pppms (³p p1 ±p ³p (³p p2))® 
	THEN1 list_spec_nth_asm_tac 8 [¬Åx:'v·T®, ¬Åx:'v·T®, ¬³p p1®, ¬³p (³p p2)®]);
a (lemma_tac ¬pppms (³p (³p p2 ±p ³p (³p p1)))® 
	THEN1 list_spec_nth_asm_tac 9 [¬Åx:'v·T®, ¬Åx:'v·T®, ¬³p p2 ±p ³p (³p p1)®, ¬³p p2®]);
a (lemma_tac ¬pppms (³p (³p p1 ±p ³p (³p p2)))® 
	THEN1 list_spec_nth_asm_tac 10 [¬Åx:'v·T®, ¬Åx:'v·T®, ¬³p p1 ±p ³p (³p p2)®, ¬³p p2®]);
a (list_spec_nth_asm_tac 11 [¬Åx:'v·T®, ¬Åx:'v·T®, ¬³p (³p p2 ±p ³p (³p p1))®,
	¬³p (³p p1 ±p ³p (³p p2))®]);
val fof_step_clauses = save_pop_thm "fof_step_clauses";
=TEX

=SML
set_goal ([], ¬fof (µp "x" (µp "y" ("x" =p "y" ¤p µp "z" ("z" p "x" ¤p "z" p "y"))))®);
a (abc_tac [fof_step_clauses, fof_base_clauses]);
val fof_extensionality_lemma1 = pop_thm ();
=TEX

=SML
set_goal ([], ¬fof (µp "x" (µp "y" ( µp "z" ("z" p "x" ¤p "z" p "y") ´p "x" =p "y")))®);
a (REPEAT (CHANGED_T (bc_tac (abc_canon fof_step_clauses)))
	THEN rewrite_tac [fof_base_clauses]);
val fof_extensionality_lemma1b = pop_thm ();
=TEX

=SML
set_goal ([], ¬fop "" (foc(µp "x" (µp "y" ("x" =p "y" ¤p µp "z" ("z" p "x" ¤p "z" p "y")))))®);
a (rewrite_tac [fop_def, foc_def]);
a (¶_tac ¬(µp "x" (µp "y" ("x" =p "y" ¤p µp "z" ("z" p "x" ¤p "z" p "y"))))®
	THEN rewrite_tac [fof_extensionality_lemma1]);
val fof_extensionality_lemma2 = pop_thm ();
=TEX

=SML
set_goal ([], ¬fop "" (foc(µp "x" (µp "y" (µp "z" ("z" p "x" ¤p "z" p "y") ´p "x" =p "y"))))®);
a (rewrite_tac [fop_def, foc_def]);
a (¶_tac ¬µp "x" (µp "y" ( µp "z" ("z" p "x" ¤p "z" p "y") ´p "x" =p "y"))®
	THEN rewrite_tac [fof_extensionality_lemma1b]);
val fof_extensionality_lemma2b = pop_thm ();
=TEX

=SML
set_goal([], ¬fop "" extensional®);
a (rewrite_tac [fop_def]);
a (¶_tac ¬µp "x" (µp "y" ( µp "z" ("z" p "x" ¤p "z" p "y") ´p "x" =p "y"))®
	THEN rewrite_tac [fof_extensionality_lemma1b]);
a (rewrite_tac[extensional_thm, foc_thm, eqp_def, ¶p_def, ³p_def,
	±p_def, ²p_def, µp_def, ´p_def, ¤p_def, p_def, PPMS_def,
	assign_def]);
a (REPEAT strip_tac
	THEN TRY all_var_elim_asm_tac
	THEN TRY (list_spec_nth_asm_tac 5 [¬a®, ¬a'®]
		THEN (list_spec_nth_asm_tac 4 [¬u®])));
a (list_spec_nth_asm_tac 4 [¬Ìv:STRING· Åy· y  Fst x®]);
(* *** Goal "1" *** *)
a (swap_nth_asm_concl_tac 1
	THEN Å_tac ¬Å y· y  Fst x®
	THEN1 (¶_tac ¬x'® THEN asm_rewrite_tac[]));
a (asm_rewrite_tac []);
(* *** Goal "2" *** *)
a (spec_nth_asm_tac 1 ¬s®);
a (spec_nth_asm_tac 1 ¬t®);
(* *** Goal "2.1" *** *)
a (all_asm_fc_tac []);
(* *** Goal "2.2" *** *)
a (spec_nth_asm_tac 6 ¬a''®);
val fop_extensional_thm = save_pop_thm "fop_extensional_thm";
=TEX

}%ignore

\subsection{Stratified Properties}

Some set theories, notably Quine's NF and NFU, are defined using \pindex{stratified\ comprehension} rather than the more usual {\it separation}.
Stratification is a syntactic constraint on the formulae of set theory which can be used to define a set.
This limited class of formulae defines a subset of the first order properties of membership structures, which we will call stratified first order properties.

The {\it semantics} of formulae is unaffected by this constraint, so in defining a stratified property exactly the same constuctors can be used as for non-stratified formulae.
However, when two properties are combined, there must be a check imposed to establish that the combined property is stratified.
This only happens in conjunction, so only one check need be specified.
The check is that there is a type assignment to the free variables of the formula, and this is best performed using a type assignment to the formulae to be combined.
The type assignments are therefore produced intially for the atomic formulae, and then elaborated by each syntactic construction, with a possibility of failure on conjunction.

\subsubsection{Type Assignment}

This version differs from the previous in the following respects:

\begin{itemize}
\item A type assignment is represented as a set of lists of sets of variable names

\item The specification for a stratified property uses a single type assignment given ab initio rather than building up a type assignement as the property is built from the primitive relations.

\item The type assignment does not take account of bound variables, and this means that some terms in which the same variable is used more than once in quantifiers there may not be a type assignment adequate for these purpose.
In these cases it will be necessary to rename some bound variables before a type assignment becomes available.
Because the type assignment comes top down it must contain information about the types of bound variables, which was not the case in the previous version, and since we have not made provision for scoping such information a proper description of the types may not be possible where the same name is bound more than once.

\end{itemize}


=SML
declare_type_abbrev("ÛTAÝ", ["'v"], (('v SET)LIST)LIST®);
=TEX

In the type assignment each list is a list of sets of type-related variable names.
The members of each set all have the same type, the members of successive sets have successive types.
Separate lists are each independent of each other.
For example the formula ¬x  y ± b  y ± v = w ± w  u® would have the type assignment
=INLINEFT
 ¬[[{x;b};{y}]; [{v;w};{u}]]®.
=TEX
The well-formedness conditions are simply that no name occurs more than once, i.e. that the sets in each list are pairwise disjoint and the unions of the sets in each list are pairwise disjoint.
To test an atomic formula for correctness relative to a type assignment, restrict the assignment to the names in the formula, then you should have, for ¬a  b®, ¬[[\{a\};\{b\}]]® and for a = b, ¬[[\{a;b\}]]® (bearing in mind that order in list displays is signficant but in set displays is not.

To check a formula you need only check each atomic sentence which occurs in it.

Now we formalise this.

¹HOLCONST
Ü ÛListUnionÝ: 'a SET LIST ­ 'a SET
÷üüüüüü
Ü µ ls· ListUnion ls = Fold $À ls {}
°

¹HOLCONST
Ü ÛDisjointÝ: 'a SET LIST ­ BOOL
÷üüüüüü
Ü (Disjoint [] ¤ T)
Ü  ± µ h t· Disjoint (Cons h t) ¤ ((h ¡ (ListUnion t) = {}) ± Disjoint t)
°

¹HOLCONST
Ü ÛSetMapÝ: ('a ­ 'b) ­ 'a SET ­ 'b SET
÷üüüüüü
Ü µ f s· SetMap f s = {x | ¶y· y  s ± x = f y}
°

¹HOLCONST
Ü ÛTaDomÝ: 'v TA ­ 'v SET
÷üüüüüü
Ü µ ta· TaDom ta = ListUnion (Map ListUnion ta)
°

¹HOLCONST
Ü ÛWfTaÝ: 'v TA ­ BOOL
÷üüüüüü
Ü µta· WfTa ta ¤
Ü	µL (Map Disjoint ta)
Ü	± Disjoint (Map ListUnion ta)
°

\ignore{
=SML
set_goal([], ¬ListUnion [] = {} ± µh t· ListUnion (Cons h t) = h À (ListUnion t)®);
a (rewrite_tac (map get_spec [¬ListUnion®, ¬Fold®]));
val ListUnion_thm = save_pop_thm "ListUnion";

set_goal([], ¬µf· SetMap f {} = {} ± µs e· SetMap f (Insert e s) = Insert (f e) (SetMap f s)®);
a (rewrite_tac [get_spec ¬SetMap®]);
a (REPEAT strip_tac);
a (POP_ASM_T ante_tac THEN asm_rewrite_tac[]);
a (¶_tac ¬y® THEN asm_rewrite_tac[]);
a (¶_tac ¬e® THEN asm_rewrite_tac[]);
a (¶_tac ¬y® THEN asm_rewrite_tac[]);
val SetMap_display_thm = save_pop_thm "SetMap_display";

set_goal([], ¬µx s t· (Insert x s) ¡ t = ({x} ¡ t) À (s ¡ t)®);
a (rewrite_tac[] THEN REPEAT strip_tac);
val Disp_¡_thm = save_pop_thm "Disp_¡_thm";

set_goal([], ¬µx y v w· {x} ¡ Insert x y = {x}
	± Insert x y ¡ Insert x w = {x} À (y ¡ w)®);
a (rewrite_tac[] THEN REPEAT strip_tac);
val Disp_¡_thm2 = save_pop_thm "Disp_¡_thm2";
=IGN
here;

set_merge_pcs["hol1", "'ú", "'savedthm_cs_¶_proof"];
set_merge_pcs["hol", "'ú", "'savedthm_cs_¶_proof"];
set_goal([],¬WfTa {[{"x";"b"};{"y"}]; [{"v";"w"};{"u"}]}®);
a (rewrite_tac [get_spec ¬WfTa®, SetMap_display_thm, ListUnion_thm,
	get_spec ¬Disjoint®]);
set_goal([], ¬{"1";"2"} ¡ {"2"} = {"2"}®);
a (prove_tac[]);

=TEX
}%ignore

=GFT
ListUnion_thm =
   ô ListUnion [] = {} ± (µ h t· ListUnion (Cons h t) = h À ListUnion t)
=TEX

=SML
declare_infix (310, "òta");
=TEX

¹HOLCONST
Ü $ÛòtaÝ: 'v SET ­ 'v TA ­ 'v TA
÷üüüüüü
Ü µ vs ta· vs òta ta = Map (Ìl· Map ($¡ vs) l) ta
°

We do not need functions to construct these type assignments, we need only to be able to check properties against them.
In fact we only need to check the atomic propositions.

¹HOLCONST
Ü ÛCheck_eqÝ: 'v TA ­ 'v ­ 'v ­ BOOL
÷üüüüüü
Ü µ ta a b· Check_eq ta a b ¤ {a; b} òta ta = [[{a;b}]]
°

¹HOLCONST
Ü ÛCheck_Ý: 'v TA ­ 'v ­ 'v ­ BOOL
÷üüüüüü
Ü µ ta a b· Check_ ta a b ¤ {a; b} òta ta = [[{a};{b}]]
°

¹HOLCONST
Ü ÛwtfofÝ: 'v TA ­ ('s, 'v)PPMS ­ BOOL
÷üüüüüü
Ü µppms1 ta· wtfof ta ppms1 ¤
Ü	µpppms· (µs1 s2 p1 p2·
Ü		  (Check_ ta s1 s2 ´ pppms (s1 p s2))
Ü		± (Check_eq ta s1 s2 ´ pppms (s1 =p s2))
Ü		± (pppms p1 ± pppms p2
Ü			´ pppms (³p p1)
Ü			± pppms (¶p s1 p1)
Ü			± pppms (p1 ±p p2))
Ü		)
Ü		´ pppms ppms1
°

We are now in a position to define the notion of a stratified first order property.

¹HOLCONST
Ü ÛStratPropÝ: ('s, 'v)PPMS ­ BOOL
÷üüüüüü
Ü µppms1· StratProp ppms1 ¤ ¶ta· WfTa ta ± wtfof ta ppms1
°

My interest in stratified first order properties differs from that in arbitrary first order properties.
My interest is in their use in determining the extension of sets and thence in properties of stratified abstraction for non-well founded set theories (such as NF and NFU).

There are two ways in which I propose to apply the concepts.
The primary consideration so far as this document is concerned is in formalising the property of membership which consists in closure under stratified abstraction.
However, I also want to export to another document in which I am exploring the formalisations of NF and NFU a property suitable for use in expressing an axiom of stratified abstraction.

Lets look first at the first of these and then consider how the second requirement can be satisfied.

To realise the first we need to abstract over a variables (which may or may not actually have free occurrences in the formula corresponding to the property at hand).
This of course is a set abstraction i.e. a comprehension.
It should convert a parameterised property of membership systems to another property which is true of those membership systems in which there exists a set with an appropriate extension.

¹HOLCONST
Ü ÛCompÝ: 'v ­ ('s,'v)PPMS ­ ('s,'v)PPMS
÷üüüüüü
Ü µv ppms1· Comp v ppms1 = MkPPMS
Ü	(Ìva (V, $r)·
Ü		¶s· s  V ± µt· t  V ´
Ü			(t r s ¤
Ü			ppms ppms1 (Ìw· if w = v then t else va w) (V, $r)
Ü			)
Ü	)
°

This should be understood as taking a formula and returning the formula which asserts the existence of the set with that extension, which differs from an instance of a comprehension axiom only in possibly having free variables.
So we want to close this formula and then quantify over the stratified properties.

We now define the property of membership structures which consists in being closed under stratified comprehension.
This has to have a variable name supplied as a parameter to make the definition type check, but the argument is ignored.

¹HOLCONST
Ü ÛStratCompClosedÝ: 'v ­ ('s)PMS
÷üüüüüü
Ü µv ms· StratCompClosed v ms = 
Ü	µsp · StratProp sp ´ µv:'v· foc (Comp v sp) ms
°

\subsection{An Axiom of Stratified Comprehension}

In this section we addres the formulation of an axiom of stratified comprehension for NF and NFU.

This could be achived using the property {\it StratCompClosed} along the following lines:

=GFT
	ô StratCompClosed (Universe, nf)
=TEX

However, if would be nice to have something which is a bit closer to the way an axiom of comprehension would be expected to look, along the lines:

=GFT
	ô µv p· Stratified p ´ ¶s· µx· x nf s ¤ p v x 
=TEX

Where  `v' is a bundle of variables packaged together nas a function.

The property {\it Stratified} would have to be defined in the relevant context since it would have to make use of the correct membership relation.
To make this possible we define here the closest support for this we can, viz. a notion of stratified property which is parameterised by the membership relationship.
Assuming we are axiomatising a set theory as a new type so that the domain of the relationship us the whole type this gives us:

=GFT
	ô µva v p· Stratified p ´ ¶s·
		µx· x nf s ¤ p $nf (Ìy· if y = v then x else va y) 
=TEX

It is this which we now seek to define.
{\it Stratified} here plays a role similar to that of  StratProp but needs to have a rather different type, e.g.:\\
=INLINEFT
('s ­ 's ­ BOOL) ­ (('v ­ 's) ­ 's ­ BOOL) ­ BOOL®
=TEX
\\
whereas {\it StratProp} has type:
=INLINEFT
('s,'v)PPMS ­ BOOL®
=TEX
\\
which is similar to \\
=INLINEFT
('v ­ 's) ­ (('s SET ¸ ('s ­ 's ­ BOOL)) ­ BOOL) ­ BOOL®
=TEX

So here goes:

¹HOLCONST
Ü ÛStratifiedÝ: (('s ­ 's ­ BOOL) ­ (STRING ­ 's) ­ 's SET) ­ BOOL
÷üüüüüü
Ü µp·	Stratified p
Ü	¤
Ü	StratProp (MkPPMS Ìva: STRING + ONE ­ 's; (V, mr)·
Ü		(va (InR One))  p mr (va o InL))
°

\section{EXTENDED MEMBERSHIP STRUCTURES}

For some applications it seems possible that having just a little more structure will be helpful.
The two elements which seem most desirable are the empty set and an ordered pair constructor (with projections).

If there is an empty set, it can of course be identified from the membership relation, but there may be more than one, and it is sometimes important to chose one of them.
There are of course ways of defining the ordered pair constructor, but most of the applications I have in mind would rather not have to make the choice.

The following notion of extended membership structure is therefore introduced, and may be subject to adjustments or abandonment in the light of how useful it turns out to be.

There are enough pieces to make use of a HOL labelled product type worthwhile.

¹HOLLABPROD XMSüüüüüüüüüüüüüüüüü
Ü	Carx	: 'a SET;
Ü	Inx	: 'a ­ 'a ­ BOOL;
Ü	x	: 'a;
Ü	Opx	: ('a ¸ 'a) ­ 'a;
Ü	Fstx	: 'a ­ 'a;
Ü	Sndx	: 'a ­ 'a;
Ü	Absx	: 'a SET ­ 'a
°üüüüüüüüüüüüüüüüüüüüüüüüü

The minimal properties one would expect are:

\begin{itemize}
\item that the empty set is in the carrier and is empty
\item that the ordered pairs are in the carrier and the projections deliver the right values
\end{itemize}

\ignore{

¹HOLCONST
Ü Ûis_XMSÝ: 'a XMS ­ BOOL
÷üüüüüü
Ü µxms:'a XMS· is_XMS xms
Ü ¤
Ü	(x xms  Carx xms ± ³ ¶s· s  Carx xms ± Inx xms s (x xms))
Ü   ±	(µl r· l  Carx xms ± r  Carx xms
Ü		´ Opx xms (l,r)  Carx xms
Ü		± Fstx xms (Opx xms (l,r)) = l
Ü		± Sndx xms (Opx xms (l,r)) = r)
Ü   ±	(µs:'a SET· (¶t:'a· µu:'a· u  s ¤ (Inx xms) u t) ´
Ü		(µu:'a· u  s ¤ (Inx xms) u (Absx xms s)))
     ±	WellFounded (Carx xms, Inx xms)
°

}%ignore
%%%%
%%%%
{\let\Section\section
\def\section#1{\Section{#1}\label{membership.th}}
\include{membership.th}
}  %\let

\twocolumn[\section{INDEX}\label{INDEX}]
{\small\printindex}

\end{document}
