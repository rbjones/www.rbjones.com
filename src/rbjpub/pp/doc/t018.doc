=IGN
$Id: t018.doc,v 1.3 2006/09/19 14:36:22 rbj01 Exp $
=TEX
\documentclass[11pt,a4paper]{article}
\usepackage{latexsym}
\usepackage{ProofPower}
\ftlinepenalty=9999
\usepackage{A4}
\def\N{\mathbb{N}}
\def\D{\mathbb{D}}
\def\B{\mathbb{B}}
\def\R{\mathbb{R}}
\def\Z{\mathbb{Z}}
\def\Q{\mathbb{Q}}

\def\ExpName{\mbox{{\sf exp}}}
\def\Exp#1{\ExpName(#1)}

\tabstop=0.4in
\newcommand{\ignore}[1]{}

\makeindex
\title{A Pseudo-Well-Founded Category Theoretic Foundation System with a Universal Category}
\author{Roger Bishop Jones}
\makeindex
\author{R.B.Jones\\ rbj01@rbjones.com}
\date{\FormatDate{$Date: 2006/09/19 14:36:22 $%
}}

\begin{document}
\begin{titlepage}
\maketitle
\begin{abstract}
This document is a formal exporation of the possibility of constructing a category theoretic foundation for mathematics using a pseudo-inductive filtering of the psuedo-well-founded sets in Quine's NF or NFU.
\end{abstract}
\vfill
\begin{centering}

\bf Copyright \copyright\ : Roger Bishop Jones \number\year \\
Reference: rbjpub/pp/doc/t0018.pdf; issue $Revision: 1.3 $%

\end{centering}
\thispagestyle{empty}
\end{titlepage}
\newpage
\addtocounter{page}{1}
%\section{DOCUMENT CONTROL}
%\subsection{Contents list}
\tableofcontents
%\newpage
%\subsection{Document cross references}

\subsection*{To Do}
\begin{itemize}

\item
Everything.

\end{itemize}

{\raggedright
\bibliographystyle{fmu}
\bibliography{rbj,fmu}
} %\raggedright

\newpage
\section{INTRODUCTION}

My objective is to use a non-well-founded set theory to construct domains useful for a category theoretic foundation for mathematics in which the ontology consists entirely of concrete categories and functors and in which the kinds of non-well-founded categories which are analogous to the set theoretic universe (and hence do not exist in well-founded set theories) are available (e.g. the categories of categories, groups, etc.).

I will spell this out informally a little more fully.

Let us begin considering the hereditarily finite sets.
A hereditarily finite set is a finite set whose {\it members} are hereditarily finite set, nothing else is.
This is an inductive definition, in higher order set theory we can define them as the intersection of all collections of sets which are closed under the formation of finite sets.
One can imagine doing this for any property of sets, there is nothing special about "finite".

Now consider the ``hereditarily functional sets''.
A set is functional if it is a set of ordered pairs which considered as a relation is many-one.
To close a paraphrase of the description of ``hereditarily finite'' fails in this case.
If we say: ``the hereditarily functional sets are those functional sets all of whose members are hereditarily functional sets'' we are immediately in trouble, because the members of a function are ordered pairs, not functions.

So in this case we need to generalise from ``member'' to constituent, the notion of constituent being a parameter along with the property.
In this case the constituents are the things in the domain and range of the function.

So now we say ``the `hereditarily functional sets' are those many-one relations whose field consists entirely of hereditarily functional sets''.
This elaboration of the idea of `hereditarily P' sets provides a semantic way of getting new foundation systems from old, the theory of hereditarily functional sets would make a foundation system similar in strength to the set theory on which its definition is based, and can be independently axiomatised, throwing away all reference to the original set theory.
To suggest that the resulting theory is a peer to set theory rather than remaining in some way parasitic upon it, I observe that by a broadly similar construction the original set theory can be constructed from the new function theory, as the `hereditarily empty set valued functions'' (i.e. the functions which always return the empty set, differing only in their domain, and which can therefore be taken as representatives of their domains).

Though there is some attraction in a foundation system based on functions rather than sets, this particular one (an untyped theory involving only well-founded functions) has attracted little interest.
Unfortunately the only ``problem'' it appears to fix is the awkwardness of coding up functions as graphs using sets, and this it replaces with the awkwardness of representing sets by special kinds of function.

We really need both sets and functions, ideally perhaps without coding either, so one might attempt an inductive construction which involved both concepts and yielded a two-sorted theory.
However, its more interesting to go one step further and consider sets and functions as special cases of concrete categories and functors.
This I have previously done in the well-founded case (at least, so far as defining the domsins is concerned).
The objective here is to do something similar, without the constraint to well-foundedness, so that we get a foundation system which is categorical and in which there is a universal category.

The well-founded case is convered only in a web page, at:

http://www.rbjones.com/rbjpub/pp/gst/pcf-defns.html

using a pair of rather cumbersome constructions.

Here I propose to take from that only the manner of representing categories and functors, and to recode the construction following Forster's definition of pseudo-well-foundedness.
Thus, a functor will be a triple consisting of a set which is the domain, a set which is the codomain and a function which is a many one relation between the domain and the codomain, total on the domain.
A category is a set of functors.
The left and right identity operations yeild the domain and codomain of the functors, composition is relational composition on the graphs.
 
In the well-founded case the construction is a liberalisation of the notion of `hereditarily P' set. which is closely coupled to the notion of well-foundedness.
The two liberalisations are, firstly that the notion of constituent replaces that of member and secondly that we have two sorts of entity involved.
In the non-well founded case we begin with the idea of pseudo-hereditary set which is coupled with Forster's notion of pseudo-wellfoundedness.
This already is two sorted, so the hope is that these two sorts can be the categories and functors.
So we perform the same liberalisation as before (from talk of members to talk of constituents) and then we have a notion of two sets being `pseudo-C-hereditarily (P,Q)' (the `C' being the notion of constituent at stake, of which strictly there are two).
Then we plumb in the properies specific to the category theoretic application.

All of this would be to no avail if done in the context of a well-founded set theory, though it would be usefull to know whether it yields the same result as `C-heredicarily (P,Q)' in such a context.
To get a result which is not well-founded, we need to start with a non-well-founded collection of sets.
For this purpose we have axiomatisations in {\Product} HOL of NF and NFU.
The work is done by defining operators on set membersbip relations, so that the same construction can be applied to more than one set theory.

\subsection{The Axioms}

I have decided to try two different axiomatisations.
Randall Holmes's axiomatisation of NFU and Hailperin's finite axiomatisation of NF.

\subsubsection{NF following Hailperin}

This should be pretty close, the difficulties being not in transcription of the axioms but in developing the theory from them.
Forster observes that these axioms tie you to the Wiener-Kuratovski representation of ordered pairs, but I can't see why that should be the case, though the axioms are presented using ordered pairs in that representation.
I can't see anything which commits any further use of that representation, but probably I will do something agnostic, following Holmes on NFU, which just doesn't say what the representation of ordered pairs is.

\subsubsection{NFU following Holmes}

Here the game plan is to begin with a routine transcription into ProofPower HOL of the axioms and definitions for NFU as presented by Randall Holmes in his book (Cahiers du Centre Logique, Volume 10, also available from his web site).
This will proceed initially no further than is necessay to interpret the stratified lambda calculus, and then attempt a construction of the domain of the stratified lambda calculus (conservatively over NFU).
If this seems OK then, without developing the stratified lambda calculs further, I will see if I can figure our how to do something category theoretic.

I will not necessarily be single-minded in heading for the category theoretic foundation, there may be aspects of NFU which will seem worth persuing en-route.

The following deliberate deviations from Holmes' axioms may be noted:

\begin{itemize}
\item Holmes' axioms contain more conditions on things being sets than are strictly necessary.
Since these conditions make theorem proving harder, I have omitted them where they are not essential.
Typically this is the case in an axiom introducing an operation over sets.
Such definitions will effectively treat atoms as if they were the empty set if the condition is removed, and I am supposing this is a harmless but convenient idosyncracy on my part.
\end{itemize}

\section{NF}
\subsection{Technical Prelude}

First of all, we must give the the ML commands to  introduce the new theory ``NF'' as a child of the theory ``rbjmisc''.

=SML
open_theory "rbjmisc";
force_new_theory "NF";
set_merge_pcs["hol1", "'savedthm_cs_¶_proof"];
=TEX

\ignore{
=SML
set_flag ("pp_use_alias", true);
=IGN
open_theory "NF";
set_merge_pcs["hol1", "'savedthm_cs_¶_proof"];
=TEX
}%ignore

In the context in which the development is taking place there is already a set theory, and we will make occasional use of it.
The normal set theoretic symbols are interpreted in this prior set theory, and the new set theory (NF) which we are introducing will therefore use symbols systematically subscripted with a small roman `n'.

Here is the new type for NF:

=SML
new_type ("NF", 0);
=TEX

This axioms use membership, the unit set and ordered pair constructors.
I will take the ordinary pair constructor as primitive and define unit set and ordered pair in terms of them before introducing the axiom.

=SML
declare_infix (310, "‰n");
new_const("‰n", ”NF ­ NF ­ BOOL®);
new_const("Pair‰n", ”NF ¸ NF ­ NF®);
declare_prefix (320, "É");
=TEX

¹HOLCONST
Ü $ÛÉİ : NF ­ NF
÷üüüüüü
Ü µu· É u = Pair‰n (u, u)
°

¹HOLCONST
Ü ÛKpİ : NF ¸ NF ­ NF
÷üüüüüü
Ü µu v· Kp(u, v) = Pair‰n(É u, Pair‰n(u, v))
°

¹HOLCONST
Ü ÛKtİ : NF ¸ NF ¸ NF ­ NF
÷üüüüüü
Ü µu v w· Kt(u, v, w) = Kp(É É u, Kp(v, w)) 
°

\subsection{The Hailperin Axioms}

=SML
val Ext‰n = new_axiom(["Ext‰n"],

	¬µu v· (µx· x ‰n u ¤ x ‰n v) ´ u = v®);

val Pairènê = new_axiom(["Pair‰n"],	

	¬µu v· (µx· x ‰n Pair‰n(u,v) ¤ x = u ² x = v)®);

val P1 = new_axiom(["P1"],

	¬µu v· ¶ y· µ x· x ‰n y ¤ ³ x ‰n u ² ³ x ‰n v®);

val P2 = new_axiom(["P2"],

	¬µu·¶v·µx y· Kp(É x, É y) ‰n v ¤ Kp(x, y) ‰n u®);

val P3 = new_axiom(["P3"],

	¬µu·¶v·µx y z· Kt(x, y, z) ‰n v ¤ Kp(x, y) ‰n u®);

val P4 = new_axiom(["P4"],

	¬µu·¶v·µx y z· Kt(x, z, y) ‰n v ¤ Kp(x, y) ‰n u®);

val P5 = new_axiom(["P5"],

	¬µu·¶v·µx y· Kp(x, y) ‰n v ¤ x ‰n u®);

val P6 = new_axiom(["P6"],

	¬µu·¶v·µx· x ‰n v ¤ µz· Kp(z, É x) ‰n u®);

val P7 = new_axiom(["P7"],

	¬µu·¶v·µx y· Kp(y, x) ‰n u ¤ Kp(x, y) ‰n v®);

val P8 = new_axiom(["P8"],

	¬¶v·µx· x ‰n v ¤ ¶y· x = É y®);

val P9 = new_axiom(["P9"],

	¬¶v·µx y· Kp(É x, y) ‰n v ¤ x ‰n y®);
=TEX

The following axiom says that for every two sets $u$ and $v$ there exists a set $y$ of those elements $x$ which appear in neither $u$ nor $v$.
This is of course the complement of the union of the two sets, and the axiom allows us to define complement and union and various other operations over sets.

\subsection{Definitions}

Many of the following definitions depend upon a consistency proof, the details of which are not presented.

Axiom P1 allows the definition of complementation and intersection, these two operators are the set theoretic counterpart to negation and conjunction which provide a universal set of operators for the propositional calculus.
Axiom P1 therefore leads by itself to the definition of any set operations which correspond to propositional truth functions.

\subsubsection{Complement}

=SML
declare_postfix (320, "›c");
=TEX

\ignore{
=SML
set_goal([], ¬¶ $›c:NF ­ NF· µu x· x ‰n u ›c ¤ ³ x ‰n u®);
a (¶_tac ¬Ìx· Åy· µz· z ‰n y ¤ ³ z ‰n x® THEN rewrite_tac[]
	THEN REPEAT_N 2 strip_tac);
a (Å_tac ¬Å y· µ z· z ‰n y = (³ z ‰n u)®);
(* *** Goal "1" *** *)
a (strip_asm_tac (list_µ_elim [¬u®, ¬u®] P1));
a (¶_tac ¬y® THEN asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a (asm_rewrite_tac[]);
save_cs_¶_thm(pop_thm());
=TEX
}%ignore

¹HOLCONST
Ü $Û›cİ : NF ­ NF
÷üüüüüü
Ü µu x· x ‰n u ›c ¤ ³ x ‰n u
°

\subsubsection{Intersection}

=SML
declare_infix(310, "¡‰n");
=TEX

\ignore{
=SML
val ›c‰n_def = get_spec ¬$›c®;

set_goal([], ¬¶$¡‰n:NF ­ NF ­ NF· µu v x· x ‰n u ¡‰n v ¤ x ‰n u ± x ‰n v®);
a (¶_tac ¬Ìu v· Åw· µx· x ‰n w ¤ x ‰n u ± x ‰n v®
	THEN rewrite_tac[]
	THEN REPEAT_N 3 strip_tac);
a (Å_tac ¬Åw· µx· x ‰n w ¤ x ‰n u ± x ‰n v®);
(* *** Goal "1" *** *)
a (strip_asm_tac (list_µ_elim [¬u®, ¬v®] P1));
a (¶_tac ¬y ›c® THEN asm_rewrite_tac[›c‰n_def]
	THEN REPEAT strip_tac);
(* *** Goal "2" *** *)
a (asm_rewrite_tac[]);
save_cs_¶_thm(pop_thm());
=TEX
}%ignore

¹HOLCONST
Ü $Û¡‰nİ : NF ­ NF ­ NF
÷üüüüüü
Ü µu v x· x ‰n (u ¡‰n v) ¤ x ‰n u ± x ‰n v
°

\ignore{
=SML
val ¡‰n_def = get_spec ¬$¡‰n®; 
=TEX
}%ignore


\subsubsection{Union}

=SML
declare_infix(305, "À‰n");
=TEX

¹HOLCONST
Ü $ÛÀ‰nİ : NF ­ NF ­ NF
÷üüüüüü
Ü µu v· u À‰n v = ((u ›c) ¡‰n (v ›c)) ›c
°

\ignore{
 ¹HOLCONST
Ü $Û›cİ : NF ­ NF
÷üüüüüü
Ü 
 °
} %ignore

\section{NFU}
\subsection{Technical Prelude for NFU}

First of all, we must give the the ML commands to  introduce the new theory ``NFU'' as a child of the theory ``hol''.

=SML
open_theory "rbjmisc";
force_new_theory "NFU";
force_new_pc "nfu";
set_merge_pcs["hol1", "nfu", "'savedthm_cs_¶_proof"];
=TEX

In the context in which the development is taking place there is already a set theory, and we will make occasional use of it.
The normal set theoretic symbols are interpreted in this prior set theory, and the new set theory (NFU) which we are introducing will therefore use symbols systematically subscripted with a small roman `n'.

\subsection{The Set Concept}

We introduce a new type which contains the sets of NFU.
NFU is distinguished from NF by a weaker axiom of extensionality which allows that there may be {\it urelements}.
In Holmes' axiomatisation the difference between sets and non-sets is treated explicitly, which he may have done for pedagogical reasons.
However, this is less convenient for formalisation than a more lightweight treatment of non-sets, in which the distinctiveness of NFU is confined to the restriction of extensionality to non-empty sets, urelements being logically like extra empty sets.
In this approach the Set predicate used by Holmes to distinguish sets from atoms is unnecessary and our only primitive is therefore the relation $¬‰u®$ which tells us what the members of a set are.

=SML
new_type("NFU",0);
declare_infix(300, "‰u");
new_const("‰u", ”NFU ­ NFU ­ BOOL®);
=TEX

=SML
val Ext_ax = new_axiom (["Ext"],
	¬µa b c· c ‰u a ´ (µx· x ‰u a ¤ x ‰u b) ´ a = b®);
=TEX

\ignore{
=SML
set_goal([], ¬µa b c· c ‰u a ² c ‰u b ´ (a = b ¤ (µx· x ‰u a ¤ x ‰u b))®);
a (REPEAT strip_tac THEN_TRY asm_rewrite_tac[]);
(* *** Goal "1" *** *)
a (all_var_elim_asm_tac);
(* *** Goal "2" *** *)
a (all_fc_tac [Ext_ax]);
(* *** Goal "3" *** *)
a (all_var_elim_asm_tac);
(* *** Goal "4" *** *)
a (DROP_NTH_ASM_T 1 (asm_tac o map_eq_sym_rule));
a (strip_asm_tac (list_µ_elim [¬b®, ¬a®, ¬c®] Ext_ax)
	THEN_TRY asm_rewrite_tac[]);
a (spec_nth_asm_tac 3 ¬x®);
a (spec_nth_asm_tac 3 ¬x®);
val Extèuê_thm = save_pop_thm "Extèuê_thm";
=TEX
}%ignore

=GFT
Extèuê_thm =
   ô µ a b c· c ‰u a ² c ‰u b ´ ((a = b) ¤ (µ x· x ‰u a = x ‰u b))
=TEX

\subsubsection{The Empty Set}


=SML
new_const("š‰u", ”NFU®);
val šèuê_ax = new_axiom (["š‰u"], ¬µx· ³ x ‰u š‰u®);
=TEX

There may be more things with no members but we think of the others as urelements, only this one is the empty set (we will make sure that none of the others ever results from an operation over sets).

Once we have complements we will define the universe.

\subsubsection{Sets and Urelements}

We can now define predicates for sets and urelements.

¹HOLCONST
Ü ÛSet‰uİ : NFU ­ BOOL
÷üüüüüü
Ü µa· Set‰u a ¤ a = š‰u ² ¶x· x ‰u a
°

¹HOLCONST
Ü ÛUr‰uİ : NFU ­ BOOL
÷üüüüüü
Ü µa· Ur‰u a ¤ ³ Set‰u a
°

\ignore{
=SML
val Setèuê_def = get_spec ¬Set‰u®;
val Urèuê_def = get_spec ¬Ur‰u®;

set_goal([], ¬Set‰u š‰u®);
a (rewrite_tac[Setèuê_def]);
val Setèuê_šèuê_thm = save_pop_thm "Setèuê_šèuê_thm";

set_goal([], ¬µa b· Set‰u a ± Set‰u b ´ (a = b ¤ (µx· x ‰u a ¤ x ‰u b))®);
a (rewrite_tac[Setèuê_def]);
a (REPEAT_N 3 strip_tac);
(* *** Goal "1" *** *)
a (asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a (FC_T1 fc_¤_canon rewrite_tac [Extèuê_thm]);
(* *** Goal "3" *** *)
a (FC_T1 fc_¤_canon rewrite_tac [Extèuê_thm]);
(* *** Goal "4" *** *)
a (FC_T1 fc_¤_canon rewrite_tac [Extèuê_thm]);
val Extèuê_set_thm = save_pop_thm "Extèuê_set_thm";
=TEX
}%ignore

=GFT
Extèuê_set_thm =
   ô µ a b c· Set‰u a ± Set‰u b ´ (a = b ¤ (µ x· x ‰u a ¤ x ‰u b))
=TEX

\subsubsection{Comprehension}

Notation for set comprehension will probably be useful.
We have syntax for sets, which in this context will yield values of type
=INLINEFT
”NFU SET®
=TEX
, so we define two new constants, one to assert the existence of a set with a particular extension, and the other to convert an object of type 
=INLINEFT
”NFU SET®
=TEX
 to one of type 
=INLINEFT
”NFU®
=TEX
.

The constant
=INLINEFT
¬¶‰u®
=TEX
 simply asserts the existence of a set with some particular extension.

¹HOLCONST
Ü Û¶‰uİ : NFU SET ­ BOOL
÷üüüüüü
Ü µs· ¶‰u s ¤ ¶a· Set‰u a ± µx· x ‰u a ¤ x  s
°

The constant 
=INLINEFT
¬•‰u®$
=TEX
 simulates set comprehension in NFU.
If applied to an extension (as an object of type
=INLINEFT
”(NFU)SET®
=TEX
) for which a set exists it yields that set.

\ignore{
=SML
val ¶‰u_def = get_spec ¬¶‰u®;

set_goal([], ¬¶ •‰u· µs· ¶‰u s ´ Set‰u (•‰u s) ± µx· x ‰u (•‰u s) ¤ x  s®);
a (¶_tac ¬Ìs· Ån· Set‰u n ± µx· x ‰u n ¤ x  s® THEN rewrite_tac[]
	THEN strip_tac THEN rewrite_tac [¶‰u_def]
	THEN strip_tac
	THEN strip_tac);
(* *** Goal "1" *** *)
a (Å_tac ¬Ån· Set‰u n ± µx· x ‰u n ¤ x  s®);
a (¶_tac ¬a® THEN asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a (Å_tac ¬Ån· Set‰u n ± µx· x ‰u n ¤ x  s®);
a (¶_tac ¬a® THEN asm_rewrite_tac[]);
save_cs_¶_thm (pop_thm());
=TEX
} %ignore

¹HOLCONST
Ü Û•‰uİ : NFU SET ­ NFU
÷üüüüüü
Ü µs· ¶‰u s ´ Set‰u (•‰u s) ± µx· x ‰u (•‰u s) ¤ x  s
°

\ignore{
=SML
val ¶èuê_def = get_spec ¬¶‰u®;
val •èuê_def = get_spec ¬•‰u®;
=TEX
}%ignore

\ignore{
=SML
set_goal([], ¬¶‰u {}®);
a (rewrite_tac[¶èuê_def]);
a (¶_tac ¬š‰u® THEN rewrite_tac [šèuê_ax, Setèuê_def]);
val ¶‰u_empty_thm = save_pop_thm "¶‰u_empty_thm";

set_goal([], ¬•‰u {} = š‰u®);
a (asm_tac ¶‰u_empty_thm THEN FC_T1 fc_¤_canon (MAP_EVERY asm_tac) [•èuê_def]);
a (asm_tac Setèuê_šèuê_thm);
a (ALL_FC_T1 fc_¤_canon (MAP_EVERY asm_tac) [•èuê_def]);
a (ALL_FC_T1 fc_¤_canon (MAP_EVERY asm_tac) [Extèuê_set_thm]);
a (asm_rewrite_tac[šèuê_ax]);
val •èuê_šèuê_thm = save_pop_thm "•èuê_šèuê_thm";
=TEX
}%ignore

Of course this is all mere notation, there are no assertions made here about which sets exist.

\subsection{Boolean Operations}

In this area the theory NFU differs from the kind of typed set theory which we do in HOL only because of the complications arising from the possibility that there are atoms in the domain of discourse.
The effect of this is that the theorems which characterise the operations over sets are all conditional.
Whereas in HOL it is straightforward to eliminate this kind of set theoretic vocabulary, reducing equalities and inequalities to propositional logic or elementary theorems of quantifier theory, in NFU this is not quite so straightforward and requires a bit more machinary. 

\subsubsection{Complement}

The first clause of this axiom ensures that the complement operation always yields a set.

=SML
new_const("›c", ”NFU ­ NFU®);
declare_postfix(310,"›c");
val çcêèuê_ax = new_axiom (["›c"], ¬µa· Set‰u (a ›c) ± µx· x ‰u a ›c ¤ ³ x ‰u a®);
=TEX

\subsubsection{The Universe}

The Universe is the complement of the empty set.

¹HOLCONST
Ü ÛV‰uİ : NFU
÷üüüüüü
Ü V‰u = š‰u ›c
°

\ignore{
=SML
val Vèuê_def = get_spec ¬V‰u®;

set_goal([], ¬µx· x ‰u V‰u®);
a (rewrite_tac[Vèuê_def, çcêèuê_ax, šèuê_ax]);
val èuêVèuê_thm = save_pop_thm "èuêVèuê_thm";
=TEX
}%ignore

=GFT
èuêVèuê_thm =
   ô µ x· x ‰u V‰u
=TEX

\subsubsection{Union}

=SML
new_const("À‰u", ”NFU ­ NFU ­ NFU®);
declare_infix(290, "À‰u");
val Àèuê_ax = new_axiom (["À‰u"],
	¬µa b· Set‰u (a À‰u b) ± µx· x ‰u (a À‰u b) ¤ x ‰u a ² x ‰u b®);
=TEX

\subsubsection{Intersection}

We are now able to {\it define} intersection:

=SML
declare_infix(300, "¡‰u");
=TEX

¹HOLCONST
Ü Û$¡‰uİ : NFU ­  NFU ­ NFU
÷üüüüüü
Ü µa b· (a ¡‰u b) = (a ›c À‰u b ›c)›c
°

\ignore{
=SML
val ¡‰u_def = get_spec ¬$¡‰u®;

set_goal ([], ¬µa b· Set‰u (a ¡‰u b) ± µx· x ‰u (a ¡‰u b) ¤ x ‰u a ± x ‰u b®);
a (rewrite_tac [¡‰u_def, Àèuê_ax, çcêèuê_ax] THEN REPEAT strip_tac);
val ¡èuê_thm = save_pop_thm "¡èuê_thm";
=TEX
}%ignore

=GFT
¡èuê_thm
	ô µ a b· Set‰u(a ¡‰u b) x· x ‰u a ¡‰u b ¤ (x ‰u a ± x ‰u b)
=TEX

\subsubsection{Relative Complement}

=SML
declare_infix(300, "\\‰u");
=TEX

¹HOLCONST
Ü Û$\‰uİ : NFU ­  NFU ­ NFU
÷üüüüüü
Ü µa b· (a \‰u b) = a ¡‰u (b ›c)
°

\ignore{
=SML
val diff‰u_def = get_spec ¬$\‰u®;

set_goal ([], ¬µa b· Set‰u (a \‰u b) ± µx· x ‰u (a \‰u b) ¤ x ‰u a ± ³ x ‰u b®);
a (rewrite_tac[diff‰u_def, çcêèuê_ax, ¡‰u_def, Àèuê_ax]);
a (REPEAT strip_tac);
val diffèuê_thm  = save_pop_thm "diffèuê_thm";
=TEX
}%ignore

=GFT
diffèuê_thm  =
    ô µ a b· Set‰u(a \‰u b) µx· x ‰u a \‰u b ¤ x ‰u a ± ³ x ‰u b
=TEX

\subsubsection{Symmetric Difference}

=SML
declare_infix(300, "„‰u");
=TEX

¹HOLCONST
Ü Û$„‰uİ : NFU ­  NFU ­ NFU
÷üüüüüü
Ü µa b· (a „‰u b) = (b \‰u a) À‰u (a \‰u b)
°
\ignore{
=SML
val „‰u_def = get_spec ¬$„‰u®;

set_goal([], ¬µa b· Set‰u (a „‰u b)
	± µx· x ‰u a „‰u b ¤ (x ‰u a ² x ‰u b) ± ³(x ‰u a ± x ‰u b)®);
a (rewrite_tac[„‰u_def, çcêèuê_ax, ¡‰u_def, Àèuê_ax, diffèuê_thm]);
a (REPEAT strip_tac);
val „èuê_thm  = save_pop_thm "„èuê_thm";
=TEX
}%ignore

\subsubsection{Inclusion}

=SML
declare_infix(290, "€‰u");
declare_infix(290, " ‰u");
=TEX

¹HOLCONST
Ü $Û€‰uİ : NFU ­  NFU ­ BOOL
÷üüüüüü
Ü µa b· (a €‰u b) ¤ µx· x ‰u a ´ x ‰u b
°

¹HOLCONST
Ü $Û ‰uİ : NFU ­  NFU ­ BOOL
÷üüüüüü
Ü µa b· (a  ‰u b) ¤ (a €‰u b) ± ³ b €‰u a
°

\ignore{
=SML
val €èuê_def = get_spec ¬$€‰u®;
val  èuê_def = get_spec ¬$ ‰u®;

set_goal([], ¬µa· š‰u €‰u a®);
a (rewrite_tac [€èuê_def, šèuê_ax]);
val šèuê_€èuê_thm = save_pop_thm "šèuê_€èuê_thm";
=IGN
set_goal([], ¬µa b· Set‰u b ± a €‰u b ¤ a À‰u b = b®);
a (rewrite_tac [€èuê_def, Àèuê_ax]
	THEN REPEAT_N 2 strip_tac);
a (cases_tac ¬Set‰u b® THEN asm_rewrite_tac[]);
(* *** Goal "1" *** *)
a (fc_tac [Setèuê_def] THEN1 asm_rewrite_tac[]);
(* *** Goal "1.1" *** *)

Ur‰u_def;
a (strip_asm_tac (list_µ_elim [¬a À‰u b®, ¬b®] Ext_ax));
val š‰u_€‰u_thm = save_pop_thm "š‰u_€‰u_thm";
=TEX
}%ignore

\subsubsection{Distributed Union}

=SML
new_const("Ş‰u", ”NFU ­ NFU®);
declare_prefix(310, "Ş‰u");
val Ş‰u_ax = new_axiom (["Ş"],
	¬µa· Set‰u (Ş‰u a) ± µx· x ‰u Ş‰u a ¤ ¶y· x ‰u y ± y ‰u Ş‰u a®);
=TEX

\subsubsection{Some Theorems}

The limitation on extensionality in NFU makes a little difficulty in using extensional reasoning to establish equalities or inequalities.
This will most frequently involve establishing that both operands are sets, though it may suffice to establish that one is non-empty.
We therefore need some theorems telling us that things are sets.

\ignore{
=SML
set_goal([], ¬Set‰u š‰u ± Set‰u V‰u
	± µa b· Set‰u(a ›c)
	  ± Set‰u (a ¡‰u b)
	  ± Set‰u (a À‰u b)
	  ± Set‰u (a \‰u b)
	  ± Set‰u (a „‰u b)®);
a (rewrite_tac [Vèuê_def, çcêèuê_ax, Àèuê_ax, Setèuê_šèuê_thm, ¡èuê_thm, diffèuê_thm, „èuê_thm]);
val Setèuê_clauses = save_pop_thm "Setèuê_clauses";
=TEX
}%ignore

In a set theory without urelements it is possible and useful to simplify away many occurrences of the empty set.
In this context, an operation involving the empty set may have the effect of converting its other operand from a urelement to an empty set, and so the simplification may not be possible or desirable.
This is reflected in the following theorem by the cases in which simplification is conditional on something being a set.

\ignore{
=SML
set_goal ([], ¬
	  V‰u ›c = š‰u
	± š‰u ›c = V‰u
®);
a (rewrite_tac[Vèuê_def, çcêèuê_ax]);
a (asm_tac Setèuê_šèuê_thm);
a (lemma_tac ¬Set‰u (š‰u ›c ›c)® THEN1 rewrite_tac [çcêèuê_ax]);
a (ALL_FC_T1 fc_¤_canon (MAP_EVERY asm_tac) [Extèuê_set_thm]);
a (asm_rewrite_tac[çcêèuê_ax]);
val šèuêVèuê_clauses = save_pop_thm "šèuêVèuê_clauses";
=TEX
=IGN
set_goal ([], ¬µa·
		a ¡‰u š‰u = š‰u
	  ±	š‰u ¡‰u a = š‰u
	  ±	š‰u \‰u a = š‰u
	  ±	a À‰u V‰u = V‰u
	  ±	V‰u À‰u a = V‰u
	  ±	a \‰u V‰u = š‰u
®);
a (strip_tac);
a (lemma_tac ¬Set‰u š‰u ± Set‰u V‰u ± Set‰u(a ¡‰u š‰u) ± Set‰u(š‰u ¡‰u a) ± Set‰u(š‰u \‰u a) ± Set‰u(a À‰u V‰u) ± Set‰u(V‰u À‰u a) ± Set‰u(a \‰u V‰u)® THEN1 rewrite_tac[Setèuê_clauses]);
a (ALL_FC_T1 fc_¤_canon rewrite_tac [Extèuê_set_thm]);
a (rewrite_tac[çcêèuê_ax, Àèuê_ax, ¡‰u_def, diff‰u_def, „‰u_def, šèuêVèuê_clauses]);
(* *** Goal "1" *** *)

=TEX
}%ignore

=GFT
val šèuêVèuê_clauses = ô V‰u ›c = š‰u ± š‰u ›c = V‰u
=TEX

\subsection{Building Finite Structures}

\subsubsection{Singletons}

=SML
val Singleton_ax = new_axiom(["Singleton_ax"], ¬µx· ¶‰u {y | y = x}®);
declare_prefix (320, "É‰u");
=TEX

¹HOLCONST
Ü $ÛÉ‰uİ : NFU ­ NFU
÷üüüüüü
Ü µx· É‰u x = •‰u {y | y = x}
°

\ignore{
=SML
val Éèuê_def = get_spec ¬$É‰u®;

set_goal([], ¬µy· Set‰u (É‰u y) ± µx· (x ‰u É‰u y ¤ x = y)®);
a (rewrite_tac [Éèuê_def]
	THEN REPEAT_N 2 strip_tac);
(* *** Goal "1" *** *)
a (asm_tac (µ_elim ¬y® Singleton_ax)
	THEN FC_T1 fc_¤_canon (MAP_EVERY asm_tac) [•èuê_def]
	THEN strip_tac);
(* *** Goal "2" *** *)
a (asm_tac (µ_elim ¬y® Singleton_ax)
	THEN FC_T1 fc_¤_canon (MAP_EVERY asm_tac) [•èuê_def]);
a (asm_rewrite_tac[]);
val Éèuê_thm = save_pop_thm "Éèuê_thm";

set_goal([], ¬µx· x ‰u É‰u x®);
a (rewrite_tac[Éèuê_thm]);
val Éèuê_thm2 = save_pop_thm "Éèuê_thm2";

set_goal([], ¬µx y· É‰u x = É‰u y ¤ x = y®);
a (REPEAT µ_tac);
a (lemma_tac ¬Set‰u (É‰u x) ± Set‰u (É‰u y)®
	THEN1 rewrite_tac [Éèuê_thm]
	THEN ALL_FC_T1 fc_¤_canon (rewrite_tac) [Extèuê_set_thm]); 
a (REPEAT_N 3 strip_tac THEN_TRY asm_rewrite_tac[]);
a (spec_nth_asm_tac 1 ¬x®
	THEN DROP_NTH_ASM_T 2 ante_tac
	THEN rewrite_tac [Éèuê_thm]);
val Éèuê_eq_thm = save_pop_thm "Éèuê_eq_thm";
=TEX
}%ignore

=GFT
Éèuê_thm =
   ô µ x· Set‰u (É‰u x) ± µy· (y ‰u É‰u x ¤ y = x)

Éèuê_thm2 =
   ô µ x· x ‰u É‰u x

Éèuê_eq_thm =
   ô µ x y· É‰u x = É‰u y ¤ x = y
=TEX

The constructor previously defined for converting a HOL set abstraction to an NFU set will work also for a HOL set display (note however that the elements in the display must be separated by semicolons rather than commas).

\subsubsection{Pairs}

A pair is the union of two singletons.

¹HOLCONST
Ü ÛPair‰uİ : NFU ¸ NFU ­ NFU
÷üüüüüü
Ü µx y· Pair‰u (x, y) = (É‰u x) À‰u (É‰u y)
°

\ignore{
=SML
val Pairèuê_def = get_spec ¬Pair‰u®;

set_goal([],¬µa b· Set‰u (Pair‰u(a, b)) ± (µx· x ‰u Pair‰u(a, b) ¤ x = a ² x = b)®);
a (rewrite_tac [Pairèuê_def, Àèuê_ax, Éèuê_thm]
	THEN REPEAT_N 2 strip_tac);
val Pairèuê_thm = save_pop_thm "Pairèuê_thm";

set_goal([], ¬µa b c· É‰u a = Pair‰u(b, c) ¤ b = a ± c = a®);
a (REPEAT_N 3 strip_tac);
a (lemma_tac ¬Set‰u(É‰u a) ± Set‰u(Pair‰u(b, c))®
	THEN1 rewrite_tac [Éèuê_thm, Pairèuê_thm]);
a (ALL_FC_T1 fc_¤_canon (rewrite_tac)
	[Extèuê_set_thm]);
a (rewrite_tac [Éèuê_thm, Pairèuê_thm]
	THEN REPEAT strip_tac THEN_TRY asm_rewrite_tac[]);
val Éèuê_eq_Pairèuê_thm = save_pop_thm "Éèuê_eq_Pairèuê_thm";

set_goal([], ¬µa b c· Pair‰u(b, c) = É‰u a ¤ b = a ± c = a®);
a (REPEAT_N 3 strip_tac);
a (LEMMA_T ¬Pair‰u(b, c) = É‰u a ¤ É‰u a = Pair‰u(b, c)® rewrite_thm_tac
	THEN1 (REPEAT strip_tac THEN asm_rewrite_tac[]));
a (rewrite_tac [Éèuê_eq_Pairèuê_thm]);
val Pairèuê_eq_Éèuê_thm = save_pop_thm "Pairèuê_eq_Éèuê_thm";

set_goal([], ¬µa b c d· Pair‰u(a, b) = Pair‰u(c, d) ¤ a = c ± b = d ² a = d ± b = c®);
a (REPEAT µ_tac);
a (lemma_tac ¬Set‰u(Pair‰u(a,b)) ± Set‰u(Pair‰u(c,d))® THEN1 rewrite_tac[Pairèuê_thm]);
a (ALL_FC_T1 fc_¤_canon rewrite_tac [list_µ_elim [¬Pair‰u(a,b)®, ¬Pair‰u(c,d)®] Extèuê_set_thm]);
a (rewrite_tac [Pairèuê_thm] THEN REPEAT strip_tac
	THEN_TRY all_var_elim_asm_tac THEN_TRY asm_rewrite_tac[]);
(* *** Goal "1" *** *)
a (spec_nth_asm_tac 2 ¬a®);
(* *** Goal "2" *** *)
a (spec_nth_asm_tac 2 ¬c®);
a (DROP_NTH_ASM_T 2 ante_tac THEN asm_rewrite_tac[]);
a (asm_rewrite_tac[]);
a (DROP_NTH_ASM_T 3 ante_tac THEN asm_rewrite_tac[]);
a (asm_rewrite_tac[]);
(* *** Goal "3" *** *)
a (lemma_tac ¬³d=b® THEN1 (swap_nth_asm_concl_tac 1 THEN asm_rewrite_tac[]));
a (spec_nth_asm_tac 3 ¬d® THEN asm_rewrite_tac[]);
(* *** Goal "4" *** *)
a (spec_nth_asm_tac 2 ¬b® THEN asm_rewrite_tac[]);
val Pairèuê_eq_Pairèuê_thm = save_pop_thm "Pairèuê_eq_Pairèuê_thm";
=TEX
}%ignore

=GFT
Pairèuê_thm =
   ô µ a b· Set‰u (Pair‰u (a, b)) ± (µ x· x ‰u Pair‰u (a, b) ¤ x = a ² x = b)

Éèuê_eq_Pairèuê_thm =
   ô µ a b c· É‰u a = Pair‰u (b, c) ¤ b = a ± c = a

Pairèuê_eq_Éèuê_thm =
   ô µ a b c· Pair‰u (b, c) = É‰u a ¤ b = a ± c = a
=TEX

\subsubsection{Ordered Pairs}

¹HOLCONST
Ü $ÛKp‰uİ : NFU ¸ NFU ­ NFU
÷üüüüüü
Ü µx y· Kp‰u (x, y) = Pair‰u (É‰u x, Pair‰u (x, y))
°

\ignore{
=SML
val Kpèuê_def = get_spec ¬Kp‰u®;

set_goal([],¬µa b· Set‰u (Kp‰u(a,b)) ± µx· x ‰u Kp‰u(a,b) ¤ x=É‰u a ² x=Pair‰u(a, b)®);
a (rewrite_tac [Kpèuê_def, Pairèuê_thm]);
val Kpèuê_thm = pop_thm ();

set_goal([], ¬µa b c d· Kp‰u(a, b) = Kp‰u(c, d) ¤ a = c ± b = d®);
a (REPEAT µ_tac THEN strip_tac THEN strip_tac);
(* *** Goal "1" *** *)
a (lemma_tac ¬Set‰u(Kp‰u(a, b)) ± Set‰u(Kp‰u(c, d))® THEN1 rewrite_tac [Kpèuê_thm]);
a (ALL_FC_T1 fc_¤_canon (rewrite_tac)
	[list_µ_elim [¬Kp‰u(a, b)®, ¬Kp‰u(c, d)®] Extèuê_set_thm]
	THEN asm_rewrite_tac[Kpèuê_thm] THEN strip_tac);
a (SPEC_NTH_ASM_T 1 ¬É‰u a® (asm_tac o (rewrite_rule[Éèuê_eq_thm, Éèuê_eq_Pairèuê_thm])));
a (lemma_tac ¬a = c® THEN1 (POP_ASM_T strip_asm_tac THEN asm_rewrite_tac[]));
a (asm_rewrite_tac[]);
a (DROP_NTH_ASM_T 3 ante_tac);
a (asm_rewrite_tac[] THEN strip_tac);
a (SPEC_NTH_ASM_T 1 ¬Pair‰u (d, b)® (ante_tac o (rewrite_rule[Éèuê_eq_thm, Éèuê_eq_Pairèuê_thm,
		Pairèuê_eq_Éèuê_thm, Pairèuê_eq_Pairèuê_thm])));
a (cases_tac ¬d = c® THEN asm_rewrite_tac[]);
a (cases_tac ¬b = c® THEN asm_rewrite_tac[]);
a (SPEC_NTH_ASM_T 3 ¬Pair‰u (c, b)® (ante_tac o (rewrite_rule[Éèuê_eq_thm, Éèuê_eq_Pairèuê_thm,
		Pairèuê_eq_Éèuê_thm, Pairèuê_eq_Pairèuê_thm]))
	THEN asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a (strip_tac THEN asm_rewrite_tac[]);
val Kpèuê_eq_Kpèuê_thm = pop_thm ();
=TEX
} %ignore

The following theorems are proven and used in the introduction of $Op$.

=GFT
   ô µ a b· Set‰u (Kp‰u (a, b))
         ± (µ x· x ‰u Kp‰u (a, b) ¤ x = É‰u a ² x = Pair‰u (a, b))

   ô µ a b c d· Kp‰u (a, b) = Kp‰u (c, d) ¤ a = c ± b = d
=TEX

Having established that a pair constructor exists using a specific encoding, we can now introduce a new name for a pair constructor which is not tied to this particular coding.
The introduction of this constant involves a consistency proof in which the {\it Kp} is used (script not shown).

\ignore{
=SML
set_goal([], ¬¶ Op‰u: NFU ¸ NFU ­ NFU· µa b c d· Op‰u (a, b) = Op‰u(c, d)
	¤ a = c ± b = d®);
a (¶_tac ¬Kp‰u® THEN accept_tac Kpèuê_eq_Kpèuê_thm);
save_cs_¶_thm(pop_thm());
=TEX
}%ignore

¹HOLCONST
Ü ÛOp‰uİ : NFU ¸ NFU ­ NFU
÷üüüüüü
Ü µa b c d· Op‰u (a, b) = Op‰u (c, d)
Ü	¤ a = c ± b = d
°

\ignore{
=SML
val Op‰u_def = get_spec ¬Op‰u®;

set_goal([], ¬¶ Fst‰u: NFU ­ NFU· µa b· Fst‰u (Op‰u (a, b)) = a®);
a (¶_tac ¬Ìp:NFU· Åa:NFU· ¶b· p = Op‰u(a,b)® THEN rewrite_tac[]);
a (Å_tac ¬Å a'· ¶ b'· Op‰u (a, b) = Op‰u (a', b')®);
(* *** Goal "1" *** *)
a (¶_tac ¬a® THEN ¶_tac ¬b® THEN rewrite_tac[]);
(* *** Goal "2" *** *)
a (REPEAT strip_tac THEN rewrite_tac[Op‰u_def ]);
a (Å_tac ¬Å a''· ¶ b'· a' = a'' ± b'' = b'®);
(* *** Goal "2.1" *** *)
a (¶_tac ¬a'® THEN ¶_tac ¬b''® THEN rewrite_tac[]);
(* *** Goal "2.2" *** *)
a (SYM_ASMS_T rewrite_tac);
save_cs_¶_thm(pop_thm());
=TEX
}%ignore

¹HOLCONST
Ü ÛFst‰uİ : NFU ­ NFU
÷üüüüüü
Ü µa b· Fst‰u (Op‰u (a, b)) = a
°

\ignore{
=SML
val Fstèuê_def = get_spec ¬Fst‰u®;

set_goal([], ¬¶ Snd‰u: NFU ­ NFU· µa b· Snd‰u (Op‰u (a, b)) = b®);
a (¶_tac ¬Ìp:NFU· Åb:NFU· ¶a· p = Op‰u(a,b)® THEN rewrite_tac[]);
a (Å_tac ¬Å b'· ¶ a'· Op‰u (a, b) = Op‰u (a', b')®);
(* *** Goal "1" *** *)
a (¶_tac ¬b® THEN ¶_tac ¬a® THEN rewrite_tac[]);
(* *** Goal "2" *** *)
a (REPEAT strip_tac THEN rewrite_tac[Op‰u_def ]);
a (Å_tac ¬Å b''· ¶ a'· a' = a'' ± b'' = b'®);
(* *** Goal "2.1" *** *)
a (¶_tac ¬b'® THEN ¶_tac ¬a''® THEN rewrite_tac[]);
(* *** Goal "2.2" *** *)
a (LEMMA_T ¬(Ìb''· ¶ a'· a'' = a' ± b' = b'') = (Ìb''·¶ a'· a' = a'' ± b'' = b')® asm_tac
	THEN1 (strip_tac THEN strip_tac THEN rewrite_tac[] THEN REPEAT strip_tac));
(* *** Goal "2.2.1" *** *)
a (¶_tac ¬a''® THEN asm_rewrite_tac[]);
(* *** Goal "2.2.2" *** *)
a (¶_tac ¬a''® THEN asm_rewrite_tac[]);
(* *** Goal "2.2.3" *** *)
a (asm_rewrite_tac[]);
save_cs_¶_thm(pop_thm());
=TEX
}%ignore

¹HOLCONST
Ü ÛSnd‰uİ : NFU ­ NFU
÷üüüüü
Ü µa b· Snd‰u (Op‰u (a, b)) = b
°

\subsubsection{Cartesian Products}

First we assert the existence of cartesian products:

=SML
val Sndèuê_def = get_spec ¬Snd‰u®;

new_const("¸‰u",”NFU ­ NFU ­ NFU®);
declare_infix(300, "¸‰u");
val Cart_prod_ax = new_axiom(["Cart_prod_ax"], 
	¬µa b· Set‰u(a ¸‰u b) ± µz· z ‰u a ¸‰u b ¤ ¶x y· z = Op‰u(x,y) ± x ‰u a ± y ‰u b®);
=TEX

\subsection{The Theory of Relations}

A relation is a set of ordered pairs.

¹HOLCONST
Ü ÛRel‰uİ : NFU ­ BOOL
÷üüüüüü
Ü µr· Rel‰u r ¤ µx· x ‰u r ´ µy z· x = Op‰u(y, z)
°

Every relation has an inverse.

=SML
val Relèuê_def = get_spec ¬Rel‰u®;

new_const("›-›1‰u", ”NFU ­ NFU®);
declare_postfix (320, "›-›1‰u");
val rel_inv_ax = new_axiom (["rel_inv_ax"],
	¬µr· Set‰u(r ›-›1‰u) ± µx· x ‰u r ›-›1‰u ¤ ¶y z· x = Op‰u(y, z) ± Op‰u(z, y) ‰u r®);
=TEX

Relations can be composed.
Relational composition is also known as relational product.

=SML
new_const("»‰u", ”NFU ­ NFU ­ NFU®);
declare_infix (300, "»‰u");
val rel_comp_ax = new_axiom (["rel_comp_ax"], ¬µr s· Set‰u(r »‰u s)
	± µx· x ‰u r »‰u s ¤ ¶u v w· x = Op‰u(u, w) ± Op‰u(u, v) ‰u r ± Op‰u(v, w) ‰u s®);
=TEX

The domain of a relation is a set.

=SML
new_const("dom‰u", ”NFU ­ NFU®);
val domèuê_ax = new_axiom (["domèuê_ax"],
	¬µr· Set‰u(dom‰u r) ± µx· x ‰u dom‰u r ¤ ¶y· Op‰u(x, y) ‰u r®);
=TEX

So is the range.

¹HOLCONST
Ü Ûrng‰uİ : NFU ­ NFU
÷üüüüüü
Ü µr· rng‰u r = dom‰u (r ›-›1‰u)
°

¹HOLCONST
Ü Ûfield‰uİ : NFU ­ NFU
÷üüüüüü
Ü µr· field‰u r = (dom‰u r) À‰u (rng‰u r)
°

Singleton images exists as follows:

=SML
val rngèuê_def = get_spec ¬rng‰u®;
val fieldèuê_def = get_spec ¬field‰u®;

new_const("si‰u", ”NFU ­ NFU®);
val sièuê_ax = new_axiom (["sièuê_ax"],
	¬µr· si‰u r = •‰u {z | ¶x y· Op‰u(x, y) ‰u r ± z = Op‰u(É‰u x, É‰u y)}®);
=TEX

=SML
val diag_ax = new_axiom(["diag_ax"], ¬¶‰u {z | ¶x· z = Op‰u(x, x)}®);
val left_proj_ax = new_axiom(["left_proj_ax"], ¬¶‰u {z | ¶x y· z = Op‰u(Op‰u(x, y), x)}®);
val right_proj_ax = new_axiom(["right_proj_ax"], ¬¶‰u {z | ¶x y· z = Op‰u(Op‰u(x, y), y)}®);
=TEX

\subsection{Introducing Functions}

Here I may begin to diverge more from Holmes, since the material on functions does not contribute to the axiom system, and I have in mind the use of functions in the appication of NFU to the construction of category theoretic foundations.

A function is a many-one relation:

¹HOLCONST
Ü ÛManyOne‰uİ : NFU ­ BOOL
÷üüüüüü
Ü µr· ManyOne‰u r ¤ µx· x ‰u dom‰u r ´
Ü	µy z· Op‰u(x, y) ‰u r ± Op‰u(x, z) ‰u r ´ y = z   
°

Identity functions will prove useful later:

¹HOLCONST
Ü ÛId‰uİ : NFU ­ NFU
÷üüüüüü
Ü µa· Id‰u a = •‰u {x | ¶y· y ‰u a ± x = Op‰u(y, y)}  
°

Function application is an infix suffix {\it u}.

=SML
declare_infix (320, "‰u");
=TEX

¹HOLCONST
Ü $Û‰uİ : NFU ­ NFU ­ NFU
÷üüüüüü
Ü µf a v· Op‰u(a, v) ‰u f ´ f ‰u a = v 
°

\subsection{Pre-Functors}

This section is not from Holmes.
A functor is a function from one category to another which respects the structure on the category.
When considered as an arrow in a category each functor has a definite codomain but need not be onto, and though it has a definite domain, it must be total, and so the domain can be recovered from the graph of the function.

If we ignore the requirement for preservation of structure, then we get a notion of pre-functor which is similar to that of a function except that it carries with it its codomain.
Thus, we may represent a pre-functor as an ordered pair of which the first element is the graph of a function, and the second is a set which includes the range of the function.

¹HOLCONST
Ü ÛPreFunctor‰uİ : NFU ­ BOOL
÷üüüüüü
Ü µp· PreFunctor‰u p ¤ ¶x y· p = Op‰u(x, y) ± Rel‰u x ± ManyOne‰u x ± rng‰u x €‰u y   
°

We define functions giving the graph, domain and codomain and field of a pre-functor and for application and composition of prefunctors.

¹HOLCONST
Ü ÛPFgraph‰uİ : NFU ­ NFU
÷üüüüüü
Ü PFgraph‰u = Fst‰u   
°

¹HOLCONST
Ü ÛPFdom‰uİ : NFU ­ NFU
÷üüüüüü
Ü µp· PFdom‰u p = dom‰u (PFgraph‰u p)   
°

¹HOLCONST
Ü ÛPFcod‰uİ : NFU ­ NFU
÷üüüüüü
Ü PFcod‰u = Snd‰u
°

¹HOLCONST
Ü ÛPFfield‰uİ : NFU ­ NFU
÷üüüüüü
Ü µp· PFfield‰u p = PFdom‰u p À‰u PFcod‰u p
°

\ignore{
=SML
val PFgraphèuê_def = get_spec ¬PFgraph‰u®;
val PFdomèuê_def = get_spec ¬PFdom‰u®;
val PFcodèuê_def = get_spec ¬PFcod‰u®;
val PFfieldèuê_def = get_spec ¬PFfield‰u®;
=TEX
}%ignore

=SML
declare_infix(300, "»‰p");
=TEX

This composition operator does not check that the pre-functors being compose have matching `types'.

¹HOLCONST
Ü $Û»‰pİ : NFU ­ NFU ­ NFU
÷üüüüüü
Ü µp q· p »‰p q = Op‰u((PFgraph‰u p) »‰u (PFgraph‰u q), PFcod‰u q)   
°

The identity pre-functor over some set is:

¹HOLCONST
Ü ÛPFid‰uİ : NFU ­ NFU
÷üüüüüü
Ü µa· PFid‰u a = Op‰u(Id‰u a, a)   
°

We can now define the left and right identities for a pre-functor.

¹HOLCONST
Ü ÛPFleft‰uİ : NFU ­ NFU
÷üüüüüü
Ü µa· PFleft‰u a = PFid‰u (PFdom‰u a)   
°

¹HOLCONST
Ü ÛPFright‰uİ : NFU ­ NFU
÷üüüüüü
Ü µa· PFright‰u a = PFid‰u (PFcod‰u a)   
°

Pre-functor composition is an infix suffix {\it p}.

=SML
declare_infix (320, "‰p");
=TEX

¹HOLCONST
Ü $Û‰pİ : NFU ­ NFU ­ NFU
÷üüüüüü
Ü µp c d· Op‰u(c, d) ‰u (PFgraph‰u p) ´ p ‰u c = d 
°

\ignore{

\subsection{Proof Contexts}

A proof context is a collection of theorems, tactics and other proof machinary suitable for reasoning in some particular context.
To make reasoning in NFU reasonably convenient a proof context for NFU is essential.

\subsubsection{Principles}

The only principle I know of which assists with elementary proofs in set theory is the principle that set theoretic conjectures can be reduced to the predicate calculus by using extensional rules for relations and for operators.

Too hasty a reduction can be overkill and may convert a simple conjecture into an unintelligible morass.
We have sometimes in the past used made available two proof contexts, an aggressive extensional one, and a milder non-extensional one.
However, the extensional rules for the operators are fairly harmless, expansion is triggered by the extensional rules for the relations (equality and subset), so a proof context containing the former together with a suitable theorem for the latter gives good control.

So the main purpose of the proof context is to make really obvious rewrites happen by defailt (e.g. taking the first element of an ordered pair), to do the obvious thing whenever there is an obvious reduction of a membership predication with an operator on the right.
Treating relations extensionally, which introduces membership predicates triggering further simplification, can be done without the aid of a specific proof context.

The other point to mention is inductive proofs, which are beyond us unless an induction principle can be identified, which will not happen unless some axiom is introduced.
The axiom of regularity is not available, and presumably actually refutable.
Forster's suggestion of an axiom of pseudo-wellfouneation might be a good idea, if this were not realised in the only application of interest to us here, without depending on it being asserted in NFU.
So induction principles will not appear in our NFU. but will appear in later theories.

\subsubsection{Theorems Used Recklessly}

This is pretty much guesswork, only time will tell whether this is the best collection.

=SML
val nfu_thms = [
	šèuê_ax,	çcêèuê_ax,	Àèuê_ax,
	Ş‰u_ax,	Urèuê_def,	Op‰u_def,
	Fstèuê_def,	Sndèuê_def,	èuêVèuê_thm,
	¡èuê_thm,	šèuê_€èuê_thm,	Éèuê_thm,
	Éèuê_eq_thm,	Pairèuê_thm,	Éèuê_eq_Pairèuê_thm,
	Pairèuê_eq_Éèuê_thm,	Pairèuê_eq_Pairèuê_thm
	];

val nfu_opext_clauses =
	(all_µ_intro
	o list_±_intro
	o (map all_µ_elim))
	nfu_thms;

save_thm ("nfu_opext_clauses", nfu_opext_clauses);
=TEX

\subsubsection{Theorems Used Cautiously}

The following theorems are too aggressive for general use in the proof context but are needed when attempting automatic proof.
When an extensional proof is appropriate it can be initiated by a cautious (i.e. a "once") rewrite using the following clauses, after which the extensional rules in the proof context will be triggered.
=GFT
val nfu_relext_clauses =
	(all_&forall;_intro
	o list_&and;_intro
	o (map all_&forall;_elim))
	[gs_ext_axiom,
	get_spec&qqtel;$&sube;<sub>g</sub>&qqter;];
save_thm ("nfu_relext_clauses", nfu_relext_clauses);
=TEX
There are a number of important theorems, such as well-foundedness and galaxy closure which have not been mentioned in this context.
The character of these theorems makes them unsuitable for the proof context, their application requires thought.

The basic proof automation is augmented by adding a preliminary rewrite with the relational extensionality clauses.
=SML
fun nfu_prove_conv thl =
	basic_prove_conv thl;
=TEX

=SML
add_rw_thms nfu_thms "nfu";
add_sc_thms nfu_thms "nfu";
add_st_thms nfu_thms "nfu";
set_pr_conv nfu_prove_conv "nfu";
set_pr_tac
	(conv_tac o nfu_prove_conv)
	"nfu";
commit_pc "nfu";
=TEX

Using the proof context "nfu" some elementary results in NFU are now provable automatically on demand.
For this reason it is not necessary to prove in advance of needing them results such as the associativity of intersection, since they can be proven when required by an expression of the form "prove rule[] term" which proves {\it term} and returns it as a theorem.
If the required proof context for doing this is not in place the form "merge\_pcs\_rule ["basic\_hol", gst-ax"] (prove\_rule []) term" may be used.
Since this is a little cumbersome we define the function "gst\_ax\_rule" and illustrate its use as follows:

=SML
val nfu_rule =
	(merge_pcs_rule1
	["basic_hol", "nfu"]
	prove_rule) [];
val nfu_conv = 
	MERGE_PCS_C1
	["basic_hol", "nfu"]
	prove_conv;
val nfu_tac =
	conv_tac o nfu_conv;

=IGN
nfu_rule ¬®
=TEX
}%ignore

\section{PSEUDO-HEREDITARILY COLLECTIONS}

The aspects of this which are independent of a specific set theory are done in the new theory ``PI''.

=SML
open_theory "rbjmisc";
force_new_theory "PI";
set_merge_pcs["hol1", "'savedthm_cs_¶_proof"];
=TEX

\subsection{Well Foundedness and Hereditarily Collections}

It would be a good idea eventually to define these first and check back that they are special cases of the pseudo versions and that the well-founded functor/category collections are contained in the pseudo-well-founded collections.

Here is a stab at a {\it hereditarily P} construction suitably generalised.

¹HOLCONST
Ü ÛHereditarilyPQİ : (('X ­ 'X ğ) ¸ ('X ­ 'X ğ) ¸ ('X ­ BOOL) ¸ ('X ­ BOOL)) 
Ü		­ ('X ğ ¸ 'X ğ)
÷üüüüüü
Ü µc d P Q· HereditarilyPQ (c, d, P, Q) = 
Ü	(¥ {X' | µx· P x ± (µy z· y  (c x) ± z  (d y) ´ Q y ± z  X') ´ x  X'},
Ü	 ¥ {Y' | µx· Q x ± (µy z· y  (d x) ± z  (c y) ´ P y ± z  Y') ´ x  Y'})
°

\subsection{Pseudo-Well-Founded Collections}

I have previously done the kind of category theoretic construction in well-founded set theories.
The same method could be used here, but the result would be similar, the constructed domains would still be well-founded.

I am therefore hoping to extract from Forster's discussion about pseudo-induction some idea about how to do the construction without throwing away the non-well-founded sets.

First we define the concept ``pseudo-well-founded''.
The set theoretic language here (membership relation and power set) is the one which comes with ProofPower HOL (and is set theoretic syntax for predicates in a type theory), the target set theory is modelled as a membership relation (r) over some type (*X).
This is based on the definition in Thomas Forster's book, and is included mainly for reference.

The presentation has been restructured.
The restructuring serves three purposes.
The first is to expose the two classes which partition the universe so that we can talk about them (in the original they are existentially quantified in the definition.
This is done by splitting the definition into two parts, the existential quantification appearing in the second.
The second is to include the claim that these two classes exhaust the type under consideration in the second part, so that the first definition can still be used in a set theory which is not known to be pseudo-well-founded for talking about its pseudo-well-founded part.
Otherwise we would have to add an axiom to NFU for the construction we have in mind.
The third change is to split our definitions of {\it I\_closed} and {\it II\_closed}, to make the structure of proofs more transparent.

¹HOLCONST
Ü ÛI_closedİ : ('X ­ 'X ­ BOOL) ­ 'X ğ ­ BOOL
÷üüüüüü
Ü µr w· I_closed r w
Ü	¤ µx· (¶y· r y x ± µz· r z y ´ z  w) ´ x  w
°
¹HOLCONST
Ü ÛII_closedİ : ('X ­ 'X ­ BOOL) ­ 'X ğ ­ BOOL
÷üüüüüü
Ü µr w· II_closed r w
Ü	¤ µx· (µy· r y x ´ ¶z· r z y ± z  w) ´ x  w
°
¹HOLCONST
Ü ÛI_closureİ : ('X ­ 'X ­ BOOL) ­ 'X ğ
÷üüüüüü
Ü µr· I_closure r = ¥{x | I_closed r x}
°
¹HOLCONST
Ü ÛII_closureİ : ('X ­ 'X ­ BOOL) ­ 'X ğ
÷üüüüüü
Ü µr· II_closure r = ¥{x | II_closed r x}
°

¹HOLCONST
Ü ÛPseudoWellFoundedİ : ('X ­ 'X ­ BOOL) ­ BOOL
÷üüüüüü
Ü µr· PseudoWellFounded r ¤
Ü	(I_closure r) ¡ (II_closure r) = {}
Ü   ±	(I_closure r) À (II_closure r) = Universe
°

\ignore{
=SML
val I_closed_def = get_spec ¬I_closed®;
val II_closed_def = get_spec ¬II_closed®;
val I_closure_def = get_spec ¬I_closure®;
val II_closure_def = get_spec ¬II_closure®;
val PseudoWellFounded_def = get_spec ¬PseudoWellFounded®;
=IGN
set_goal([], ¬µr ia iia ib iib· PWFC r (ia, iia) ± PWFC r (ib, iib) ´ ia = ib ± iia = iib®);
a (REPEAT µ_tac THEN rewrite_tac [PWFC_def]);
a (REPEAT strip_tac);
(* *** Goal "1" *** *)
a (lemma_tac ¬µ x· (¶ y· r y x ± (µ z· r z y ´ z  ib)) ´ x  ib®);
a (REPEAT strip_tac);

a (spec_nth_asm_tac 5 ¬ib®);
=TEX
}%ignore

The idea is to use this to define a notion of "pseudo-hereditarily P" set for a property of sets P, analogously to the notion of a "heridtarily P" set in a well-founded set theory.

This is a bit too simplistic, because the idea of heriditarily P sets is {\it thin} in the following sense.
To prove that a set is hereditarily P you need only to know that each of its members is hereditarily P.
So, in a sense you are only looking one level down.
When you do this with categories and functors the categories and functors alternate as the rank increases.
You either need mutually recursive definitions or else the independent definitions of categories and functors have to look down two levels to express the required condition.
There is already something like this going on in the pseudo-well-foundedness condition.
I've no idea at present whether these work together or not.

\subsection{Pseudo-Well-Founded-PQ Collections}

This is derived from pseudo-well-foundedness by the following generalisations:

\begin{itemize}
\item instead of looking down one level at a time according to the membership relation, the property is parameterised by a function which extracts the `content' from an object.
This might be just the members, or it might be, say, the field of a function.
\item for each of the two classes in question there is an additional parameterised property which is required to be satisfied.
\end{itemize}

Note that we have apparently lost the membership relation here, which is effectively hidden in the content extractors {\it c} and {\it d}.

The structure of this definition is now broken down similarly to that of {\it PseudoWellFounded}.

¹HOLCONST
Ü ÛP_closedİ : (('X ­ 'X ğ) ¸ ('X ­ 'X ğ) ¸ ('X ­ BOOL) ¸ ('X ­ BOOL))
		­ 'X ğ ­ BOOL
÷üüüüüü
Ü µc d P Q w· P_closed (c, d, P, Q) w
Ü	¤ µx· P x ± (µy· y  (c x) ´ Q y ± (¶z· z  (d y) ± z  w)) ´ x  w
°

¹HOLCONST
Ü ÛQ_closedİ : (('X ­ 'X ğ) ¸ ('X ­ 'X ğ) ¸ ('X ­ BOOL) ¸ ('X ­ BOOL))
		­ 'X ğ ­ BOOL
÷üüüüüü
Ü µc d P Q w· Q_closed (c, d, P, Q) w
Ü	¤ µx· Q x ± (¶y· y  (d x) ± P y ± µz· z  (c y) ´ z  w) ´ x  w
°
¹HOLCONST
Ü ÛP_closureİ : (('X ­ 'X ğ) ¸ ('X ­ 'X ğ) ¸ ('X ­ BOOL) ¸ ('X ­ BOOL))
		­ 'X ğ
÷üüüüüü
Ü µz· P_closure z = ¥{x | P_closed z x}
°
¹HOLCONST
Ü ÛQ_closureİ : (('X ­ 'X ğ) ¸ ('X ­ 'X ğ) ¸ ('X ­ BOOL) ¸ ('X ­ BOOL))
		­ 'X ğ
÷üüüüüü
Ü µz· Q_closure z = ¥{x | Q_closed z x}
°

¹HOLCONST
Ü ÛPseudoWellFoundedPQİ :
Ü	(('X ­ 'X ğ) ¸ ('X ­ 'X ğ) ¸ ('X ­ BOOL) ¸ ('X ­ BOOL)) ­ BOOL
÷üüüüüü
Ü µz· PseudoWellFoundedPQ z ¤
Ü	(P_closure z) ¡ (Q_closure z) = {}
Ü   ±	(P_closure z) À (Q_closure z) = Universe
°

Need to check that this encompasses pseudo-well-foundedness when suitably parameterised and that the `pseudo' bit only makes a difference for non-well-founded membership structures.

\ignore{
=SML
val P_closed_def = get_spec ¬P_closed®;
val Q_closed_def = get_spec ¬Q_closed®;
val P_closure_def = get_spec ¬P_closure®;
val Q_closure_def = get_spec ¬Q_closure®;
val PseudoWellFoundedPQ_def = get_spec ¬PseudoWellFoundedPQ®;

set_goal([], ¬µc d P Q x· x  P_closure (c, d, P, Q) ´ P x®);
a (REPEAT µ_tac THEN rewrite_tac[P_closure_def, P_closed_def]
	THEN REPEAT strip_tac);
a (spec_nth_asm_tac 1 ¬{x | P x}®);
val P_closed_´_P_thm = save_pop_thm "P_closed_´_P_thm";

set_goal([], ¬µc d P Q x· x  Q_closure (c, d, P, Q) ´ Q x®);
a (REPEAT µ_tac THEN rewrite_tac[Q_closure_def, Q_closed_def]
	THEN REPEAT strip_tac);
a (spec_nth_asm_tac 1 ¬{x | Q x}®);
val Q_closed_´_Q_thm = save_pop_thm "Q_closed_´_Q_thm";

=IGN
set_goal([], ¬µc d P Q· P_closed (c, d, P, Q) (P_closure (c, d, P, Q))®);
a (REPEAT µ_tac THEN rewrite_tac[P_closed_def]
	THEN REPEAT strip_tac);
a (rewrite_tac[P_closure_def, P_closed_def] THEN REPEAT strip_tac);
a (asm_fc_tac[]);
a (spec_nth_asm_tac 4 ¬y®);
a (spec_nth_asm_tac 3 ¬z®);
a (spec_nth_asm_tac 6 ¬z®);
(* *** Goal "1" *** *)
a (all_fc_tac [P_closed_´_P_thm]);
(* *** Goal "2" *** *)
a (spec_nth_asm_tac 9 ¬y'®);
a (lemma_tac ¬P z® THEN1 all_fc_tac [P_closed_´_P_thm]);

a (asm_fc_tac[]);

val P_closed_´_P_thm = save_pop_thm "P_closed_´_P_thm";
=TEX
}%ignore

=GFT
P_closed_´_P_thm = ô µ c d P Q x· x  P_closure (c, d, P, Q) ´ P x

Q_closed_´_Q_thm = ô µ c d P Q x· x  Q_closure (c, d, P, Q) ´ Q x
=TEX

\subsection{Pseudo-Hereditarily-PQ Collections}

Even if we had a pseudo-well-founded universe in NFU, it would not be pseudo-well-founded-PQ for any interesting or useful properties P and Q.
The whole idea is to use these properties to create a pair of useful subclasses of the universe.
So what we want to do is just take the two closures resulting from P and Q, and use their union as new a psuedo-well-founded domain of discourse.
In fact, we won't take the union at all, we will be looking for a two-sorted foundational theory.

¹HOLCONST
Ü ÛPseudoHereditarilyPQİ :
Ü	(('X ­ 'X ğ) ¸ ('X ­ 'X ğ) ¸ ('X ­ BOOL) ¸ ('X ­ BOOL)) ­ ('X ğ ¸ 'X ğ)
÷üüüüüü
Ü µz· PseudoHereditarilyPQ z = (P_closure z, Q_closure z)
°

Among the important properties which we hope this construction will have are:

\begin{itemize}
\item The values in the left collection will all have property P.
\item The values in the right collection will all have property Q.
\item Both collections will include the corresponding {\it HereditarilyPQ} sets.
\end{itemize}

I am by no means confident of any of these features at present.

\section{PWF CATEGORIES AND FUNCTORS}

\subsection{Meta-Theory}

Now we define the properties and content functions corresponding to concrete categories and functors.
This could be done by defining a function which takes a membership relation as an argument and returns a full set of four values for use with the function {\it PseudoCDPQHeredirary}.
However, this involves additional effort which would only be repaid if the construction were used over multiple set theories so I shall begin with a more direct definition.

The intention is that when the two collections have been defined they will be used to create two new types, and that theorems would then be proven about those types which would be suitable for an independent axiomatisation of the theories (for use as a foundation system).
This all involves quite a bit of reasoning which strictly belongs to the metatheory and would best not stored in the same theories as contain then object theory.
I will therefore create a theory {\it meta\_cf} which will contain the `metatheory' and put the theory itself in theory {\it cf} (for Categories and Functors).
I propose to base the construction on NFU.

=SML
force_new_theory "meta_cf";
new_parent "NFU";
=IGN
open_theory "NFU";
set_merge_pcs["hol1", "'savedthm_cs_¶_proof"];
=TEX

Since these sets (the categories and functors) are expected to be disjoint, at most (hopefully exactly) one of them will contain the empty set.
In our scheme the empty set is a category (but not a functor, functors will all be ordered pairs).
Looking at our definition of hereditarily above we see that the empty set can only be a member of the left hand collection, and so (c,P) must be the content function and characterising property for the categories and (d,Q) are those for functors.

A concrete category (here) is a set of functors (the arrows) which is closed under composition (where the domain and codomains match) and includes the identity functors on the domain and codomain of each functor.
Composition is the same operation in all categories, and is associative as here defined.

A concrete functor is an ordered pair of which:
\begin{itemize}
\item the first element is a many-one relation
\item the second element is a set which includes the right field of the relation
\item the mapping defined by the first element over its domain respects composition on that domain
\end{itemize}

Note that the codomain is explicit in the right hand element of the functor, the domain is recovered from the graph on the left, hence all functors are total.

¹HOLCONST
Ü ÛCatPropİ : NFU ­ BOOL
÷üüüüüü
Ü µa· CatProp a ¤
Ü	(µb· b ‰u a ´ PFleft‰u b ‰u a ± PFright‰u b ‰u a)
Ü  ±	(µb c· b ‰u a ± c ‰u a ± PFdom‰u c = PFcod‰u b ´ (b »‰p c) ‰u a)
°

This function returns the set of functors in a category.

¹HOLCONST
Ü ÛCatConİ : NFU ­ NFU ğ
÷üüüüüü
Ü µa· CatCon a = {f | f ‰u a}
°

¹HOLCONST
Ü ÛFuncPropİ : NFU ­ BOOL
÷üüüüüü
Ü µa· FuncProp a ¤
Ü	rng‰u (PFgraph‰u a) €‰u (PFcod‰u a)
Ü  ±	(µb c· b ‰u PFdom‰u a ± c ‰u PFdom‰u a ± PFcod‰u b = PFdom‰u c
Ü		´ Op‰u (b »‰p c, (a ‰p b) »‰u (a ‰p c)) ‰u a)
°

This function returns the set of categories in the field of a functor.

¹HOLCONST
Ü ÛFuncConİ : NFU ­ NFU ğ
÷üüüüüü
Ü µf· FuncCon f = {PFdom‰u f; PFcod‰u f}
°

We are now in a position to define the sets of pseudo-well-founded categories and functors.

¹HOLCONST
Ü ÛPWFcfİ : NFU ğ ¸ NFU ğ
÷üüüüüü
Ü PWFcf = PseudoHereditarilyPQ (CatCon, FuncCon, CatProp, FuncProp)
°

We need them as properties for introducing types.

¹HOLCONST
Ü ÛPWFcategoryİ : NFU ­ BOOL
÷üüüüüü
Ü PWFcategory = Ìc· c  (Fst PWFcf)
°

¹HOLCONST
Ü ÛPWFfunctorİ : NFU ­ BOOL
÷üüüüüü
Ü PWFfunctor = Ìf· f  (Snd PWFcf)
°

In order to use these properties to introducing new types we have to prove that they are non-empty.
Its useful to keep the theorems for the specific witnesses, the empty categort and the trivial functor.

\ignore{
=SML
val CatCon_def = get_spec ¬CatCon®;
val CatProp_def = get_spec ¬CatProp®;
val FuncCon_def = get_spec ¬FuncCon®;
val FuncProp_def = get_spec ¬FuncProp®;
val P_closed_def = get_spec ¬P_closed®;
val Q_closed_def = get_spec ¬Q_closed®;
val P_closure_def = get_spec ¬P_closure®;
val Q_closure_def = get_spec ¬Q_closure®;
val PseudoHereditarilyPQ_def = get_spec ¬PseudoHereditarilyPQ®;
val PWFcf_def = get_spec ¬PWFcf®;
val PWFcategory_def = get_spec ¬PWFcategory®;
val PWFfunctor_def = get_spec ¬PWFfunctor®;

set_goal([], ¬PWFcategory š‰u®);
a (rewrite_tac[PWFcategory_def, PWFcf_def, PseudoHereditarilyPQ_def,
	P_closure_def, Q_closure_def, P_closed_def, Q_closed_def, CatCon_def]
	THEN REPEAT strip_tac);
a (strip_asm_tac šèuê_ax);
a (spec_nth_asm_tac 2 ¬š‰u® THEN_TRY asm_fc_tac[]);
a (swap_nth_asm_concl_tac 1);
a (asm_rewrite_tac [CatProp_def]);
val pwf_cat_š‰u_thm = save_pop_thm "pwf_cat_š‰u_thm";

set_goal([], ¬¶a· PWFcategory a®);
a (¶_tac ¬š‰u® THEN accept_tac pwf_cat_š‰u_thm);
val ¶_pwf_cat_thm = save_pop_thm "¶_pwf_cat_thm";

set_goal([], ¬PWFfunctor (Op‰u(š‰u, š‰u))®);
a (rewrite_tac[PWFfunctor_def, PWFcf_def, PseudoHereditarilyPQ_def,
	P_closure_def, Q_closure_def, P_closed_def, Q_closed_def, CatCon_def]
	THEN REPEAT strip_tac);
a (spec_nth_asm_tac 1 ¬Op‰u (š‰u, š‰u)®);
(* *** Goal "1" *** *)
a (swap_nth_asm_concl_tac 1);
a (rewrite_tac [FuncProp_def]);
a (strip_tac);
(* *** Goal "1.1" *** *)
a (rewrite_tac[PFgraphèuê_def, Fstèuê_def, rngèuê_def, domèuê_ax, PFcodèuê_def, Sndèuê_def]);
a (lemma_tac ¬Set‰u(dom‰u (š‰u ›-›1‰u)) ± Set‰u(š‰u)® THEN1 rewrite_tac [Setèuê_def, domèuê_ax]);
a (rewrite_tac[€èuê_def] THEN µ_tac THEN rewrite_tac[domèuê_ax, šèuê_ax, rel_inv_ax]);
(* *** Goal "1.2" *** *)
a (rewrite_tac[PFdomèuê_def, PFgraphèuê_def, Fstèuê_def, domèuê_ax, šèuê_ax]);
(* *** Goal "2" *** *)
a (swap_nth_asm_concl_tac 1);
a (strip_tac);
a (¶_tac ¬š‰u®);
a (rewrite_tac[FuncCon_def, CatProp_def, PFgraphèuê_def, PFdomèuê_def, PFcodèuê_def,
	Fstèuê_def, Sndèuê_def, domèuê_ax, šèuê_ax]);
val š_pwf_func_thm = save_pop_thm "š_pwf_func_thm";

set_goal([], ¬¶a· PWFfunctor a®);
a (¶_tac ¬Op‰u(š‰u, š‰u)® THEN accept_tac š_pwf_func_thm);
val ¶_pwf_func_thm = save_pop_thm "¶_pwf_func_thm";
=TEX
}%ignore

=GFT
pwf_cat_š‰u_thm = 	ô PWFcategory š‰u

¶_pwf_cat_thm = 	ô ¶ a· PWFcategory a

š_pwf_func_thm = 	ô PWFfunctor (Op‰u(š‰u, š‰u))

¶_pwf_func_thm = 	ô ¶ a· PWFfunctor a
=TEX

\subsection{Object Theory}

Now we introduce a new theory in which the types of pseudo-well-founded categories and functors are defined, and whose theories are intended to be a suitable independent axiomatisation for a two-sorted foundation system for which these two types supply a model. 

=SML
open_theory "meta_cf";
force_new_theory "cf";
force_new_pc "cf";
new_type_defn(["CAT"], "CAT", [], ¶_pwf_cat_thm);
new_type_defn(["FUNC"], "FUNC", [], ¶_pwf_func_thm);
=TEX


\ignore{
=SML
=TEX
} %ignore

\ignore{
=SML
=TEX
} %ignore

\ignore{
 ¹HOLCONST
Ü Ûİ :
÷üüüüüü
Ü
 °
} %ignore

{\let\Section\section
\newcounter{ThyNum}
\def\section#1{\Section{#1}
\addtocounter{ThyNum}{1}\label{Theory\arabic{ThyNum}}}
\include{NF.th}
}  %\let

{\let\Section\section
\def\section#1{\Section{#1}
\addtocounter{ThyNum}{1}\label{Theory\arabic{ThyNum}}}
\include{NFU.th}
}  %\let

{\let\Section\section
\def\section#1{\Section{#1}
\addtocounter{ThyNum}{1}\label{Theory\arabic{ThyNum}}}
\include{PI.th}
}  %\let

{\let\Section\section
\def\section#1{\Section{#1}
\addtocounter{ThyNum}{1}\label{Theory\arabic{ThyNum}}}
\include{meta_cf.th}
}  %\let

{\let\Section\section
\def\section#1{\Section{#1}
\addtocounter{ThyNum}{1}\label{Theory\arabic{ThyNum}}}
\include{cf.th}
}  %\let

\twocolumn[\section{INDEX}\label{index}]
{\small\printindex}

\end{document}
=SML
open_theory "NF";
output_theory{out_file="NF.th.doc", theory="NF"};
open_theory "NFU";
output_theory{out_file="NFU.th.doc", theory="NFU"};
open_theory "PI";
output_theory{out_file="PI.th.doc", theory="PI"};
open_theory "meta_cf";
output_theory{out_file="meta_cf.th.doc", theory="meta_cf"};
open_theory "cf";
output_theory{out_file="cf.th.doc", theory="cf"};
=IGN