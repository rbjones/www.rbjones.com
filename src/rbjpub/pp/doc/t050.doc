=TEX
\ignore{
=VDUMP t050i.tex
\hypersetup{pdfkeywords=RogerBishopJones}

Last Change $ $Date: 2013/01/03 17:12:44 $ $

$ $Id: t050.doc,v 1.1 2013/01/03 17:12:44 rbj Exp $ $
=TEX
}%ignore

This is first a rough transcription into ProofPower of the simple HOL4 proof of the Church Rosser theorem for the pure combinatory logic, eventually perhaps to be upgraded to an illative combinatory logic.

Since we don't have a datatype package I will follow my own usual practice of using a set theoretic approach to the syntax.


=SML
open_theory "misc3";
force_new_theory "ÛiclÝ";
force_new_pc Û"'icl"Ý;
merge_pcs ["'savedthm_cs_¶_proof"] "'icl";
=IGN
new_parent "equiv";
=SML
set_merge_pcs ["misc31", "'icl"];
=TEX

\section{Combinatory Terms}

\subsection{Introduction}

In hol4 the syntax of combinatory logic is give as a single line definition of a recursive datatype.
We can't do this in ProofPower, datatypes have to be manually cranked.
This section replicates that process, and aims to replicate pretty closely what hol4 produces for that datatype.

I did first of all modify the type to allow any number of combinatory constants after which the definition read:

=GFT hol4
val _ = Hol_datatype `CT = C of num | # of CT => CT`;
=TEX

The theory resulting from that datatype definition is as follows:

=GFT hol4
Theory: cl

Parents:
    list

Type constants:
    CT 0

Term constants:
    #    :CT -> CT -> CT
    C    :num -> CT
    CT_case    :(num -> Á) -> (CT -> CT -> Á) -> CT -> Á
    CT_size    :CT -> num

Definitions:
    CT_TY_DEF
    |- ¶rep.
         TYPE_DEFINITION
           (Ìa0'.
              µ'CT' .
                (µa0'.
                   (¶a.
                      a0' =
                      (Ìa. ind_type$CONSTR 0 a (Ìn. ind_type$BOTTOM))
                        a) ²
                   (¶a0 a1.
                      (a0' =
                       (Ìa0 a1.
                          ind_type$CONSTR (SUC 0) ARB
                            (ind_type$FCONS a0
                               (ind_type$FCONS a1
                                  (Ìn. ind_type$BOTTOM)))) a0 a1) ±
                      'CT' a0 ± 'CT' a1) ´
                   'CT' a0') ´
                'CT' a0') rep
    CT_case_def
    |- (µf f1 a. CT_case f f1 (C a) = f a) ±
       µf f1 a0 a1. CT_case f f1 (# a0 a1) = f1 a0 a1
    CT_size_def
    |- (µa. CT_size (C a) = 1 + a) ±
       µa0 a1. CT_size (# a0 a1) = 1 + (CT_size a0 + CT_size a1)

Theorems:
    datatype_CT  |- DATATYPE (CT C #)
    CT_11
    |- (µa a'. (C a = C a') ¤ (a = a')) ±
       µa0 a1 a0' a1'. (# a0 a1 = # a0' a1') ¤ (a0 = a0') ± (a1 = a1')
    CT_distinct  |- µa1 a0 a. C a ½ # a0 a1
    CT_case_cong
    |- µM M' f f1.
         (M = M') ± (µa. (M' = C a) ´ (f a = f' a)) ±
         (µa0 a1. (M' = # a0 a1) ´ (f1 a0 a1 = f1' a0 a1)) ´
         (CT_case f f1 M = CT_case f' f1' M')
    CT_nchotomy  |- µCC. (¶n. CC = C n) ² ¶C C0. CC = # C C0
    CT_Axiom
    |- µf0 f1.
         ¶fn.
           (µa. fn (C a) = f0 a) ±
           µa0 a1. fn (# a0 a1) = f1 a0 a1 (fn a0) (fn a1)
    CT_induction
    |- µP. (µn. P (C n)) ± (µC C0. P C ± P C0 ´ P (# C C0)) ´ µC. P C
=TEX

In this section I aim to replicate this quite closely, though using a different representation.
I am assuming that once this is done here, there will be no further need to refer to the representing type.

\subsection{Introducing the type CT}

The natural way to hand crank such a datatype in ProofPower HOL would be to use the theory of trees in Arthan's mathematical examples as a representation type.
However, I am more familiar with using the domain of an axiomatic set theory so it will be slightly easier for me to do that.

I define the constructors over the representation type since they are simple enough to write out, instead I go straight to defining the closure conditions on the set of representatives.

There are two constructors, a constant constructor and an application constructor.
There are countably many constants named by natural numbers, and tagged by zero to distinguish them from applications.
An application is constructed from two combinators and is tagged by 1.

The closure condition is:

¹HOLCONST
Ü ÛCTrepClosedÝ: (ONE GSU ­ BOOL) ­ BOOL
÷üüüüüüüüüüü
Ü µ s· CTrepClosed s ¤ (µn· s (Nat‰u 0 í‰u Nat‰u n))
Ü	± (µf a· s f ± s a ´ s (Nat‰u 1 í‰u (f í‰u a)))
°

The set of combinatory terms is then the smallest set which is \emph{CTrepClosed}.

¹HOLCONST
Ü ÛCTsyntaxÝ : ONE GSU ­ BOOL
÷üüüüüüüüüüü
Ü µs· CTsyntax s = µt · CTrepClosed t ´ t s
°

The following theorems about the representation are helpful in proving related result for the new type:

=GFT
ÛCTrepclosed_CTsyntax_lemma1Ý =
	ô CTrepClosed CTsyntax

ÛCTrepclosed_CTsyntax_thmÝ =
	ô (µn· CTsyntax (Nat‰u 0 í‰u Nat‰u n))
       ± (µf a· CTsyntax f ± CTsyntax a ´ CTsyntax (Nat‰u 1 í‰u f í‰u a))
=TEX
=GFT
ÛCTrepclosed_CTsyntax_lemma2Ý =
	ô µs· CTrepClosed s ´ (µ t· CTsyntax t ´ s t)
=TEX

\ignore{
=SML
val CTrepClosed_def = get_spec ¬CTrepClosed®;
val CTsyntax_def = get_spec ¬CTsyntax®;

set_goal([], ¬CTrepClosed CTsyntax®);
val _ = a (rewrite_tac [CTsyntax_def, CTrepClosed_def]
	THEN REPEAT strip_tac
	THEN REPEAT_N 3 (asm_ufc_tac[])
	THEN asm_rewrite_tac[]);
val CTrepclosed_CTsyntax_lemma1 = save_pop_thm "CTrepclosed_CTsyntax_lemma1";

val CTrepclosed_CTsyntax_thm = save_thm ("CTrepclosed_CTsyntax_thm",
	pure_rewrite_rule [get_spec ¬CTrepClosed®] CTrepclosed_CTsyntax_lemma1);

local val _ = set_goal([], ¬µ s· CTrepClosed s ´ µt· CTsyntax t ´ s t®);
val _ = a (rewrite_tac [CTsyntax_def]
	THEN prove_tac[]);
in val CTrepclosed_CTsyntax_lemma2 = save_pop_thm "CTrepclosed_CTsyntax_lemma2";
end;
=TEX
}%ignore

=GFT
ÛCTsyntax_cases_thmÝ =
	ô µc· CTsyntax c
		´ (¶ n· c = Nat‰u 0 í‰u Nat‰u n)
		² (¶ f a· CTsyntax f ± CTsyntax a ± c = Nat‰u 1 í‰u f í‰u a)
=TEX

\ignore{
=SML
set_goal([], ¬µc· CTsyntax c ´
		(¶n· c = Nat‰u 0 í‰u Nat‰u n)
	²	(¶f a· CTsyntax f ± CTsyntax a ± c = (Nat‰u 1 í‰u f í‰u a))®);
a (lemma_tac ¬CTrepClosed (Ìc· (¶n· c = Nat‰u 0 í‰u Nat‰u n)
	²	(¶f a· CTsyntax f ± CTsyntax a ± c = (Nat‰u 1 í‰u f í‰u a)))®
	THEN1 (rewrite_tac[CTrepClosed_def]
		THEN REPEAT strip_tac));
(* *** Goal "1" *** *)
a (prove_¶_tac);
(* *** Goal "2" *** *)
a (asm_prove_¶_tac THEN asm_rewrite_tac[CTrepclosed_CTsyntax_thm]);
(* *** Goal "3" *** *)
a (asm_prove_¶_tac
	THEN asm_rewrite_tac[]
	THEN ALL_FC_T rewrite_tac [CTrepclosed_CTsyntax_thm]
	THEN rewrite_tac[CTrepclosed_CTsyntax_thm]);
(* *** Goal "4" *** *)
a (asm_prove_¶_tac
	THEN asm_rewrite_tac[]
	THEN ALL_FC_T rewrite_tac [CTrepclosed_CTsyntax_thm]
	THEN rewrite_tac[CTrepclosed_CTsyntax_thm]);
(* *** Goal "5" *** *)
a (asm_prove_¶_tac
	THEN asm_rewrite_tac[]
	THEN ALL_FC_T rewrite_tac [CTrepclosed_CTsyntax_thm]
	THEN rewrite_tac[CTrepclosed_CTsyntax_thm]);
(* *** Goal "6" *** *)
a (REPEAT_N 2 strip_tac);
a (fc_tac [CTsyntax_def]);
a (all_asm_fc_tac[]);
a (POP_ASM_T ante_tac THEN rewrite_tac[]);
val CTsyntax_cases_thm = save_pop_thm "CTsyntax_cases_thm";

set_goal([], ¬¶c· CTsyntax c®);
a (¶_tac ¬Nat‰u 0 í‰u Nat‰u 0®
	THEN rewrite_tac [CTsyntax_def, CTrepClosed_def]
	THEN REPEAT strip_tac
	THEN asm_rewrite_tac[]);
val CTsyntax_nonempty = pop_thm();
=TEX
}%ignore

To introduce the new type we must prove that \emph{CTsyntax} is inhabited: 

=GFT
ÛCTsyntax_nonemptyÝ = 
	ô ¶c· CTsyntax c
=TEX

The type \emph{CT} is then introduced as follows:

=SML
val CT_type_defn_thm = new_type_defn(["CT"], "CT", [], CTsyntax_nonempty);
=TEX

\ignore{
=SML
val [CT_type_lemma2] = fc_rule [type_defn_lemma4] [CT_type_defn_thm];
=TEX
}%ignore

\subsection{Primitive Constructors over CT}

There will be two constructors one for constants and one for applications.
Applications are infix.

=SML
declare_infix(1000, "‰c");
=TEX

\ignore{
=SML
set_goal([], ¬¶(CTabs:ONE GSU ­ CT) (CTrep:CT ­ ONE GSU)·
	(µ a· CTabs (CTrep a) = a)
     ± (µ r· CTsyntax r ¤ CTrep (CTabs r) = r)
     ± OneOne CTrep
     ± (µ a· CTsyntax (CTrep a))®);
a (strip_asm_tac CT_type_lemma2);
a (¶_tac ¬abs® THEN ¶_tac ¬rep® THEN asm_rewrite_tac[]);
save_cs_¶_thm(pop_thm());
=TEX
}%ignore

¹HOLCONST
Ü ÛCTabsÝ: ONE GSU ­ CT;
Ü ÛCTrepÝ: CT ­ ONE GSU
÷üüüüüüüüüüü
Ü	(µ a· CTabs (CTrep a) = a)
Ü     ± (µ r· CTsyntax r ¤ CTrep (CTabs r) = r)
Ü     ± OneOne CTrep
Ü     ± (µ a· CTsyntax (CTrep a))
°

¹HOLCONST
Ü Û$‰cÝ: CT ­ CT ­ CT
÷üüüüüüüüüüü
Ü µs t· s ‰c t = CTabs (Nat‰u 1 í‰u (CTrep s) í‰u (CTrep t))
°

¹HOLCONST
Ü ÛCÝ: î ­ CT
÷üüüüüüüüüüü
Ü µs· C s = CTabs(Nat‰u 0 í‰u (Nat‰u s))
°

=GFT
ÛCT_casesÝ =
	ô µ t· (¶ n· t = C n) ² (¶ c1 c2· t = c1 ‰c c2)
=TEX

\ignore{
=SML
val CTrep_def = get_spec ¬CTrep®;
val ‰c_def = get_spec ¬$‰c®;
val C_def = get_spec ¬C®;

set_goal([], ¬µt· (¶n· t = C n) ² (¶c1 c2· t = c1 ‰c c2)®);
a (strip_tac);
a (strip_asm_tac (µ_elim ¬CTrep t® CTsyntax_cases_thm));
(* *** Goal "1" *** *)
a (POP_ASM_T ante_tac THEN rewrite_tac [CTrep_def]);
(* *** Goal "2" *** *)
a (²_left_tac THEN ¶_tac ¬n® THEN asm_rewrite_tac[C_def]);
a (LEMMA_T ¬CTabs(Nat‰u 0 í‰u Nat‰u n) = CTabs(CTrep t)® rewrite_thm_tac
	THEN1 asm_rewrite_tac[]);
a (rewrite_tac[CTrep_def]);
(* *** Goal "3" *** *)
a (²_right_tac THEN ¶_tac ¬CTabs f® THEN ¶_tac ¬CTabs a®
	THEN asm_rewrite_tac[‰c_def]);
a (LEMMA_T ¬CTabs(Nat‰u 1 í‰u CTrep (CTabs f) í‰u CTrep (CTabs a)) = CTabs(CTrep t)® rewrite_thm_tac
	THEN1 asm_rewrite_tac[]);
a (FC_T rewrite_tac [CTrep_def]);
(* *** Goal "3.2" *** *)
a (rewrite_tac [CTrep_def]);
val CT_cases = save_pop_thm "CT_cases";
=TEX
}%ignore

\subsection{Induction and Recursion}

Now we obtain a principle of induction for reasoning about these combinatory terms and a recursion theorem to justify definitions over the terms by pattern matching recursion.

We can derive a well-founded ordering for combinatory terms from the well-foundedness of membership over the sets used to represent the terms.
This provides a first method of proof by induction over the combinatory terms which is used to prove the induction principle produced by hol4.

=GFT
Ûwf_CT_thmÝ =
	ô well_founded (Ì x y· CTrep x ‰u CTrep y)
Ûtc‰u_rep_‰c_lemmaÝ =
	ô µ c1 c2· CTrep c1 ‰u›+ CTrep (c1 ‰c c2)
		± CTrep c2 ‰u›+ CTrep (c1 ‰c c2)
ÛCT_inductionÝ =
	ô µ P· (µ n· P (C n)) ± (µ c c0· P c ± P c0 ´ P (c ‰c c0))
		´ (µ c· P c)
ÛCT_axiomÝ =
	ô µ f0 f1· ¶ fn·
		(µ a· fn (C a) = f0 a)
           ±	(µ a0 a1· fn (a0 ‰c a1) = f1 a0 a1 (fn a0) (fn a1))
=TEX

\ignore{
=SML
set_goal([], ¬well_founded(DerivedOrder CTrep ($‰u›+:ONE GSU ­ ONE GSU ­ BOOL))®);
a (rewrite_tac [µ_elim ¬CTrep® (´_elim (µ_elim ¬$‰u›+:ONE GSU ­ ONE GSU ­ BOOL® wf_derived_order_thm) (inst_type_rule [(”ONE®, ”'a®)] gsu_wftc_thm2))]);
val wf_CT_lemma = pop_thm ();

val wf_CT_thm = save_thm ("wf_CT_thm", rewrite_rule [get_spec ¬DerivedOrder®] wf_CT_lemma);

set_goal([], ¬µc1 c2· CTrep c1 ‰u›+ CTrep (c1 ‰c c2)
		± CTrep c2 ‰u›+ CTrep (c1 ‰c c2)®);
a (REPEAT µ_tac THEN rewrite_tac[‰c_def]);
a (lemma_tac ¬CTsyntax (Nat‰u 1 í‰u CTrep c1 í‰u CTrep c2)® 
	THEN1 (bc_tac [±_right_elim CTrepclosed_CTsyntax_thm]
		THEN rewrite_tac [CTrep_def]));
a (lemma_tac ¬CTrep c1 í‰u CTrep c2 ‰u›+ Nat‰u 1 í‰u CTrep c1 í‰u CTrep c2®
	THEN1 rewrite_tac[]);
a (lemma_tac ¬CTrep c1 ‰u›+ CTrep c1 í‰u CTrep c2 ± CTrep c2 ‰u›+ CTrep c1 í‰u CTrep c2®
	THEN1 rewrite_tac[]);
a (all_asm_fc_tac [tc‰u_trans_thm]);
a (ALL_FC_T asm_rewrite_tac[CTrep_def]);
val tc‰u_rep_‰c_lemma = save_pop_thm "tc‰u_rep_‰c_lemma";

set_goal([], ¬µP· (µn· P (C n)) ± (µc c0· P c ± P c0 ´ P (c ‰c c0)) ´ µc· P c®);
a (REPEAT strip_tac);
a (wf_induction_tac wf_CT_thm ¬c®);
a (strip_asm_tac (µ_elim ¬t® CT_cases)
	THEN asm_rewrite_tac[]);
a (var_elim_asm_tac ¬t = c1 ‰c c2®);
a (POP_ASM_T (asm_tac o (rewrite_rule[])));
a (lemma_tac ¬CTrep c1 ‰u›+ CTrep (c1 ‰c c2) ± CTrep c2 ‰u›+ CTrep (c1 ‰c c2)®
	THEN1 rewrite_tac [tc‰u_rep_‰c_lemma]);
a (all_asm_fc_tac[]);
a (all_asm_fc_tac[]);
val CT_induction = save_pop_thm "CT_induction";

set_goal([], ¬µf0 f1· ¶fn:ONE GSU ­ 'a·
	(µn· fn (Nat‰u 0 í‰u Nat‰u n:ONE GSU) = f0 (Nat‰u n:ONE GSU))
	± (µa0 a1· fn (Nat‰u 1 í‰u (a0 í‰u a1)) = f1 a0 a1 (fn a0) (fn a1))®);
a (REPEAT strip_tac);
a (lemma_tac ¬¶g· g = Ìfn (x:ONE GSU)·
  if (¶n· x = (Nat‰u 0 í‰u (Nat‰u n:ONE GSU))) ² ¶a0 a1· x = (Nat‰u 1 í‰u a0 í‰u a1)
  then
	if Fst‰u x = Nat‰u 0
	then f0 (Snd‰u x)
	else	let a0 = Fst‰u (Snd‰u x)
		and a1 = Snd‰u (Snd‰u x)
		in f1 a0 a1 (fn a0) (fn a1)
  else Åx· T®
	THEN1 prove_¶_tac);
a (lemma_tac ¬g respects $‰u®
	THEN1 (rewrite_tac [get_spec ¬$respects®]
		THEN REPEAT strip_tac
		THEN asm_rewrite_tac[]));
(* *** Goal "1" *** *)
a (cond_cases_tac ¬Fst‰u x = Nat‰u 0®);
a (CASES_T ¬(¶n· x = (Nat‰u 0 í‰u (Nat‰u n:ONE GSU))) ² ¶a0 a1· x = (Nat‰u 1 í‰u a0 í‰u a1)®
	(fn x => rewrite_thm_tac x THEN asm_tac x));
a (POP_ASM_T strip_asm_tac);
(* *** Goal "1.1" *** *)
a (var_elim_asm_tac ¬x = Nat‰u 0 í‰u Nat‰u n®);
a (POP_ASM_T (strip_asm_tac o (rewrite_rule[])));
(* *** Goal "1.2" *** *)
a (lemma_tac ¬tc $‰u a0 x ± tc $‰u a1 x®
	THEN1 asm_rewrite_tac[]);
(* *** Goal "1.2.1" *** *)
a (lemma_tac ¬a0 ‰u›+ (a0 í‰u a1)® THEN1 asm_rewrite_tac[tc‰u_í‰u_left_thm]);
a (lemma_tac ¬(a0 í‰u a1) ‰u›+ (Nat‰u 1 í‰u (a0 í‰u a1))®
	THEN1 asm_rewrite_tac[tc‰u_í‰u_right_thm]);
a (LEMMA_T ¬a0 ‰u›+ (Nat‰u 1 í‰u a0 í‰u a1)®
	(asm_tac o (rewrite_rule[get_spec ¬$‰u›+®]))
	THEN1 all_fc_tac [tc‰u_trans_thm]);
a (asm_rewrite_tac[]);
a (lemma_tac ¬a1 ‰u›+ (a0 í‰u a1)® THEN1 asm_rewrite_tac[tc‰u_í‰u_left_thm]);
a (LEMMA_T ¬a1 ‰u›+ (Nat‰u 1 í‰u a0 í‰u a1)®
	(rewrite_thm_tac o (rewrite_rule[get_spec ¬$‰u›+®]))
	THEN1 all_fc_tac [tc‰u_trans_thm]);
(* *** Goal "1.2.2" *** *)
a (all_asm_fc_tac []);
a (REPEAT_N 2 (POP_ASM_T ante_tac) THEN asm_rewrite_tac[let_def]);
a (REPEAT strip_tac THEN asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a (strip_asm_tac (inst_type_rule [(”ONE®, ”'a®)] gsu_wf_thm1));
a (all_fc_tac [fixp_thm1]);
a (¶_tac ¬g'®);
a (POP_ASM_T ante_tac
	THEN once_asm_rewrite_tac[]
	THEN rewrite_tac[]
	THEN strip_tac);
a (strip_tac THEN REPEAT µ_tac);
(* *** Goal "2.1" *** *)
a (SPEC_NTH_ASM_T 1 ¬Nat‰u 0 í‰u (Nat‰u n):ONE GSU® ante_tac);
a (LEMMA_T ¬¶ n'· Nat‰u 0 í‰u Nat‰u n = Nat‰u 0 í‰u Nat‰u n'® rewrite_thm_tac
	THEN1 (¶_tac ¬n® THEN rewrite_tac[]));
a (LEMMA_T ¬¶ n'· n = n'® rewrite_thm_tac
	THEN1 (¶_tac ¬n® THEN rewrite_tac[]));
a (STRIP_T (rewrite_thm_tac o (eq_sym_rule)));
(* *** Goal "2.2" *** *)
a (SPEC_NTH_ASM_T 1 ¬Nat‰u 1 í‰u a0 í‰u a1:ONE GSU® ante_tac);
a (LEMMA_T ¬¶ a0' a1'· Nat‰u 1 í‰u a0 í‰u a1 = Nat‰u 1 í‰u a0' í‰u a1'® rewrite_thm_tac
	THEN1 (¶_tac ¬a0® THEN ¶_tac ¬a1® THEN rewrite_tac[]));
a (rewrite_tac[let_def]);
a (STRIP_T (rewrite_thm_tac o (eq_sym_rule)));
val rec_lemma1 = pop_thm ();

set_goal([], ¬µf0 f1·
         ¶fn: CT ­ 'a·
           (µa· fn (C a) = f0 a) ±
           µa0 a1:CT· (fn (a0 ‰c a1):'a) = (f1 a0 a1 (fn a0) (fn a1))®);
a (REPEAT strip_tac);
a (strip_asm_tac (list_µ_elim
	[¬Ìc:ONE GSU· f0 (Ån· Nat‰u n = c)®,
	¬Ìa0 a1 fa0 fa1· f1 (CTabs a0) (CTabs a1) fa0 fa1®]
 rec_lemma1));
a (¶_tac ¬Ìc· fn (CTrep c)®
	THEN REPEAT strip_tac THEN_TRY asm_rewrite_tac[CTrep_def, C_def, ‰c_def]);
(* *** Goal "1" *** *)
a (lemma_tac ¬CTsyntax (Nat‰u 0 í‰u Nat‰u a)®
	THEN1 rewrite_tac[CTrepclosed_CTsyntax_thm]);
a (FC_T asm_rewrite_tac [CTrep_def]);
a (Å_tac ¬Å n· n = a® THEN1 prove_¶_tac);
a (asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a (lemma_tac ¬CTsyntax(CTrep a0) ± CTsyntax(CTrep a1)®
	THEN1 rewrite_tac [CTrep_def]);
a (lemma_tac ¬CTsyntax(Nat‰u 1 í‰u CTrep a0 í‰u CTrep a1)®
	THEN1 all_fc_tac [CTrepclosed_CTsyntax_thm]);
a (ALL_FC_T asm_rewrite_tac [CTrep_def]);
a (rewrite_tac[CTrep_def]);
val CT_axiom = save_pop_thm "CT_axiom";

add_¶_cd_thms [CT_axiom] "'icl";
set_merge_pcs ["misc31", "'icl"];
=TEX
}%ignore

\subsection{Further Definitions}

We can now define constants over $CT$ by pattern matching primitive recursion.

I would normally obtain a `course of values' induction by defining a well-founded relation over the terms, which is easily done thus:

=SML
declare_infix(200, "in‰c");
=TEX

¹HOLCONST
Ü $Ûin‰cÝ: CT ­ CT ­ BOOL
÷üüüüüüüüüüü
Ü µx y· x in‰c y ¤ ¶z· y = x ‰c z ² y = z ‰c x
°


=GFT
=TEX

\ignore{
=SML
val in‰c_def = get_spec ¬$in‰c®;

=IGN
set_goal([], ¬well_founded $in‰c®);
a (rewrite_tac [get_spec ¬well_founded®, in‰c_def, ‰c_def]
	THEN REPEAT strip_tac);
a (gsu_induction_tac ¬x®);

=TEX
}%ignore

However, the method used in the hol4 datatype system is to define a numeric `size' for combinatory terms as follows:

¹HOLCONST
Ü ÛCT_sizeÝ: CT ­ î
÷üüüüüüüüüüü
Ü	(µa·		CT_size (C a)		= 1 + a)
Ü ±	µa0 a1·	CT_size (a0 ‰c a1)	= 1 + CT_size a0 + CT_size a1
°

Course of values induction can then be obtained by induction over the size of combinatory terms.

¹HOLCONST
Ü ÛCT_caseÝ: (î ­ CT) ­ (CT ­ CT ­ CT) ­ (CT ­ CT)
÷üüüüüüüüüüü
Ü µf g x y n·	CT_case f g (C n) = f n
Ü		±	CT_case f g (x ‰c y) = g x y
°

\ignore{
=SML
val CT_case_def = get_spec ¬CT_case®;

set_goal([], ¬¶CT_size2· (µa·	CT_size2 (C a)	= 1 + a)
Ü ±	µa0 a1·	CT_size2 (a0 ‰c a1)	= 1 + CT_size2 a0 + CT_size2 a1®);
a (strip_asm_tac (list_µ_elim
	[¬Ìa:î· 1 + a®, ¬Ì(a0:CT) (a1:CT) fa0 fa1· 1 + fa0 + fa1®] CT_axiom));

set_flag("pp_show_HOL_types", false);
=TEX
}%ignore

We now prove the rest of the theorems which are derived automatically for the datatype in hol4.

=GFT
ÛCT_11Ý =
	ô (µ a a'· C a = C a' ´ a = a')
	± (µ a0 a1 a0' a1'· a0 ‰c a1 = a0' ‰c a1' ´ a0 = a0' ± a1 = a1')
ÛCT_distinctÝ =
	ô µ a a0 a1· ³ C a = a0 ‰c a1
ÛCT_nchotomyÝ =
	ô µ cc· ³ ((¶ n· cc = C n) ¤ (¶ c c0· cc = c ‰c c0))
=TEX


\ignore{
=SML
set_goal([], ¬
	(µa a'· (C a = C a') ´ (a = a')) ±
        (µa0 a1 a0' a1'· (a0 ‰c a1 = a0' ‰c a1') ´ (a0 = a0') ± (a1 = a1'))
®);
a (rewrite_tac [C_def, ‰c_def] THEN REPEAT_N 2 strip_tac
	THEN REPEAT µ_tac THEN strip_tac);
(* *** Goal "1" *** *)
a (lemma_tac ¬CTsyntax(Nat‰u 0 í‰u Nat‰u a)® THEN1 rewrite_tac [CTrepclosed_CTsyntax_thm]);
a (lemma_tac ¬CTsyntax(Nat‰u 0 í‰u Nat‰u a')® THEN1 rewrite_tac [CTrepclosed_CTsyntax_thm]);
a (LEMMA_T ¬CTrep(CTabs (Nat‰u 0 í‰u Nat‰u a)) = CTrep(CTabs (Nat‰u 0 í‰u Nat‰u a'))® (fn y => ALL_FC_T (fn x => (asm_tac o (rewrite_rule x)) y) [CTrep_def])
	THEN1 asm_rewrite_tac[]);
a (strip_tac);
(* *** Goal "2" *** *)
a (lemma_tac ¬CTsyntax(CTrep a0) ± CTsyntax(CTrep a1)®
	THEN1 rewrite_tac [CTrep_def]);
a ((lemma_tac ¬CTsyntax (Nat‰u 1 í‰u CTrep a0 í‰u CTrep a1)®
	THEN1 (bc_tac [±_right_elim CTrepclosed_CTsyntax_thm]))
		THEN_TRY ALL_FC_T asm_rewrite_tac [CTrep_def]);
a (lemma_tac ¬CTsyntax(CTrep a0') ± CTsyntax(CTrep a1')®
	THEN1 rewrite_tac [CTrep_def]);
a ((lemma_tac ¬CTsyntax (Nat‰u 1 í‰u CTrep a0' í‰u CTrep a1')®
	THEN1 (bc_tac [±_right_elim CTrepclosed_CTsyntax_thm]))
		THEN_TRY ALL_FC_T asm_rewrite_tac [CTrep_def]);
a (LEMMA_T ¬CTrep(CTabs (Nat‰u 1 í‰u CTrep a0 í‰u CTrep a1))
             = CTrep(CTabs (Nat‰u 1 í‰u CTrep a0' í‰u CTrep a1'))®
	(fn y => ALL_FC_T (fn x => (ante_tac o (try(rewrite_rule x))) y) [CTrep_def])
	THEN1 asm_rewrite_tac[]);
a (strip_tac THEN LEMMA_T
	¬CTabs(CTrep a0) = CTabs(CTrep a0')
	± CTabs(CTrep a1) = CTabs(CTrep a1')®
	(rewrite_thm_tac o (rewrite_rule [CTrep_def]))
	THEN1 asm_rewrite_tac[]);
val CT_11 = save_pop_thm "CT_11";

set_goal([], ¬µa a0 a1· ³ C a = a0 ‰c a1®);
a (rewrite_tac [C_def, ‰c_def] THEN contr_tac);
a (lemma_tac ¬CTsyntax(CTrep a0) ± CTsyntax(CTrep a1)®
	THEN1 rewrite_tac [CTrep_def]);
a ((lemma_tac ¬CTsyntax (Nat‰u 1 í‰u CTrep a0 í‰u CTrep a1)®
	THEN1 (bc_tac [±_right_elim CTrepclosed_CTsyntax_thm]))
		THEN_TRY ALL_FC_T asm_rewrite_tac [CTrep_def]);
a (lemma_tac ¬CTsyntax(Nat‰u 0 í‰u Nat‰u a)®
	THEN1 (rewrite_tac [CTrepclosed_CTsyntax_thm]));
a (LEMMA_T ¬CTrep(CTabs (Nat‰u 0 í‰u Nat‰u a))
	= CTrep(CTabs (Nat‰u 1 í‰u CTrep a0 í‰u CTrep a1))®
	ante_tac
	THEN1 asm_rewrite_tac[]);
a (FC_T rewrite_tac [CTrep_def]);
val CT_distinct = save_pop_thm "CT_distinct";

set_goal([], ¬µM M' f f1·
         (M = M') ± (µa· (M' = C a) ´ (f a = f' a)) ±
         (µa0 a1· (M' = a0 ‰c a1) ´ (f1 a0 a1 = f1' a0 a1)) ´
         (CT_case f f1 M = CT_case f' f1' M')®);
a (REPEAT µ_tac
	THEN REPEAT strip_tac
	THEN asm_rewrite_tac[]);
a (strip_asm_tac (µ_elim ¬M'® CT_cases)
	THEN asm_rewrite_tac[CT_case_def]
	THEN GET_NTH_ASM_T 1 (var_elim_asm_tac o concl));
(* *** Goal "1" *** *)
a (spec_nth_asm_tac 2 ¬n®);
(* *** Goal "2" *** *)
a (var_elim_asm_tac ¬M = c1 ‰c c2®);
a (list_spec_nth_asm_tac 1 [¬c1®, ¬c2®]);
val CT_case_cong = save_pop_thm "CT_case_cong";

set_goal([], ¬µcc· ³ (¶n· cc = C n) = (¶c c0· cc = c ‰c c0)®);
a (REPEAT µ_tac);
a (strip_asm_tac (µ_elim ¬cc® CT_cases) THEN asm_rewrite_tac [CT_distinct]);
(* *** Goal "1" *** *)
a (¶_tac ¬n® THEN asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a (LEMMA_T ¬µ a a0 a1· ³ a0 ‰c a1 = C a® rewrite_thm_tac
	THEN1 (REPEAT strip_tac THEN_TRY rewrite_tac[CT_distinct]));
(* *** Goal "2.1" *** *)
a (rewrite_tac [map_eq_sym_rule (all_µ_elim CT_distinct)]);
(* *** Goal "2.2" *** *)
a (¶_tac ¬c1® THEN ¶_tac ¬c2® THEN asm_rewrite_tac[]);
val CT_nchotomy = save_pop_thm "CT_nchotomy";
=TEX
}%ignore

\subsection{Combinator Names}

In the original hol4 treatment the combinators K and S were constructors of the abstract datatype.
In this quasi replica I made the minor generalisation of allowing countably many constants using a constructor taking a natural number parameter.

To make the material more legible I now define constants to give the conventional names to the S and K constructors as follows.

¹HOLCONST
Ü ÛK‰cÝ: CT
÷üüüüüüüüüüü
Ü	K‰c = C 0
°

¹HOLCONST
Ü ÛS‰cÝ: CT
÷üüüüüüüüüüü
Ü	S‰c = C 1
°

Once I have replicated essentially the same Church Rosser proof for this pure combinatory logic I will then attempt a proof for an illative system with one illative combinatory.
This will be called `Q'.

¹HOLCONST
Ü ÛQ‰cÝ: CT
÷üüüüüüüüüüü
Ü	Q‰c = C 2
°

Since `Q' is intended to be a close approximation to equality, it might be nice to have the following way of writing equations:

=SML
declare_infix(300, "=‰c");
=TEX


¹HOLCONST
Ü $Û=‰cÝ: CT ­ CT ­ CT
÷üüüüüüüüüüü
Ü µa0 a1· a0 =‰c a1 = (Q‰c ‰c a0) ‰c a1
°

This kind of equality delivers a combinatory term rather than a BOOL.
True and false will probably be coded as left and right projections, i.e. K and KI (where I is the identity, which is SKK).

These definitions really only give names to the combinators, to know what they mean you have to look at the reduction relations over the combinators.

\section{Reduction}

hol4 has a special way of defining relations which results in the following definition:

=GFT
    redn_def
    |- $--> =
       (Ìa0 a1.
          µ-->' .
            (µa0 a1.
               (¶x y f. (a0 = f # x) ± (a1 = f # y) ± -->' x y) ²
               (¶f g x. (a0 = f # x) ± (a1 = g # x) ± -->' f g) ²
               (¶y. a0 = C 0 # a1 # y) ²
               (¶f g x.
                  (a0 = C 1 # f # g # x) ± (a1 = f # x # (g # x))) ²
               (¶x. (a0 = C 2 # x # x) ± (a1 = C 0)) ´
               -->' a0 a1) ´
            -->' a0 a1)
=TEX

Of the various parts in this definition, the first two make this a congruence relation, i.e. reductions on parts yeild reductions on the whole, the third is the primitive reduction for K, the fourth for S, the fifth for Q.
These are wrapped up to assert that the defined relation is the intersection of all relations closed under these rules.

So the natural way to proceed in the absence of the rule-based relation definition facility in hol4 is to define the primitive relations for each combinator, combine them (take the union or disjunction), form the congruence and take the transitive closure.

¹HOLCONST
Ü ÛconfluentÝ: ('a ­ 'a  ­ BOOL) ­ BOOL
÷üüüüüüüüüüü
Ü µR· confluent R ¤ µx y z· rtc R x y ± rtc R x z ´
Ü             ¶u· rtc R y u ± rtc R z u
°

¹HOLCONST
Ü ÛnormformÝ: ('a ­ 'a  ­ BOOL) ­ 'a ­BOOL
÷üüüüüüüüüüü
Ü µR x· normform R x ¤ µy· ³ R x y
°

\ignore{
=SML
val confluent_def = get_spec ¬confluent®;
val normform_def = get_spec ¬normform®;

set_goal([], ¬µR· confluent R ´
        µx y z· rtc R x y ± normform R y ± rtc R x z ± normform R z
                  ´ (y = z)®);
a (rewrite_tac[confluent_def, normform_def]
	THEN REPEAT strip_tac);
a (LIST_SPEC_NTH_ASM_T 5 [¬x®, ¬y®, ¬z®] ante_tac
	THEN rewrite_tac [rtc_def]
	THEN strip_tac
	THEN_TRY asm_rewrite_tac[]);
(* *** Goal "1" *** *)

=IGN

stop;

a (spec_nth_asm_tac 9 ¬u'®);
a (all_asm_fc_tac[]);


RW_TAC std_ss [confluent_def] THEN
  `?u. RTC R y u /\ RTC R z u` by PROVE_TAC [] THEN
  PROVE_TAC [normform_def, RTC_cases]);

val confluent_normforms_unique = save_pop_thm "confluent_normforms_unique";

=TEX
}%ignore


=SML
set_flag ("subgoal_package_quiet", false);
set_flag ("pp_use_alias", true);
=TEX


