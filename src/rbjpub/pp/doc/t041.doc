=IGN
$Id: t041.doc,v 1.4 2010/11/30 13:48:35 rbj Exp $
=TEX

The idea is to obtain an exotic model for illative lambda-calculi by methods analogous to those employed for set theory in \cite{rbjt027}, and then to use that as a semantic foundation for the definition of one or more finitary illative lambda-calculi with systems of type assignment.

The work is conducted by conservative extension in the context of a higher order set theory established axiomatically in HOL, which I will refer to as HOL/GSU, or just GSU\cite{rbjt042}.
The end result is intended to be a semantic embedding of an illative lambda-calculus into HOL/GSU.
This end is to be realised in stages as follows:

\begin{itemize}
\item Establish an infinitary illative combinatory logic.
\begin{itemize}
\item Define the infinitary syntax by transfinite recursion in GSU.
\item Define the semantics, by determining a partial equivalence relation and a notion of reducibility over the syntax.
This involves taking a least fixed point of a recursive definition of the relation and proving a result analogous to the Church-Rosser theorem to establish coherence and non-triviality of the results.
\end{itemize}
\item Using this as a semantic domain, a new type is then introduced, which will be the domain over which the operations in the illative lambda-calculus will be defined. 
The theory is then developed by defining further operations as necessary and proving result which establish the required type assignment and inference rules for the embedded calculus.
\end{itemize}

At this moment after many iterations the syntax of the infinitary system may now be stable, and I have begun work on the semantics, which remains at an early stage.

\subsection{Type Assignments}

The systems of type assignments I am interested in have the following features:

\begin{itemize}
\item A universal type.
\item Dependent product and sum (function and pair) types.
\item A heirarchy of Universes, not all well-founded.
\item A well founded part in which classical mathematics can be conducted in the normal way, and which admits arbitrarily risky axiomatic extensions analogous to (possibly even identical to) large cardinal axioms (with no greater risk here than in ZFC).
\end{itemize}

The difficult question with such a shopping list, is whether it can be consistently fulfilled, and the principal purpose of this document is to explore an idea about how to construct an interpretation which might allow the equiconsistency of the systems considered here with ZFC (plus large cardinals where appropriate) to be established.
Having said that, the procedure is \emph{semantics first}, so I aim to construct the interpretation first, and then to derive logical systems of which it is an interpretation.
This method guarantees that the resulting system is consistent relative to my set theory (which is `Galactic Set Theory' (GSU\index{GSU}), see \cite{rbjt042}).

In the talk which follows about syntax and semantics there are two levels involved, that of the infinitary calculus (which is the interpretation constructed in GSU) and that of the finitary calculus which will be based on it.
From the point of view of our end objective, all aspects of the infinitary calculus are part of the semantics of that finitary language.

\section{The Infinitary Interpretation}

I have had quite a few (lost count) iterations in my conception of the syntax of the infinitary system which I use for the semantics of the target illative lambda-calculus.

My first attempt was an infinitary illative lambda calculus in which there was infinitary abstraction (abstraction over infinitely many variables at once) and application (application of an infinitary abstraction to an infinite collection of arguments).
There was something unsatisfactory about this approach (a muddle about the scope of the variables, which I used to tag the arguments in an application) and by the time I had sorted it out the infinitary abstraction had been dumped (in favour of infinitary function displays).
Unfortunately the new version left me with five syntactic constructors, and, because the (infinitary) abstract syntax is hand cranked, I have a strong incentive to keep its complexity to an absolute minimum.
So I decided to ditch abstraction, and with it, variables.

Several attempts on I now have an infinitary illative combinatory logic with just one syntactic constructor.

I call this syntax infinitary because the syntax has large (inaccessible) cardinality.
It isn't actually a deductive system, but it is a language, for which we have syntax and semantics.
We have a notion of truth and can prove the truth of expressions of our infinitary language in the metalanguage (which is HOL/GSU, a higher order set theory).

The semantic intent explains the infinitary nature of the system considered, this is so that we have underlying our ultimate language (which will be a finitary untyped illative lambda-calculus with a system of type assignments) a basis for the development of exactly the same (``classical'') applicable mathematics as is more often considered in the context of ZFC or HOL.
For this purpose there are intended to be, within the ontology, structures which mirror or mimic the hierarchy of well-founded sets, and particularly, full function spaces over well founded subsets of the universe.

The idea is to define a kind of syntactic interpretation for the lambda-calculus and to give a semantics to it.
Lambda terms in the target language will denote equivalence classes of infinitary combinators in the underlying language.
The equivalence classes over the combinators are generated by the defining equations for the combinators except for the sole illative combinator, which will be equivalence (aka convertibility).
The tricky bit is to determine the semantics of this equivalence relation, since the formal definition follows the previous sentence in being recursive, and the recursion will probably not be well-founded.
This is done by treating it as a partial equivalence, giving the recursive definition in the form of a functor over partial approximations to convertibility, and then taking the least fixed point of this functor, and praying that there will be enough in there.

An important departure from the method adopted for non-well-founded set theory in \cite{rbjt027} is the acceptance that the domain of discourse will be full of junk (e.g. non-normalising terms), and that the application of a lambda-calculus based on this interpretation will depend on reasoning almost exlusively within the confines of well-behaved subdomains which are delimited by an appropriate system of type-assignment (even though the terms themselves will be un-typed).
This is intended to yield something which will look a bit like a typed lambda-calculus with subtyping and a universal type (plus some other exotic features to make it at least as strong as ZFC) but which differs from it in a manner similar to the difference between the simply-typed lambda-calculus and a system of type assignments to the pure lambda-calculus.

=SML
open_theory "misc3";
force_new_theory "€icomb›";
force_new_pc €"'icomb"›;
merge_pcs ["'savedthm_cs_∂_proof"] "'icomb";
new_parent "GSU";
set_merge_pcs ["misc31", "'icomb"];
=TEX

\subsection{Infinitary Syntax}

The syntax of an infinitary illative combinatory logic is to be encoded as sets in a higher order set theory.

Since I will probably have to prove something like the Church-Rosser theorem and the syntax can be made very simple, this will be a bare bones treatment of the syntax, by contrast with my previous similar enterprise for non-well-founded set theory in \cite{rbjt027}.

There will be just one constructor, which is the ordered pair constructor constrained to operate on sequences of combinators.
We can therefore go immediately to specification of the required closure condition for the syntax.

The closure condition is:

πHOLCONST
‹ €CrepClosed›: 'a GSU SET ≠ BOOL
˜¸¸¸¸¸¸¸¸¸¸¸
‹ µ s∑ CrepClosed s §
‹	(µc i∑ Funâu i ± Ordinalâu (Domâu i) ± Xâu (Ranâu i) Ä s ¥ c Ìâu i ç s)
∞

The well-formed syntax is then the smallest set closed under these constructions.

πHOLCONST
‹ €Csyntax› : 'a GSU SET
˜¸¸¸¸¸¸¸¸¸¸¸
‹ Csyntax = •{x | CrepClosed x}
∞

I have contrived to arrange the semantics which follows as a monotone function over a complete partial order, so that when I start to look for fixed points of the semantic functor (to give the equivalence relation for an interpretation of an illative lambda-calculus) I can look at the least and greatest fixed points, and either prove one of the total or otherwise employ them to find a total fixed point.

\subsubsection{Closure}\label{Closure}

=GFT
€crepclosed_csyntax_lemma› =
	Ù CrepClosed Csyntax
=TEX
=GFT
€crepclosed_csyntax_thm› =
	Ù µ c i∑ Funâu i
		± Ordinalâu (Domâu i)
		± (µ x∑ x ç Xâu (Ranâu i) ¥ x ç Csyntax)
         ¥ c Ìâu i ç Csyntax
=TEX
=GFT
€crepclosed_csyntax_thm2› =
   Ù µ c i∑ Funâu i
		± Ordinalâu (Domâu i)
		± (µ x∑ x çâu Ranâu i ¥ x ç Csyntax)
	¥ c Ìâu i ç Csyntax
=TEX
=GFT
€crepclosed_csyntax_lemma1› =
	Ù µ s∑ CrepClosed s ¥ Csyntax Ä s
=TEX
=GFT
€crepclosed_csyntax_lemma2› =
	Ù µ p∑ CrepClosed {x|p x} ¥ (µ x∑ x ç Csyntax ¥ p x)
=TEX

\ignore{
=SML
val CrepClosed_def = get_spec ¨CrepClosedÆ;
val Csyntax_def = get_spec ¨CsyntaxÆ;

set_goal([], ¨CrepClosed CsyntaxÆ);
val _ = a (rewrite_tac [CrepClosed_def] THEN strip_tac);
val _ = a (rewrite_tac [Csyntax_def, CrepClosed_def]
	THEN REPEAT strip_tac
	THEN REPEAT (asm_ufc_tac[]));
val _ = a (lemma_tac ¨(µ x'∑ x' ç Xâu (Ranâu i) ¥ x' ç s)Æ
		THEN1 (REPEAT strip_tac THEN REPEAT (asm_ufc_tac[])));
val _ = a (asm_ufc_tac[] THEN asm_rewrite_tac []);
val crepclosed_csyntax_lemma = pop_thm();

val crepclosed_csyntax_thm = save_thm ("crepclosed_csyntax_thm",
	rewrite_rule [get_spec ¨CrepClosedÆ] crepclosed_csyntax_lemma);

val crepclosed_csyntax_thm2 = save_thm ("crepclosed_csyntax_thm2",
	rewrite_rule [get_spec ¨XâuÆ] crepclosed_csyntax_thm);

local val _ = set_goal([], ¨µs∑ CrepClosed s ¥ Csyntax Ä sÆ);
val _ = a (rewrite_tac [get_spec ¨CsyntaxÆ]
	THEN prove_tac[]);
in val crepclosed_csyntax_lemma1 = save_pop_thm "crepclosed_csyntax_lemma1";
end;

local val _ = set_goal([], ¨µp∑ CrepClosed {x | p x} ¥ µx∑ x ç Csyntax ¥ p xÆ);
val _ = a (rewrite_tac [get_spec ¨CsyntaxÆ] THEN REPEAT strip_tac);
val _ = a (asm_fc_tac[]);
in val crepclosed_csyntax_lemma2 = save_pop_thm "crepclosed_csyntax_lemma2";
end;
=TEX
}%ignore

\subsubsection{Recursion and Induction Principles and Rules}\label{Induction}

We need to be able to define functions by recursion over this syntax.
To do that we need to prove that the syntax is well-founded.
This is the case relative to the transitive closure of the membership relation, but to get a convenient basis for reasoning inductively over the syntax and for defining functions by recursion over the syntax it is best to define an ordering in terms of the syntactic constructors for the syntax.

This could be done strictly over the well-formed syntactic constructs, but this would involve more complexity both in the definitions and in subsequent proofs than by defining it in terms of the syntactic constructors whatever they are applied to.

πHOLCONST
‹ €CscPrec› : 'a GSU REL
˜¸¸¸¸¸¸¸¸¸¸¸
‹ µ¡ «∑ CscPrec ¡ « § ∂c i∑ ¡ çâu (Ranâu i) ± « = c Ìâu i
∞

=GFT
€CscPrec_tc_ç_thm› =
	Ù µ x y∑ CscPrec x y ¥ tc $çâu x y

€well_founded_CscPrec_thm› =
	Ù well_founded CscPrec
=TEX

\ignore{
=SML
val CscPrec_def = get_spec ¨CscPrecÆ;

local val _ = set_goal([], ¨µx y∑ CscPrec x y ¥ tc $çâu x yÆ);
val _ = a (rewrite_tac (map get_spec [¨CscPrecÆ]));
val _ = a (REPEAT strip_tac THEN asm_rewrite_tac [Ìâu_tc_thm]);
val _ = a (all_fc_tac [tcçâu_incr_thm]);
val _ = a (fc_tac [tcçâu_Ranâu_thm]);
val _ = a (lemma_tac ¨$çâuõ+ i (c Ìâu i)Æ
	THEN1 rewrite_tac [tcçâu_Ìâu_right_thm]);
val _ = a (all_fc_tac [tcçâu_trans_thm]);
val _ = a (POP_ASM_T ante_tac THEN rewrite_tac[get_spec ¨$çâuõ+Æ]);
in val CscPrec_tc_ç_thm = pop_thm();
end;

local val _ = set_goal ([], ¨well_founded CscPrecÆ);
val _ = a (rewrite_tac [get_spec ¨well_foundedÆ]);
val _ = a (REPEAT strip_tac);
val _ = a (asm_tac (µ_elim ¨sÆ gsu_cv_ind_thm));
val _ = a (lemma_tac ¨µ x∑ (µ y∑ tc $çâu y x ¥ s y) ¥ s xÆ
	THEN1 REPEAT strip_tac);
(* *** Goal "1" *** *)
val _ = a (lemma_tac ¨µ y∑ CscPrec y x ¥ s yÆ
	THEN1 (REPEAT strip_tac THEN all_fc_tac [CscPrec_tc_ç_thm]
		THEN asm_fc_tac []));
val _ = a (asm_fc_tac[]);
(* *** Goal "2" *** *)
val _ = a (asm_fc_tac[]);
val _ = a (asm_rewrite_tac[]);
in val well_founded_CscPrec_thm =  save_pop_thm "well_founded_CscPrec_thm";
end;
=TEX
}%ignore

=GFT
€well_founded_tcCscPrec_thm› =
	Ù well_founded (tc CscPrec)
=TEX

\ignore{
=SML
set_goal([], ¨well_founded (tc CscPrec)Æ);
val _ = a (asm_tac well_founded_CscPrec_thm);
val _ = a (fc_tac [wf_tc_wf_thm]);
val well_founded_tcCscPrec_thm = save_pop_thm ("well_founded_tcCscPrec_thm");
=TEX
}%ignore

=SML
val €CSC_INDUCTION_T› = WFCV_INDUCTION_T well_founded_CscPrec_thm;
val €csc_induction_tac› = wfcv_induction_tac well_founded_CscPrec_thm;
=TEX

The set Csyntax gives us the syntactically well-formed phrases of our language.
It will be useful to have some predicates which incorporate well-formedness, which are defined here.

=GFT
€csc_fc_thm› =
   Ù µ x∑ x ç Csyntax ¥
	(∂c i∑ Funâu i ± Ordinalâu(Domâu i)
	± (µ y∑ y çâu Ranâu i ¥ y ç Csyntax)
	± x = c Ìâu i)
=TEX
=GFT
€≥öâu_ç_csyntax_lemma› =
   Ù ≥ öâu ç Csyntax

€≥öâu_ç_csyntax_lemma2› =
   Ù µ x∑ x ç Csyntax ¥ ≥ x = öâu

€≥öâu_ç_csyntax_lemma3› =
   Ù µ V x∑ x ç V ± V Ä Csyntax ¥ ≥ x = öâu
=TEX

\ignore{
=SML
local val _ = set_goal([], ¨µ x∑ x ç Csyntax ¥ (∂c i∑ Funâu i ± Ordinalâu(Domâu i) ± (µ y∑ y çâu (Ranâu i) ¥ y ç Csyntax) ± x = c Ìâu i)
Æ);
val _ = a (contr_tac);
val _ = a (lemma_tac ¨CrepClosed (Csyntax \ {x})Æ
	THEN1 (rewrite_tac [get_spec ¨CrepClosedÆ] THEN REPEAT strip_tac));
(* *** Goal "1" *** *)
val _ = a (lemma_tac ¨(µy∑ y ç Xâu (Ranâu i) ¥ y ç Csyntax)Æ
	THEN1 (REPEAT strip_tac));
(* *** Goal "1.1" *** *)
val _ = a (all_asm_fc_tac []);
(* *** Goal "1.2" *** *)
val _ = a (ALL_FC_T rewrite_tac [crepclosed_csyntax_thm]);
(* *** Goal "2" *** *)
val _ = a (lemma_tac ¨(µy∑ y çâu (Ranâu i) ¥ y ç Csyntax)Æ
	THEN1 (REPEAT strip_tac));
(* *** Goal "2.1" *** *)
val _ = a (lemma_tac ¨y ç Xâu (Ranâu i)Æ
	THEN1 (asm_rewrite_tac [Xâu_def]));
val _ = a (all_asm_fc_tac []);
(* *** Goal "2.2" *** *)
val _ = a (spec_nth_asm_tac 5 ¨cÆ);
val _ = a (spec_nth_asm_tac 1 ¨iÆ THEN all_asm_fc_tac []);
val _ = a (swap_nth_asm_concl_tac 1 THEN asm_rewrite_tac[]);
(* *** Goal "3" *** *)
val _ = a (asm_tac crepclosed_csyntax_lemma1);
val _ = a (spec_nth_asm_tac 1 ¨Csyntax \ {x}Æ);
val _ = a (spec_nth_asm_tac 1 ¨xÆ);
in val csc_fc_thm = save_pop_thm "csc_fc_thm";
end;

set_goal([], ¨≥ öâu ç CsyntaxÆ);
a (contr_tac);
a (fc_tac [csc_fc_thm] THEN POP_ASM_T ante_tac THEN rewrite_tac[]);
val ≥öâu_ç_csyntax_lemma = save_pop_thm "≥öâu_ç_csyntax_lemma";

set_goal([], ¨µx∑ x ç Csyntax ¥ ≥ x = öâuÆ);
a (contr_tac THEN var_elim_nth_asm_tac 1
	THEN POP_ASM_T ante_tac
	THEN rewrite_tac [≥öâu_ç_csyntax_lemma]);
val ≥öâu_ç_csyntax_lemma2 = save_pop_thm "≥öâu_ç_csyntax_lemma2";
 
set_goal([], ¨µV x∑ x ç V ± V Ä Csyntax ¥ ≥ x = öâuÆ);
a (REPEAT strip_tac
	THEN lemma_tac ¨x ç CsyntaxÆ THEN1 PC_T1 "hol1" asm_prove_tac[]
	THEN fc_tac [≥öâu_ç_csyntax_lemma2]);
val ≥öâu_ç_csyntax_lemma3 = save_pop_thm "≥öâu_ç_csyntax_lemma3";

add_pc_thms "'icomb" [≥öâu_ç_csyntax_lemma];
set_merge_pcs ["misc31", "'icomb"];
=TEX
}%ignore

=GFT
€csc_fc_thm2› =
   Ù µc i∑ c Ìâu i ç Csyntax ¥ Funâu i ± Ordinalâu (Domâu i) ± (µ x∑ x çâu (Ranâu i) ¥ x ç Csyntax)

€cscprec_fc_thm› =
   Ù µ c i x∑ x çâu Ranâu i ¥ CscPrec x (c Ìâu i)
=TEX

\ignore{
=SML
local val _ = set_goal([], ¨µc i∑ c Ìâu i ç Csyntax ¥ Funâu i ± Ordinalâu (Domâu i) ± (µ x∑ x çâu (Ranâu i) ¥ x ç Csyntax)Æ);
val _ = a (REPEAT strip_tac THEN fc_tac[csc_fc_thm] THEN all_var_elim_asm_tac THEN REPEAT strip_tac
	THEN asm_fc_tac[]);
in val csc_fc_thm2 = save_pop_thm "csc_fc_thm2";
end;

local val _ = set_goal([], ¨µc i x∑ x çâu (Ranâu i) ¥ CscPrec x (c Ìâu i)Æ);
val _ = a (rewrite_tac [get_spec ¨CscPrecÆ]);
val _ = a (REPEAT strip_tac);
val _ = a (∂_tac ¨cÆ THEN ∂_tac ¨iÆ THEN asm_rewrite_tac[]);
in val cscprec_fc_thm = save_pop_thm "cscprec_fc_thm";
end;
=TEX
}%ignore

Inductive proofs using the well-foundedness of ScPrec are fiddly.
The following induction principle simplifies the proofs.

=GFT
€csyn_induction_thm› =
   Ù	(µc i∑ Funâu i ± Ordinalâu(Domâu i)
		± (µx∑ x çâu (Ranâu i) ¥ x ç Csyntax ± p x)
		¥ p (c Ìâu i))
	¥ (µ x∑ x ç Csyntax ¥ p x)
=TEX

\ignore{
=SML
set_goal([], ¨(µc i∑ Funâu i ± Ordinalâu(Domâu i) ± (µx∑ x çâu (Ranâu i) ¥ x ç Csyntax ± p x) ¥ p (c Ìâu i))
	¥ (µ x∑ x ç Csyntax ¥ p x)Æ);
a (REPEAT strip_tac);
a (POP_ASM_T ante_tac THEN csc_induction_tac ¨xÆ THEN strip_tac);
a (fc_tac [csc_fc_thm]);
a (lemma_tac ¨µ x∑ x çâu Ranâu i ¥ x ç Csyntax ± p xÆ
	THEN (REPEAT strip_tac THEN all_asm_fc_tac[] THEN_TRY asm_rewrite_tac[]));
a (lemma_tac ¨CscPrec x tÆ
	THEN1 (asm_rewrite_tac[CscPrec_def]));
(* *** Goal "1" *** *)
a (∂_tac ¨cÆ THEN ∂_tac ¨iÆ THEN asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a (fc_tac [tc_incr_thm] THEN all_asm_fc_tac[]);
val csyn_induction_thm = save_pop_thm "csyn_induction_thm";
=TEX
}%ignore

Using this induction principle an induction tactic is defined as follows:

=SML
fun €icomb_induction_tac› t (a,c) = (
	let val l1 = mk_app (mk_Ã (t,c), t)
	    and l2 = mk_app (mk_app (mk_const ("ç", î'a GSU ≠ 'a GSU SET ≠ BOOLÆ), t),
					mk_const ("Csyntax", î'a GSU SETÆ))
	in  let val l3 = mk_µ (t, mk_¥ (l2, l1))
	in  LEMMA_T l1 (rewrite_thm_tac o rewrite_rule[])
	THEN DROP_ASM_T l2 ante_tac
	THEN LEMMA_T l3 (rewrite_thm_tac o rewrite_rule[])
	THEN bc_tac [csyn_induction_thm]
	THEN rewrite_tac[]
	THEN strip_tac
	end end) (a,c);
=TEX

This tactic expects an argument $t$ of type $TERM$ which is a free variable of type $'a GSU$ whose sole occurrence in the assumptions is in an assumption ¨ëtÆ ç CsyntaxÆ, and results in two subgoals, one requiring a proof for atomic and the other for compound formulae (with the benefit of the induction hypothesis in the assumptions).

\subsubsection{Recursion Theorem}\label{Recursion}

The following recursion theorem supports definition by primitive recursion of functions over the syntax.

The following function provides domain restriction of a function over 'a GSU.
Since this is an operation on total functions, the effect is achieved by delivering a function which returns the same value for all arguments outside the restricted domain.
The purpose is to constrain recursion to be well founded, so the possibility of returning a function completely unconstrained in what it does off the restricted domain does not suffice (we would not be able to prove that the domain restriction had done anything at all).


=SML
declare_infix(310, "Úâuâe");
=TEX

πHOLCONST
‹ $€Úâuâe› : 'a GSU ≠ ('a GSU ≠ 'b) ≠ ('a GSU ≠ 'b)
˜¸¸¸¸¸¸¸¸¸¸¸
‹ µs f∑ s Úâuâe f = Ãt∑ if t çâu s then f t else ≈x∑T
∞


A recursion lemma suitable for consistency proofs of primitive recursive definitions over our syntax can now be proven:

=GFT
€csc_recursion_lemma› =
   Ù µaf∑ ∂f∑ µc i∑ f (c Ìâu i) = af ((Ranâu Úâuâe i) f) c i
=TEX


\ignore{
=SML
val Úâuâe_def = get_spec ¨$ÚâuâeÆ;

set_goal([], ¨µ(af:('a GSU ≠ 'b) ≠ 'a GSU ≠ 'a GSU ≠ 'b)∑ ∂(f:'a GSU ≠ 'b)∑
	µc i∑ f (c Ìâu i) = af ((Ranâu i) Úâuâe f) c iÆ);
val _ = a (REPEAT strip_tac);
val _ = a (lemma_tac ¨∂g:((('a)GSU≠'b)≠('a)GSU≠'b)∑
	g = Ãf x∑ if (∂c i∑ x = c Ìâu i) 
		then af ((Ranâu (Sndâu x)) Úâuâe f) (Fstâu x) (Sndâu x)
		else ≈x∑TÆ
	THEN1 prove_∂_tac);
val _ = a (lemma_tac ¨g respects CscPrecÆ
	THEN1 (asm_rewrite_tac [get_spec ¨$respectsÆ] THEN REPEAT strip_tac));
(* *** Goal "1" *** *)
a (cond_cases_tac ¨∂ c i∑ x = c Ìâu iÆ);
a (LEMMA_T ¨(Ranâu (Sndâu x)) Úâuâe g' = (Ranâu (Sndâu x)) Úâuâe hÆ rewrite_thm_tac);
a (rewrite_tac [Úâuâe_def] THEN strip_tac);
a (cond_cases_tac ¨x' çâu Ranâu (Sndâu x)Æ);
a (lemma_tac ¨CscPrec x' xÆ THEN1 (rewrite_tac [get_spec ¨CscPrecÆ]));
(* *** Goal "1.1" *** *)
a (∂_tac ¨cÆ THEN ∂_tac ¨iÆ THEN asm_rewrite_tac[]);
a (POP_ASM_T ante_tac THEN asm_rewrite_tac[]);
(* *** Goal "1.2" *** *)
a (fc_tac [tc_incr_thm]);
a (asm_fc_tac []);
(* *** Goal "2" *** *)
a (∂_tac ¨fix gÆ);
a (asm_tac well_founded_CscPrec_thm);
a (all_fc_tac [get_spec ¨fixÆ]);
a (POP_ASM_T ante_tac THEN asm_rewrite_tac[] THEN strip_tac);
a (GET_NTH_ASM_T 1 (once_rewrite_thm_tac o map_eq_sym_rule));
a (rewrite_tac[] THEN REPEAT strip_tac);
a (cond_cases_tac ¨∂ c' i'∑ c = c' ± i = i'Æ);
a (spec_nth_asm_tac 1 ¨cÆ);
a (spec_nth_asm_tac 1 ¨iÆ);
val csc_recursion_lemma = save_pop_thm "csc_recursion_lemma";
=TEX
}%ignore

This is (when proven) plugged into proof context {\it 'icomb} for use in consistency proofs.

=SML
add_∂_cd_thms [csc_recursion_lemma] "'icomb";
set_merge_pcs ["misc31", "'icomb"];
=TEX

\subsubsection{Auxiliary Concepts}

This is just to test the recursion theorem.

πHOLCONST
‹ €CscRank› : 'a GSU ≠ 'a GSU
˜¸¸¸¸¸¸¸¸¸¸¸
‹ µc i∑ CscRank (c Ìâu i) =  ﬁâu (Imagepâu Sucâu ((Imagepâu ((Ranâu i) Úâuâe CscRank)) (Ranâu i)))
∞

\subsubsection{Derived Syntax}

Our syntax does not include the standard finitary application.
For this we will use an infix bare subscript $c$.

=SML
declare_infix (350, "âc");
=TEX

πHOLCONST
‹ $€âc› : 'a GSU ≠ 'a GSU ≠ 'a GSU
˜¸¸¸¸¸¸¸¸¸¸¸
‹ µf a∑ f âc a = let fc = Fstâu f
		and fa = Sndâu f
		in fc Ìâu (fa @âu (Unitâu (öâu Ìâu a)))
∞

We also define a function corresponding to a constant constructor.
This gives a combinator with an empty list of arguments.

πHOLCONST
‹ $€MkCcon› : 'a GSU ≠ 'a GSU
˜¸¸¸¸¸¸¸¸¸¸¸
‹ µn∑ MkCcon n = n Ìâu öâu
∞

Using which we name the primitive combinators.
First two finitary pure combinators:

πHOLCONST
‹ $€Sâc› : 'a GSU
˜¸¸¸¸¸¸¸¸¸¸¸
‹ Sâc = MkCcon (Natâu 0)
∞

πHOLCONST
‹ $€Kâc› : 'a GSU
˜¸¸¸¸¸¸¸¸¸¸¸
‹ Kâc = MkCcon (Natâu 1)
∞

Then the sole illative combinator, which is equality or equivalence.

πHOLCONST
‹ $€Èâc› : 'a GSU
˜¸¸¸¸¸¸¸¸¸¸¸
‹ Èâc = MkCcon (Natâu 2)
∞

Various useful combinatorial expressions may now be named.

=GFT
	I = Ãx∑x
=TEX

πHOLCONST
‹ $€Iâc› : 'a GSU
˜¸¸¸¸¸¸¸¸¸¸¸
‹ Iâc = (Sâc âc Kâc) âc Kâc
∞

The truth values may be represented as two projections from the argument list.

=GFT
	F = Ãx y∑ x
=TEX

πHOLCONST
‹ $€Tâc› : 'a GSU
˜¸¸¸¸¸¸¸¸¸¸¸
‹ Tâc = Kâc
∞

=GFT
	F = Ãx y∑ y
=TEX

πHOLCONST
‹ $€Fâc› : 'a GSU
˜¸¸¸¸¸¸¸¸¸¸¸
‹ Fâc = Kâc âc Iâc
∞

Conditionals may then be represented by applying the condition to the two alternatives:

=GFT
	if x then y else z = xyz
=TEX

πHOLCONST
‹ $€Ifâc› : 'a GSU ≠ 'a GSU ≠ 'a GSU ≠ 'a GSU
˜¸¸¸¸¸¸¸¸¸¸¸
‹ µx y z∑ Ifâc x y z = (x âc y) âc z
∞

Natural numbers may be represented as iterators:

This, zero is the identity function.

πHOLCONST
‹ $€0âc› : 'a GSU
˜¸¸¸¸¸¸¸¸¸¸¸
‹ 0âc = Iâc
∞

=GFT
	Suc n = Ãf x∑ f((n f)x)
	= Ãf∑ Ãx∑ f((n f)x)
	= Ãf∑ S (K f) (n f)
	= S (Ãf∑ S (K f)) n
	= S (S (K S) K) n
	= Ãf∑ ((S (K S) K) f) (n f)
	= Ãf∑ ((Ãx∑ ((K S) x) (K x)) f) (n f)
	= Ãf∑ ((Ãx∑ S (K x)) f) (n f)
	= Ãf∑ S (K (n f)) f
	= Ãf x∑ ((K (n f) x) (f x)
	= Ãf x∑ (n f) (f x)
=TEX

πHOLCONST
‹ $€Sucâc› : 'a GSU
˜¸¸¸¸¸¸¸¸¸¸¸
‹ Sucâc = Sâc âc (Sâc âc (Kâc âc Sâc) âc Kâc)
∞

However, we require a representation of transfinite ordinals.
It is not clear how this could be obtained as iterators. 

It is probable that arithmetic will be arrived at in a manner more similar to that adopted in a well-founded set theory.
Such a set theory could be derived within the target illative lambda-calculus as a theory of characteristic functions, provided that we have a sufficiency of such functions, which the infinitary combinators are intended to ensure.

\subsection{Infinitary Combinators}

The idea is to get a system which is ontologically equivalent to the standard interpretations of well-founded set theory with large carndinal axioms.
By equivalent here I mean something like mutually interpretable, but the interpretations at stake here are correspondences between the ontologies, not interpretability of theories.
However, this is the case without the infinitary combinators, so what I am looking for is a bit more.

I want to ensure that the functions available as combinators are all functions with small graphs (and a decent collection of those with large graphs, but they are not our present concern).
The infinitary combinators are introduced to permit a function to be defined in extension, so long as its graph is ``small'' (i.e. smaller than the universe of discourse).

It is not entirely straightforward to do this.
The present proposal is to use three infinitary combinators.

First an inert combinator which is used to construct lists or sequences.

In the following definition the argument should be a sequence of combinators.

πHOLCONST
‹ $€Üâc› : 'a GSU ≠ 'a GSU
˜¸¸¸¸¸¸¸¸¸¸¸
‹ µs∑ Üâc s = (Natâu 3) Ìâu s
∞

Such combinators are irreducible and injective, and it is therefore possible in principle to extract the components, for which we supply the following projection combinator.

The projection combinator takes two sequences, the first effectively determining an element of the second to be extracted.
Normally this would be supplied with two sequences of equal length and the element to be extracted from the second would be the one which corresponds to the first element of the first sequence which reduces to `T', provided that all previous values reduce to `F' (otherwise no element is selected, i.e. no reduction is possible).

πHOLCONST
‹ $€óâc› : 'a GSU
˜¸¸¸¸¸¸¸¸¸¸¸
‹ óâc = MkCcon (Natâu 4)
∞

One may think of the first sequence supplied as an argument to $óâc$ as an ordinal $¡$ and of $óâc\ âc\ ¡\ âc\ ¬$ as selecting the $¡^{th}$ element of $¬$, but when we do eventually come to the theory of ordinals we will not use this representation.
Furthermore note that this way of indicating the element to be selected is determined primarily because it is convenient for constructing infinitary `case' constructions, and hence for the definition of arbitrary functions.

To achieve this effect we need one further infinitary combinator, a mapping combinator.

This combinator expects its second argument to be a sequence, and maps its first argument over the elements of the sequence, returning a sequence which consists of the elements of the original sequence transformed by the function supplied as the first argument.
Of course, the intended ``transformation'' will only take place as the combinators in the new sequence are themselves reduced, the reduction arising from this combinator is just to apply the function to each element giving a sequence of applications.

πHOLCONST
‹ $€ôâc› : 'a GSU
˜¸¸¸¸¸¸¸¸¸¸¸
‹ ôâc = MkCcon (Natâu 5)
∞

These three combinators together may be used to define a function as a graph in the following way.
Form two corresponding sequences, the first of values in the domain of the desired function, the second having at each position the value of the function at that point.
The required function takes some value $x$, and maps $¨È âc\ vÆ$ over the first argument, and then uses that list to determine which value to select from the second list.

An infinitary case combinator might therefore be obtained from these three combinators as follows.
=GFT
	Gfunâc	= Ãx y z∑ ó âc (ô âc (È âc z) âc x) âc y
=TEX

It is not expected that this will ever be done, it is important only that it \emph{could} be done (if only by some inaccessibly infinite deity), and this is intended to ensure that we can do `classical' mathematics in pretty much the normal way within our target calculus, which will probably be demonstrated by reconstructing a strong set theory within it.
The ability to represent arbitrary functions of infinite domains (e.g. over the reals) by such means depends upon the axiom of choice, which we do have at our disposal.
It is intended also that the target illative lambda calculus will benefit (or perhaps in some eyes be blighted by) a choice principle.

\subsection{Semantics}

The semantics is defined as an equivalence relation over the abstract syntax.

This is obtained as the least fixed point of a monotone operator over partial equivalence relations, where a partial equivalence relation is something like a pair of sets of ordered pairs of terms, one containing those known to be inequivalent and the other those known to be equivalent.

This functor is defined using a notion of direct conversion which captures the semantics of all the primitive combinators except the sole illative combinator (which is equivalence under indirect conversion).

\subsubsection{Approach}

The question of what are the primitive combinators must therefore now be addressed.

My inclination is to work with four combinators, S, K, $È$, and $ó$, of which only the last (a case combinator) is infinitary, the first three being much the same as you would expect in a finitary illative combinatory logic in which the illative primitive is equality.
I toyed with the idea that S should be made infinitary, but have decided to see whether it works without.

The rationale for this is that the infinitary aspect is of marginal significance, and may be thought of as supplying strength, but just as in the role of large cardinals in set theory, the strength is bound up with ontological plenitude.
It should be like an afterthough, the main features of the system should arise in the finitary case from the first three combinators, and the principle innovation is in the approach to giving meaning to $È$.

The definitions of the pure combinators (among which I count $ó$) are given as conversion rules, whose reflexive symmettric transitive closure give a first approximation to the meaning of $È$.
If we assume given some meaning for $È$ and obtain from it a second version by combining it with the conversion rules for the other combinators, then we have a functor over possible meanings for $È$, which can be defined so as to be monotone relative to some appropriate ordering.
The least fixed point will then be used to determine the semantics of the infinitary combinatory logic.

\subsubsection{Direct Conversions for the Pure Combinators}

These are defined as relations over \emph{Csyntax}.

πHOLCONST
‹ €Kred› : 'a GSU ≠ 'a GSU ≠ BOOL
˜¸¸¸¸¸¸¸¸¸¸¸
‹ µs t∑ Kred s t § ∂x y∑ s = (Kâc âc x) âc y ± t = x
∞

πHOLCONST
‹ €Sred› : 'a GSU ≠ 'a GSU ≠ BOOL
˜¸¸¸¸¸¸¸¸¸¸¸
‹ µs t∑ Sred s t § ∂x y z∑ s = ((Sâc âc x) âc y) âc z ± t = (x âc z) âc (y âc z)
∞

The projection combinator is more complicated.

πHOLCONST
‹ €óârâeâd› : 'a GSU ≠ 'a GSU ≠ BOOL
˜¸¸¸¸¸¸¸¸¸¸¸
‹ µs t∑ óârâeâd s t § (∂k l m n∑ Domâu k = Domâu m
		± Ordinalâu (Domâu k) ± Ranâu k = Unitâu Fâc
		± s = óâc âc (Üâc (k @âu l)) âc (Üâc (m @âu n)) 
		± t = óâc âc (Üâc l) âc (Üâc n))
	≤ (∂k m∑ öâu Ìâu Tâc çâu k
		± öâu Ìâu t çâu m
		± s = óâc âc (Üâc k) âc (Üâc m))
∞ 

As is the infinitary ``map''.

πHOLCONST
‹ €ôârâeâd› : 'a GSU ≠ 'a GSU ≠ BOOL
˜¸¸¸¸¸¸¸¸¸¸¸
‹ µs t∑ ôârâeâd s t § ∂f l m∑ Domâu l = Domâu m
‹		± Ordinalâu (Domâu l)
‹		± m = (Ãâu x∑ f âc x)(Domâu l)
‹		± s = (ôâc âc f) âc (Üâc l)
‹		± t = Üâc m
∞ 

Direct combinatorial reducibility is the union of these relationships.
Because the infinitary combinators are so much more complex than the finitary combinators in ways which are probably not pertinent to the problem of defining equivalence, I propose to separate out the two kinds of reduction, and undertake the development in the first instance using only the finitary part.

The finitary combinators yield this notion of reducibility:

πHOLCONST
‹ €DComRed› : 'a GSU ≠ 'a GSU ≠ BOOL
˜¸¸¸¸¸¸¸¸¸¸¸
‹ µs t∑ DComRed s t § Kred s t ≤ Sred s t
∞ 

With the following for the infinitary combinators, which we will consider no further until we have demonstrated the viability of our method using only the finitary combinators.

πHOLCONST
‹ €DiComRed› : 'a GSU ≠ 'a GSU ≠ BOOL
˜¸¸¸¸¸¸¸¸¸¸¸
‹ µs t∑ DiComRed s t § óârâeâd s t ≤ ôârâeâd s t 
∞ 

Direct finitary combinatorial equivalence is then:

πHOLCONST
‹ €DComEq› : 'a GSU ≠ 'a GSU ≠ BOOL
˜¸¸¸¸¸¸¸¸¸¸¸
‹ µs t∑ DComEq s t § DComRed s t ≤ DComRed t s
∞ 

\section{Equivalence}

We now come to the problem of defining the semantics of the illative combinator, equivalence.
This is problematic because the definition will be recursive and the recursion will not everywhere terminate.

However, I am expecting a partial definition to suffice, provided that it is (in an appropriate sense) consistent.
The required consistency is analogous (loosely) to the Church-Rosser theorem.

I will approach this in the first instace by means somewhat distant from Church-Rosser.

We assume a partial definition of equivalence (convertibility) as a function into a partially ordered set of four truth values.
In terms of this we define a better approximation, using a monotone functor.
This will make use single reduction steps, i.e. a pair of combinators are equivalent under the new approximation if they are within one conversion step each of a pair already known to be equivalent.
Then we take the least fixed point of this monotone functor, and this is used to define conversion rules for the equivalence combinator which will be used to determine (loosely) the semantics.

\subsection{Equivalence Closure}

Given some putative equivalence relationship over the combinators, certain other equivalences may follow.
The most obvious are any which appear in the reflexive transitive closure of the first, if it is not already thus closed.
Less obvious are certain equivalences which arise by substitution.

Thus, if two combinators are equivalent, and are applied to equivalent combinators, then the results will be equal.
Conversely, if two combinators applied to equivalent operands yield distinct results, then they must be distinct.

Here we define a closure operation on partial equivalence relations to add in these desirable features.


=GFTSHOW
 πHOLCONST
 ‹ €EqAppClosure› : ('a GSU, FTV) BR ≠ ('a GSU, FTV) BR
 ˜¸¸¸¸¸¸¸¸¸¸¸
 ‹ µ$=âp∑ EqAppClosure $=âp = Ãx y∑ Lub $ºâtâ4 {ftv | ∂t u v w∑ t =âp v ± u =âp w ± x = t âc u ± y = v âc w ±  ftv = f v w}
 ∞ 

 πHOLCONST+
 ‹ €EqClosure› : ('a GSU, FTV) BR ≠ ('a GSU, FTV) BR
 ˜¸¸¸¸¸¸¸¸¸¸¸
 ‹ µf∑ EqClosure f = Ãx y∑ Lub $ºâtâ4 {ftv | ∂v w∑ ftv = f v w}
 ∞ 
=TEX

\subsection{The Equivalence Functor}

πHOLCONST
‹ €EqFunctor› : ('a GSU, FTV) BR ≠ ('a GSU, FTV) BR
˜¸¸¸¸¸¸¸¸¸¸¸
‹ µf∑ EqFunctor f = Ãx y∑ Lub $ºâtâ4 {ftv | ∂v w∑ DComEq v x ± DComEq w y ± ftv = f v w}
∞ 

\subsection{Monotonicity}

To get a least fixed point of \emph{EqFunctor} we need to identify an ordering relative to which it is monotone.

=IGN
(* add_pc_thms "'icomb" [evalcf_ftv_ft_lemma, evalcf_ftv_fb_lemma]; *)
(* add_pc_thms "'icomb" [get_spec ¨ExtensionÆ, get_spec ¨EssenceÆ]; *)
=SML
commit_pc "'icomb";

force_new_pc "€icomb›";
merge_pcs ["misc3", "'icomb"] "icomb";
commit_pc "icomb";

force_new_pc "€icomb1›";
merge_pcs ["misc31", "'icomb"] "icomb1";
commit_pc "icomb1";
=TEX


\section{The Finitary System}

This is a marker for something in the future.
It is possible that in the exploration of the semantic ideas I may have to sketch some things out here before coming here to consider this level more seriously.

\subsection{The System of Type Assignment}

=SML
set_flag ("subgoal_package_quiet", false);
=TEX


