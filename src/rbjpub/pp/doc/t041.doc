=IGN
$Id: t041.doc,v 1.2 2010/11/09 13:32:40 rbj Exp $
=TEX

The idea is to obtain an exotic model for illative lambda-calculi by methods analogous to those employed for set theory in \cite{rbjt027}, and then to use that as a semantic foundation for the definition of one or more finitary illative lambda-calculi with a system of type assignments.

The systems of type assignments I am interested in have the following features:

\begin{itemize}
\item A universal type.
\item Dependent product and sum (function and pair) types.
\item A heirarchy of Universes, not all well-founded.
\item A well founded part in which classical mathematics can be conducted in the normal way, and which admits arbitrarily risky axiomatic extensions analogous to (possibly even identical to) large cardinal axioms (with no greater risk here than in ZFC).
\end{itemize}

The difficult question with such a shopping list, is whether it can be consistently fulfilled, and the principal purpose of this document is to explore an idea about how to construct an interpretation which might allow the equiconsistency of the systems considered here with ZFC (plus large cardinals where appropriate) to be established.
Having said that, the procedure is \emph{semantics first}, so I aim to construct the interpretation first, and then to derive logical systems of which it is an interpretation.
This method guarantees that the resulting system is consistent relative to my set theory (which is `Galactic Set Theory' (GSU\index{GSU}), see \cite{rbjt042}).

In the talk which follows about syntax and semantics there are two levels involved, that of the infinitary calculus (which is the interpretation constructed in GSU) and that of the finitary calculus which will be based on it.
From the point of view of our end objective, all aspects of the infinitary calculus are part of the semantics of that finitary language.

\section{The Infinitary Interpretation}

My first attempt at this was with an infinitary illative icomb calculus, in which there was infinitary abstraction (abstraction over infinitely many variables at once) and application (application of an infinitary abstraction to an infinite collection of arguments).
There was something unsatisfactory about this approach (a muddle about the scope of the variables, which I used to tag the arguments in an application) and by the time I had sorted it out the infinitary abstraction had been dumped (in favour of infinitary function displays).
Unfortunately the new version left me with five syntactic constructors and because the (infinitary) abstract syntax is hand cranked, I have a strong incentive to keep its complexity to an absolute minimum.
So I decided to ditch abstraction. and with it, variables.

This leaves the infinitary syntax which I use for my underlying semantics as an illative combinatory logic, for the sake of its simplicity, even though the target systems (for which this provides an interpretation) are still lambda-calculi.

I call this syntax infinitary because the syntax has large (inaccessible) cardinality.
It isn't actually a deductive system, but it is a language, for which we have syntax and semantics.
We have a notion of truth and can prove the truth of expressions in our infinitary language in the metalanguage (which is GSU, a higher order set theory).

The semantic intent explains the infinitary nature of the system considered, this is so that we have underlying our ultimate language (which will be a finitary untyped illative icomb-calculus with a system of type assignments) a basis for the development of exactly the same applicable mathematics as is more often considered in the context of ZFC or HOL.
For this purpose there are intended to be, within the ontology, structures which mirror or mimic the hierarchy of well-founded sets, and particularly, full function spaces over well founded subtypes of the universe.

The idea is to define a kind of syntactic interpretation for the icomb-calculus and to give a semantics to it.
Lambda terms in the target language will denote equivalence classes of infinitary combinators in the underlying language.
The equivalence classes over the combinators are generated by the defining equations for the combinators except for the sole illative combinator, which will be equivalence (aka convertibility).
The tricky bit is to determine the semantics of this equivalence relation, since the formal definition follows the previous sentence in being recursive.
This is done by treating it as a partial equivalence, giving the recursive definition in the form of a functor over partial approximations to convertibility, and then taking the least fixed point of this functor, and praying that there will be enough in there.

An important departure from the method adopted for non-well-founded set theory in \cite{rbjt027} is the acceptance that the domain of discourse will be full of junk (including non-normalising terms), and that the application of a icomb-calculus based on this interpretation will depend on reasoning almost exlusively within the confines of well-behaved subdomains which are delimited by an appropriate system of type-assignment (even though the terms themselves will be un-typed).
This is intended to yield something which will look a bit like a typed icomb calculus with subtyping and a universal type (plus some other exotic features to make it at least as strong as ZFC) but which differs from it in a manner similar to the difference between the simply-typed icomb-calculus and a system of type assignments to the pure icomb-calculus.

=IGN
To ensure that we get all the well-founded sets we start with definability in an infinitary first order set theory ({\it icomb}).
Given any membership structure, i.e. a domain of discourse and a membership relation over that domain, each formula of {\it icomb} with one free variable will define a subset of the domain of discourse (you may prefer to think of these as classes, since they will often have the same size as the domain).

If we take as our domain of discourse the formulae of {\it icomb} having a single free variable, then the semantics of {\it icomb} gives rise to a functor which, given one membership relation over that domain will yield another membership relation.
Over this domain the functor can have no fixed point, for we would have a formula for the Russell set.
To obtain a set theory, we must omit some of these potential sets, i.e. we must consisider subsets as potential domains.
Any subset together with a fixed point of the semantic functor will yeild an interpretation of set theory.

It seems clear that some subsets of the formulae of {\it icomb} do have fixed points under the semantics of {\it icomb}.
For example, a collection of formulae denoting all the well-founded sets, or those denoting well-founded sets or their complements.

It is the purpose of this work to see whether models for rich non-well-founded set theories can be obtained in this way.
The purpose is ultimately to provide a semantic basis for a kind of type theory suitable for ``formalised mathematics in the large'', in which ordinary mathematics is done primarily using well-founded sets and abstract mathematics often involves non-well-founded sets (theories generic over many types).

=SML
open_theory "misc3";
force_new_theory "€icomb›";
force_new_pc €"'icomb"›;
merge_pcs ["'savedthm_cs_∂_proof"] "'icomb";
new_parent "GSU";
set_merge_pcs ["misc31", "'icomb"];
=TEX

\subsection{Csyntax}

The syntax of an infinitary illative combinatory logic is to be encoded as sets in a higher order set theory.

This is (in effect if not in appearance) an ``inductive datatype'' (albeit transfinite) so we should expect the usual kinds of theorems.

Informally these should say:

\begin{enumerate}
\item Csyntax is closed under the constructors.
\item The syntax constructors are injections and have disjoint ranges
\item The ranges of the constructors partition the syntax. 
\item Any syntactic property which is preserved by the constructors (i.e. is true of any construction if it is true of all its syntactic constituents) is true of everything in the syntax (this is an induction principle).
\item A recursion theorem which supports definition of recursive functions over the syntax.
\end{enumerate}

As well as the constructors, discriminators and destructors are defined.

\subsubsection{Constructors, Discriminators and Destructors}

Preliminary to presenting the inductive definition of the required classes we define the nuts and bolts operations on the required syntactic entities (some of which will be used in the inductive definition).

Note the terminology here.

\begin{description}
\item[constructor]
A function which constructs a complex structure in the abstract syntax from the immediate constituents of that structure.
\item[discriminator]
A propositional function or predicate which tests for a particular class of entities in the abstract syntax.
This will normally be that class of entities formed using some particular constructor.
\item[destructor]
A function which extracts from a complex entity of the abstract syntax one or more of the immediate constutuents from which it was constructed.
\end{description}

More concisely, a constructor puts together some syntactic entity from its constituents, discriminators distinguist between the different kinds of entity and destructors take them apart.

The constructors are as follows:

\begin{itemize}
\item[Application] This is the usual application of one combinator two another (all combinators are functions).
\item[Constants] We have three specific constants (K, S, and equivalence) and a combinator which represents infinitary `case' or conditional constructs.
\end{itemize}

Equivalence is the epicenter of the innovation, insofar as giving meaning to it is the difficult part of our enterprise.
The infinitary case notation is also a little tricky in this context (infinitary features are easier to incorporate into a set theory than a combinatory logic).
Equivalence will be a binary partial relation which will include the natural rules for the ``pure'' combinators, and itself, hence a recursion which we resolve by allowing the relation to be partial and taking a least fixed point of a functor which defines the semantics of the infinitary combinatory expressions in terms of the meaning of equivalence.

True and false above are particular abstractions, to be defined.

This syntax is now encoded in a classical well-founded set theory.

\paragraph{Constants}

πHOLCONST
‹ €MkCcon› : 'a ≠ 'a GSU
˜¸¸¸¸¸¸¸¸¸¸¸
‹ µvc∑ MkCcon vc = (Natâu 0) Ìâu Urelement vc
∞

The discriminator is:

πHOLCONST
‹ €IsCcon› : 'a GSU ≠ BOOL
˜¸¸¸¸¸¸¸¸¸¸¸
‹    µt∑ IsCcon t § ∂vc∑ t = MkCcon vc
∞

and the following is the destructor:

πHOLCONST
‹ €CconName› : 'a GSU ≠ 'a
˜¸¸¸¸¸¸¸¸¸¸¸
‹  CconName = Ãx∑ UeVal (Sndâu x)
∞

\paragraph{Infinitary Application}

πHOLCONST
‹ €MkCiapp› : 'a GSU ≠ 'a GSU
˜¸¸¸¸¸¸¸¸¸¸¸
‹ µg∑ MkCiapp g = (Natâu 1) Ìâu g
∞

The discriminator is:

πHOLCONST
‹ €IsCiapp› : 'a GSU ≠ BOOL
˜¸¸¸¸¸¸¸¸¸¸¸
‹    µt∑ IsCiapp t § ∂g∑ t = MkCiapp g
∞

and the following is the destructor:

πHOLCONST
‹ €CiappFargs› : 'a GSU ≠ 'a GSU
˜¸¸¸¸¸¸¸¸¸¸¸
‹  CiappFargs = Sndâu
∞

=GFT
€cis_clauses› =
   Ù     (µ x∑ IsCcon (MkCcon x))
       ± (µ x∑ ≥ IsCcon (MkCiapp x))
       ± (µ x∑ IsCiapp (MkCiapp x))
       ± (µ x∑ ≥ IsCiapp (MkCcon x))
=TEX
=GFT
€csyn_proj_clauses› =
    Ù    (µ i∑ CconName (MkCcon i) = i)
       ± (µ v∑ CiappFargs (MkCiapp v) = v)
=TEX
=GFT
€csyn_con_inv_fc_clauses› =
   Ù µ p∑  (IsCcon p ¥ MkCcon (CconName p) = p)
         ± (IsCiapp p ¥ MkCiapp (CiappFargs p) = p)
=TEX
=GFT
€csyn_con_eq_clauses› =
   Ù (µ p1 p2∑ MkCcon p1 = MkCcon p2 § p1 = p2)
       ± (µ p1 p2∑ MkCiapp p1 = MkCiapp p2 § p1 = p2)
=TEX
=GFT
€csyn_con_neq_clauses› =
   Ù (µ x y∑ ≥ MkCcon x = MkCiapp y)
       ± (µ x y∑ ≥ MkCiapp x = MkCcon y)
=TEX
=GFT
€is_fc_clauses1› =
   Ù µ x∑ (IsCcon x ¥ (∂ y∑ x = MkCcon y))
         ± (IsCiapp x ¥ (∂ y∑ x = MkCiapp y))
=TEX
=GFT
€Is_not_cases› =
   Ù µ x∑ ≥ IsCiapp x ≤ ≥ IsCcon x

€Is_not_fc_clauses› =
   Ù (µ x∑ IsCiapp x ¥ ≥ IsCcon x) ± (µ x∑ IsCcon x ¥ ≥ IsCiapp x)
=TEX

\ignore{
=IGN
set_flag("subgoal_package_quiet", true);
=SML
set_goal([], ¨(µ x∑ IsCcon (MkCcon x))
       ± (µ x∑ ≥ IsCcon (MkCiapp x))
       ± (µ x∑ IsCiapp (MkCiapp x))
       ± (µ x∑ ≥ IsCiapp (MkCcon x))
	Æ);
a (rewrite_tac [get_spec ¨IsCconÆ,
	get_spec ¨MkCconÆ,
	get_spec ¨IsCiappÆ,
	get_spec ¨MkCiappÆ]);
a (REPEAT strip_tac);
a (∂_tac ¨xÆ THEN rewrite_tac[]);
a (∂_tac ¨xÆ THEN rewrite_tac[]);
val cis_clauses = save_pop_thm "cis_clauses";

set_goal([], ¨(µi∑ CconName (MkCcon i) = i)
	±	(µv∑ CiappFargs (MkCiapp v) = v)
Æ);
a (rewrite_tac (map get_spec [
	¨MkCconÆ, ¨MkCiappÆ,
	¨CconNameÆ, ¨CiappFargsÆ]));
val csyn_proj_clauses = save_pop_thm "csyn_proj_clauses";

set_goal([], ¨µp∑ (IsCcon p ¥ MkCcon (CconName p) = p)
	±	(IsCiapp p ¥ MkCiapp (CiappFargs p) = p)
Æ);
a (rewrite_tac (map get_spec [
	¨MkCconÆ, ¨MkCiappÆ,
	¨CconNameÆ, ¨CiappFargsÆ, ¨IsCconÆ, ¨IsCiappÆ])
	THEN REPEAT strip_tac
	THEN asm_rewrite_tac[]);
val csyn_con_inv_fc_clauses = save_pop_thm "csyn_con_inv_fc_clauses";

set_goal([], ¨(µp1 p2∑ MkCcon p1 =  MkCcon p2 § p1 = p2)
	± (µp1 p2∑ MkCiapp p1 =  MkCiapp p2 § p1 = p2)Æ);
a (REPEAT µ_tac THEN rewrite_tac (map get_spec [¨MkCconÆ, ¨MkCiappÆ, ¨CconNameÆ, ¨CiappFargsÆ, ¨IsCconÆ, ¨IsCiappÆ])
	THEN REPEAT strip_tac
	THEN_TRY asm_rewrite_tac[]);
a (fc_tac [rewrite_rule [get_spec ¨OneOneÆ] Urelement_def]);
val csyn_con_eq_clauses = save_pop_thm "csyn_con_eq_clauses";

set_goal([], ¨(µx y∑ ≥ MkCcon x = MkCiapp y)
	± (µx y∑ ≥ MkCiapp x = MkCcon y)Æ);
a (rewrite_tac (map get_spec [¨MkCconÆ, ¨MkCiappÆ]));
val csyn_con_neq_clauses = save_pop_thm "csyn_con_neq_clauses";

add_pc_thms "'icomb" [ordâu_natâu_thm, cis_clauses, csyn_proj_clauses, csyn_con_eq_clauses, csyn_con_neq_clauses];
set_merge_pcs ["misc31", "'icomb"];

set_goal([], ¨µx∑
	(IsCcon x ¥ ∂y∑ x = MkCcon y)
±	(IsCiapp x ¥ ∂y∑ x = MkCiapp y)
Æ);
a (REPEAT µ_tac THEN rewrite_tac [get_spec ¨IsCiappÆ, get_spec ¨MkCiappÆ, get_spec ¨IsCconÆ, get_spec ¨MkCconÆ, get_spec ¨MkCiappÆ]);
val is_fc_clauses1 = save_pop_thm "is_fc_clauses1";

set_goal([], ¨µx∑ ≥ IsCiapp x ≤ ≥ IsCcon xÆ);
a (rewrite_tac (map get_spec [¨IsCiappÆ, ¨IsCconÆ, ¨MkCiappÆ, ¨MkCconÆ]));
a (REPEAT strip_tac THEN asm_rewrite_tac[]
	THEN contr_tac THEN FC_T (MAP_EVERY ante_tac) [natg_one_one_thm]
	THEN PC_T1 "lin_arith" rewrite_tac[]);
val Is_not_cases = save_pop_thm "Is_not_cases";

set_goal ([], ¨
	(µx∑ IsCiapp x ¥ ≥ IsCcon x)
±	(µx∑ IsCcon x ¥ ≥ IsCiapp x)
Æ);
a (rewrite_tac (map get_spec [¨IsCiappÆ, ¨IsCconÆ, ¨MkCiappÆ, ¨MkCconÆ]));
a (REPEAT strip_tac THEN asm_rewrite_tac[]
	THEN contr_tac THEN FC_T (MAP_EVERY ante_tac) [natg_one_one_thm]
	THEN_TRY PC_T1 "lin_arith" rewrite_tac[]);
val Is_not_fc_clauses = save_pop_thm "Is_not_fc_clauses";
=TEX
}%ignore

=GFT
€cis_fc_clauses1› =
   Ù µ x∑ (IsCiapp x ¥ (∂ f args∑ x = MkCiapp (f, args)))
         ± (IsCcon x ¥ (∂ n∑ x = MkCcon n)) 

€cis_not_cases› =
   Ù µ x∑ ≥ IsCiapp x ≤ ≥ IsCcon x

€cis_not_fc_clauses› =
   Ù (µ x∑ IsCiapp x ¥ ≥ IsCcon x) ± (µ x∑ IsCcon x ¥ ≥ IsCiapp x)
=TEX

\ignore{
=SML
set_goal([], ¨µ x∑ (IsCcon x ¥ (∂ n∑ x = MkCcon n))
         ± (IsCiapp x ¥ (∂g∑ x = MkCiapp g))Æ);
a (REPEAT µ_tac THEN rewrite_tac (map get_spec [¨MkCconÆ, ¨CconNameÆ, ¨IsCconÆ, ¨IsCiappÆ]));
val cis_fc_clauses1 = save_pop_thm "cis_fc_clauses1";

set_goal([], ¨µx∑ ≥ IsCiapp x ≤ ≥ IsCcon xÆ);
a (rewrite_tac (map get_spec [¨IsCiappÆ, ¨IsCconÆ, ¨MkCiappÆ, ¨MkCconÆ]));
a (REPEAT strip_tac THEN asm_rewrite_tac[]);
val cis_not_cases = save_pop_thm "cis_not_cases";

set_goal ([], ¨
	(µx∑ IsCiapp x ¥ ≥ IsCcon x)
±	(µx∑ IsCcon x ¥ ≥ IsCiapp x)
Æ);
a (rewrite_tac (map get_spec [¨IsCiappÆ, ¨IsCconÆ, ¨MkCiappÆ, ¨MkCconÆ]));
a (REPEAT strip_tac THEN asm_rewrite_tac[]
	THEN contr_tac THEN FC_T (MAP_EVERY ante_tac) [natg_one_one_thm]
	THEN PC_T1 "lin_arith" rewrite_tac[]);
val cis_not_fc_clauses = save_pop_thm "cis_not_fc_clauses";
=TEX
}%ignore

\subsubsection{Infinitary Application}

The purpose of the infinitary case combinator is to ensure that ``all'' functions over small collections are available.
The naive way of doing this would simply be to have a small map from combinators to combinators, to represent an arbitrary small function graph.
However, all functions must respect equivalence over combinators, and such a representation would admit function graphs which violate this requirement, and reduce the calculus to nonsense.

The way round this which I have chosen is to represent the functions with a more operational flavour, the effect of which is to disambiguate graphs which might otherwise fall foul of the requirement to respect equivalence.
This is done with an infinitary case statement.
This takes an ordered sequence of pairs of combinators.
The reduction rules only address the first of the pairs.
If the lhs converts to ``true'' (a value to be defined) then the rhs is the value of the expression as a whole.
If the lhs converts to ``false'' then the first pair from the sequence is removed and conversion continues.
\footnote{This is not a wholly satisfactory definition, since it fails adequately to articulate the treatment of limit cases so as to admit case statements of arbitrary cardinality.
This problem will be more carefully addressed when the conversion rules are articulated.}

The following predicate is the discriminator for the case combinations.

πHOLCONST
‹ €IsFargs›: 'a GSU ≠ BOOL
˜¸¸¸¸¸¸¸¸¸¸¸
‹ µs∑ IsFargs s § Funâu s ± Ordinalâu (Domâu s)
∞

\subsubsection{The Inductive Definition of Csyntax}

This is accomplished by defining the required closure condition (closure under the above constructors for arguments of the right kind) and then taking the intersection of all sets which satisfy the closure condition.

The closure condition is:

πHOLCONST
‹ €CrepClosed›: 'a GSU SET ≠ BOOL
˜¸¸¸¸¸¸¸¸¸¸¸
‹ µ s∑ CrepClosed s §
‹	(µx∑ MkCcon x ç s)
‹±	(µg∑ IsFargs g ± Xâu (Ranâu g) Ä s ¥ MkCiapp g ç s)
∞

The well-formed syntax is then the smallest set closed under these constructions.

πHOLCONST
‹ €Csyntax› : 'a GSU SET
˜¸¸¸¸¸¸¸¸¸¸¸
‹ Csyntax = •{x | CrepClosed x}
∞

I have contrived to arrange the semantics which follows as a monotone function over a complete partial order, so that when I start to look for fixed points of the semantic functor (to give the equivalence relation for an intepretation of an illative icomb-calculus) I can look at the least and greatest fixed points, and either prove one of the total or otherwise employ them to find a total fixed point.

\subsubsection{Closure}\label{Closure}

=GFT
€crepclosed_csyntax_lemma› =
	Ù CrepClosed Csyntax
=TEX
=GFT
€crepclosed_csyntax_thm› =
  Ù	 (µ x∑ MkCcon x ç Csyntax)
       ± (µ g
       ∑ IsIcase g ± (µ x∑ x ç Xâu (Fieldâu (Ranâu g)) ¥ x ç Csyntax)
           ¥ MkCcon g ç Csyntax)
       ± (µ f a∑ f ç Csyntax ± a ç Csyntax ¥ MkCapp (f, a) ç Csyntax)
=TEX
=GFT
€crepclosed_csyntax_thm2› =
   Ù (µ x∑ MkCcon x ç Csyntax)
       ± (µ g
       ∑ IsIcase g
             ± (µ x∑ x çâu Domâu (Ranâu g) ≤ x çâu Ranâu (Ranâu g) ¥ x ç Csyntax)
           ¥ MkCcon g ç Csyntax)
       ± (µ f a∑ f ç Csyntax ± a ç Csyntax ¥ MkCapp (f, a) ç Csyntax)
=TEX
=GFT
€crepclosed_csyntax_lemma1› =
	Ù µ s∑ CrepClosed s ¥ Csyntax Ä s
=TEX
=GFT
€crepclosed_csyntax_lemma2› =
	Ù µ p∑ CrepClosed {x|p x} ¥ (µ x∑ x ç Csyntax ¥ p x)
=TEX

\ignore{
=SML
val IsFargs_def = get_spec ¨IsFargsÆ;
val CrepClosed_def = get_spec ¨CrepClosedÆ;
val Csyntax_def = get_spec ¨CsyntaxÆ;

set_goal([], ¨CrepClosed CsyntaxÆ);
val _ = a (rewrite_tac [CrepClosed_def]
	THEN strip_tac);
(* *** Goal "1" *** *)
val _ = a (rewrite_tac [Csyntax_def, CrepClosed_def, IsFargs_def]
	THEN REPEAT strip_tac THEN asm_fc_tac [] THEN asm_rewrite_tac[]);
(* *** Goal "2" *** *)
val _ = a (rewrite_tac [Csyntax_def]
	THEN REPEAT strip_tac
	THEN all_asm_fc_tac[]);
val _ = a (fc_tac [get_spec ¨CrepClosedÆ]);
val _ = a (REPEAT (asm_ufc_tac[]));
val crepclosed_csyntax_lemma = pop_thm();

val crepclosed_csyntax_thm = save_thm ("crepclosed_csyntax_thm",
	rewrite_rule [get_spec ¨CrepClosedÆ] crepclosed_csyntax_lemma);

val crepclosed_csyntax_thm2 = save_thm ("crepclosed_csyntax_thm2",
	rewrite_rule [get_spec ¨XâuÆ] crepclosed_csyntax_thm);

local val _ = set_goal([], ¨µs∑ CrepClosed s ¥ Csyntax Ä sÆ);
val _ = a (rewrite_tac [get_spec ¨CsyntaxÆ]
	THEN prove_tac[]);
in val crepclosed_csyntax_lemma1 = save_pop_thm "crepclosed_csyntax_lemma1";
end;

local val _ = set_goal([], ¨µp∑ CrepClosed {x | p x} ¥ µx∑ x ç Csyntax ¥ p xÆ);
val _ = a (rewrite_tac [get_spec ¨CsyntaxÆ] THEN REPEAT strip_tac);
val _ = a (asm_fc_tac[]);
in val crepclosed_csyntax_lemma2 = save_pop_thm "crepclosed_csyntax_lemma2";
end;
=TEX
}%ignore

\subsubsection{Recursion and Induction Principles and Rules}\label{Induction}

We need to be able to define functions by recursion over this syntax.
To do that we need to prove that the syntax is well-founded.
This is the case relative to the transitive closure of the membership relation, but to get a convenient basis for reasoning inductively over the syntax and for defining functions by recursion over the syntax it is best to define an ordering in terms of the syntactic constructors for the syntax.

This could be done strictly over the well-formed syntactic constructs, but this would involve more complexity both in the definitions and in subsequent proofs than by defining it in terms of the syntactic constructors whatever they are applied to.

πHOLCONST
‹ €CscPrec› : 'a GSU REL
˜¸¸¸¸¸¸¸¸¸¸¸
‹ µ¡ «∑ CscPrec ¡ « §
‹		(∂iappn∑ (¡ çâu (Ranâu iappn)) ± « = MkCiapp iappn)
∞


=GFT
€CscPrec_tc_ç_thm› =
	Ù µ x y∑ CscPrec x y ¥ tc $çâu x y

€well_founded_CscPrec_thm› =
	Ù well_founded CscPrec
=TEX

\ignore{
=SML
local val _ = set_goal([], ¨µx y∑ CscPrec x y ¥ tc $çâu x yÆ);
val _ = a (rewrite_tac (map get_spec [¨CscPrecÆ, ¨MkCiappÆ, ¨MkCconÆ]));
val _ = a (REPEAT strip_tac THEN asm_rewrite_tac [Ìâu_tc_thm]);
val _ = a (all_fc_tac [tcçâu_incr_thm]);
val _ = a (fc_tac [tcçâu_Ranâu_thm]);
val _ = a (lemma_tac ¨$çâuõ+ iappn (Natâu 1 Ìâu iappn)Æ
	THEN1 rewrite_tac [tcçâu_Ìâu_right_thm]);
val _ = a (all_fc_tac [tcçâu_trans_thm]);
val _ = a (POP_ASM_T ante_tac THEN rewrite_tac[get_spec ¨$çâuõ+Æ]);
in val CscPrec_tc_ç_thm = pop_thm();
end;

local val _ = set_goal ([], ¨well_founded CscPrecÆ);
val _ = a (rewrite_tac [get_spec ¨well_foundedÆ]);
val _ = a (REPEAT strip_tac);
val _ = a (asm_tac (µ_elim ¨sÆ gsu_cv_ind_thm));
val _ = a (lemma_tac ¨µ x∑ (µ y∑ tc $çâu y x ¥ s y) ¥ s xÆ
	THEN1 REPEAT strip_tac);
(* *** Goal "1" *** *)
val _ = a (lemma_tac ¨µ y∑ CscPrec y x ¥ s yÆ
	THEN1 (REPEAT strip_tac THEN all_fc_tac [CscPrec_tc_ç_thm]
		THEN asm_fc_tac []));
val _ = a (asm_fc_tac[]);
(* *** Goal "2" *** *)
val _ = a (asm_fc_tac[]);
val _ = a (asm_rewrite_tac[]);
in val well_founded_CscPrec_thm =  save_pop_thm "well_founded_CscPrec_thm";
end;
=TEX
}%ignore

=GFT
€well_founded_tcCscPrec_thm› =
	Ù well_founded (tc CscPrec)
=TEX

\ignore{
=SML
set_goal([], ¨well_founded (tc CscPrec)Æ);
val _ = a (asm_tac well_founded_CscPrec_thm);
val _ = a (fc_tac [wf_tc_wf_thm]);
val well_founded_tcCscPrec_thm = save_pop_thm ("well_founded_tcCscPrec_thm");
=TEX
}%ignore

=SML
val €CSC_INDUCTION_T› = WFCV_INDUCTION_T well_founded_CscPrec_thm;
val €csc_induction_tac› = wfcv_induction_tac well_founded_CscPrec_thm;
=TEX

The set Csyntax gives us the syntactically well-formed phrases of our language.
It will be useful to have some predicates which incorporate well-formedness, which are defined here.

=GFT
€csyntax_disj_thm› =
   Ù µ x∑ x ç Csyntax ¥ (∂ n∑ x = MkCcon n)
           ≤ (∂ g∑ IsFargs g ± (µ y∑ y çâu Ranâu g ¥ y ç Csyntax) ± x = MkCiapp g)

€csyntax_cases_thm› =
   Ù µ x∑ x ç Csyntax ¥ IsCcon x ≤ IsCiapp x
=TEX
=GFT
€cis_fc_clauses› =
   Ù µ x∑ x ç Csyntax
         ¥ (IsCcon x ¥ (∂ n∑ x = MkCcon n))
           ± (IsCiapp x ¥ (∂ g∑ IsFargs g
                 ± (µ y∑ y çâu Ranâu g ¥ y ç Csyntax)
                 ± x = MkCiapp g))
=TEX
=GFT
€MkCcon_ç_Csyntax_lemma› = Ù µ n∑ MkCcon n ç Csyntax 
=TEX
=GFT
€≥öâu_lemma1› =
   Ù (µ n∑ ≥ MkCcon n = öâu)
       ± (µ x y∑ ≥ MkCiapp x = öâu)

€≥öâu_lemma2› =
   Ù ≥ IsCcon öâu ± ≥ IsCiapp öâu

€≥öâu_ç_csyntax_lemma› =
   Ù ≥ öâu ç Csyntax

€≥öâu_ç_csyntax_lemma2› =
   Ù µ x∑ x ç Csyntax ¥ ≥ x = öâu

€≥öâu_ç_csyntax_lemma3› =
   Ù µ V x∑ x ç V ± V Ä Csyntax ¥ ≥ x = öâu
=TEX

\ignore{
=SML
local val _ = set_goal([], ¨µx∑	x ç Csyntax
¥	(∂n∑ x = MkCcon n)
  ≤	(∂g∑ IsFargs g ± (µy∑ y çâu (Ranâu g) ¥ y ç Csyntax) ± x = MkCiapp g)
Æ);
val _ = a (contr_tac);
val _ = a (lemma_tac ¨CrepClosed (Csyntax \ {x})Æ
	THEN1 (rewrite_tac [get_spec ¨CrepClosedÆ] THEN REPEAT strip_tac));
(* *** Goal "1" *** *)
val _ = a (asm_rewrite_tac [crepclosed_csyntax_thm]);
(* *** Goal "2" *** *)
val _ = a (contr_tac);
val _ = a (spec_nth_asm_tac 3 ¨x'Æ);
val _ = a (POP_ASM_T ante_tac);
val _ = a (POP_ASM_T (asm_tac o eq_sym_rule));
val _ = a (contr_tac);
(* *** Goal "3" *** *)
val _ = a (lemma_tac ¨MkCcon x' ç CsyntaxÆ THEN1 asm_rewrite_tac [crepclosed_csyntax_thm]);
val _ = a (lemma_tac ¨µ y∑ y ç Xâu (Ranâu g) ¥ y ç CsyntaxÆ
	THEN1 (REPEAT strip_tac THEN asm_fc_tac[]));
val _ = a (all_fc_tac [crepclosed_csyntax_thm]);
(* *** Goal "4" *** *)
val _ = a (lemma_tac ¨µ y∑ y çâu (Ranâu g) ¥ y ç CsyntaxÆ
	THEN1 (REPEAT strip_tac THEN asm_fc_tac[]));
(* *** Goal "4.1" *** *)
val _ = a (lemma_tac ¨y ç Xâu (Ranâu g)Æ
	THEN1 (asm_rewrite_tac [Xâu_def]));
val _ = a (all_asm_fc_tac []);
(* *** Goal "4.2" *** *)
val _ = a (spec_nth_asm_tac 4 ¨gÆ);
(* *** Goal "4.2.1" *** *)
val _ = a (all_asm_fc_tac []);
(* *** Goal "4.2.2" *** *)
val _ = a (swap_nth_asm_concl_tac 1);
val _ = a (asm_rewrite_tac []);
(* *** Goal "5" *** *)
val _ = a (asm_tac crepclosed_csyntax_lemma1);
val _ = a (spec_nth_asm_tac 1 ¨Csyntax \ {x}Æ);
val _ = a (spec_nth_asm_tac 1 ¨xÆ);
in val csyntax_disj_thm = save_pop_thm "csyntax_disj_thm";
end;

local val _ = set_goal([], ¨µx∑ x ç Csyntax ¥ IsCcon x ≤ IsCiapp xÆ);
val _ = a (REPEAT_N 2 strip_tac THEN fc_tac [csyntax_disj_thm]
	THEN asm_rewrite_tac[]);
in val csyntax_cases_thm = save_pop_thm "csyntax_cases_thm";
end;

local val _ = set_goal([], ¨µx∑	x ç Csyntax
¥	(IsCcon x ¥ ∂n∑ x = MkCcon n)
±	(IsCiapp x ¥ ∂g∑ IsFargs g ± (µy∑ y çâu (Ranâu g) ¥ y ç Csyntax) ± x = MkCiapp g)
Æ);
val _ = a (REPEAT_N 2 strip_tac);
val _ = a (asm_tac (csyntax_disj_thm));
val _ = a (asm_fc_tac[] THEN asm_rewrite_tac [cis_clauses]);
(* *** Goal "1" *** *)
val _ = a (∂_tac ¨nÆ THEN asm_rewrite_tac[]);
(* *** Goal "2" *** *)
val _ = a (∂_tac ¨gÆ THEN asm_rewrite_tac[IsFargs_def]);
in val cis_fc_clauses = save_pop_thm "cis_fc_clauses";
end;

set_goal([], ¨µn∑ MkCcon n ç CsyntaxÆ);
a (rewrite_tac [get_spec ¨CsyntaxÆ, sets_ext_clauses, ç_in_clauses, get_spec ¨CrepClosedÆ]
	THEN REPEAT strip_tac
	THEN asm_rewrite_tac[]);
val MkCcon_ç_Csyntax_lemma = save_pop_thm "MkCcon_ç_Csyntax_lemma";

set_goal([], ¨(µn∑ ≥ MkCcon n = öâu) ± µx∑ ≥ MkCiapp x = öâuÆ);
a (rewrite_tac (map get_spec [¨MkCconÆ, ¨MkCiappÆ]));
val ≥öâu_lemma1 = save_pop_thm "≥öâu_lemma1";

set_goal([], ¨≥ IsCcon öâu ± ≥ IsCiapp öâuÆ);
a (rewrite_tac (map get_spec [¨IsCconÆ, ¨IsCiappÆ]));
a (rewrite_tac (map get_spec [¨MkCconÆ, ¨MkCiappÆ]));
val ≥öâu_lemma2 = save_pop_thm "≥öâu_lemma2";

set_goal([], ¨≥ öâu ç CsyntaxÆ);
a (contr_tac);
a (fc_tac [csyntax_cases_thm] THEN POP_ASM_T ante_tac THEN rewrite_tac[≥öâu_lemma2]);
val ≥öâu_ç_csyntax_lemma = save_pop_thm "≥öâu_ç_csyntax_lemma";

set_goal([], ¨µx∑ x ç Csyntax ¥ ≥ x = öâuÆ);
a (contr_tac THEN var_elim_nth_asm_tac 1
	THEN POP_ASM_T ante_tac
	THEN rewrite_tac [≥öâu_ç_csyntax_lemma]);
val ≥öâu_ç_csyntax_lemma2 = save_pop_thm "≥öâu_ç_csyntax_lemma2";
 
set_goal([], ¨µV x∑ x ç V ± V Ä Csyntax ¥ ≥ x = öâuÆ);
a (REPEAT strip_tac
	THEN lemma_tac ¨x ç CsyntaxÆ THEN1 PC_T1 "hol1" asm_prove_tac[]
	THEN fc_tac [≥öâu_ç_csyntax_lemma2]);
val ≥öâu_ç_csyntax_lemma3 = save_pop_thm "≥öâu_ç_csyntax_lemma3";

add_pc_thms "'icomb" [≥öâu_ç_csyntax_lemma, MkCcon_ç_Csyntax_lemma, ≥öâu_lemma1, ≥öâu_lemma2];
set_merge_pcs ["misc31", "'icomb"];
=TEX
}%ignore

=GFT
€cis_fc_clauses2› =
   Ù µx∑ x ç Csyntax
	¥ (IsCiapp x ¥ IsFargs (CiappFargs x)
			± (µy∑ y çâu (Ranâu (CiappFargs x)) ¥ y ç Csyntax))

€csyn_comp_fc_clauses› =
   Ù µg∑ MkCiapp g ç Csyntax ¥ IsFargs g ± (µ x∑ x çâu (Ranâu g) ¥ x ç Csyntax)

€cscprec_fc_clauses› =
   Ù µ ¡ « vars fs∑ « = MkCcon (vars, fs) ± ¡ çâu fs ¥ ScPrec ¡ «
=IGN
€cscprec_fc_clauses2› =
   Ù µ t∑ t ç Csyntax ¥ IsCcon t ¥ (µ f∑ f çâu CfForms t ¥ ScPrec f t)
=TEX

\ignore{
=SML
local val _ = set_goal([], ¨µx∑ x ç Csyntax
	¥ (IsCiapp x ¥ IsFargs (CiappFargs x) ± (µy∑ y çâu (Ranâu (CiappFargs x)) ¥ y ç Csyntax))
Æ);
val _ = a (REPEAT strip_tac
	THEN all_fc_tac [cis_fc_clauses]
	THEN GET_NTH_ASM_T 1 (var_elim_asm_tac o concl)
	THEN_TRY asm_rewrite_tac[]);
val _ = a (DROP_NTH_ASM_T 3 ante_tac THEN asm_rewrite_tac[]);
in val cis_fc_clauses2 = save_pop_thm "cis_fc_clauses2";
end;

local val _ = set_goal([], ¨
	(µg∑ MkCiapp g ç Csyntax ¥ IsFargs g ± (µx∑ x çâu (Ranâu g) ¥ x ç Csyntax))Æ);
val _ = a (REPEAT strip_tac
	THEN FC_T (MAP_EVERY (strip_asm_tac o (rewrite_rule []))) [cis_fc_clauses2]
	THEN asm_fc_tac[]);
in val csyn_comp_fc_clauses = save_pop_thm "csyn_comp_fc_clauses";
end;

local val _ = set_goal([], ¨µ«∑
		(µg∑ « = MkCiapp g ¥ (µx∑ x çâu (Ranâu g) ¥ CscPrec x «))
Æ);
val _ = a (rewrite_tac [get_spec ¨CscPrecÆ]);
val _ = a (REPEAT µ_tac THEN strip_tac THEN strip_tac THEN REPEAT µ_tac THEN strip_tac
	THEN asm_rewrite_tac[]);
val _ = a (∂_tac ¨gÆ THEN asm_rewrite_tac[]);
in val cscprec_fc_clauses = save_pop_thm "cscprec_fc_clauses";
end;

=IGN
local val _ = set_goal ([], ¨µt∑ t ç Csyntax ¥ 
	(IsCcon t ¥ µf∑ f çâu CfForms t ¥ ScPrec f t)Æ);
val _ = a (REPEAT strip_tac
	THEN all_fc_tac [cis_fc_clauses]
	THEN DROP_NTH_ASM_T 3 ante_tac
	THEN asm_rewrite_tac[]
	THEN strip_tac
	THEN all_fc_tac [cscprec_fc_clauses]
	THEN POP_ASM_T ante_tac
	THEN_TRY asm_rewrite_tac []);
in val cscprec_fc_clauses2 = save_pop_thm "cscprec_fc_clauses2";
end;

set_goal ([], ¨µt∑ IsCabs t ¥ µf∑ f çâu CfForms t ¥ ScPrec f tÆ);
a (REPEAT strip_tac THEN rewrite_tac [get_spec ¨ScPrecÆ]);
a (∂_tac ¨CconName tÆ THEN ∂_tac ¨CfForms tÆ THEN asm_rewrite_tac[]);
a (ALL_FC_T rewrite_tac [csyn_con_inv_fc_clauses]);
val cscprec_fc_clauses2 = save_pop_thm "cscprec_fc_clauses2";
=TEX
}%ignore

Inductive proofs using the well-foundedness of ScPrec are fiddly.
The following induction principle simplifies the proofs.

=GFT
€csyn_induction_thm› =
   Ù µ p∑ (µ n∑ p (MkCcon n))
        ± (µ g∑ IsFargs g ± (µ x∑ x çâu (Ranâu g) ¥ x ç Csyntax ± p x) ¥ p (MkCiapp g))
     ¥ (µ x∑ x ç Csyntax ¥ p x)
=TEX

\ignore{
=SML
set_goal([], ¨µ p∑ (µ n∑ p (MkCcon n))
	± (µg∑ IsFargs g ± (µx∑ x çâu (Ranâu g) ¥ x ç Csyntax ± p x) ¥ p (MkCiapp g))
	¥ (µ x∑ x ç Csyntax ¥ p x)Æ);
a (REPEAT strip_tac);
a (POP_ASM_T ante_tac THEN csc_induction_tac ¨xÆ THEN strip_tac);
a (fc_tac [csyntax_cases_thm]);
(* *** Goal "1" *** *)
a (fc_tac [cis_fc_clauses] THEN asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a (all_fc_tac [cis_fc_clauses] THEN asm_rewrite_tac[]);

a (lemma_tac ¨µ x∑ x çâu (Ranâu g) ¥ x ç Csyntax ± p xÆ
	THEN1 (strip_tac THEN STRIP_T asm_tac));
(* *** Goal "2.1" *** *)
a (spec_nth_asm_tac 3 ¨xÆ THEN asm_rewrite_tac[]);
a (lemma_tac ¨CscPrec x tÆ THEN1 (asm_rewrite_tac[get_spec ¨CscPrecÆ]));
(* *** Goal "2.1.1" *** *)
a (∂_tac ¨gÆ THEN asm_rewrite_tac[]);
a (DROP_NTH_ASM_T 2 ante_tac THEN REPEAT strip_tac);
(* *** Goal "2.1.2" *** *)
a (all_fc_tac [tc_incr_thm]);
a (all_asm_fc_tac[]);
(* *** Goal "2.2" *** *)
a (all_asm_fc_tac[]);
val csyn_induction_thm = save_pop_thm "csyn_induction_thm";
=TEX
}%ignore

Using this induction principle an induction tactic is defined as follows:

=SML
fun €icomb_induction_tac› t (a,c) = (
	let val l1 = mk_app (mk_Ã (t,c), t)
	    and l2 = mk_app (mk_app (mk_const ("ç", î'a GSU ≠ 'a GSU SET ≠ BOOLÆ), t),
					mk_const ("Csyntax", î'a GSU SETÆ))
	in  let val l3 = mk_µ (t, mk_¥ (l2, l1))
	in  LEMMA_T l1 (rewrite_thm_tac o rewrite_rule[])
	THEN DROP_ASM_T l2 ante_tac
	THEN LEMMA_T l3 (rewrite_thm_tac o rewrite_rule[])
	THEN bc_tac [csyn_induction_thm]
	THEN rewrite_tac[]
	THEN strip_tac
	end end) (a,c);
=TEX

This tactic expects an argument $t$ of type $TERM$ which is a free variable of type $'a GSU$ whose sole occurrence in the assumptions is in an assumption ¨ëtÆ ç CsyntaxÆ, and results in two subgoals, one requiring a proof for atomic and the other for compound formulae (with the benefit of the induction hypothesis in the assumptions).

\subsubsection{Recursion Theorem}\label{Recursion}

The following recursion theorem supports definition by primitive recursion of functions over the syntax.

The following function provides domain restriction of a function over 'a GSU.
Since this is an operation on total functions, the effect is achieved by delivering a function which returns the same value for all arguments outside the restricted domain.
The purpose is to constrain recursion to be well founded, so the possibility of returning a function completely unconstrained in what it does off the restricted domain does not suffice (we would not be able to prove that the domain restriction had done anything at all).


πHOLCONST
‹ €DomRes› : 'a GSU ≠ ('a GSU ≠ 'b) ≠ ('a GSU ≠ 'b)
˜¸¸¸¸¸¸¸¸¸¸¸
‹ µs f∑ DomRes s f = Ãt∑ if t çâu s then f t else ≈x∑T
∞


=SML
declare_alias("Ú", ¨DomResÆ);
=TEX

A recursion lemma suitable for consistency proofs of primitive recursive definitions over our syntax can now be proven:

=GFT
€csc_recursion_lemma› =
   Ù µcf af∑ ∂f∑
	(µn∑ f (MkCcon n) = cf n)
	± (µg∑ f (MkCiapp g) = af (DomRes (Ranâu g) f) g
=TEX


\ignore{
=SML
val DomRes_def = get_spec ¨DomResÆ;

set_goal([], ¨µ(cf:'a ≠ 'b) (af:('a GSU ≠ 'b) ≠ 'a GSU ≠ 'b)∑ ∂(f:'a GSU ≠ 'b)∑
	(µn∑ f (MkCcon n) = cf n)
	± µg∑ f (MkCiapp g) = af (DomRes (Ranâu g) f) gÆ);
val _ = a (REPEAT strip_tac);
val _ = a (lemma_tac ¨∂g:((('a)GSU≠'b)≠(('a)GSU≠'b))∑
	g = Ãf x∑
	if IsCcon x then cf (CconName x)
	else if IsCiapp x then af (DomRes (Ranâu (CiappFargs x)) f) (CiappFargs x)
	else cf (≈x:'a∑T)Æ
	THEN1 prove_∂_tac);
val _ = a (lemma_tac ¨g respects CscPrecÆ
	THEN1 (asm_rewrite_tac [get_spec ¨$respectsÆ] THEN REPEAT strip_tac));
(* *** Goal "1" *** *)
a (cond_cases_tac ¨IsCcon xÆ);
a (cond_cases_tac ¨IsCiapp xÆ);
a (LEMMA_T ¨DomRes (Ranâu (CiappFargs x)) g' = DomRes (Ranâu (CiappFargs x)) hÆ rewrite_thm_tac);
a (rewrite_tac [DomRes_def] THEN strip_tac);
a (cond_cases_tac ¨x' çâu Ranâu (CiappFargs x)Æ);
a (lemma_tac ¨CscPrec x' xÆ THEN1 (rewrite_tac [get_spec ¨CscPrecÆ]));
(* *** Goal "1.1" *** *)
a (∂_tac ¨CiappFargs xÆ THEN asm_rewrite_tac[]);
a (all_ufc_§_rewrite_tac [csyn_con_inv_fc_clauses]);
(* *** Goal "1.2" *** *)
a (fc_tac [tc_incr_thm]);
a (asm_fc_tac []);
(* *** Goal "2" *** *)
a (∂_tac ¨fix gÆ);
a (asm_tac well_founded_CscPrec_thm);
a (all_fc_tac [get_spec ¨fixÆ]);
a (POP_ASM_T ante_tac THEN asm_rewrite_tac[] THEN strip_tac);
a (GET_NTH_ASM_T 1 (once_rewrite_thm_tac o map_eq_sym_rule));
a (rewrite_tac[]);
val lsc_recursion_lemma = save_pop_thm "lsc_recursion_lemma";
=TEX
}%ignore

This is (when proven) plugged into proof context {\it 'icomb} for use in consistency proofs.

=GFT
add_∂_cd_thms [lsc_recursion_lemma] "'icomb";
set_merge_pcs ["misc31", "'icomb"];
=TEX

Unfortunately, it doesn't seem to work, as may be seen in the theory listing where the following constant, \emph{FreeVars}, has not had its consistency proven.

\subsubsection{Auxiliary Concepts}

This is just to test the recursion theorem.

πHOLCONST
‹ €CscRank› : 'a GSU ≠ 'a GSU
˜¸¸¸¸¸¸¸¸¸¸¸
‹ (µn∑ CscRank (MkCcon n) = Natâu 0)
  ± (µg∑ CscRank (MkCiapp g) = ﬁâu (Imagepâu (DomRes (Ranâu g) CscRank) (Ranâu g)))
∞


\subsection{Proof Contexts}

=IGN SML
(* add_pc_thms "'icomb" [evalcf_ftv_ft_lemma, evalcf_ftv_fb_lemma]; *)

(* add_pc_thms "'icomb" [get_spec ¨ExtensionÆ, get_spec ¨EssenceÆ]; *)
commit_pc "'icomb";

force_new_pc "€icomb›";
merge_pcs ["misc3", "'icomb"] "icomb";
commit_pc "icomb";

force_new_pc "€icomb1›";
merge_pcs ["misc31", "'icomb"] "icomb1";
commit_pc "icomb1";
=TEX

\section{Semantics}

The semantics is defined as an equivalence relation over the abstract syntax.

This is obtained as the least fixed point of a monotone operator over partial equivalence relations, where a partial equivalence relation is something like a pair of sets of ordered pairs of terms, one containing those known to be inequivalent and the other those known to be equivalent.

This functor is defined using a notion of direct conversion which captures the semantics of all the primitive combinators except the sole illative combinator (which is equivalence under indirect conversion).

\subsection{Direct Conversion}

The question of what are the primitive combinators must therefore now be addressed.
The starting point is with K and S, appropriately extended for an infinitary context.


\section{The Finitary System}

This is a marker for something in the future.
It is possible that in the exploration of the semantic ideas I may have to sketch some things out here before coming here to consider this level more seriously.

\subsection{The System of Type Assignment}




=SML
set_flag ("subgoal_package_quiet", false);
=TEX
