get_spec ¨ManyOneÆ;
=IGN
$Id: t023.doc,v 1.18 2012/11/24 20:22:24 rbj Exp $
open_theory "GS";
set_merge_pcs ["basic_hol", "'gst-ax", "'gst-ord", "'savedthm_cs_∂_proof"];
set_merge_pcs ["hol", "'wf_relp", "'wf_recp", "'GS1", "'savedthm_cs_∂_proof"];
set_merge_pcs ["hol1", "'gst-ax", "'gst-ord", "'savedthm_cs_∂_proof"];
=TEX
\documentclass[11pt,a4paper]{article}
%\usepackage{latexsym}
%\usepackage{ProofPower}
\usepackage{rbj}
\ftlinepenalty=9999
\usepackage{A4}

\def\ExpName{\mbox{{\sf exp}}}
\def\Exp#1{\ExpName(#1)}
\tabstop=0.4in
\newcommand{\ignore}[1]{}

\title{A Higher Order Theory of Well-Founded Sets}
\makeindex
\usepackage[unicode,pdftex]{hyperref}
\hypersetup{pdfauthor={Roger Bishop Jones}}
\hypersetup{colorlinks=true, urlcolor=black, citecolor=black, filecolor=black, linkcolor=black}

\author{Roger Bishop Jones}
\date{\ }

\begin{document}
\begin{titlepage}
\maketitle
\begin{abstract}
An axiomatic development in ProofPower-HOL of a higher order theory of well-founded sets.
This is similar to a higher order ZFC strengthened by the assertion that every set is a member of some other set which is a (standard) model of ZFC.
\end{abstract}

\vfill

\begin{centering}

{\footnotesize

Created 2007/09/25

Last Change $ $Date: 2012/11/24 20:22:24 $ $

\href{http://www.rbjones.com/rbjpub/pp/doc/t023.pdf}
{http://www.rbjones.com/rbjpub/pp/doc/t023.pdf}

$ $Id: t023.doc,v 1.18 2012/11/24 20:22:24 rbj Exp $ $

\copyright\ Roger Bishop Jones; Licenced under Gnu LGPL

}%footnotesize

\end{centering}

\thispagestyle{empty}
\end{titlepage}
\newpage
\addtocounter{page}{1}
{\parskip=0pt\tableofcontents}

\newpage

\section{Introduction}

This document provides a theory which is used in various foundational studies, for example in my investigations into non well-founded set theories.
So its primary purpose has been pragmatic (in the context of some rather bizzarre objectives).

However, central to my philosophy of {\it metaphysical positivism} is an analytic method and the necessary philosophical and technical material necessary to explain and underpin, possibly to justify, the method and its applications.
This has lead me to begin an attempt at explaining this theory as part of that method, which has not progressed far enough as yet to be of much value.
This follows.

This document forms a part of a foundational architecture.

In this introduction I will say a few words about the architecture and how this document fits into it, sufficient to give some motivation for the choices I have made here,

The architecture addresses descriptive languages and their use in deductive reasoning.
Such languages and methods are seen as enabling, especially when appropriately supported by digital information processing, advances in the ways in which various important objectives may be realised.

To reason deductively using some language, it is important that the language has a definite abstract semantics, and this is best realised by defining suitable languages using a formal semantics.
Unfortunately, a semantic regress results.

Multiple strategems are advocated for the termination of semantic regress.
We are concerned here with just one of these.
This involves termination of formal semantic regress in an informal semantics, which is itself primarily vested in an abstract ontology.

We therefore present:

\begin{itemize}
\item an informal description of an abstract ontology
\item an inforaml account of the truth conditions of languages suitable for talking and reasoning about this ontology
\item an approximation to this language as a computer supported formalised axiomatic theory
\end{itemize}

\section{Ontology}

The aim is for a universal abstract ontology.
That is, one to which any other kind of abstract ontology may be reduced.
This is to provide the subject matter for languages which may be universal in senses to be discussed.

It is seems natural, for many involved in formal semantics, to regard set theory as a metalanguage of last resort, in which the formal semantics of any other language might be given.
To be sure negative results on definability are interpreted as forcing us to consider set theories as languages which come in a heirarchy of strengths, and only the family of languages rather than any particular member of that family has any hope of being universal.
This does not exhaust the objections which can be raised against the possibility that set theory (or any other language) can be universal.

\subsection{Semantic Universality}

The practical utility of a foundation for abstract semantics does not rest on its being universal, but it is nevertheless an interesting possibility.

The kind of universality concerned here is universality for defining abstract semantics.
A universal language in this sense would be one in which the semantics of any other language could be rendered.
To make this notion of unversality precise you would have to make precise the relevant notion of ``language'' concerned and that of ``semantics''.
I know of no single contender for this.

It may be worth mentioning a couple of examples.

It is conventional wisdom that the truth predicate of a language cannot be defined in that language.
This is certainly demonstrable for first order arithmetic, via formalisation of epeminides' paradox.
If this could be generalised, it would yield a negative result on the possibility of a universal language for abstract semantics, and it is sometimes construed as doing so.

\subsection{Well-Founded Collections}

{\quote
A well-founded set is any definite collection of well-founded sets. 
}

This is intended as an inductive definition, and hence that only those collections whose well-foundedness follows from this definition are well-founded sets.
The term ``definite'' is important, since without some such qualification the definition would yield a contradiction, since the collection of well-founded sets which it defines would then be itself a well-founded set, and would hence not be well-founded.

This tells us that the notion of well-founded set is essentially open ended, that the formation of well-founded sets never comes to an end, that the well-founded sets do not form a definite collection.
The meaning of definite is intended here to be very weak.
We do require a set to be a definite collection in the sense that every possible member of the set either is or is not a member. 
This is what we need for membership to be encapsulated in a boolean relationship.
The concept of well-founded set could be made definite by giving a stronger meaning to definite in the above definition, e.g. by incorporating a limit on the size or rank of a definite set.
But I know of no natural and intuitively plausible strengthening, limitations of size and rank seem quite arbitrary.

\section{Axioms}

\subsection{Introduction}

Galactic set theory is a set theory with ``galaxies'' (previously known as ``universes'') axiomatised in Higher Order Logic.

\subsubsection{Scope}
This document is mainly concerned with the axioms of galactic set theory, but includes in addition some definitions and theorems which might easily have been part of the axiomatisation.
In the usual first order axiomatisations of set theory, for example, the $Pairâg$ constructor is introduced axiomatically.
In this axiomatisation neither the empty set nor $Pairâg$ are primitive, they are introduced by definition once the axioms have been presented.
Same goes for separation and intersection.
The theory {\tt gst-ax} created by this document, consists of an axiomatic development of a well-founded set theory in ProofPower HOL, and is created as a child of {\tt basic-hol}.
This version of the theory is derived from a previous version in which ``pseudo-urelements'' were available, and in which the standard set theoretic vocabulary was used (which rendered the theory unusable in combination with the usual ProofPower HOL theory of sets).
Pseudo-urelements were dropped because I don't need them, and, however slight the complication they introduce, its not necessary.
To enable this theory to be used with the standard set theory (properties in set theoretic clothing) the volcabulary has been systematically subscripted with `g' (for galactic).

\subsubsection{Why Galactic?}

This document introduces Galactic Set Theory, which is similar to what has elsewhere been called Universal Set Theory (e.g. by Paul M. Cohn in his ``Universal Algebra'', but I dare say it came from somewhere else).
The ``universes'' in Cohn, and the galaxies here are mostly models of ZFC, except the smallest in which there is no infinite set.
The other main difference is that galactic set theory is formulated in higher order logic.

\subsection{Membership}

The first thing we do is to introduce a new ProofPower theory and, in that theory, the new TYPE SET together with the membership relation and a psuedo-urelement injection.

\subsubsection{The Type GS}

The sets under consideration will be the elements of a new type {\it GS} so the first thing we do is to introduce that new type.
GS is a {\it pure} {\it well-founded} set theory.
Since the theory will not be conservative, we make no attempt to relate the membership of "GS" to any of the types already available.

=SML
open_theory "rbjmisc";
force_new_theory "€gst-ax›";
new_parent "U_orders";
new_parent "wf_relp";
new_parent "wf_recp";
force_new_pc "€'gst-ax›";
merge_pcs ["'savedthm_cs_∂_proof"] "'gst-ax";
set_merge_pcs ["basic_hol", "'gst-ax"];
new_type ("€GS›", 0);
=TEX

\subsection{Membership}

The most important constant is membership, which is a relation over the sets.
We can't define this constant (in this context) so it is introduced as a new constant (about which nothing is asserted except its name and type) and its properties are introduced axiomatically. 

=SML
new_const ("€çâg›", îGS≠GS≠BOOLÆ);
declare_infix (230,"çâg");
=TEX

I will possibly be making use of two different treatments of well-foundedness (from the theories {\it U\_orders}, and {\it wf\_relp}) and it may be helpful to establish the connection between them.

The following theorem does the trick:

=GFT
€UWellFounded_well_founded_thm› =
	Ù µ $<<∑ UWellFounded $<< § well_founded $<<
=TEX

\ignore{
=SML
set_goal ([], ¨µ$<<∑ UWellFounded $<< § well_founded $<<Æ);
a (rewrite_tac [get_spec ¨well_foundedÆ, u_well_founded_induction_thm]);
val UWellFounded_well_founded_thm = save_pop_thm "UWellFounded_well_founded_thm";
=TEX
}%ignore

The axioms of extensionality and well-foundedness may be thought of as telling us what kind of thing a set is (later axioms tell us how many of these sets are to be found in our domain of discourse).

\subsubsection{Extensionality}

The most fundamental property of membership (or is it of sets?) is {\it extensionality}, which tells us what kind of thing a set is.
The axiom tells us that if two sets have the same elements then they are in fact the same set.

=SML
val €gs_ext_axiom› = new_axiom (["gs_ext_axiom"],
	¨µs t:GS∑  s = t § µe∑ e çâg s § e çâg tÆ);
=TEX

It follows from the definitions of {\it IsPue} and {\it IsSet} and {\it ue\_inj\_axiom} that nothing is both a set and a urelement, and that urelements are equal iff the values from which they were obtained under Pue are equal.

It is convenient to have a function which gives the extension of a GS set as a SET of GSs.

πHOLCONST
‹ €Xâg› : GS ≠ GS SET
˜¸¸¸¸¸¸¸¸¸
‹ µs∑ Xâg s = {t | t çâg s}
∞

\subsubsection{Well-Foundedness}

Wellfoundedness is asserted using the definition in the theory ``U\_orders'', which is conventional in asserting that each non-empty set has a minimal element.

=SML
val €gs_wf_axiom› = new_axiom (["gs_wf_axiom"], ¨UWellFounded $çâgÆ);
=TEX

=GFT
€gs_wf_thm1› =		Ù well_founded $çâg
€gs_wf_min_thm› =	Ù µ x∑ (∂ y∑ y çâg x) ¥ (∂ z∑ z çâg x ± ≥ (∂ v∑ v çâg z ± v çâg x))
€gs_wftc_thm› =		Ù well_founded (tc $çâg)
=TEX

\ignore{
=SML
val gs_wf_thm1 = save_thm ("gs_wf_thm1", rewrite_rule [UWellFounded_well_founded_thm] gs_wf_axiom);
push_pc "sets_ext";

set_goal([], ¨well_founded (tc $çâg)Æ);
a (bc_tac [wf_tc_wf_thm]);
a (accept_tac gs_wf_thm1);
val gs_wftc_thm = save_pop_thm "gs_wftc_thm";

set_goal([], ¨µx∑ (∂y∑ y çâg x) ¥ ∂z∑ z çâg x ± ≥∂v∑ v çâg z ± v çâg xÆ);
a (REPEAT strip_tac);
a (asm_tac (rewrite_rule [µ_elim ¨$çâgÆ u_well_founded_def_thm] gs_wf_axiom));
a (spec_nth_asm_tac 1 ¨{z | z çâg x}Æ);
(* *** Goal "1" *** *)
a (spec_nth_asm_tac 1 ¨yÆ);
(* *** Goal "2" *** *)
a (∂_tac ¨x'Æ THEN contr_tac);
a (asm_prove_tac[]);
val gs_wf_min_thm = save_pop_thm "gs_wf_min_thm";
pop_pc();
=TEX
}%ignore

=SML
declare_infix (230, "çâgõ+");
=TEX

πHOLCONST
‹ $€çâgõ+› : GS ≠ GS ≠ BOOL
˜¸¸¸¸¸¸¸¸¸¸¸¸
‹ $çâgõ+ = tc $çâg
∞

=GFT
€gs_wftc_thm2› =	Ù well_founded $çâgõ+
€tcç_incr_thm› =		Ù µ x y∑ x çâg y ¥ x çâgõ+ y
€tcç_cases_thm› =	Ù µ x y∑ x çâgõ+ y § (x çâg y ≤ (∂ z∑ x çâgõ+ z ± z çâg y))
€tcç_trans_thm› =	Ù µ s t u∑ s çâgõ+ t ± t çâgõ+ u ¥ s çâgõ+ u
=TEX

\ignore{
=SML
set_goal([], ¨well_founded $çâgõ+Æ);
a (rewrite_tac [get_spec ¨$çâgõ+Æ, gs_wftc_thm]);
val gs_wftc_thm2 = save_pop_thm "gs_wftc_thm2";

set_goal([], ¨µx y∑ x çâg y ¥ x çâgõ+ yÆ);
a (rewrite_tac [get_spec ¨$çâgõ+Æ] THEN REPEAT strip_tac THEN fc_tac [tc_incr_thm]);
val tcç_incr_thm = save_pop_thm "tcç_incr_thm";

set_goal([], ¨µ x y∑ x çâgõ+ y § x çâg y ≤ ∂z∑ x çâgõ+ z ± z çâg yÆ);
a (REPEAT µ_tac THEN rewrite_tac [get_spec ¨$çâgõ+Æ] THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a (fc_tac [tc_decomp_thm]);
a (∂_tac ¨zÆ THEN asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a (fc_tac [tc_incr_thm]);
(* *** Goal "3" *** *)
a (lemma_tac ¨tc $çâg z yÆ THEN1 fc_tac [tc_incr_thm]);
a (all_ufc_tac [tran_tc_thm2]);
val tcç_cases_thm = save_pop_thm "tcç_cases_thm";

set_goal([], ¨µs t u∑ s çâgõ+ t ± t çâgõ+ u ¥ s çâgõ+ uÆ);
a(REPEAT µ_tac THEN rewrite_tac [get_spec ¨$çâgõ+Æ, tran_tc_thm2]);
val tcç_trans_thm = save_pop_thm "tcç_trans_thm";
=TEX
}%ignore

The resulting induction principle (sometimes called Neotherian induction) is useful.

=GFT
€gs_wf_ind_thm› =	Ù µ p∑ (µ x∑ (µ y∑ y çâg x ¥ p y) ¥ p x) ¥ (µ x∑ p x)
€gs_cv_ind_thm› =	Ù µ p∑ (µ x∑ (µ y∑ tc $çâg y x ¥ p y) ¥ p x) ¥ (µ x∑ p x)
€gs_cv_ind_thm2› =	Ù µ p∑ (µ x∑ (µ y∑ y çâgõ+ x ¥ p y) ¥ p x) ¥ (µ x∑ p x)
=TEX

But we can get induction tactics directly from the well-foundedness theorems:

=SML
val €GS_INDUCTION_T› = WF_INDUCTION_T gs_wf_thm1;
val €gs_induction_tac› = wf_induction_tac gs_wf_thm1;
val €GS_INDUCTION_T2› = WF_INDUCTION_T gs_wftc_thm2;
val €gs_induction_tac2› = wf_induction_tac gs_wftc_thm2;
=TEX

\ignore{
=SML
val gs_wf_ind_thm = save_thm ("gs_wf_ind_thm",
	(rewrite_rule  [µ_elim ¨$çâgÆ u_well_founded_induction_thm] gs_wf_axiom));

val gs_cv_ind_thm = save_thm ("gs_cv_ind_thm",
	(rewrite_rule  [rewrite_rule [UWellFounded_well_founded_thm]
	(µ_elim ¨tc $çâgÆ u_well_founded_induction_thm)] gs_wftc_thm));

val gs_cv_ind_thm2 = save_thm ("gs_cv_ind_thm2",
	(prove_rule  [gs_cv_ind_thm, get_spec ¨$çâgõ+Æ]
	¨µ p∑ (µ x∑ (µ y∑ y çâgõ+ x ¥ p y) ¥ p x) ¥ (µ x∑ p x)Æ));
=TEX
}%ignore


=GFT
€wf_l1› =	Ù µ x:GS∑ ≥ x çâg x
€wf_l2› =	Ù µ x y:GS∑ ≥ (x çâg y ± y çâg x)
€wf_l3› =	Ù µ x y z:GS∑ ≥ (x çâg y ± y çâg z ± z çâg x)
=TEX

\ignore{
=SML
set_goal([], ¨
	µ x:GS∑ ≥ x çâg x
Æ);
=TEX

The proof uses well-founded transfinite induction over the membership relation.

=SML
a (asm_tac (gs_wf_ind_thm));
a (spec_nth_asm_tac 1 ¨Ãx∑ ≥ x çâg xÆ);
=GFT
(* *** Goal "1" *** *)

(*  3 *)  ¨µ s∑ (µ x∑ (µ y∑ y çâg x ¥ s y) ¥ s x) ¥ (µ x∑ s x)Æ
(*  2 *)  ¨µ y∑ y çâg x ¥ (Ã x∑ ≥ x çâg x) yÆ
(*  1 *)  ¨≥ (Ã x∑ ≥ x çâg x) xÆ

(* ?Ù *)  ¨µ x∑ ≥ x çâg xÆ
=SML
a (swap_nth_asm_concl_tac 1
	THEN rewrite_tac[]
	THEN swap_nth_asm_concl_tac 1
	THEN ALL_ASM_FC_T (MAP_EVERY ante_tac) []
	THEN asm_rewrite_tac[]);
=GFT
(* *** Goal "2" *** *)

(*  2 *)  ¨µ s∑ (µ x∑ (µ y∑ y çâg x ¥ s y) ¥ s x) ¥ (µ x∑ s x)Æ
(*  1 *)  ¨µ x∑ (Ã x∑ ≥ x çâg x) xÆ

(* ?Ù *)  ¨µ x∑ ≥ x çâg xÆ
=SML
a (strip_tac
	THEN swap_nth_asm_concl_tac 1
	THEN rewrite_tac[]
	THEN REPEAT strip_tac
	THEN ∂_tac ¨xÆ
	THEN asm_rewrite_tac[]);
val wf_l1 = save_pop_thm "wf_l1";
=SML
set_goal([], ¨µ x y:GS∑ ≥ (x çâg y ± y çâg x)Æ);
=TEX

=SML
a (asm_tac gs_wf_ind_thm);
a (spec_nth_asm_tac 1 ¨Ãz∑ µx∑ ≥(x çâg z ± z çâg x)Æ);
(* *** Goal "1" *** *)
a (swap_nth_asm_concl_tac 1
	THEN rewrite_tac[]
	THEN swap_nth_asm_concl_tac 1
	THEN ALL_ASM_FC_T (MAP_EVERY ante_tac) []
	THEN asm_rewrite_tac[]);
a (strip_tac
	THEN spec_nth_asm_tac 1 ¨xÆ);
(* *** Goal "2" *** *)
a (strip_tac
	THEN swap_nth_asm_concl_tac 1
	THEN rewrite_tac[]
	THEN REPEAT strip_tac
	THEN ∂_tac ¨yÆ
	THEN REPEAT strip_tac
	THEN ∂_tac ¨xÆ
	THEN REPEAT strip_tac);
val wf_l2 = save_pop_thm "wf_l2";
=TEX

=SML
set_goal([], ¨µ x y z:GS∑ ≥ (x çâg y ± y çâg z ± z çâg x)Æ);
=TEX

=SML
a (asm_tac gs_wf_ind_thm);
a (spec_nth_asm_tac 1 ¨Ãz∑ µx y∑ ≥(x çâg y ± y çâg z ± z çâg x)Æ);
(* *** Goal "1" *** *)
a (swap_nth_asm_concl_tac 1
	THEN rewrite_tac[]
	THEN swap_nth_asm_concl_tac 1
	THEN ALL_ASM_FC_T (MAP_EVERY ante_tac) []
	THEN asm_rewrite_tac[]);
a (strip_tac
	THEN list_spec_nth_asm_tac 1 [¨xÆ, ¨x''Æ]);
(* *** Goal "2" *** *)
a (REPEAT µ_tac);
a (SPEC_NTH_ASM_T 1 ¨z:GSÆ ante_tac);
a (rewrite_tac[]);
a (strip_tac THEN asm_rewrite_tac[]);
val wf_l3 = save_pop_thm "wf_l3";
=TEX
}%ignore

\subsection{The Ontology Axiom}

The remaining axioms are intended to ensure that the subset is a large and well-rounded subset of the cumulative heirarchy.
This is to be accomplished by defining a Galaxy as a set satisfying certain closure properties and then asserting that every set is a member of some Galaxy.
It is convenient to introduce new constants and axioms for each of the Galactic closure properties before asserting the existence of the Galaxies.

Here we define the subset relation and assert the existence of powersets and unions.

\subsubsection{Subsets}

A subset s of t is a set all of whose members are also members of t.

=SML
declare_infix (230,"Äâg");
declare_infix (230,"†âg");
=TEX

πHOLCONST
‹ $€Äâg› : GS ≠ GS ≠ BOOL
˜¸¸¸¸¸¸¸¸¸¸¸
‹ µs t∑ s Äâg t § µe∑ e çâg s ¥ e çâg t
∞

πHOLCONST
‹ $€†âg› : GS ≠ GS ≠ BOOL
˜¸¸¸¸¸¸¸¸¸¸¸
‹ µs t∑ s †âg t § s Äâg t ± ≥ t Äâg s
∞

=GFT
€Äâg_thm› =			Ù µ s t∑ s Äâg t § (µ e∑ e çâg s ¥ e çâg t)
€Äâg_eq_thm› =		Ù µ A B∑ A = B § A Äâg B ± B Äâg A
€Äâg_refl_thm› =		Ù µ A∑ A Äâg A
€çâgÄâg_thm› =		Ù µ e A B∑ e çâg A ± A Äâg B ¥ e çâg B
€Äâg_trans_thm› =	Ù µ A B C∑ A Äâg B ± B Äâg C ¥ A Äâg C
€not_psub_thm› =	Ù µ x∑ ≥ x †âg x
=TEX

\ignore{
=SML
val Äâg_thm = get_spec ¨$ÄâgÆ;
val Äâg_eq_thm = save_thm ("Äâg_eq_thm", 
	prove_rule [get_spec ¨$ÄâgÆ, gs_ext_axiom]
	¨µA B∑ A = B § A Äâg B ± B Äâg AÆ);
val Äâg_refl_thm = save_thm ("Äâg_refl_thm", 
	prove_rule [get_spec ¨$ÄâgÆ]
	¨µA∑ A Äâg AÆ);
val çâgÄâg_thm = save_thm ("çâgÄâg_thm",
	prove_rule [get_spec ¨$ÄâgÆ]
	¨µe A B∑ e çâg A ± A Äâg B ¥ e çâg BÆ);
val Äâg_trans_thm = save_thm ("Äâg_trans_thm",
	prove_rule [get_spec ¨$ÄâgÆ]
	¨µA B C∑ A Äâg B ± B Äâg C ¥ A Äâg CÆ);

set_goal ([], ¨µx∑ ≥ x †âg xÆ);
a (rewrite_tac [get_spec ¨$†âgÆ]);
a (REPEAT strip_tac);
val not_psub_thm = save_pop_thm "not_psub_thm";
=TEX
}%ignore

πHOLCONST
‹ €Äâg_closed› : GS ≠ BOOL
˜¸¸¸¸¸¸¸¸¸¸¸¸
‹ µs∑ Äâg_closed s § µe f∑ e çâg s ± f Äâg e ¥ f çâg s
∞


\subsubsection{The Ontology Axiom}

We now specify with a single axiom the closure requirements which ensure that our universe is adequately populated.
The ontology axiom states that every set is a member of some galaxy which is transitive and closed under formation of powersets and unions and under replacement.

The formulation of replacement only makes membership of a galaxy dependent on the range being contained in the galaxy, it asserts unconditionally the sethood of the image of a set under a functional relation.

=SML
val €Ontology_axiom› =
	new_axiom (["Ontology_axiom"],
¨ µs∑
	∂g∑ s çâg g
±
	µt∑ t çâg g ¥ t Äâg g
	± (∂p∑ (µv∑ v çâg p § v Äâg t) ± p çâg g)
	± (∂u∑ (µv∑ v çâg u § ∂w∑ v çâg w ± w çâg t) ± u çâg g)
	± (µrel∑ ManyOne rel ¥
		(∂r∑ (µv∑ v çâg r § ∂w ∑ w çâg t ± rel w v) ±
			(r Äâg g ¥ r çâg g)))Æ
);
=TEX

\subsection{PowerSets and Union}

Here we define the powerset and union operators.

\subsubsection{PowerSets}

\ignore{
=SML
set_goal([],¨∂ âg∑ µs t:GS∑ t çâg âg s § t Äâg sÆ);
a (prove_∂_tac THEN strip_tac);
a (strip_asm_tac (µ_elim ¨s'Æ (Ontology_axiom)));
a (spec_nth_asm_tac 1 ¨s'Æ);
a (∂_tac ¨pÆ THEN asm_rewrite_tac[]);
save_cs_∂_thm (pop_thm ());
=TEX
}%ignore

πHOLCONST
‹ €âg›: GS ≠ GS
˜¸¸¸¸¸¸¸¸¸¸¸¸¸
‹ µs t:GS∑ t çâg âg s § t Äâg s
∞

=GFT
€sçs_thm› =	Ù µ s∑ s çâg âg s
€stcçs_thm› =	Ù µ s∑ s çâgõ+ âg s
=TEX

\ignore{
=SML
set_goal([], ¨µs∑ s çâg âg sÆ);
a (rewrite_tac [get_spec ¨âgÆ, Äâg_thm]);
val sçs_thm = save_pop_thm "sçs_thm";

set_goal([], ¨µs∑ s çâgõ+ âg sÆ);
a (rewrite_tac [get_spec ¨$çâgõ+Æ]);
a (asm_tac sçs_thm THEN ufc_tac [tc_incr_thm]);
val stcçs_thm = save_pop_thm "stcçs_thm";
=TEX
}%ignore

\subsubsection{Union}

\ignore{
=SML
set_goal([],¨∂ﬁâg∑ µs t∑ t çâg ﬁâg s § ∂e∑ t çâg e ± e çâg sÆ);
a (prove_∂_tac THEN strip_tac);
a (strip_asm_tac (µ_elim ¨s'Æ Ontology_axiom));
a (spec_nth_asm_tac 1 ¨s'Æ);
a (∂_tac ¨uÆ THEN asm_rewrite_tac[]);
save_cs_∂_thm (pop_thm ());
=TEX
}%ignore

πHOLCONST
‹ €ﬁâg›: GS ≠ GS
˜¸¸¸¸¸¸¸¸¸¸¸
‹ µs t∑ t çâg ﬁâg s § ∂e∑ t çâg e ± e çâg s
∞

=GFT
€çâgﬁâg_thm› =	Ù µs t:GS∑ t çâg s ¥ t Äâg ﬁâg s
=TEX

\ignore{
=SML
val çâgﬁâg_thm = save_thm ("çâgﬁâg_thm",
	prove_rule [get_spec ¨ﬁâgÆ, Äâg_thm]
	¨µs t:GS∑ t çâg s ¥ t Äâg ﬁâg sÆ);
=TEX
}%ignore

\subsection{Relational Replacement}

The constant RelIm is defined for relational replacement.

\subsubsection{RelIm}

\ignore{
=SML
set_goal([],¨∂RelIm∑ µrel s t∑ ManyOne rel ¥ (t çâg RelIm rel s § ∂e∑ e çâg s ± rel e t)Æ);
a (prove_∂_tac THEN REPEAT strip_tac);
a (strip_asm_tac (µ_elim ¨s'Æ Ontology_axiom));
a (spec_nth_asm_tac 1 ¨s'Æ);
a (spec_nth_asm_tac 1 ¨rel'Æ);
a (asm_rewrite_tac[]);
a (∂_tac ¨rÆ THEN strip_tac THEN strip_tac THEN asm_rewrite_tac[]);
a (∂_tac ¨rÆ THEN strip_tac THEN strip_tac THEN asm_rewrite_tac[]);
save_cs_∂_thm (pop_thm ());
=TEX
}%ignore

πHOLCONST
‹ €RelIm›: (GS ≠ GS ≠ BOOL) ≠ GS ≠ GS
˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹ µrel s t∑ ManyOne rel ¥ (t çâg RelIm rel s § ∂e∑ e çâg s ± rel e t)
∞

\subsection{Separation}

Separation is introduced by conservative extension.

The specification of {\it Sep} which follows is introduced after proving that it is satisfied by a term involving the use of $RelIm$.

\ignore{
=SML
set_goal([],¨∂Sep∑ µs p e∑
e çâg (Sep s p) § e çâg s ± p e
Æ);
a (prove_∂_tac THEN REPEAT strip_tac);
a (strip_asm_tac (list_µ_elim [¨s'Æ] (Ontology_axiom)));
a (lemma_tac ¨∂rel∑ rel = Ãx y∑ p' x ± y = xÆ
	THEN1 prove_∂_tac);
a (lemma_tac ¨ManyOne relÆ
	THEN1 asm_rewrite_tac [get_spec ¨ManyOne relÆ]);
(* *** Goal "1" *** *)
a (REPEAT strip_tac THEN asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a (∂_tac ¨RelIm rel s'Æ);
a (§_FC_T asm_rewrite_tac [get_spec ¨RelImÆ]);
a (prove_tac[]);
save_cs_∂_thm (pop_thm());
=TEX
}%ignore

This higher order formulation of separation is accomplished by defining a new constant which takes a property of sets {\it p} and a set {\it s} and returns the subset of {\it s} consisting of those elements which satisfy {\it p}.

πHOLCONST
‹ €Sep› : GS ≠ (GS ≠ BOOL) ≠ GS
˜¸¸¸¸¸¸¸¸¸¸¸
‹ µs p e∑ e çâg (Sep s p) § e çâg s ± p e
∞

\ignore{
=SML
val Sep_thm = get_spec ¨SepÆ;
fun add_pc_thms pc thms =
		(add_rw_thms thms pc;
		add_sc_thms thms pc;
 		add_st_thms thms pc);
add_pc_thms "'gst-ax" [Sep_thm, Äâg_refl_thm];
add_rw_thms [stcçs_thm] "'gst-ax";
add_sc_thms [stcçs_thm] "'gst-ax";
set_merge_pcs ["basic_hol", "'gst-ax"];
=TEX
}%ignore

=GFT
€Sep_sub_thm› =		Ù µ s p∑ Sep s p Äâg s
€Sep_sub_thm2› =	Ù µ s p e∑ e çâg Sep s p ¥ e çâg s
€Sep_ç__thm› =	Ù µ s p∑ Sep s p çâg âg s
€Sep_Ä_thm› =		Ù µ s t∑ t Äâg s ¥ Sep s (CombC $çâg t) = t
=TEX

\ignore{
=SML
set_goal([], ¨µs p∑ (Sep s p) Äâg sÆ);
a (rewrite_tac [get_spec ¨$ÄâgÆ, get_spec ¨SepÆ]
	THEN REPEAT strip_tac);
val Sep_sub_thm = save_pop_thm "Sep_sub_thm";

val Sep_sub_thm2 = save_thm ("Sep_sub_thm2", pure_rewrite_rule [get_spec ¨$ÄâgÆ] Sep_sub_thm);

set_goal([], ¨µs p∑ (Sep s p) çâg âg sÆ);
a (rewrite_tac [get_spec ¨âgÆ, Sep_sub_thm]);
val Sep_ç__thm = save_pop_thm "Sep_ç__thm";

set_goal([], ¨µs t∑ t Äâg s ¥ Sep s (CombC $çâg t) = tÆ);
a (strip_tac THEN rewrite_tac [gs_ext_axiom, get_spec ¨$ÄâgÆ, get_spec ¨SepÆ, get_spec ¨CombCÆ]
	THEN REPEAT strip_tac
	THEN asm_fc_tac[]);
val Sep_Ä_thm = save_pop_thm "Sep_Ä_thm";
=TEX
}%ignore

\subsection{Galaxies}

A Galaxy is a transitive set closed under powerset formation, union and replacement.
The Ontology axioms ensures that every set is a member of some galaxy.
Here we define a galaxy constructor and establish some of its properties.

\subsubsection{Definition of Galaxy}

First we define the property of being a galaxy.

πHOLCONST
‹ €galaxy›: GS ≠ BOOL
˜¸¸¸¸¸¸¸¸¸¸¸
‹ µs∑
‹	galaxy s § (∂x∑ x çâg s)
‹	± µt∑ t çâg s
‹		¥ t Äâg s
‹		± âg t çâg s
‹		± ﬁâg t çâg s
‹		± (µrel∑ ManyOne rel
‹			¥ RelIm rel t Äâg s
‹			¥ RelIm rel t çâg s)
∞

=GFT
€galaxies_∂_thm› =
	Ù µs∑ ∂g∑ s çâg g ± galaxy g
=TEX

\ignore{
=SML
set_goal([],¨µs∑ ∂g∑ s çâg g ± galaxy gÆ);
a (strip_tac THEN rewrite_tac [get_spec ¨galaxyÆ]);
a (strip_asm_tac (µ_elim ¨sÆ Ontology_axiom));
a (∂_tac ¨gÆ THEN asm_rewrite_tac []);
a (strip_tac
	THEN1 (∂_tac ¨sÆ THEN strip_tac)
	THEN strip_tac THEN strip_tac);
a (spec_nth_asm_tac 2 ¨tÆ);
a (asm_rewrite_tac[] THEN strip_tac);
(* *** Goal "1" *** *)
a (lemma_tac ¨âg t = pÆ
	THEN1 (rewrite_tac [get_spec ¨âgÆ, gs_ext_axiom]
		THEN strip_tac
		THEN asm_rewrite_tac[])
	);
a (asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a (strip_tac);
(* *** Goal "2.1" *** *)
a (lemma_tac ¨ﬁâg t = uÆ
	THEN1 (rewrite_tac [get_spec ¨ﬁâgÆ, gs_ext_axiom]
		THEN strip_tac
		THEN asm_rewrite_tac[])
	);
a (asm_rewrite_tac[]);
(* *** Goal "2.2" *** *)
a (strip_tac THEN strip_tac);
a (spec_nth_asm_tac 2 ¨relÆ);
(* *** Goal "2.2.1" *** *)
a (lemma_tac ¨RelIm rel t = rÆ);
(* *** Goal "2.2.1.1" *** *)
a (rewrite_tac [gs_ext_axiom]);
a (§_FC_T asm_rewrite_tac [get_spec ¨RelImÆ]);
(* *** Goal "2.2.1.2" *** *)
a (asm_rewrite_tac[]);
(* *** Goal "2.2.2" *** *)
a (lemma_tac ¨RelIm rel t = rÆ);
(* *** Goal "2.2.2.1" *** *)
a (rewrite_tac [gs_ext_axiom]);
a (§_FC_T asm_rewrite_tac [get_spec ¨RelImÆ]);
(* *** Goal "2.2.2.2" *** *)
a (asm_rewrite_tac[]);
val galaxies_∂_thm = save_pop_thm "galaxies_∂_thm";
=TEX
}%ignore

\subsubsection{Definition of Gx}

{\it Gx} is a function which maps each set onto the smallest galaxy of which it is a member.

\ignore{
=SML
set_goal([],¨∂ Gx∑ µs t∑ t çâg Gx s § µg∑ galaxy g ± s çâg g ¥ t çâg gÆ);
a (prove_∂_tac THEN strip_tac);
a (strip_asm_tac (µ_elim ¨s'Æ galaxies_∂_thm));
a (∂_tac ¨Sep g (Ãh∑ µ i∑ galaxy i ± s' çâg i ¥ h çâg i)Æ);
a (rewrite_tac [get_spec ¨SepÆ]);
a (REPEAT strip_tac THEN_TRY all_asm_fc_tac[]);
save_cs_∂_thm (pop_thm());
=TEX
}%ignore

πHOLCONST
‹ €Gx›: GS ≠ GS
˜¸¸¸¸¸¸¸¸¸¸¸¸
‹ µs t∑ t çâg Gx s § µg∑ galaxy g ± s çâg g ¥ t çâg g
∞

Each set is in its smallest enclosing galaxy, which is of course a galaxy and is contained in any other galaxy of which that set is a member:

=GFT
€t_in_Gx_t_thm› =		Ù µ t∑ t çâg Gx t
€tcç_Gx_thm› =			Ù µ t∑ t çâgõ+ Gx t
€galaxy_Gx› =			Ù µs∑ galaxy (Gx s)
€Gx_Äâg_galaxy› =		Ù µs g∑ galaxy g ± s çâg g  ¥ (Gx s) Äâg g
=TEX

\ignore{
=SML
set_goal([], ¨µt∑ t çâg Gx tÆ);
a (prove_tac [get_spec ¨GxÆ]);
val t_in_Gx_t_thm = save_pop_thm "t_in_Gx_t_thm";

val tcç_Gx_thm = 
	let val [thm] = ufc_rule [tcç_incr_thm] [t_in_Gx_t_thm]
	in save_thm("tcç_Gx_thm", thm)
	end;
=TEX

Now we prove that Gx s is a subset of any galaxy containing s.

=SML
set_goal([],¨µs g∑ galaxy g ± s çâg g  ¥ (Gx s) Äâg gÆ);
a (rewrite_tac[get_spec ¨$ÄâgÆ, get_spec ¨GxÆ]);
a (REPEAT strip_tac THEN all_asm_fc_tac[]);
val Gx_Äâg_galaxy = save_pop_thm "Gx_Äâg_galaxy";
=TEX

Now we prove that Gx always yeilds a galaxy.

=SML
set_goal([],¨µs∑ galaxy (Gx s)Æ);
a (rewrite_tac (map get_spec [¨galaxyÆ]));
a (REPEAT_N 2 strip_tac
	THEN1 (∂_tac ¨sÆ
		THEN rewrite_tac [get_spec ¨GxÆ]
		THEN REPEAT strip_tac)
	THEN strip_tac
	THEN rewrite_tac [get_spec ¨GxÆ]
	THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a (rewrite_tac (map get_spec [¨$ÄâgÆ,¨GxÆ])
	THEN REPEAT strip_tac);
a (all_asm_fc_tac [get_spec ¨galaxyÆ]);
a (all_asm_fc_tac [get_spec ¨galaxyÆ]);
a (asm_ante_tac ¨t Äâg gÆ
	THEN rewrite_tac [get_spec ¨$ÄâgÆ]
	THEN strip_tac
	THEN REPEAT (asm_fc_tac[]));
(* *** Goal "2" *** *)
a (all_asm_fc_tac [get_spec ¨galaxyÆ]);
a (all_asm_fc_tac [get_spec ¨galaxyÆ]);
(* *** Goal "3" *** *)
a (all_asm_fc_tac [get_spec ¨galaxyÆ]);
a (all_asm_fc_tac [get_spec ¨galaxyÆ]);
(* *** Goal "4" *** *)
a (all_asm_fc_tac[]);
a (asm_fc_tac [list_µ_elim [¨gÆ] (get_spec ¨galaxyÆ)]);
a (REPEAT (all_asm_fc_tac [Gx_Äâg_galaxy, Äâg_trans_thm]));
val galaxy_Gx = save_pop_thm "galaxy_Gx";
=TEX
}%ignore

\subsubsection{Galaxy Closure}

The galaxy axiom asserts that a Galaxy is transitive and closed under construction of powersets, distributed union and replacement.
Galaxies are also closed under most other ways of constructing sets, and we need to demonstrate these facts systematically as the theory is developed.

πHOLCONST
‹ €transitive› : GS ≠ BOOL
˜¸¸¸¸¸¸¸¸¸¸¸¸
‹ µs∑ transitive s § µe∑ e çâg s ¥ e Äâg s
∞

=GFT
€GalaxiesTransitive_thm› =	Ù µs∑ galaxy s ¥ transitive s
=TEX

\ignore{
=SML
set_goal([],¨µs∑ galaxy s ¥ transitive sÆ);
a (rewrite_tac [get_spec ¨transitiveÆ]);
a (REPEAT strip_tac
	THEN fc_tac [get_spec¨galaxyÆ]
	THEN asm_fc_tac[]);
val GalaxiesTransitive_thm = save_pop_thm "GalaxiesTransitive_thm";
=TEX
}%ignore

=GFT
€GClose_thm› =	Ù µ g∑ galaxy g ¥ (µ s∑ s çâg g ¥ âg s çâg g)
€GCloseﬁ_thm› =	Ù µ g∑ galaxy g ¥ (µ s∑ s çâg g ¥ ﬁâg s çâg g)
€GCloseSep_thm› =	Ù µ g∑ galaxy g ¥ (µs∑ s çâg g ¥ µp∑ Sep s p çâg g)
€GClose_Ä_thm› =	Ù µ g∑ galaxy g ¥ (µ s∑ s çâg g ¥ (µ t∑ t Äâg s ¥ t çâg g))
=TEX

\ignore{
=SML
set_goal([],¨µg∑ galaxy g ¥ µs∑ s çâg g ¥ âg s çâg gÆ);
a (REPEAT strip_tac);
a (fc_tac [get_spec ¨galaxyÆ]);
a (asm_fc_tac[]);
val GClose_thm = pop_thm ();

set_goal([],¨µg∑ galaxy g ¥ µs∑ s çâg g ¥ ﬁâg s çâg gÆ);
a (REPEAT strip_tac);
a (fc_tac [get_spec ¨galaxyÆ]);
a (asm_fc_tac[]);
val GCloseﬁ_thm = pop_thm ();

set_goal([],¨µg∑ galaxy g ¥ µs∑ s çâg g ¥ µp∑ Sep s p çâg gÆ);
a (REPEAT strip_tac);
a (fc_tac [get_spec ¨galaxyÆ]);
a (lemma_tac ¨∂rel∑ rel = Ãx y∑ p x ± y = xÆ
	THEN1 prove_∂_tac);
a (lemma_tac ¨ManyOne relÆ
	THEN1 asm_rewrite_tac [get_spec ¨ManyOne relÆ]);
(* *** Goal "1" *** *)
a (REPEAT strip_tac THEN asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a (lemma_tac ¨Sep s p = RelIm rel s ± RelIm rel s çâg gÆ);
(* *** Goal "2.1" *** *)
a (list_spec_nth_asm_tac 7 [¨sÆ,¨relÆ]);
(* *** Goal "2.1.1" *** *)
a (SWAP_NTH_ASM_CONCL_T 1 discard_tac);
a (rewrite_tac[get_spec ¨$ÄâgÆ]);
a (§_FC_T rewrite_tac [get_spec ¨RelImÆ]);
a (asm_rewrite_tac[]);
a (REPEAT strip_tac THEN asm_rewrite_tac[]);
a (SPEC_NTH_ASM_T 7 ¨sÆ ante_tac);
a (rewrite_tac[get_spec ¨$ÄâgÆ]);
a (REPEAT strip_tac THEN asm_fc_tac[]);
(* *** Goal "2.1.2" *** *)
a (REPEAT strip_tac THEN rewrite_tac[gs_ext_axiom]);
a (§_FC_T asm_rewrite_tac [get_spec ¨RelImÆ]);
a (REPEAT strip_tac THEN_TRY asm_rewrite_tac[]);
a (∂_tac ¨eÆ THEN asm_rewrite_tac[]);
(* *** Goal "2.2" *** *)
a (once_asm_rewrite_tac[] THEN strip_tac);
val GCloseSep_thm = pop_thm {};

set_goal([],¨µg∑ galaxy g ¥ µs∑ s çâg g ¥ µt∑ t Äâg s ¥ t çâg gÆ);
a (REPEAT strip_tac);
a (fc_tac [GCloseSep_thm, GClose_thm]);
a (asm_ufc_tac[]);
a (SPEC_NTH_ASM_T 1 ¨Ãx∑ x çâg tÆ ante_tac);
a (LEMMA_T ¨(Ã x∑ x çâg t) = CombC $çâg tÆ rewrite_thm_tac
	THEN1 rewrite_tac [get_spec ¨CombCÆ]);
a (FC_T rewrite_tac [Sep_Ä_thm]);
val GClose_Ä_thm = pop_thm ();
=TEX
}%ignore

=GFT
€GClose_fc_clauses› =
   Ù µ g
     ∑ galaxy g
         ¥ (µ s
         ∑ s çâg g
             ¥ âg s çâg g
               ± ﬁâg s çâg g
               ± (µ p∑ Sep s p çâg g)
               ± (µ t∑ t Äâg s ¥ t çâg g))
=TEX

\ignore{
=SML
set_goal([], ¨µg∑ galaxy g ¥ µs∑ s çâg g
	¥ âg s çâg g
	± ﬁâg s çâg g
	± (µp∑ Sep s p çâg g)
	± (µt∑ t Äâg s ¥ t çâg g)Æ);
a (REPEAT strip_tac
	THEN all_fc_tac [GClose_thm, GCloseﬁ_thm, GCloseSep_thm, GClose_Ä_thm]
	THEN asm_rewrite_tac[]);
val GClose_fc_clauses = save_pop_thm "GClose_fc_clauses";
=TEX
}%ignore

=GFT
€tcçâg_lemma› =		Ù µ s e∑ e çâgõ+ s ¥ (µ t∑ transitive t ± s Äâg t ¥ e çâg t)
€GClose_tcçâg_thm› =	Ù µ s g∑ galaxy g ¥ s çâgõ+ g ¥ s çâg g
=TEX

\ignore{
=SML
set_goal([], ¨µs e∑ e çâgõ+ s ¥ µt∑ transitive t ± s Äâg t ¥ e çâg tÆ);
a (strip_tac THEN rewrite_tac [get_spec ¨transitiveÆ, get_spec ¨$çâgõ+Æ]);
a (gs_induction_tac ¨sÆ THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a (fc_tac[tc_decomp_thm, get_spec ¨$ÄâgÆ]);
(* *** Goal "1.1" *** *)
a (asm_fc_tac []);
(* *** Goal "1.2" *** *)
a (lemma_tac ¨tc $çâg z tÆ THEN1 fc_tac [tc_incr_thm]);
a (spec_nth_asm_tac 8 ¨zÆ);
a (spec_nth_asm_tac 1 ¨sÆ);
(* *** Goal "1.2.1" *** *)
a (all_asm_fc_tac[]);
(* *** Goal "1.2.2" *** *)
a (lemma_tac ¨z Äâg t'Æ THEN1 (REPEAT (asm_fc_tac[])));
a (all_asm_fc_tac[]);
val tcçâg_lemma = pop_thm();

set_goal([], ¨µs g∑ galaxy g ¥ (s çâgõ+ g ¥ s çâg g)Æ);
a (REPEAT strip_tac);
a (fc_tac [GalaxiesTransitive_thm]);
a (fc_tac [tcçâg_lemma]);
a (asm_fc_tac []);
a (POP_ASM_T ante_tac THEN rewrite_tac[]);
val GClose_tcçâg_thm = save_pop_thm "GClose_tcçâg_thm";
=TEX
}%ignore

=GFT
€Gx_mono_thm› =	Ù µs t∑ s Äâg t ¥ Gx s Äâg Gx t
€Gx_mono_thm2› =	Ù µs t∑ s çâg t ¥ Gx s Äâg Gx t
=TEX

=GFT
€Gx_trans_thm› =	Ù µ s∑ transitive (Gx s)
€Gx_trans_thm2› =	Ù µ s t∑ s çâg t ¥ s çâg Gx t
€Gx_trans_thm3› =	Ù µ s t u∑ s çâg t ± t çâg Gx u ¥ s çâg Gx u
€t_sub_Gx_t_thm› =	Ù µ t∑ t Äâg Gx t
=TEX

=GFT
€Gx_mono_thm3› =	Ù µ s t∑ s Äâg t ¥ s Äâg Gx t
€Gx_mono_thm4› =	Ù µ s t∑ s Äâg t ¥ s çâg Gx t
=TEX

\ignore{
=SML
set_goal([], ¨µs t∑ s Äâg t ¥ Gx s Äâg Gx tÆ);
a (REPEAT strip_tac);
a (lemma_tac ¨galaxy (Gx t)Æ THEN1 rewrite_tac [galaxy_Gx]);
a (lemma_tac ¨s çâg (Gx t)Æ);
(* *** Goal "1" *** *)
a (lemma_tac ¨t çâg Gx tÆ
	THEN1 rewrite_tac [t_in_Gx_t_thm]);
a (fc_tac [GCloseSep_thm]);
a (LIST_SPEC_NTH_ASM_T 1 [¨tÆ, ¨Ãx∑ x çâg sÆ] ante_tac);
a (lemma_tac ¨Sep t (Ã x∑ x çâg s) = sÆ
	THEN1 (once_rewrite_tac[gs_ext_axiom]
		THEN rewrite_tac[get_spec ¨SepÆ]
		THEN REPEAT strip_tac));
(* *** Goal "1.1" *** *)
a (GET_NTH_ASM_T 5 ante_tac
	THEN once_rewrite_tac [get_spec ¨$ÄâgÆ]
	THEN strip_tac
	THEN asm_fc_tac[]);
(* *** Goal "1.2" *** *)
a (once_rewrite_tac[asm_rule ¨Sep t (Ã x∑ x çâg s) = sÆ]);
a (strip_tac);
(* *** Goal "2" *** *)
a (fc_tac [Gx_Äâg_galaxy]);
a (asm_fc_tac[]);
val Gx_mono_thm = save_pop_thm "Gx_mono_thm";

set_goal([], ¨µs t∑ s çâg t ¥ Gx s Äâg Gx tÆ);
a (REPEAT strip_tac);
a (lemma_tac ¨galaxy (Gx t)Æ THEN1 rewrite_tac [galaxy_Gx]);
a (fc_tac [GalaxiesTransitive_thm]);
a (fc_tac [get_spec ¨transitiveÆ]);
a (lemma_tac ¨t çâg Gx tÆ THEN1 rewrite_tac[t_in_Gx_t_thm]);
a (ASM_FC_T (MAP_EVERY(strip_asm_tac o (once_rewrite_rule [get_spec ¨$ÄâgÆ]))) [] 
	THEN asm_fc_tac[]);
a (all_fc_tac [Gx_Äâg_galaxy]);
val Gx_mono_thm2 = save_pop_thm "Gx_mono_thm2";

set_goal([], ¨µs∑ transitive (Gx s)Æ);
a (strip_tac);
a (lemma_tac ¨galaxy (Gx s)Æ THEN1 rewrite_tac [galaxy_Gx]);
a (fc_tac [GalaxiesTransitive_thm]);
val Gx_trans_thm = save_pop_thm "Gx_trans_thm";

set_goal([], ¨µt∑ t Äâg Gx tÆ);
a (REPEAT strip_tac);
a (lemma_tac ¨t çâg Gx tÆ THEN1 rewrite_tac [t_in_Gx_t_thm]);
a (fc_tac [rewrite_rule [get_spec ¨transitiveÆ]Gx_trans_thm]);
val t_sub_Gx_t_thm = save_pop_thm "t_sub_Gx_t_thm";

set_goal([], ¨µs t∑ s Äâg t ¥ s Äâg Gx tÆ);
a (REPEAT strip_tac);
a (lemma_tac ¨t Äâg Gx tÆ THEN1 rewrite_tac [t_sub_Gx_t_thm]);
a (all_fc_tac [Äâg_trans_thm]);
val Gx_mono_thm3 = save_pop_thm "Gx_mono_thm3";

set_goal([], ¨µs t∑ s Äâg t ¥ s çâg Gx tÆ);
a (REPEAT strip_tac);
a (lemma_tac ¨galaxy (Gx t)Æ THEN1 rewrite_tac[galaxy_Gx]);
a (lemma_tac ¨t çâg Gx tÆ THEN1 rewrite_tac[t_in_Gx_t_thm]);
a (all_ufc_tac [GClose_fc_clauses]);
val Gx_mono_thm4 = save_pop_thm "Gx_mono_thm4";

set_goal([], ¨µs t∑ s çâg t ¥ s çâg Gx tÆ);
a (REPEAT strip_tac);
a (lemma_tac ¨t çâg Gx tÆ THEN1 rewrite_tac [t_in_Gx_t_thm]);
a (lemma_tac ¨transitive (Gx t)Æ THEN1 rewrite_tac [Gx_trans_thm]);
a (ALL_FC_T (MAP_EVERY (fn x => fc_tac [rewrite_rule [get_spec ¨$ÄâgÆ] x]))
	[get_spec ¨transitiveÆ]);
val Gx_trans_thm2 = save_pop_thm "Gx_trans_thm2";

set_goal([], ¨µs t u∑ s çâg t ± t çâg Gx u ¥ s çâg Gx uÆ);
a (REPEAT strip_tac);
a (LEMMA_T ¨transitive (Gx u)Æ ante_tac THEN1 rewrite_tac [Gx_trans_thm]);
a (rewrite_tac [get_spec ¨transitiveÆ]
	THEN STRIP_T (fn x => FC_T (MAP_EVERY ante_tac) [x]));
a (rewrite_tac [get_spec ¨$ÄâgÆ] THEN STRIP_T (fn x => fc_tac [x]));
val Gx_trans_thm3 = save_pop_thm "Gx_trans_thm3";

=TEX
}%ignore

\subsubsection{The Empty Set}

We can now prove that there is an empty set.

\ignore{
=SML
set_goal([], ¨∂ öâg∑ µs∑ ≥ s çâg öâgÆ);
a (∂_tac ¨Sep (≈s:GS∑ T) (Ãx:GS∑ F)Æ
	THEN rewrite_tac [get_spec¨SepÆ]);
save_cs_∂_thm (pop_thm ());
=TEX
}%ignore

So we define $¨öâgÆ$ as the empty set:

πHOLCONST
‹ €öâg› : GS
˜
‹ µs∑ ≥ s çâg öâg
∞

and the empty set is a member of every galaxy:

=GFT
€GöâgC› =		Ù µ g∑ galaxy g ¥ öâg çâg g
€öâgÄâg_thm› =	Ù µ s∑ öâg Äâg s
€ﬁâgöâg_thm› =	Ù ﬁâg öâg = öâg
=TEX
=GFT
€öâg_spec› =				Ù µ s∑ ≥ s çâg öâg
€mem_not_empty_thm› =	Ù µ m n∑ m çâg n ¥ ≥ n = öâg
€öâg_çâg_galaxy_thm› =	Ù µ x∑ galaxy x ¥ öâg çâg x
€öâg_çâg_Gx_thm› =		Ù µ x∑ öâg çâg Gx x
=TEX

\ignore{
=SML
set_goal([],¨µg∑ galaxy g ¥ öâg çâg gÆ);
a (REPEAT strip_tac);
a (fc_tac [GCloseSep_thm, get_spec ¨galaxyÆ]);
a (list_spec_nth_asm_tac 1 [¨xÆ,¨Ãx:GS∑ FÆ]);
a (lemma_tac ¨öâg = Sep x (Ã x∑ F)Æ
	THEN1 (rewrite_tac [gs_ext_axiom, get_spec ¨öâgÆ, get_spec ¨SepÆ]));
a (asm_rewrite_tac[]);
val GöâgC = save_pop_thm "GöâgC";

val öâgÄâg_thm = save_thm ("öâgÄâg_thm",
	prove_rule [get_spec ¨öâgÆ, Äâg_thm]
	¨µs:GS∑ öâg Äâg sÆ);
val ﬁâgöâg_thm = save_thm ("ﬁâgöâg_thm",
	prove_rule [get_spec ¨öâgÆ, get_spec ¨ﬁâgÆ, gs_ext_axiom]
	¨ﬁâg öâg = öâgÆ);
val öâg_spec = get_spec ¨öâgÆ;

set_goal ([], ¨µm n∑ m çâg n ¥ ≥ n = öâgÆ);
a (REPEAT strip_tac);
a (rewrite_tac [gs_ext_axiom]
	THEN REPEAT strip_tac);
a (∂_tac ¨mÆ THEN asm_rewrite_tac[get_spec ¨öâgÆ]);
val mem_not_empty_thm = save_pop_thm "mem_not_empty_thm";

set_goal ([], ¨µx∑ galaxy x ¥ öâg çâg xÆ);
a (REPEAT strip_tac THEN fc_tac [GClose_fc_clauses]);
a (fc_tac [get_spec ¨galaxyÆ]);
a (asm_ufc_tac[]);
a (SPEC_NTH_ASM_T 5 ¨Ãx:GS∑FÆ ante_tac);
a (lemma_tac ¨öâg Äâg x'Æ THEN1 rewrite_tac [öâgÄâg_thm]);
a (fc_tac[Sep_Ä_thm]);
a (lemma_tac ¨(Ã x∑ F) = (CombC $çâg öâg)Æ
	THEN1 (rewrite_tac [ext_thm, get_spec ¨CombCÆ, öâg_spec]));
a (rewrite_tac [asm_rule ¨(Ã x∑ F) = CombC $çâg öâgÆ, asm_rule ¨Sep x' (CombC $çâg öâg) = öâgÆ]);
val öâg_çâg_galaxy_thm = save_pop_thm "öâg_çâg_galaxy_thm";

set_goal ([], ¨µx∑ öâg çâg Gx xÆ);
a (asm_tac galaxy_Gx THEN ufc_tac [öâg_çâg_galaxy_thm]);
val öâg_çâg_Gx_thm = save_pop_thm "öâg_çâg_Gx_thm";

add_pc_thms "'gst-ax" (map get_spec [¨âgÆ, ¨ﬁâgÆ] @ [öâg_spec, öâgÄâg_thm, ﬁâgöâg_thm]);
set_merge_pcs ["basic_hol", "'gst-ax"];
=TEX
}%ignore

\subsection{Functional Replacement}

The more convenient form of replacement which takes a function rather than a relation (and hence needs no "ManyOne" caveat) is introduced here.

\subsubsection{Introduction}

Though a functional formulation of replacement is most convenient for most applications, it has a number of small disadvantages which have persuaded me to stay closer to the traditional formulation of replacement in terms of relations.
The more convenient functional version will then be introduced by definition (so if you don't know what I'm talking about, look forward to compare the two versions).

For the record the disadvantages of the functional one (if used as an axiom) are:

\begin{enumerate}
\item It can't be used to prove the existence of the empty set.
\item When used to define separation it requires the axiom of choice.
\end{enumerate}

\subsubsection{Imagep}

Now we prove a more convenient version of replacement which takes a HOL function rather than a relation as its argument.
It states that the image of any set under a function is also a set.

\ignore{
=SML
set_goal([],¨∂Imagep∑ µf:GS ≠ GS∑ µs: GS∑ 
	(µx∑ x çâg Imagep f s § ∂e∑ e çâg s ± x = f e)Æ);
a (prove_∂_tac THEN REPEAT strip_tac);
a (lemma_tac ¨∂fr∑ fr = Ãx y∑ y = f' xÆ THEN1 prove_∂_tac);
a (lemma_tac ¨ManyOne frÆ
	THEN1 (asm_rewrite_tac [get_spec ¨ManyOneÆ]
		THEN REPEAT strip_tac
		THEN asm_rewrite_tac[]));
a (∂_tac ¨RelIm fr s'Æ);
a (§_FC_T asm_rewrite_tac [get_spec ¨RelImÆ]);
save_cs_∂_thm (pop_thm ());
=TEX
}%ignore

$¨Imagep\ f\ sÆ$ is the image of $s$ through $f$.

πHOLCONST
‹ €Imagep› : (GS ≠ GS) ≠ GS ≠ GS
˜¸¸¸¸¸¸¸¸¸¸¸
‹ µf s x∑ x çâg Imagep f s § ∂e∑ e çâg s ± x = f e
∞

\ignore{
=SML
val Imagep_spec = get_spec ¨ImagepÆ;
add_pc_thms "'gst-ax" (map get_spec [¨ImagepÆ]);
set_merge_pcs ["basic_hol", "'gst-ax"];
=TEX
}%ignore

\subsubsection{Galaxy Closure}

We now show that galaxies are closed under {\it Imagep}.

=GFT
€GImagepC› =	Ù µg∑ galaxy g ¥ µs∑ s çâg g
				¥ µf∑ Imagep f s Äâg g ¥ Imagep f s çâg g
=TEX

\ignore{
=SML
set_goal([],¨µg∑ galaxy g
	¥ µs∑ s çâg g
	¥ µf∑ Imagep f s Äâg g
	¥ Imagep f s çâg gÆ);
a (REPEAT_N 5 strip_tac);
a (lemma_tac ¨∂fr∑ fr = Ãx y∑ y = f xÆ THEN1 prove_∂_tac);
a (lemma_tac ¨ManyOne frÆ
	THEN1 (asm_rewrite_tac [get_spec ¨ManyOneÆ]
		THEN REPEAT strip_tac
		THEN asm_rewrite_tac[]));
a (lemma_tac ¨Imagep f s = RelIm fr sÆ);
(* *** Goal "1" *** *)
a (pure_rewrite_tac [gs_ext_axiom]);
a (§_FC_T pure_once_rewrite_tac [get_spec ¨RelImÆ]);
a (asm_rewrite_tac[] THEN REPEAT strip_tac);
(* *** Goal "2" *** *)
a (once_asm_rewrite_tac[]);
a (fc_tac[get_spec ¨galaxyÆ]);
a (list_spec_nth_asm_tac 5 [¨sÆ,¨frÆ]
	THEN asm_rewrite_tac[]);
val GImagepC = save_pop_thm "GImagepC";
=TEX
}%ignore

\subsection{Pair and Unit sets}

$Pairâg$ is defined using replacement, and Sing (because ``Unit'' is used elsewhere) using $Pairâg$.

\ignore{
=SML
set_goal([],¨∂Pairâg∑ µs t e:GS∑
	e çâg Pairâg s t
	§ e = s ≤ e = tÆ);
a (∂_tac ¨Ãs t∑Imagep (Ãx∑ if x = öâg then s else t) (âg (âg öâg))Æ
	THEN rewrite_tac[get_spec ¨$ÄâgÆ]);
a (REPEAT strip_tac);
(* *** Goal "1" *** *)
a (asm_ante_tac ¨≥ e = sÆ);
a (asm_rewrite_tac[]);
a (cases_tac ¨e'=öâgÆ
	THEN_TRY asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a (∂_tac ¨öâgÆ
	THEN prove_tac
	[get_spec ¨$ÄâgÆ]);
(* *** Goal "3" *** *)
a (lemma_tac ¨≥ âg öâg = öâgÆ);
a (prove_tac[
	get_spec ¨$ÄâgÆ,
	gs_ext_axiom]);
a (∂_tac ¨öâgÆ
	THEN prove_tac[]);
a (∂_tac ¨âg öâgÆ THEN asm_rewrite_tac[]);
a (strip_tac THEN rewrite_tac[get_spec ¨$ÄâgÆ]);
save_cs_∂_thm (pop_thm ());
=TEX
}%ignore

Pairs can be defined as the image of some two element set under a function defined by a conditional.
A suitable two element set can be constructed from the empty set using the powerset construction a couple of times.
However, having proven that this can be done (details omitted), we can introduce the pair constructor by conservative extension as follows.
(the ProofPower tool shows that it has accepted my proof by putting this extension into the "definitions" section of the theory listing).

πHOLCONST
‹ €Pairâg› : GS ≠ GS ≠ GS
˜¸¸¸¸¸¸¸¸¸¸¸¸
‹ µs t e:GS∑ e çâg Pairâg s t § e = s ≤ e = t	
∞

=GFT
€Pairâg_ç_thm› =		Ù µ x y∑ x çâg Pairâg x y ± y çâg Pairâg x y
€Pairâg_tcç_thm› =	Ù µ s t∑ s çâgõ+ Pairâg s t ± t çâgõ+ Pairâg s t
€Pairâg_eq_thm› =		Ù µ s t u v∑ Pairâg s t = Pairâg u v
					§ s = u ± t = v ≤ s = v ± t = u
=TEX

\ignore{
=SML
set_goal([], ¨µx y∑ x çâg Pairâg x y ± y çâg Pairâg x yÆ);
a (rewrite_tac [get_spec ¨PairâgÆ]);
val Pairâg_ç_thm = save_pop_thm "Pairâg_ç_thm";

set_goal([], ¨µs t∑ s çâgõ+ Pairâg s t ± t çâgõ+ Pairâg s tÆ);
a (REPEAT µ_tac);
a (STRIP_THM_THEN asm_tac (list_µ_elim [¨sÆ, ¨tÆ] Pairâg_ç_thm)
	THEN ufc_tac [tcç_incr_thm]);
a (REPEAT strip_tac);
val Pairâg_tcç_thm = save_pop_thm "Pairâg_tcç_thm";

set_goal([],¨µs t u v∑
	Pairâg s t = Pairâg u v
	§ s = u ± t = v
	≤ s = v ± t = uÆ);
a (rewrite_tac[
	µ_elim ¨Pairâg s tÆ gs_ext_axiom,	
	get_spec ¨PairâgÆ]
	THEN REPEAT strip_tac
	THEN_TRY all_var_elim_asm_tac
	THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a (spec_nth_asm_tac 2 ¨sÆ
	THEN_TRY all_var_elim_asm_tac
	THEN_TRY asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a (spec_nth_asm_tac 2 ¨uÆ
	THEN_TRY all_var_elim_asm_tac
	THEN_TRY asm_rewrite_tac[]);
(* *** Goal "3" *** *)
a (spec_nth_asm_tac 2 ¨vÆ
	THEN_TRY all_var_elim_asm_tac
	THEN_TRY asm_rewrite_tac[]);
(* *** Goal "4" *** *)
a (spec_nth_asm_tac 2 ¨tÆ
	THEN_TRY all_var_elim_asm_tac
	THEN_TRY asm_rewrite_tac[]);
val Pairâg_eq_thm =
	save_pop_thm "Pairâg_eq_thm";
=TEX
}%ignore

=GFT
€GClosePairâg› =	Ù µg∑ galaxy g ¥ µs t∑ s çâg g ± t çâg g
				¥ Pairâg s t çâg g
=TEX

\ignore{
=SML
set_goal([],¨µg∑ galaxy g ¥ µs t∑ s çâg g ± t çâg g ¥ Pairâg s t çâg gÆ);
a (REPEAT strip_tac);
a (lemma_tac ¨Pairâg s t = Imagep (Ãx∑ if x = öâg then s else t) (âg (âg öâg))Æ);
(* *** Goal "1" *** *)
a (once_rewrite_tac [gs_ext_axiom]);
a (rewrite_tac (map get_spec [¨PairâgÆ,¨ImagepÆ]));
a (REPEAT strip_tac THEN asm_rewrite_tac[]);
(* *** Goal "1.1" *** *)
a (∂_tac ¨öâgÆ THEN rewrite_tac[get_spec ¨$ÄâgÆ]);
(* *** Goal "1.2" *** *)
a (∂_tac ¨âg öâgÆ THEN rewrite_tac[get_spec ¨$ÄâgÆ]);
a (lemma_tac ¨≥ âg öâg = öâgÆ);
(* *** Goal "1.2.1" *** *)
a (rewrite_tac [gs_ext_axiom]
	THEN strip_tac
	THEN ∂_tac ¨öâgÆ
	THEN rewrite_tac[]);
(* *** Goal "1.2.2" *** *)
a (asm_rewrite_tac[]);
(* *** Goal "1.3" *** *)
a (cases_tac ¨e' = öâgÆ
	THEN asm_rewrite_tac[]);
a (asm_ante_tac ¨e = (if e' = öâg then s else t)Æ
	THEN asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a (asm_rewrite_tac[]);
a (fc_tac [GImagepC]);
a (list_spec_nth_asm_tac 1 [¨âg (âg öâg)Æ,¨Ã x∑ if x = öâg then s else tÆ]);
a (fc_tac [GöâgC]);
a (lemma_tac ¨µs∑ s çâg g ¥ âg s çâg gÆ
	THEN1 (REPEAT (fc_tac [get_spec ¨galaxyÆ])));
a (REPEAT (asm_fc_tac []));
(* *** Goal "2.2" *** *)
a (swap_nth_asm_concl_tac 1);
a (rewrite_tac [get_spec ¨$ÄâgÆ]);
a (REPEAT strip_tac);
a (POP_ASM_T ante_tac
	THEN cases_tac ¨e' = öâgÆ
	THEN asm_rewrite_tac[]
	THEN strip_tac
	THEN asm_rewrite_tac[]);
val GClosePairâg = save_pop_thm "GClosePairâg";
=TEX
}%ignore

\subsubsection{Unit Sets}

Since ``Unit'' is used in the theory of groups I use ``Sing'' for singleton sets.

πHOLCONST
‹ €Sing› : GS ≠ GS
˜¸¸¸¸¸¸¸¸¸¸
‹ µs∑ Sing s = Pairâg s s
∞

The following theorem tells you what the members of a unit sets are.

=GFT
€Sing_thm› =	Ù µs e∑ e çâg Sing s § e = s
€Sing_thm2› =	Ù µx∑ x çâg Sing x
€Sing_tcç_thm› =	Ù µx∑ x çâgõ+ Sing x
=TEX

\ignore{
=SML
set_goal([],¨µs e∑
	e çâg Sing s § e = sÆ);
a (rewrite_tac [
	get_spec¨SingÆ,
	get_spec¨PairâgÆ]
	THEN REPEAT strip_tac);
val Sing_thm = pop_thm ();

set_goal([], ¨µx∑ x çâg Sing xÆ);
a (rewrite_tac [Sing_thm]);
val Sing_thm2 = save_pop_thm "Sing_thm2";

set_goal([], ¨µx∑ x çâgõ+ Sing xÆ);
a (strip_tac);
a (asm_tac (µ_elim ¨xÆ Sing_thm2) THEN fc_tac [tcç_incr_thm]);
val Sing_tcç_thm = save_pop_thm "Sing_tcç_thm";

add_pc_thms "'gst-ax" [get_spec ¨PairâgÆ, Sing_thm];
add_rw_thms [Pairâg_ç_thm, Pairâg_tcç_thm, Sing_tcç_thm] "'gst-ax";
add_sc_thms [Pairâg_ç_thm, Pairâg_tcç_thm, Sing_tcç_thm] "'gst-ax";
set_merge_pcs ["basic_hol", "'gst-ax"];
=TEX
}%ignore

The following theorem tells you when two unit sets are equal.

=GFT
€Sing_eq_thm› =	Ù µs t∑ Sing s = Sing t § s = t
=TEX

\ignore{
=SML
set_goal([],¨µs t∑
	Sing s = Sing t
	§ s = tÆ);
a (prove_tac [
	µ_elim ¨Sing sÆ gs_ext_axiom]);
val Sing_eq_thm = pop_thm ();
add_pc_thms "'gst-ax" [Sing_eq_thm];
set_merge_pcs ["basic_hol", "'gst-ax"];
=TEX
}%ignore

\subsubsection{Galaxy Closure}

=GFT
€GCloseSing› =	Ù µg∑ galaxy g ¥ µs∑ s çâg g ¥ Sing s çâg g
=TEX

\ignore{
=SML
set_goal([],¨µg∑ galaxy g ¥ µs∑ s çâg g ¥ Sing s çâg gÆ);
a (REPEAT strip_tac
	THEN rewrite_tac [get_spec ¨SingÆ]);
a (REPEAT (asm_fc_tac[GClosePairâg]));
val GCloseSing = save_pop_thm "GCloseSing";
=TEX
}%ignore

\subsubsection{Sing-Pair equations}

The following theorems tell you when Pairs are really Sings.

=GFT
€Sing_Pairâg_eq_thm› =	Ù µs t u∑ Sing s = Pairâg t u § s = t ± s = u
€Pairâg_Sing_eq_thm› =	Ù µs t u∑ Pairâg s t = Sing u § s = u ± t = u
=TEX

\ignore{
=SML
set_goal([],
	¨µs t u∑
	Sing s = Pairâg t u
	§ s = t ± s = uÆ);
a (prove_tac [
	µ_elim ¨Sing sÆ gs_ext_axiom]);
(* *** Goal "1" *** *)
a (spec_nth_asm_tac 1 ¨sÆ
	THEN spec_nth_asm_tac 2 ¨tÆ
	THEN_TRY all_var_elim_asm_tac
	THEN_TRY rewrite_tac[]);
(* *** Goal "2" *** *)
a (spec_nth_asm_tac 1 ¨uÆ
	THEN_TRY all_var_elim_asm_tac
	THEN_TRY rewrite_tac[]);
val Sing_Pairâg_eq_thm = pop_thm ();
=TEX

=SML
set_goal([],¨µs t u∑
	Pairâg s t = Sing u
	§ s = u ± t = uÆ);
a (prove_tac [
	µ_elim ¨Pairâg s tÆ gs_ext_axiom]);
val Pairâg_Sing_eq_thm = pop_thm ();
=TEX
}%ignore

\subsection{Union and Intersection}

Binary union and distributed and binary intersection are defined.

\subsubsection{Binary Union}

\ignore{
=SML
declare_infix (240, "¿âg");
set_goal ([],¨∂($¿âg)∑ µs t e∑
e çâg (s ¿âg t) § e çâg s ≤ e çâg t
Æ);
a (∂_tac ¨Ãs t∑ ﬁâg (Pairâg s t)Æ);
a (prove_tac [get_spec ¨ﬁâgÆ]);
save_cs_∂_thm(pop_thm());
=TEX
}%ignore

πHOLCONST
‹ $¿âg : GS ≠ GS ≠ GS
˜¸¸¸¸¸¸¸¸¸¸¸¸¸
‹ µs t e∑ e çâg (s ¿âg t) § e çâg s ≤ e çâg t
∞

=GFT
€Äâg¿âg_thm› =	Ù µ A B∑ A Äâg A ¿âg B ± B Äâg A ¿âg B
€¿âgÄâg_thm1› =	Ù µ A B C∑ A Äâg C ± B Äâg C ¥ A ¿âg B Äâg C
€¿âgÄâg_thm2› =	Ù µ A B C D∑ A Äâg C ± B Äâg D ¥ A ¿âg B Äâg C ¿âg D
€¿âgöâg_clauses› =	Ù µ A∑ A ¿âg öâg = A ± öâg ¿âg A = A
=TEX

\ignore{
=SML
val €¿âg_thm› = get_spec ¨$¿âgÆ;
val €Äâg¿âg_thm› = save_thm ("Äâg¿âg_thm", prove_rule
	[Äâg_thm, ¿âg_thm]
	¨µA B∑ A Äâg A ¿âg B ± B Äâg A ¿âg BÆ);
val €¿âgÄâg_thm1› = save_thm ("¿âgÄâg_thm1", prove_rule
	[Äâg_thm, ¿âg_thm]
	¨µA B C∑ A Äâg C ± B Äâg C ¥ A ¿âg B Äâg CÆ);
val €¿âgÄâg_thm2› = save_thm ("¿âgÄâg_thm2", prove_rule
	[Äâg_thm, ¿âg_thm]
	¨µA B C D∑ A Äâg C ± B Äâg D ¥ (A ¿âg B) Äâg (C ¿âg D)Æ);
val €¿âgöâg_clauses› = save_thm ("¿âgöâg_clauses", prove_rule
	[gs_ext_axiom, ¿âg_thm]
	¨µA∑ (A ¿âg öâg) = A
	± (öâg ¿âg A) = AÆ);
=TEX
}%ignore

\subsubsection{Galaxy Closure}

=GFT
€GClose¿âg› =	Ù µg∑ galaxy g ¥ µs t∑ s çâg g ± t çâg g ¥ s ¿âg t çâg g
=TEX

\ignore{
=SML
set_goal([],¨µg∑ galaxy g ¥ µs t∑ s çâg g ± t çâg g ¥ s ¿âg t çâg gÆ);
a (REPEAT strip_tac THEN fc_tac [get_spec ¨galaxyÆ]);
a (lemma_tac ¨s ¿âg t = ﬁâg (Pairâg s t)Æ
	THEN1 (once_rewrite_tac [gs_ext_axiom]
		THEN rewrite_tac [get_spec ¨ﬁâgÆ, get_spec ¨$¿âgÆ]
		THEN prove_tac[]));
a (asm_rewrite_tac []);
a (lemma_tac ¨Pairâg s t çâg gÆ
	THEN1 (REPEAT (asm_fc_tac [GClosePairâg])));
a (REPEAT (asm_fc_tac[]));
val GClose¿âg = save_pop_thm "GClose¿âg";
=TEX
}%ignore

\subsubsection{Distributed Intersection}

Distributed intersection doesn't really make sense for the empty set, but under this definition it maps the empty set onto itself.

πHOLCONST
‹ €•âg› : GS ≠ GS
˜
‹ µs∑ •âg s = Sep (ﬁâg s) (Ãx∑ µt∑ t çâg s ¥ x çâg t)
∞


=GFT
€•âgÄâg_thm› =	Ù µx s e∑ x çâg s
				¥ (e çâg •âg s § µy∑ y çâg s ¥ e çâg y)
€Äâg•âg_thm› =	Ù  µA B∑ A çâg B
				¥ µC∑ (µD∑ D çâg B ¥ C Äâg D)
				¥ C Äâg •âg B
€•âgöâg_thm› = 	Ù •âg öâg = öâg
=TEX

\ignore{
=SML
set_goal ([],¨µx s e∑ x çâg s ¥
	(e çâg •âg s § µy∑ y çâg s ¥ e çâg y)Æ);
a (prove_tac [
	get_spec ¨•âgÆ]);
val •âg_thm = save_pop_thm "•âg_thm";
=SML
set_goal([],¨µs t∑ s çâg t ¥ •âg t Äâg sÆ);
a (rewrite_tac [•âg_thm, Äâg_thm]);
a (REPEAT strip_tac);
a (REPEAT (asm_fc_tac[•âg_thm]));
val •âgÄâg_thm = save_pop_thm "•âgÄâg_thm";

val Äâg•âg_thm = save_thm ("Äâg•âg_thm", 
	(prove_rule [Äâg_thm, gs_ext_axiom,
	get_spec ¨$•âgÆ]
	¨µA B∑ A çâg B ¥ µC∑	
	(µD∑ D çâg B ¥ C Äâg D)
	¥ C Äâg •âg BÆ));

val •âgöâg_thm = save_thm ("•âgöâg_thm", 
	(prove_rule [gs_ext_axiom,	get_spec ¨$•âgÆ]
	¨•âg öâg = öâgÆ));
=TEX
}%ignore

\subsubsection{Binary Intersection}

Binary intersection could be defined in terms of distributed intersection, but its easier not to.

=SML
declare_infix (240, "°âg");
=TEX

πHOLCONST
‹ $€°âg› : GS ≠ GS ≠ GS
˜
‹ µs t∑ s °âg t = Sep s (Ãx∑ x çâg t)
∞

\subsubsection{Galaxy Closure}

=GFT
€GClose•âg› =	Ù µg∑ galaxy g ¥ µs∑ s çâg g ¥ •âg s çâg g
€GClose°âg› =	Ù µg∑ galaxy g ¥ µs t∑ s çâg g ± t çâg g ¥ s °âg t çâg g
=TEX

\ignore{
=SML
set_goal([],¨µg∑ galaxy g ¥ µs∑ s çâg g ¥ •âg s çâg gÆ);
a (REPEAT strip_tac
	THEN rewrite_tac[get_spec ¨•âgÆ]);
a (fc_tac [GCloseSep_thm, get_spec ¨galaxyÆ]);
a (list_spec_nth_asm_tac 1 [¨ﬁâg sÆ, ¨Ã x∑ µ t∑ t çâg s ¥ x çâg tÆ]);
a (asm_fc_tac[]);
val GClose•âg = save_pop_thm "GClose•âg";

set_goal([],¨µg∑ galaxy g ¥ µs t∑ s çâg g ± t çâg g ¥ s °âg t çâg gÆ);
a (REPEAT strip_tac
	THEN rewrite_tac[get_spec ¨$°âgÆ]);
a (fc_tac [GCloseSep_thm]);
a (list_spec_nth_asm_tac 1 [¨sÆ, ¨Ã x∑ x çâg tÆ]);
val GClose°âg = save_pop_thm "GClose°âg";
=TEX
}%ignore

=GFT
€°âg_thm› =		Ù µs t e∑ e çâg s °âg t § e çâg s ± e çâg t
€°âg_thm› =		Ù µs t e∑	e çâg s °âg t § e çâg s ± e çâg t
=TEX

=GFT
€Äâg°âg_thm› =	Ù µA B∑ A °âg B Äâg A ± A °âg B Äâg B
€°âgÄâg_thm1› =	Ù µA B C∑ A Äâg C ± B Äâg C ¥ A °âg B Äâg C
€°âgÄâg_thm2› =	Ù µA B C D∑ A Äâg C ± B Äâg D ¥ (A °âg B) Äâg (C °âg D)
€°âgÄâg_thm3› =	Ù µA B C∑ C Äâg A ± C Äâg B ¥ C Äâg A °âg B
=TEX

\ignore{
=SML
set_goal ([],¨µs t e∑
	e çâg s °âg t § e çâg s ± e çâg tÆ);
a (prove_tac [
	get_spec ¨$°âgÆ]);
val °âg_thm = save_thm ("°âg_thm",
	prove_rule [get_spec ¨$°âgÆ]
	¨µs t e∑	e çâg s °âg t § e çâg s ± e çâg tÆ);
val Äâg°âg_thm = save_thm ("Äâg°âg_thm",
	prove_rule [Äâg_thm, °âg_thm]
	¨µA B∑ A °âg B Äâg A ± A °âg B Äâg BÆ);
val °âgÄâg_thm1 = save_thm ("°âgÄâg_thm1",
	prove_rule [Äâg_thm, °âg_thm]
	¨µA B C∑ A Äâg C ± B Äâg C ¥ A °âg B Äâg CÆ);
val °âgÄâg_thm2 = save_thm ("°âgÄâg_thm2",
	prove_rule [Äâg_thm, °âg_thm]
	¨µA B C D∑ A Äâg C ± B Äâg D ¥ (A °âg B) Äâg (C °âg D)Æ);
val °âgÄâg_thm3 = save_thm ("°âgÄâg_thm3",
	prove_rule [Äâg_thm, °âg_thm]
	¨µA B C∑ C Äâg A ± C Äâg B ¥ C Äâg A °âg BÆ);
=TEX
}%ignore

\subsubsection{Consequences of Well-Foundedness}

=GFT
€not_x_in_x_thm› =	Ù ≥ (∂ x∑ x çâg x)
=TEX

\ignore{
=SML
set_goal([], ¨≥ ∂x∑ x çâg xÆ);
a contr_tac;
a (asm_tac gs_wf_min_thm);
a (spec_nth_asm_tac 1 ¨Sep x (Ãy:GS∑ y = x)Æ);
a (spec_nth_asm_tac 1 ¨xÆ);
a (POP_ASM_T ante_tac
	THEN rewrite_tac[]);
a strip_tac;
a (DROP_NTH_ASM_T 2 ante_tac
	THEN rewrite_tac[]);
a (swap_nth_asm_concl_tac 1);
a (all_var_elim_asm_tac);
a (strip_tac);
a (∂_tac ¨xÆ THEN asm_rewrite_tac[]);
val not_x_in_x_thm = save_pop_thm "not_x_in_x_thm";
=TEX
}%ignore

\subsection{Galaxy Closure Clauses}

=GFT
€GClose_fc_clauses2› =
   Ù µ g
     ∑ galaxy g
         ¥ (µ s t∑ s çâg g ± t çâg g ¥ Pairâg s t çâg g)
           ± (µ s∑ s çâg g ¥ Sing s çâg g)
           ± (µ s t∑ s çâg g ± t çâg g ¥ s ¿âg t çâg g)
           ± (µ s∑ s çâg g ¥ •âg s çâg g)
           ± (µ s t∑ s çâg g ± t çâg g ¥ s °âg t çâg g)
=TEX

\ignore{
=SML
set_goal([], ¨µg∑ galaxy g ¥
	  (µs t∑ s çâg g ± t çâg g ¥ Pairâg s t çâg g)
	± (µs∑ s çâg g ¥ Sing s çâg g)
	± (µs t∑ s çâg g ± t çâg g ¥ s ¿âg t çâg g)
	± (µs∑ s çâg g ¥ •âg s çâg g)
	± (µs t∑ s çâg g ± t çâg g ¥ s °âg t çâg g)
	Æ);
a (REPEAT strip_tac
	THEN all_fc_tac [GClosePairâg, GCloseSing, GClose¿âg, GClose•âg, GClose°âg]);
val GClose_fc_clauses2 = save_pop_thm "GClose_fc_clauses2";
=TEX
}%ignore

=GFT
€tcç_clauses› =	Ù µ s∑	s çâgõ+ Sing s
			± 	s çâgõ+ âg s
			± µt∑	t çâgõ+ Pairâg s t
			± 	s çâgõ+ Pairâg s t
=TEX

\ignore{
=SML
set_goal([], ¨µ s∑	s çâgõ+ Sing s
		± 	s çâgõ+ âg s
		± µt∑	t çâgõ+ Pairâg s t
		± 	s çâgõ+ Pairâg s tÆ);
a (rewrite_tac[]);
val tcç_clauses = save_pop_thm "tcç_clauses";
=TEX
}%ignore


\subsection{Proof Context}

To simplify subsequent proofs a new "proof context" is created enabling automatic use of the results now available.

\subsubsection{Principles}

The only principle I know of which assists with elementary proofs in set theory is the principle that set theoretic conjectures can be reduced to the predicate calculus by using extensional rules for relations and for operators.

Too hasty a reduction can be overkill and may convert a simple conjecture into an unintelligible morass.
We have sometimes in the past used made available two proof contexts, an aggressive extensional one, and a milder non-extensional one.
However, the extensional rules for the operators are fairly harmless, expansion is triggered by the extensional rules for the relations (equality and subset), so a proof context containing the former together with a suitable theorem for the latter gives good control.

\subsubsection{Theorems Used Recklessly}

This is pretty much guesswork, only time will tell whether this is the best collection.

=SML
val gst_ax_thms = [
	öâg_spec,
	get_spec ¨âgÆ,
	get_spec ¨ﬁâgÆ,
	Imagep_spec,
	Pairâg_eq_thm,
	get_spec ¨PairâgÆ,
	Sing_eq_thm,
	Sing_thm,
	Pairâg_Sing_eq_thm,
	Sing_Pairâg_eq_thm,
	Sep_thm,
	¿âg_thm,
	°âg_thm
];

val gst_opext_clauses =
	(all_µ_intro
	o list_±_intro
	o (map all_µ_elim))
	gst_ax_thms;
save_thm ("gst_opext_clauses", gst_opext_clauses);
=TEX

\subsubsection{Theorems Used Cautiously}

The following theorems are too aggressive for general use in the proof context but are needed when attempting automatic proof.
When an extensional proof is appropriate it can be initiated by a cautious (i.e. a "once") rewrite using the following clauses, after which the extensional rules in the proof context will be triggered.

=SML
val gst_relext_clauses =
	(all_µ_intro
	o list_±_intro
	o (map all_µ_elim))
	[gs_ext_axiom,
	get_spec¨$ÄâgÆ];
save_thm ("gst_relext_clauses", gst_relext_clauses);
=TEX

There are a number of important theorems, such as well-foundedness and galaxy closure which have not been mentioned in this context.
The character of these theorems makes them unsuitable for the proof context, their application requires thought.

\subsubsection{Automatic Proof}

The basic proof automation is augmented by adding a preliminary rewrite with the relational extensionality clauses.

=SML
fun gst_ax_prove_conv thl =
	TRY_C (pure_rewrite_conv [gst_relext_clauses])
	THEN_C (basic_prove_conv thl);
=TEX

\subsubsection{Proof Context 'gst-ax}

=SML
val nost_thms = [galaxy_Gx, t_in_Gx_t_thm];

add_rw_thms (gst_ax_thms @ nost_thms) "'gst-ax";
add_sc_thms (gst_ax_thms @ nost_thms) "'gst-ax";
add_st_thms gst_ax_thms "'gst-ax";
set_pr_conv gst_ax_prove_conv "'gst-ax";
set_pr_tac
	(conv_tac o gst_ax_prove_conv)
	"'gst-ax";
commit_pc "'gst-ax";
=TEX

Using the proof context "'gst-ax" elementary results in gst are now provable automatically on demand.
For this reason it is not necessary to prove in advance of needing them results such as the associativity of intersection, since they can be proven when required by an expression of the form "prove rule[] term" which proves {\it term} and returns it as a theorem.
If the required proof context for doing this is not in place the form ``
=INLINEFT
merge_pcs_rule ["basic_hol", 'gst-ax"] (prove_rule []) term
=TEX
'' may be used.
Since this is a little cumbersome we define the function {\it $gst\_ax\_rule$} and illustrate its use as follows:

=SML
val gst_ax_rule =
	(merge_pcs_rule1
	["basic_hol", "'gst-ax"]
	prove_rule) [];
val gst_ax_conv = 
	MERGE_PCS_C1
	["basic_hol", "'gst-ax"]
	prove_conv;
val gst_ax_tac =
	conv_tac o gst_ax_conv;
=TEX

\subsubsection{Examples}

The following are examples of the elementary results which are now proven automatically:
=SML
gst_ax_rule ¨
	a °âg (b °âg c)
	= (a °âg b) °âg cÆ;
gst_ax_rule ¨a °âg b Äâg bÆ;
gst_ax_rule ¨öâg ¿âg b = bÆ;
gst_ax_rule ¨
	a Äâg b ± c Äâg d
	¥ a °âg c Äâg b °âg dÆ;
gst_ax_rule ¨Sep b p Äâg bÆ;
gst_ax_rule ¨a Äâg b ¥
	Imagep f a Äâg Imagep f bÆ;
=IGN
Imagep_axiom;
set_goal([],¨a Äâg b ± c Äâg d
	¥ Imagep f (a °âg c)
	Äâg Imagep f (b °âg d)Æ);
a (once_rewrite_tac
	[gst_relext_clauses]);
a (gst_ax_tac[]);
a (rewrite_tac[]);
a (prove_tac[]);
a contr_tac;
Sep_thm;
=TEX

\section{Products and Sums}

A new "gst-fun" theory is created as a child of "gst-ax".
The theory will contain the definitions of ordered pairs, cartesian product, relations and functions, dependent products (functions), dependent sums (disjoint unions) and related material for general use.

=SML
open_theory "gst-ax";
force_new_theory "gst-fun";
force_new_pc "'gst-fun";
merge_pcs ["'savedthm_cs_∂_proof"] "'gst-fun";
set_merge_pcs ["basic_hol", "'gst-ax", "'gst-fun"];
=TEX

\subsection{Ordered Pairs}

=SML
declare_infix (240,"Ìâg");
=TEX

I first attempted to define ordered pairs in a more abstract way than by explicit use of the Wiener-Kuratovski representation, but this gace me problems so I eventually switched to the explicit definition.

This influences the development of the theory, since the first thing I do is to replicate the previously used defining properties.

πHOLCONST
‹ $€Ìâg› : GS ≠ GS ≠ GS
˜¸¸¸¸¸¸¸¸¸¸¸¸
‹ µs t∑ (s Ìâg t) = Pairâg (Sing s) (Pairâg s t)
∞

=GFT
€Ìâg_eq_thm› =			Ù µ s t u v∑ (s Ìâg t = u Ìâg v) = (s = u ± t = v)
€Pairâg_ç_Ìâg_thm› =		Ù µs t∑ Pairâg s t çâg s Ìâg t
€Pairâg_çâg_Gx_Ìâg_thm› =	Ù µ s t∑ Pairâg s t çâg Gx (s Ìâg t)
€Ìâg_spec_thm› =		Ù (µ s t u v∑ (s Ìâg t = u Ìâg v) = (s = u ± t = v))
       				± (µ s t∑ Pairâg s t çâg s Ìâg t)
       				± (µ s t∑ Pairâg s t çâg Gx (s Ìâg t))
€Ìâg_çâg_Gx_Pairâg_thm› =	Ù µ s t∑ s Ìâg t çâg Gx (Pairâg s t)
=TEX

\ignore{
=SML
set_goal([], ¨µs t u v:GS∑
	(s Ìâg t = u Ìâg v § s = u ± t = v)Æ);
a (REPEAT µ_tac THEN rewrite_tac[get_spec ¨$ÌâgÆ] THEN REPEAT strip_tac
	THEN_TRY all_var_elim_asm_tac
	THEN REPEAT strip_tac);
val Ìâg_eq_thm = save_pop_thm "Ìâg_eq_thm";
 
set_goal([], ¨µs t∑ Pairâg s t çâg (s Ìâg t)Æ);
a (REPEAT µ_tac THEN rewrite_tac[get_spec ¨$ÌâgÆ] THEN REPEAT strip_tac
	THEN_TRY all_var_elim_asm_tac
	THEN REPEAT strip_tac);
val Pairâg_ç_Ìâg_thm = save_pop_thm "Pairâg_ç_Ìâg_thm";

set_goal([], ¨µs t∑ Pairâg s t çâg Gx (s Ìâg t)Æ);
a (rewrite_tac[get_spec ¨$ÌâgÆ] THEN REPEAT strip_tac
	THEN_TRY all_var_elim_asm_tac
	THEN REPEAT strip_tac);
a (lemma_tac ¨galaxy (Gx (Pairâg s t))Æ
	THEN1 rewrite_tac [galaxy_Gx]);
a (lemma_tac ¨Pairâg s t çâg Gx (Pairâg s t)Æ
	THEN1 rewrite_tac [t_in_Gx_t_thm]);
a (strip_asm_tac (µ_elim ¨Gx (Pairâg s t)Æ GClosePairâg));
a (lemma_tac ¨(Sing s) çâg Gx (Pairâg s t)Æ);
(* *** Goal "1" *** *)
a (lemma_tac ¨s çâg Gx (Pairâg s t)Æ);
(* *** Goal "1.1" *** *)
a (fc_tac [GalaxiesTransitive_thm]);
a (fc_tac [get_spec ¨transitiveÆ]);
a (LEMMA_T ¨Pairâg s t Äâg Gx (Pairâg s t)Æ ante_tac
	THEN1 asm_fc_tac[]
	THEN once_rewrite_tac [gst_relext_clauses]
	THEN strip_tac);
a (spec_nth_asm_tac 1 ¨sÆ);
a (POP_ASM_T ante_tac THEN rewrite_tac [get_spec ¨PairâgÆ]);
(* *** Goal "1.2" *** *)
a (strip_asm_tac (µ_elim ¨Gx (Pairâg s t)Æ GCloseSing)
	THEN asm_fc_tac[]);
(* *** Goal "2" *** *)
a (LEMMA_T ¨(Pairâg s t) çâg (Pairâg (Sing s) (Pairâg s t))Æasm_tac 
	THEN1 (once_rewrite_tac [get_spec ¨PairâgÆ]
		THEN REPEAT strip_tac));
a (LEMMA_T ¨Gx (Pairâg s t) Äâg Gx (Pairâg (Sing s) (Pairâg s t))Æ ante_tac
	THEN1 (all_fc_tac [Gx_mono_thm2]));
a (once_rewrite_tac [get_spec ¨$ÄâgÆ]
	THEN STRIP_T (fn x => all_fc_tac [x]));
val Pairâg_çâg_Gx_Ìâg_thm = save_pop_thm "Pairâg_çâg_Gx_Ìâg_thm";

set_goal([], ¨µs t∑ s Ìâg t çâg Gx (Pairâg s t)Æ);
a (REPEAT strip_tac THEN rewrite_tac [get_spec ¨$ÌâgÆ]);
a (lemma_tac ¨galaxy (Gx (Pairâg s t))Æ
	THEN1 rewrite_tac [galaxy_Gx]);
a (lemma_tac ¨Pairâg s t çâg Gx (Pairâg s t)Æ
	THEN1 rewrite_tac [t_in_Gx_t_thm]);
a (lemma_tac ¨(Sing s) çâg Gx (Pairâg s t)Æ);
(* *** Goal "1" *** *)
a (lemma_tac ¨s çâg Gx (Pairâg s t)Æ);
(* *** Goal "1.1" *** *)
a (fc_tac [GalaxiesTransitive_thm]);
a (fc_tac [get_spec ¨transitiveÆ]);
a (LEMMA_T ¨Pairâg s t Äâg Gx (Pairâg s t)Æ ante_tac
	THEN1 asm_fc_tac[]
	THEN once_rewrite_tac [gst_relext_clauses]
	THEN strip_tac);
a (spec_nth_asm_tac 1 ¨sÆ);
a (POP_ASM_T ante_tac THEN rewrite_tac [get_spec ¨PairâgÆ]);
(* *** Goal "1.2" *** *)
a (strip_asm_tac (µ_elim ¨Gx (Pairâg s t)Æ GCloseSing)
	THEN asm_fc_tac[]);
(* *** Goal "2" *** *)
a (strip_asm_tac (list_µ_elim [¨Gx (Pairâg s t)Æ] GClosePairâg));
a (all_asm_fc_tac[]);
val Ìâg_çâg_Gx_Pairâg_thm = save_pop_thm "Ìâg_çâg_Gx_Pairâg_thm";

val Ìâg_spec_thm = list_±_intro [Ìâg_eq_thm, Pairâg_ç_Ìâg_thm, Pairâg_çâg_Gx_Ìâg_thm];
=TEX

=SML
add_pc_thms "'gst-fun" [Ìâg_spec_thm];
set_merge_pcs ["basic_hol", "'gst-ax", "'gst-fun"];
=TEX
}%ignore

=GFT
€≥Ìâgöâg_thm› =	Ù µ x y∑ ≥ x Ìâg y = öâg
€≥öâgÌâg_thm› =	Ù µ x y∑ ≥ öâg = x Ìâg y
€GCloseÌâg_thm› =	Ù µ g∑ galaxy g ¥ (µ s t∑ s çâg g ± t çâg g ¥ s Ìâg t çâg g)
=TEX

\ignore{
=SML
set_goal([], ¨µx y∑ ≥ x Ìâg y = öâgÆ);
a (REPEAT strip_tac THEN once_rewrite_tac [gs_ext_axiom] THEN REPEAT strip_tac);
a (∂_tac ¨Pairâg x yÆ THEN rewrite_tac [Ìâg_spec_thm]);
val ≥Ìâgöâg_thm = save_pop_thm "≥Ìâgöâg_thm";

set_goal([], ¨µx y∑ ≥ öâg = x Ìâg yÆ);
a (REPEAT strip_tac THEN once_rewrite_tac [gs_ext_axiom] THEN REPEAT strip_tac);
a (∂_tac ¨Pairâg x yÆ THEN rewrite_tac [Ìâg_spec_thm]);
val ≥öâgÌâg_thm = save_pop_thm "≥öâgÌâg_thm";

set_goal([], ¨µg∑  galaxy g ¥ (µs t∑ s çâg g ± t çâg g ¥ s Ìâg t çâg g)Æ);
a (REPEAT strip_tac THEN rewrite_tac[get_spec ¨$ÌâgÆ]);
a (all_fc_tac [GClose_fc_clauses2]);
a (all_fc_tac [GClose_fc_clauses2]);
val GCloseÌâg_thm = save_pop_thm "GCloseÌâg_thm";
=TEX
}%ignore

=GFT
€tcç_Ì_left_thm› =	Ù µ s t∑ s çâgõ+ s Ìâg t
€tcç_Ì_right_thm› =	Ù µ s t∑ t çâgõ+ s Ìâg t
=TEX

\ignore{
=SML
set_goal([], ¨µs t:GS∑ s çâgõ+ s Ìâg tÆ);
a (REPEAT µ_tac THEN rewrite_tac[get_spec ¨$ÌâgÆ]);
a (lemma_tac ¨Sing s çâgõ+ Pairâg (Sing s) (Pairâg s t)Æ THEN1 rewrite_tac[]);
a (lemma_tac ¨s çâgõ+ Sing sÆ THEN1 rewrite_tac[]);
a (all_fc_tac[tcç_trans_thm]);
val tcç_Ì_left_thm = save_pop_thm "tcç_Ì_left_thm";

set_goal([], ¨µs t:GS∑ t çâgõ+ s Ìâg tÆ);
a (REPEAT µ_tac THEN rewrite_tac[get_spec ¨$ÌâgÆ]);
a (lemma_tac ¨Pairâg s t çâgõ+ Pairâg (Sing s) (Pairâg s t)Æ THEN1 rewrite_tac[]);
a (lemma_tac ¨t çâgõ+ Pairâg s tÆ THEN1 rewrite_tac[]);
a (all_fc_tac[tcç_trans_thm]);
val tcç_Ì_right_thm = save_pop_thm "tcç_Ì_right_thm";
=TEX

=SML
add_pc_thms "'gst-fun" [≥Ìâgöâg_thm, ≥öâgÌâg_thm];
add_rw_thms [Ìâg_çâg_Gx_Pairâg_thm, tcç_Ì_left_thm, tcç_Ì_right_thm] "'gst-fun";
add_sc_thms [Ìâg_çâg_Gx_Pairâg_thm, tcç_Ì_left_thm, tcç_Ì_right_thm] "'gst-fun";
set_merge_pcs ["basic_hol", "'gst-ax", "'gst-fun"];
=TEX
}%ignore

\subsubsection{Projections}

The following functions may be used for extracting the components of ordered pairs.

\ignore{
=SML
set_goal([], ¨∂ fst snd∑
µs t∑
	fst(s Ìâg t) = s
	± snd(s Ìâg t) = tÆ);
a (∂_tac ¨Ãp∑≈x∑∂y∑p=x Ìâg yÆ);
a (∂_tac ¨Ãp∑≈y∑∂x∑p=x Ìâg yÆ);
a (rewrite_tac[] THEN REPEAT µ_tac);
a (all_≈_tac);
(* *** Goal "1" *** *)
a (∂_tac ¨tÆ THEN ∂_tac ¨sÆ
 THEN prove_tac[]);
(* *** Goal "2" *** *)
a (∂_tac ¨sÆ THEN ∂_tac ¨tÆ
 THEN prove_tac[]);
(* *** Goal "3" *** *)
a (∂_tac ¨tÆ THEN ∂_tac ¨sÆ
 THEN prove_tac[]);
(* *** Goal "4" *** *)
a (eq_sym_nth_asm_tac 1);
a (eq_sym_nth_asm_tac 4);
a (asm_rewrite_tac[]);
save_cs_∂_thm (pop_thm ());
=TEX
}%ignore

πHOLCONST
‹ €fst› €snd› : GS ≠ GS
˜¸¸¸¸¸¸¸¸¸¸
‹ µs t∑ fst(s Ìâg t) = s	± snd(s Ìâg t) = t
∞

=GFT
€Ì_tc_thm› =	Ù µ x y∑ tc $çâg x (x Ìâg y) ± tc $çâg y (x Ìâg y)
=TEX

\ignore{
=SML
set_goal([], ¨µx y∑ tc $çâg x (x Ìâg y) ± tc $çâg y (x Ìâg y)Æ);
a (REPEAT µ_tac);
a (LEMMA_T ¨Pairâg x y çâg (x Ìâg y) ± x çâg Pairâg x y ± y çâg Pairâg x yÆ
	(REPEAT_TTCL ±_THEN asm_tac)
	THEN1 (rewrite_tac [Ìâg_spec_thm, Pairâg_ç_thm]
		THEN all_var_elim_asm_tac));
a (fc_tac [tc_incr_thm]);
a (all_fc_tac [tran_tc_thm2]
	THEN asm_rewrite_tac[]);
val Ì_tc_thm = save_pop_thm "Ì_tc_thm";
=TEX

=SML
add_pc_thms "'gst-fun" [get_spec ¨fstÆ];
set_merge_pcs ["basic_hol", "'gst-ax", "'gst-fun"];
=TEX
}%ignore

\subsubsection{MkPair and MkTriple}

It proves convenient to have constructors which take HOL pairs and triples as parameters.

πHOLCONST
‹ €MkPairâg› : GS ∏ GS ≠ GS
˜¸¸¸¸¸¸¸¸¸¸
‹ µlr∑ MkPairâg lr = (Fst lr) Ìâg (Snd lr)
∞

πHOLCONST
‹ €MkTripleâg› : GS ∏ GS ∏ GS ≠ GS
˜¸¸¸¸¸¸¸¸¸¸
‹ µt∑ MkTripleâg t = (Fst t) Ìâg (MkPairâg (Snd t))
∞

\ignore{
=IGN

set_goal([], ¨µx y∑ x çâgõ+ MkPair Æ);

=TEX
}%ignore

\subsection{Relations}

πHOLCONST
‹ €rel› : GS ≠ BOOL
˜¸¸¸¸¸¸¸¸¸¸¸
‹ µx∑ rel x § µy∑ y çâg x ¥ ∂s t∑ y = s Ìâg t
∞

\ignore{
=SML
val relâg_def = get_spec ¨relÆ;
=TEX
}%ignore

=GFT
€rel_öâg_thm› =	Ù rel öâg
=TEX

\ignore{
=SML
val rel_öâg_thm = prove_thm (
	"rel_öâg_thm",
	¨rel öâgÆ,
	prove_tac[get_spec¨relÆ]);
=TEX
}%ignore

The domain is the set of elements which are related to something under the relationship.

πHOLCONST
‹ €dom› : GS ≠ GS
˜¸¸¸¸¸¸¸¸¸¸
‹ µx∑ dom x = Sep (Gx x) (Ãw∑ ∂v∑ w Ìâg v çâg x)
∞

=GFT
€dom_öâg_thm› =		Ù dom öâg = öâg
€dom_thm› =		Ù µ r y∑ y çâg dom r § (∂ x∑ y Ìâg x çâg r)
€dom_Gx_thm› =	Ù µ r∑ dom r çâg Gx r
€GClose_dom_thm› =	Ù µ g∑ galaxy g ¥ (µ r∑ r çâg g ¥ dom r çâg g)
=TEX

\ignore{
=SML
set_goal([],¨dom öâg = öâgÆ);
a (prove_tac[get_spec¨domÆ, gst_relext_clauses]);
val dom_öâg_thm = save_pop_thm "dom_öâg_thm";

set_goal([], ¨µr y∑ y çâg dom r § ∂ x∑ y Ìâg x çâg rÆ);
a (rewrite_tac [get_spec ¨domÆ] THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a (∂_tac ¨vÆ THEN asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a (LEMMA_T  ¨(Pairâg y x) çâg Gx (y Ìâg x)Æ asm_tac
	THEN1 rewrite_tac [Ìâg_spec_thm]);
a (lemma_tac ¨Gx (y Ìâg x) Äâg Gx rÆ THEN1 fc_tac [Gx_mono_thm2]);
a (LEMMA_T ¨y çâg Pairâg y xÆ asm_tac THEN1 rewrite_tac []);
a (lemma_tac ¨y çâg Gx (y Ìâg x)Æ);
(* *** Goal "2.1" *** *)
a (lemma_tac ¨galaxy (Gx (y Ìâg x))Æ THEN1 rewrite_tac[galaxy_Gx]);
a (fc_tac [GalaxiesTransitive_thm]);
a (fc_tac [get_spec ¨transitiveÆ]);
a (ASM_FC_T (MAP_EVERY ante_tac) []
	THEN once_rewrite_tac [get_spec ¨$ÄâgÆ]
	THEN REPEAT strip_tac);
a (spec_nth_asm_tac 1 ¨yÆ);
(* *** Goal "2.2" *** *)
a (DROP_NTH_ASM_T 3 (asm_tac o (once_rewrite_rule [get_spec¨$ÄâgÆ])));
a (spec_nth_asm_tac 1 ¨yÆ);
(* *** Goal "3" *** *)
a (∂_tac ¨xÆ THEN strip_tac);
val dom_thm = save_pop_thm "dom_thm";

set_goal([], ¨µr∑ dom r çâg Gx rÆ);
a (strip_tac THEN rewrite_tac [get_spec ¨domÆ]);
a (lemma_tac ¨galaxy (Gx r)Æ THEN1 rewrite_tac[]);
a (lemma_tac ¨Sep (Gx r) (Ã w∑ ∂ v∑ w Ìâg v çâg r) = Sep (ﬁâg (ﬁâg r)) (Ã w∑ ∂ v∑ w Ìâg v çâg r)Æ
	THEN1 (rewrite_tac [gst_relext_clauses] THEN REPEAT strip_tac));
(* *** Goal "1" *** *)
a (∂_tac ¨Pairâg e vÆ THEN asm_rewrite_tac[]);
a (∂_tac ¨e Ìâg vÆ THEN asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a (∂_tac ¨vÆ THEN asm_rewrite_tac[]);
(* *** Goal "3" *** *)
a (lemma_tac ¨e çâgõ+ rÆ THEN1 (
	ufc_tac [tcç_incr_thm]
	THEN REPEAT_N 2 (all_ufc_tac [tcç_trans_thm])));
a (asm_tac t_in_Gx_t_thm);
a (all_ufc_tac [tcç_incr_thm]);
a (all_ufc_tac [tcç_trans_thm]);
a (all_fc_tac [GClose_tcçâg_thm]);
(* *** Goal "4" *** *)
a (∂_tac ¨vÆ THEN asm_rewrite_tac[]);
(* *** Goal "5" *** *)
a (asm_rewrite_tac[]);
a (lemma_tac ¨r çâg Gx rÆ THEN1 rewrite_tac[]);
a (lemma_tac ¨ﬁâg r çâg Gx rÆ THEN1 all_fc_tac[GClose_fc_clauses]);
a (lemma_tac ¨(ﬁâg (ﬁâg r)) çâg Gx rÆ THEN1 (all_fc_tac[GClose_fc_clauses]));
a (all_fc_tac [GClose_fc_clauses]);
a (asm_rewrite_tac[]);
val dom_Gx_thm = save_pop_thm "dom_Gx_thm"; 

set_goal([], ¨µg∑ galaxy g ¥ µr∑ r çâg g ¥ dom r çâg gÆ);
a (REPEAT strip_tac THEN rewrite_tac [get_spec ¨domÆ]);
a (lemma_tac ¨galaxy (Gx r)Æ THEN1 rewrite_tac[]);
a (lemma_tac ¨Sep (Gx r) (Ã w∑ ∂ v∑ w Ìâg v çâg r) = Sep (ﬁâg (ﬁâg r)) (Ã w∑ ∂ v∑ w Ìâg v çâg r)Æ
	THEN1 (rewrite_tac [gst_relext_clauses] THEN REPEAT strip_tac));
(* *** Goal "1" *** *)
a (∂_tac ¨Pairâg e vÆ THEN asm_rewrite_tac[]);
a (∂_tac ¨e Ìâg vÆ THEN asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a (∂_tac ¨vÆ THEN asm_rewrite_tac[]);
(* *** Goal "3" *** *)
a (lemma_tac ¨e çâgõ+ rÆ THEN1 (
	ufc_tac [tcç_incr_thm]
	THEN REPEAT_N 2 (all_ufc_tac [tcç_trans_thm])));
a (asm_tac t_in_Gx_t_thm);
a (all_ufc_tac [tcç_incr_thm]);
a (all_ufc_tac [tcç_trans_thm]);
a (all_fc_tac [GClose_tcçâg_thm]);
(* *** Goal "4" *** *)
a (∂_tac ¨vÆ THEN asm_rewrite_tac[]);
(* *** Goal "5" *** *)
a (asm_rewrite_tac[]);
a (lemma_tac ¨r çâg Gx rÆ THEN1 rewrite_tac[]);
a (lemma_tac ¨ﬁâg r çâg Gx rÆ THEN1 all_fc_tac[GClose_fc_clauses]);
a (lemma_tac ¨(ﬁâg (ﬁâg r)) çâg Gx rÆ THEN1 (all_fc_tac[GClose_fc_clauses]));
a (lemma_tac ¨ﬁâg r çâg gÆ THEN1 all_fc_tac [GClose_fc_clauses]);
a (lemma_tac ¨ﬁâg (ﬁâg r) çâg gÆ THEN1 all_fc_tac [GClose_fc_clauses]);
a (lemma_tac ¨µ p∑ Sep (ﬁâg (ﬁâg r)) p çâg gÆ THEN1 all_fc_tac [GClose_fc_clauses]);
a (asm_rewrite_tac[]);
val GClose_dom_thm = save_pop_thm "GClose_dom_thm";
=TEX
}%ignore

πHOLCONST
‹ €ran› : GS ≠ GS
˜¸¸¸¸¸¸¸¸¸¸¸¸
‹ µx∑ ran x = Sep (Gx x) (Ãw∑ ∂v∑ v Ìâg w çâg x)
∞

=GFT
€ran_öâg_thm› =		Ù ran öâg = öâg
€ran_thm› =		Ù µr y∑ y çâg ran r § ∂ x∑ x Ìâg y çâg r
€GClose_ran_thm› =	Ù µ g∑ galaxy g ¥ (µ r∑ r çâg g ¥ ran r çâg g)
€tcç_ran_thm› = 		Ù µ x y∑ x çâgõ+ ran y ¥ x çâgõ+ y
=TEX

\ignore{
=SML
set_goal([],¨ran öâg = öâgÆ);
a (prove_tac[get_spec ¨ranÆ, gst_relext_clauses]);
val ran_öâg_thm =	save_pop_thm "ran_öâg_thm";

set_goal([], ¨µr y∑ y çâg ran r § ∂ x∑ x Ìâg y çâg rÆ);
a (rewrite_tac [get_spec ¨ranÆ] THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a (∂_tac ¨vÆ THEN asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a (LEMMA_T  ¨(Pairâg x y) çâg Gx (x Ìâg y)Æ asm_tac
	THEN1 rewrite_tac [Ìâg_spec_thm]);
a (lemma_tac ¨Gx (x Ìâg y) Äâg Gx rÆ THEN1 fc_tac [Gx_mono_thm2]);
a (LEMMA_T ¨y çâg Pairâg x yÆ asm_tac THEN1 rewrite_tac []);
a (lemma_tac ¨y çâg Gx (x Ìâg y)Æ);
(* *** Goal "2.1" *** *)
a (lemma_tac ¨galaxy (Gx (x Ìâg y))Æ THEN1 rewrite_tac[galaxy_Gx]);
a (fc_tac [GalaxiesTransitive_thm]);
a (fc_tac [get_spec ¨transitiveÆ]);
a (ASM_FC_T (MAP_EVERY ante_tac) []
	THEN once_rewrite_tac [get_spec ¨$ÄâgÆ]
	THEN REPEAT strip_tac);
a (spec_nth_asm_tac 1 ¨yÆ);
(* *** Goal "2.2" *** *)
a (DROP_NTH_ASM_T 3 (asm_tac o (once_rewrite_rule [get_spec¨$ÄâgÆ])));
a (spec_nth_asm_tac 1 ¨yÆ);
(* *** Goal "3" *** *)
a (∂_tac ¨xÆ THEN strip_tac);
val ran_thm = save_pop_thm "ran_thm";

set_goal([], ¨µg∑ galaxy g ¥ µr∑ r çâg g ¥ ran r çâg gÆ);
a (REPEAT strip_tac THEN rewrite_tac [get_spec ¨ranÆ]);
a (lemma_tac ¨galaxy (Gx r)Æ THEN1 rewrite_tac[]);
a (lemma_tac ¨Sep (Gx r) (Ã w∑ ∂ v∑ v Ìâg w çâg r) = Sep (ﬁâg (ﬁâg r)) (Ã w∑ ∂ v∑ v Ìâg w çâg r)Æ
	THEN1 (rewrite_tac [gst_relext_clauses] THEN REPEAT strip_tac));
(* *** Goal "1" *** *)
a (∂_tac ¨Pairâg v eÆ THEN asm_rewrite_tac[]);
a (∂_tac ¨v Ìâg eÆ THEN asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a (∂_tac ¨vÆ THEN asm_rewrite_tac[]);
(* *** Goal "3" *** *)
a (lemma_tac ¨e çâgõ+ rÆ THEN1 (
	ufc_tac [tcç_incr_thm]
	THEN REPEAT_N 2 (all_ufc_tac [tcç_trans_thm])));
a (asm_tac t_in_Gx_t_thm);
a (all_ufc_tac [tcç_incr_thm]);
a (all_ufc_tac [tcç_trans_thm]);
a (all_fc_tac [GClose_tcçâg_thm]);
(* *** Goal "4" *** *)
a (∂_tac ¨vÆ THEN asm_rewrite_tac[]);
(* *** Goal "5" *** *)
a (asm_rewrite_tac[]);
a (lemma_tac ¨r çâg Gx rÆ THEN1 rewrite_tac[]);
a (lemma_tac ¨ﬁâg r çâg Gx rÆ THEN1 all_fc_tac[GClose_fc_clauses]);
a (lemma_tac ¨(ﬁâg (ﬁâg r)) çâg Gx rÆ THEN1 (all_fc_tac[GClose_fc_clauses]));
a (lemma_tac ¨ﬁâg r çâg gÆ THEN1 all_fc_tac [GClose_fc_clauses]);
a (lemma_tac ¨ﬁâg (ﬁâg r) çâg gÆ THEN1 all_fc_tac [GClose_fc_clauses]);
a (lemma_tac ¨µ p∑ Sep (ﬁâg (ﬁâg r)) p çâg gÆ THEN1 (all_fc_tac [GClose_fc_clauses]));
a (asm_rewrite_tac[]);
val GClose_ran_thm = save_pop_thm "GClose_ran_thm";

set_goal([], ¨µx y∑ $çâgõ+ x (ran y) ¥ $çâgõ+ x yÆ);
a (REPEAT strip_tac);
a (fc_tac [tcç_cases_thm]);
(* *** Goal "1" *** *)
a (POP_ASM_T ante_tac);
a (rewrite_tac [ran_thm] THEN REPEAT strip_tac);
a (lemma_tac ¨$çâgõ+ x (x' Ìâg x)Æ THEN1 rewrite_tac [tcç_Ì_right_thm]);
a (fc_tac [tcç_incr_thm]);
a (all_fc_tac [tcç_trans_thm]);
(* *** Goal "2" *** *)
a (POP_ASM_T ante_tac);
a (rewrite_tac [ran_thm] THEN REPEAT strip_tac);
a (lemma_tac ¨$çâgõ+ z (x' Ìâg z)Æ THEN1 rewrite_tac [tcç_Ì_right_thm]);
a (fc_tac [tcç_incr_thm]);
a (all_ufc_tac [tcç_trans_thm]);
a (all_ufc_tac [tcç_trans_thm]);
val tcç_ran_thm = save_pop_thm "tcç_ran_thm";
=TEX
}%ignore

\ignore{
=SML
set_goal([],¨∂field∑ µs e∑
e çâg (field s) § e çâg (dom s) ≤ e çâg (ran s)Æ);
a (∂_tac ¨Ãx∑ (dom x) ¿âg (ran x)Æ);
a (prove_tac[]);
save_cs_∂_thm (pop_thm ());
=TEX
}%ignore

πHOLCONST
‹ €field›: GS ≠ GS
˜¸¸¸¸¸¸¸¸¸
‹ µs e∑ e çâg (field s) § e çâg (dom s) ≤ e çâg (ran s)
∞

=GFT
€field_öâg_thm› =	Ù field öâg = öâg
=TEX

\ignore{
=SML
add_pc_thms "'gst-fun" ([
	get_spec ¨fieldÆ,
	rel_öâg_thm,
	dom_öâg_thm,
	ran_öâg_thm]);
set_merge_pcs ["basic_hol", "'gst-ax", "'gst-fun"];

set_goal([],¨field öâg = öâgÆ);
a (prove_tac[gst_relext_clauses]);
val field_öâg_thm = save_pop_thm "field_öâg_thm";
add_pc_thms "'gst-fun" ([field_öâg_thm]);
set_merge_pcs ["basic_hol", "'gst-ax", "'gst-fun"];
=TEX
}%ignore

\subsection{Domain and Range Restrictions}

=SML
declare_infix (300, "Úâg");
declare_infix (300, "íâg");
declare_infix (300, "·âg");
declare_infix (300, "Åâg");
=TEX

πHOLCONST
‹ $€Úâg›: GS ≠ GS ≠ GS
˜¸¸¸¸¸¸
‹ µs r∑ s Úâg r = Sep r (Ãp∑ fst p çâg s)
∞

πHOLCONST
‹ $€íâg›: GS ≠ GS ≠ GS
˜¸¸¸¸¸¸
‹ µs r∑ r íâg s = Sep r (Ãp∑ snd p çâg s)
∞

πHOLCONST
‹ $€·âg›: GS ≠ GS ≠ GS
˜¸¸¸¸¸¸
‹ µs r∑ s ·âg r = Sep r (Ãp∑ ≥ fst p çâg s)
∞

πHOLCONST
‹ $€Åâg›: GS ≠ GS ≠ GS
˜¸¸¸¸¸¸
‹ µs r∑ r Åâg s = Sep r (Ãp∑ ≥ snd p çâg s)
∞

=SML
declare_alias ("Ú", ¨$ÚâgÆ);
declare_alias ("í", ¨$íâgÆ);
declare_alias ("·", ¨$·âgÆ);
declare_alias ("Å", ¨$ÅâgÆ);
=TEX

\subsection{Dependent Types}

Any relation may be regarded as a dependent sum type.
When so regarded, each ordered pair in the relation consist with a type-index and a value whose type is that associated with the type.

The indexed set of types, relative to which every pair in the relation is well-typed may be retrieved from the relation as follows.

πHOLCONST
‹ €Rel2DepTypeâg› : GS ≠ GS
˜¸¸¸¸¸¸¸¸¸¸¸¸¸
‹ µr∑ Rel2DepTypeâg r = Sep
‹		(Gx r)
‹		(Ãe∑ ∂i t:GS∑
‹			e = i Ìâg t
‹			± i çâg dom r
‹			± (µj∑ j çâg t § i Ìâg j çâg r))
∞

\ignore{
=IGN
stop;
set_goal([], ¨µr e∑ rel r ¥
	(e çâg Rel2DepTypeâg r
	§ ∂i t:GS∑ e = i Ìâg t
			± i çâg dom r
			± (µj∑ j çâg t § i Ìâg j çâg r))Æ);
a (REPEAT_N 3 strip_tac THEN rewrite_tac [get_spec ¨Rel2DepTypeâgÆ]
	THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a (∂_tac ¨iÆ THEN ∂_tac ¨tÆ THEN asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a (lemma_tac ¨galaxy (Gx r)Æ THEN1 rewrite_tac[]);
a (lemma_tac ¨r çâg Gx rÆ THEN1 rewrite_tac[]);
a (lemma_tac ¨dom r çâg (Gx r)Æ THEN1 (all_fc_tac [GClose_dom_thm]));
a (lemma_tac ¨i çâg (Gx r)Æ THEN1 (
	all_fc_tac [tcç_incr_thm]
	THEN all_fc_tac [tcç_trans_thm]
	THEN all_fc_tac [GClose_tcçâg_thm]));
a (lemma_tac ¨t = Sep (ran r) (Ãj∑ i Ìâg j çâg r)Æ
	THEN1 (rewrite_tac [gst_relext_clauses] THEN REPEAT strip_tac));
(* *** Goal "2.1" *** *)
a (rewrite_tac [ran_thm]);
a (asm_ufc_tac []);
a (∂_tac ¨iÆ THEN asm_rewrite_tac[]);
(* *** Goal "2.2" *** *)
a (asm_ufc_tac []);
(* *** Goal "2.3" *** *)
a (SYM_ASMS_T ufc_tac);
(* *** Goal "2.4" *** *)
a (lemma_tac ¨ran r çâg Gx rÆ THEN1 all_fc_tac [GClose_ran_thm]);
a (lemma_tac ¨Sep (ran r) (Ã j∑ i Ìâg j çâg r) çâg Gx rÆ
	THEN1 (ALL_FC_T  rewrite_tac[GClose_fc_clauses]));
stop;
a (lemma_tac ¨Æ THEN1 fc_tac [tcç_incr_thm]);


a (∂_tac ¨iÆ THEN asm_rewrite_tac[]);

a (∂_tac ¨Æ THEN asm_rewrite_tac[]);

a (lemma_tac ¨µj∑ j çâg t ¥ j çâgõ+ rÆ THEN1 REPEAT strip_tac);
(* *** Goal "2.1" *** *)
a (lemma_tac ¨i Ìâg j çâg rÆ THEN1 asm_fc_tac[]);
a (lemma_tac ¨j çâgõ+ i Ìâg jÆ THEN1 rewrite_tac[]);
a (all_fc_tac [tcç_incr_thm] THEN all_fc_tac [tcç_trans_thm]);
(* *** Goal "2.2" *** *)
a (lemma_tac ¨Æ THEN1 (asm_rewrite_tac[gst_relext_clauses]));
a (lemma_tac ¨µj∑ j çâg t ¥ j çâg rÆ
	THEN1 (REPEAT strip_tac
		THEN asm_fc_tac []
		THEN fc_tac [GClose_tcçâg_thm]));
GClose_fc_clauses;

a (asm_rewrite_tac[]);
a (fc_tac [GCloseÌâg_thm]);

a (lemma_tac ¨t çâg Gx rÆ

a (∂_tac ¨Ãr∑ Sep
		(Gx r)
		(Ãe∑ ∂i t:GS∑
			e = i Ìâg t
			± i çâg dom r
			± (µj∑ j çâg t § i Ìâg j çâg r))Æ
	THEN rewrite_tac[]);
a (REPEAT strip_tac THEN_TRY asm_rewrite_tac[]);
(* *** Goal "1" *** *)
a (∂_tac ¨iÆ THEN ∂_tac ¨tÆ THEN asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a (lemma_tac ¨galaxy (Gx r)Æ THEN1 rewrite_tac[]);
a (lemma_tac ¨i çâg Gx r ± t çâg Gx rÆ
a (fc_tac [GCloseÌâg_thm]);
a (list_spec_nth_asm_tac 1 [¨iÆ, ¨tÆ]);
=TEX
}%ignore

Any similar indexed collection of sets, determines a set of ordered pairs and a set of functions according to the following definitions.

The dependent sums are as follows:

πHOLCONST
‹ €DepSumâg› : GS ≠ GS
˜¸¸¸¸¸¸¸¸¸¸¸¸¸
‹ µt∑ DepSumâg t = Sep
‹		(Gx t)
‹		(Ãe∑ ∂i t2 v:GS∑
‹			e = i Ìâg v
‹			± v çâg t2
‹			± i Ìâg t2 çâg t)
∞

=GFT
=TEX

\ignore{
=IGN
stop;

set_goal([], ¨µr∑ rel r ¥ DepSumâg (Rel2DepTypeâg r) = rÆ);
a (REPEAT strip_tac THEN rewrite_tac (map get_spec [¨DepSumâgÆ, ¨Rel2DepTypeâgÆ]));
a (once_rewrite_tac [gst_relext_clauses] THEN_TRY (rewrite_tac []) THEN REPEAT strip_tac THEN_TRY rewrite_tac[]);
(* *** Goal "1" *** *)
a (all_var_elim_asm_tac);
a (all_asm_fc_tac[]);
a (POP_ASM_T ante_tac THEN asm_rewrite_tac[]);
(* *** Goal "2" *** *)

=TEX
}%ignore

\ignore{
 πHOLCONST
‹ €DepProdâg› : GS ≠ GS
˜¸¸¸¸¸¸¸¸¸¸¸¸¸
‹ µt∑ DepProdâg t = Sep
‹		(Gx t)
‹		(Ãf∑ dom f = dom t
‹			± µe∑ e çâg f ¥ ∂a v∑ e = a Ìâg v çâg f ¥ )
 ∞
}%ignore


\subsection{Dependent Sums and Cartesian Products}

=SML
declare_binder "ìâg";
=TEX

πHOLCONST
‹ $€ìâg› : (GS ≠ GS) ≠ GS ≠ GS
˜¸¸¸¸¸¸¸¸¸¸¸
‹ µf s∑  $ìâg f s = ﬁâg (
‹	Imagep	(Ãe∑ Imagep (Ãx∑ e Ìâg x) (f e))
‹		s
‹ )
∞

=SML
declare_infix(240,"∏âg");
=TEX

πHOLCONST
‹ $€∏âg› : GS ≠ GS ≠ GS
˜¸¸¸¸¸¸¸¸¸¸¸
‹ µs t∑ s ∏âg t = ﬁâg (
‹	Imagep
‹	(Ãse∑ (Imagep (Ãte∑ se Ìâg te) t))
‹	s)
∞

\ignore{
=SML
set_goal([],¨µs t e∑ e çâg s ∏âg t §
	∂l r∑l çâg s ± r çâg t
	± e = l Ìâg r
Æ);
a (REPEAT µ_tac THEN rewrite_tac [get_spec ¨$∏âgÆ]);
a (prove_tac[]);
(* *** Goal "1" *** *)
a (∂_tac ¨e''Æ
	THEN ∂_tac ¨snd(e)Æ
	THEN asm_rewrite_tac[]);
a (DROP_NTH_ASM_T 1 
	(fn x=> fc_tac [
	(once_rewrite_rule
		[gst_relext_clauses] x)]));
a (asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a (∂_tac ¨Imagep (Ã te∑ l Ìâg te) tÆ);
a (prove_tac[]);
(* *** Goal "2.1" *** *)
a (∂_tac ¨rÆ
 THEN prove_tac[]);
(* *** Goal "2.2" *** *)
a (∂_tac ¨lÆ THEN prove_tac[]);
val ∏âg_spec = save_pop_thm "∏âg_spec";
=TEX
}%ignore


=GFT
€fÌâgs_thm› =
	Ù µ s t p∑ p çâg s ∏âg t ¥ fst p Ìâg snd p = p

€vçâg∏âg_thm› =
	Ù µ p s t∑ p çâg s ∏âg t ¥ fst p çâg s ± snd p çâg t

€Ìâgçâg∏âg_thm› =
	Ù µ l r s t∑ l Ìâg r çâg s ∏âg t § (l çâg s ± r çâg t)
=TEX

\ignore{
=SML
set_goal ([],¨µs t p∑ p çâg s ∏âg t
	¥ fst(p) Ìâg snd(p) = pÆ);
a (prove_tac[∏âg_spec]);
a (asm_rewrite_tac[]);
val fÌâgs_thm = save_pop_thm "fÌâgs_thm";

set_goal([],¨µp s t∑
	p çâg (s ∏âg t)
	¥ fst p çâg s ± snd p çâg tÆ);
a (prove_tac[∏âg_spec]
      THEN_TRY asm_rewrite_tac[]);
val vçâg∏âg_thm = 
	save_pop_thm "vçâg∏âg_thm";

(*
add_pc_thms "'gst-fun" [vçâg∏âg_thm];
set_merge_pcs ["basic_hol", "'gst-ax", "'gst-fun"];
*)

set_goal([],¨µl r s t∑
	(l Ìâg r) çâg (s ∏âg t)
	§ l çâg s ± r çâg tÆ);
a (prove_tac[∏âg_spec]);
a (∂_tac ¨lÆ
	THEN ∂_tac ¨rÆ
	THEN asm_prove_tac[]);
val Ìâgçâg∏âg_thm = save_pop_thm "Ìâgçâg∏âg_thm";

add_pc_thms "'gst-fun" [Ìâgçâg∏âg_thm];
set_merge_pcs ["basic_hol", "'gst-ax", "'gst-fun"];
=TEX
}%ignore

=GFT
=TEX

\ignore{
=IGN
stop;

set_goal([], ¨s ∏âg t çâg = {z | }Æ);

set_goal([], ¨µg∑ galaxy g ¥ (µs t∑ s çâg g ± t çâg g ¥ s ∏âg t çâg g)Æ);
a (REPEAT strip_tac THEN fc_tac [get_spec ¨galaxyÆ, GCloseSep_thm, ]);

=TEX
}%ignore

\subsubsection{Relation Space}

This is the set of all relations over some domain and codomain, i.e. the power set of the cartesian product.

=SML
declare_infix(240,"™âg");
=TEX

πHOLCONST
‹ $™âg : GS ≠ GS ≠ GS
˜¸¸¸¸¸¸¸¸¸¸¸
‹ µs t∑ s ™âg t = âg(s ∏âg t)
∞

=GFT
™âgÄâg∏âg_thm =	Ù µs t r∑ r çâg s ™âg t § r Äâg (s ∏âg t)
öâgçâg™âg_thm =	Ù µs t∑ öâg çâg s ™âg t
=TEX

\ignore{
=SML
set_goal ([], ¨µs t r∑ r çâg s ™âg t § r Äâg (s ∏âg t)Æ);
a (prove_tac[get_spec¨$™âgÆ, gst_relext_clauses]);
val ™âgÄâg∏âg_thm = save_pop_thm "™âgÄâg∏âg_thm";

set_goal ([], ¨µs t∑ öâg çâg s ™âg tÆ);
a (prove_tac[get_spec¨$™âgÆ,
	gst_relext_clauses]);
val öâgçâg™âg_thm = save_pop_thm "öâgçâg™âg_thm";
add_pc_thms "'gst-fun" [öâgçâg™âg_thm];
set_merge_pcs ["basic_hol", "'gst-ax", "'gst-fun"];
=TEX
}%ignore

\subsubsection{Another Pair-Projection Inverse Theorem}

Couched in terms of membership of relation spaces.

=SML
set_goal ([], ¨µp r s t∑
	p çâg r ±
	r çâg s ™âg t ¥
	fst(p) Ìâg snd(p) = pÆ); 
a (prove_tac[
	get_spec ¨$™âgÆ,
	Äâg_thm]); 
a (REPEAT
	(asm_fc_tac[fÌâgs_thm])); 
val fÌâgs_thm1 =
	save_pop_thm "fÌâgs_thm1"; 
=TEX

\subsubsection{Member of Relation Theorem}

=SML
set_goal ([],¨µp r s t∑
	p çâg r ±
	r çâg s ™âg t ¥
	fst(p) çâg s ±
	snd(p) çâg tÆ); 
a (prove_tac[
	get_spec ¨$™âgÆ,
	Äâg_thm]); 
a (asm_fc_tac[]); 
a (fc_tac[vçâg∏âg_thm]); 
a (asm_fc_tac[]); 
a (fc_tac[vçâg∏âg_thm]); 
val çâg™âg_thm =
	save_pop_thm "çâg™âg_thm";
=TEX

\subsubsection{Relational Composition}

=SML
declare_infix (250,"oâg");
πHOLCONST
 $oâg : GS ≠ GS ≠ GS
˜
µf g∑ f oâg g =
	Imagep
	(Ãp∑ (fst(fst p) Ìâg snd(snd p)))
	(Sep (g ∏âg f) Ãp∑ ∂q r s∑ p = (q Ìâg r) Ìâg (r Ìâg s))
∞

=GFT
oâg_thm =
   Ù µf g x∑ x çâg f oâg g §
	∂q r s∑ q Ìâg r çâg g ± r Ìâg s çâg f
		± x = q Ìâg s
oâg_thm2 =
   Ù µ f g x y∑ x Ìâg y çâg f oâg g
	§ (∂ z∑ x Ìâg z çâg g ± z Ìâg y çâg f)

oâg_associative_thm =
   Ù µf g h∑ (f oâg g) oâg h = f oâg g oâg h

oâg_rel_thm =
   Ù µ r s∑ rel r ± rel s ¥ rel (r oâg s)
=TEX

\ignore{
=SML
set_goal([], ¨µf g x∑ x çâg f oâg g §
	∂q r s∑ q Ìâg r çâg g
	± r Ìâg s çâg f ± x = q Ìâg sÆ);
a (rewrite_tac (map get_spec [¨$oâgÆ]));
a (REPEAT strip_tac);
(* *** Goal "1" *** *)
a (MAP_EVERY ∂_tac [¨qÆ, ¨rÆ, ¨sÆ]);
a (DROP_NTH_ASM_T 3 ante_tac
	THEN asm_rewrite_tac []);
(* *** Goal "2" *** *)
a (∂_tac ¨(q Ìâg r) Ìâg r Ìâg sÆ
	THEN asm_rewrite_tac[]);
a (prove_∂_tac);
val oâg_thm = save_pop_thm "oâg_thm";
=SML
set_goal([], ¨µf g x y∑ x Ìâg y çâg f oâg g §
	∂z∑ x Ìâg z çâg g
	± z Ìâg y çâg fÆ);
a (REPEAT_N 4 strip_tac
	THEN rewrite_tac [oâg_thm]
	THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a (∂_tac ¨rÆ THEN asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a (MAP_EVERY ∂_tac [¨xÆ, ¨zÆ, ¨yÆ]
	THEN asm_rewrite_tac[]);
val oâg_thm2 = save_pop_thm "oâg_thm2";

set_goal ([], ¨µr s∑ rel r ± rel s ¥  rel (r oâg s)Æ);
a (rewrite_tac [get_spec ¨relÆ, oâg_thm] THEN REPEAT strip_tac);
a (∂_tac ¨qÆ THEN ∂_tac ¨s'Æ THEN strip_tac);
val oâg_rel_thm = save_pop_thm "oâg_rel_thm";

set_goal([], ¨µf g h∑ (f oâg g) oâg h = f oâg (g oâg h)Æ);
a (once_rewrite_tac [gs_ext_axiom]);
a (rewrite_tac [oâg_thm]);
a (REPEAT step_strip_tac);
(* *** Goal "1" *** *)
a (prove_∂_tac THEN all_var_elim_asm_tac);
a (MAP_EVERY ∂_tac [¨s'Æ, ¨r'Æ] THEN asm_rewrite_tac[]);
a (∂_tac ¨qÆ THEN asm_rewrite_tac[]);
a (∂_tac ¨q'Æ THEN asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a (prove_∂_tac THEN all_var_elim_asm_tac);
a (MAP_EVERY ∂_tac [¨sÆ, ¨r'Æ] THEN asm_rewrite_tac[] THEN strip_tac);
(* *** Goal "2.1" *** *)
a (∂_tac ¨q'Æ THEN asm_rewrite_tac[]);
(* *** Goal "2.2" *** *)
a (∂_tac ¨s'Æ THEN asm_rewrite_tac[]);
val oâg_associative_thm = save_pop_thm "oâg_associative_thm"; 

add_pc_thms "'gst-fun" [oâg_thm2];
set_merge_pcs ["basic_hol", "'gst-ax", "'gst-fun"];
=TEX
}%ignore

\subsubsection{Relation Subset of Cartesian Product}

=GFT
rel_sub_cp_thm = 
	Ù µ x∑ rel x § (∂ s t∑ x Äâg s ∏âg t)
=TEX

\ignore{
=SML
set_goal ([], ¨µx∑ rel x § ∂s t∑ x Äâg s ∏âg tÆ);
a (once_rewrite_tac [gst_relext_clauses]);
a (rewrite_tac[get_spec¨relÆ, ∏âg_spec]
	THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a (∂_tac ¨dom xÆ THEN ∂_tac ¨ran xÆ THEN REPEAT strip_tac);
a (asm_fc_tac[]);
a (∂_tac ¨sÆ THEN ∂_tac ¨tÆ
	THEN asm_rewrite_tac[get_spec ¨domÆ, get_spec ¨ranÆ]);
a (lemma_tac ¨Pairâg s t çâg Gx eÆ THEN1 asm_rewrite_tac [Ìâg_spec_thm]);
a (LEMMA_T ¨s çâg Pairâg s tÆ asm_tac THEN1 rewrite_tac[]);
a (LEMMA_T ¨t çâg Pairâg s tÆ asm_tac THEN1 rewrite_tac[]);
a (all_fc_tac [Gx_trans_thm3]);
a (LEMMA_T ¨Gx e Äâg Gx xÆ (fn x => fc_tac [rewrite_rule [get_spec ¨$ÄâgÆ] x])
	THEN1 fc_tac [Gx_mono_thm2]
	THEN REPEAT strip_tac);
(* *** Goal "1.1" *** *)
a (DROP_NTH_ASM_T 10 ante_tac THEN asm_rewrite_tac[] THEN strip_tac);
a (∂_tac ¨tÆ THEN asm_rewrite_tac[]);
(* *** Goal "1.2" *** *)
a (DROP_NTH_ASM_T 10 ante_tac THEN asm_rewrite_tac[] THEN strip_tac);
a (∂_tac ¨sÆ THEN asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a (asm_fc_tac[]);
a (∂_tac ¨lÆ THEN ∂_tac ¨rÆ THEN asm_rewrite_tac[]);
val rel_sub_cp_thm = save_pop_thm "rel_sub_cp_thm";
=TEX
}%ignore

\subsection{Functions}

Definition of partial and total functions and the corresponding function spaces.

\subsubsection{fun}

πHOLCONST
 fun : GS ≠ BOOL
˜
µx∑ fun x § rel x ±
	µs t u∑ s Ìâg u çâg x
		± s Ìâg t çâg x
		¥ u = t
∞

\ignore{
=SML
val fun_def = get_spec ¨funÆ;
=TEX
}%ignore

\subsubsection{lemmas}

=GFT
fun_öâg_thm =
	Ù fun öâg
oâg_fun_thm =
	Ù µ f g∑ fun f ± fun g ¥ fun (f oâg g)
ran_oâg_thm =
	Ù µ f g∑ ran (f oâg g) Äâg ran f
dom_oâg_thm =
	Ù µ f g∑ dom (f oâg g) Äâg dom g
dom_oâg_thm2 =
	Ù µ f g∑ ran g Äâg dom f ¥ dom (f oâg g) = dom g
=TEX
\ignore{
=SML
val fun_öâg_thm = prove_thm (
	"fun_öâg_thm", ¨fun öâgÆ,
	prove_tac[
	 get_spec ¨funÆ]);

set_goal([], ¨µf g∑ fun f ± fun g ¥ fun (f oâg g)Æ);
a (rewrite_tac [get_spec ¨funÆ] THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a (all_fc_tac [oâg_rel_thm]);
(* *** Goal "2" *** *)
a (lemma_tac ¨z = z'Æ THEN1 all_asm_fc_tac[]);
a (all_var_elim_asm_tac THEN all_asm_fc_tac[]);
val oâg_fun_thm = save_pop_thm "oâg_fun_thm";

set_goal ([], ¨µf g∑ ran (f oâg g) Äâg ran fÆ);
a (once_rewrite_tac [gst_relext_clauses]);
a (rewrite_tac [ran_thm] THEN REPEAT strip_tac);
a (∂_tac ¨zÆ THEN strip_tac);
val ran_oâg_thm = save_pop_thm "ran_oâg_thm";

set_goal ([], ¨µf g∑ dom (f oâg g) Äâg dom gÆ);
a (once_rewrite_tac [gst_relext_clauses]);
a (rewrite_tac [dom_thm] THEN REPEAT strip_tac);
a (∂_tac ¨zÆ THEN strip_tac);
val dom_oâg_thm = save_pop_thm "dom_oâg_thm";

set_goal([], ¨µ f g∑ ran g Äâg dom f ¥ dom (f oâg g) = dom gÆ);
a (once_rewrite_tac [gst_relext_clauses]
	THEN rewrite_tac [ran_thm, dom_thm]
	THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a (∂_tac ¨zÆ THEN asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a (spec_nth_asm_tac 2 ¨xÆ);
(* *** Goal "2.1" *** *)
a (spec_nth_asm_tac 1 ¨eÆ);
(* *** Goal "2.2" *** *)
a (∂_tac ¨x'Æ THEN ∂_tac ¨xÆ THEN asm_rewrite_tac[]);
val dom_oâg_thm2 = save_pop_thm "dom_oâg_thm2";
=TEX
}%ignore

\subsubsection{Partial Function Space}

This is the set of all partial functions (i.e. many one mapings) over some domain and codomain.
=SML
declare_infix (240, "ﬂâg");
πHOLCONST
 $ﬂâg : GS ≠ GS ≠ GS
˜
µs t∑ s ﬂâg t = Sep (s ™âg t) fun
∞
=TEX

\subsubsection{Partial Function Space Non-Empty}

First the theorem that the empty set is a partial function over any domain and codomain.
=SML
set_goal([],
	¨µs t∑ öâg çâg s ﬂâg tÆ);
a (prove_tac[
	get_spec ¨$ﬂâgÆ,
	fun_öâg_thm]);
val öâgçâgﬂâg_thm =
	save_pop_thm "öâgçâgﬂâg_thm";
=TEX
And then that every partial function space is non-empty.
=SML
set_goal([],
	¨µs t∑ ∂ f∑ f çâg s ﬂâg tÆ);
a (REPEAT strip_tac
	THEN ∂_tac ¨öâgÆ
	THEN
	rewrite_tac [öâgçâgﬂâg_thm]);
val ∂ﬂâg_thm =
	save_pop_thm "∂ﬂâg_thm";
=TEX

\subsubsection{Function Space}

This is the set of all total functions over some domain and codomain.

=SML
declare_infix (240, "≠âg");
πHOLCONST
‹ $≠âg : GS ≠ GS ≠ GS
˜
‹ µs t∑ s ≠âg t = Sep (s ﬂâg t)
‹	Ãr∑ dom r = s
∞

\subsubsection{Function Space Non-Empty}

First, for the special case of function spaces with empty domain we prove the theorem that the empty set is a member:

=SML
set_goal([],¨µs t∑ öâg çâg öâg ≠âg tÆ);
a (prove_tac[get_spec ¨$≠âgÆ,
	fun_öâg_thm,
	öâgçâgﬂâg_thm]);
val öâgçâgöâg≠âg_thm =
	save_pop_thm "öâgçâgöâg≠âg_thm";
=TEX

Then that whenever the codomain is non-empty the function space is non-empty.

=GFT
∂≠âg_thm =
   Ù µ s t∑ (∂ x∑ x çâg t) ¥ (∂ f∑ f çâg s ≠âg t)
=TEX

\ignore{
=SML
set_goal([],
	¨µs t∑ (∂x∑ x çâg t)
	¥ ∂ f∑ f çâg s ≠âg tÆ);
a (REPEAT strip_tac
	THEN ∂_tac ¨s ∏âg (Sing x)Æ);
a (rewrite_tac [get_spec ¨$≠âgÆ,
	get_spec ¨$ﬂâgÆ,
	get_spec ¨$™âgÆ]);
a (once_rewrite_tac
	[gst_relext_clauses]);
a (rewrite_tac[
	get_spec ¨domÆ,
	get_spec ¨funÆ,
	get_spec ¨relÆ,
	∏âg_spec, dom_thm]
	THEN REPEAT strip_tac
	THEN TRY (asm_rewrite_tac[])
	THEN TRY prove_∂_tac);
a (∂_tac ¨xÆ THEN REPEAT strip_tac
	THEN ∂_tac ¨lÆ
	THEN asm_rewrite_tac[]);
val ∂≠âg_thm = save_pop_thm "∂≠âg_thm";
=TEX
}%ignore

πHOLCONST
‹ ≠âg_closed : GS ≠ BOOL
˜¸¸¸¸¸¸¸¸¸¸¸¸
‹ µs∑ ≠âg_closed s § µd c∑ d çâg s ± c çâg s ¥ d ≠âg c çâg s
∞

\subsection{Functional Abstraction}

Functional abstraction is defined as a new variable binding construct yeilding a functional set.

\subsubsection{Abstraction}

Because of the closeness to lambda abstraction $Ãâg$ is used as the name of a new binder for set theoretic functional abstraction.

=SML
declare_binder "Ãâg";
=TEX

To define a functional set we need a HOL function over sets together with a set which is to be the domain of the function.
Specification of the range is not needed.
The binding therefore yields a function which maps sets to sets (maps the domain to the function).

The following definition is a placeholder, a more abstract definition might eventually be substituted.
The function is defined as that subset of the cartesian product of the set s and its image under the function f which coincides with the graph of f over s.

πHOLCONST
‹ $Ãâg: (GS ≠ GS) ≠ GS ≠ GS
˜¸¸¸¸¸¸¸¸¸
‹ µf s∑ $Ãâg f s = Sep (s ∏âg (Imagep f s)) (Ãp∑ snd p = f (fst p))
∞

\subsection{Application and Extensionality}

In this section we define function application and show that functions are extensional.

\subsubsection{Application}

Application by juxtaposition cannot be overloaded and is used for application of HOL functions.
Application of functional sets is therefore defined as an infix operator whose name is the empty name subscripted by "g".

=SML
declare_infix (250,"âg");
=TEX

The particular form shown here is innovative in the value specified for applications of functions to values outside their domain.
The merit of the particular value chosen is that it makes true an extensionality theorem which quantifies over all sets as arguments to the function, which might not otherwise be the case.
Whether this form is useful I don't know.
Generally a result with fewer conditionals is harder to prove but easier to use, but in this case I'm not so sure of the benefit.

It may be noted that it may also be used to apply a non-functional relation, if what you want it some arbitrary value (selected by the choice function) to which some object relates.

πHOLCONST
‹ $âg : GS ≠ GS ≠ GS
˜¸¸¸¸¸¸¸
‹ µf x∑ f âg x =
‹	if ∂y∑ x Ìâg y çâg f
‹	then ≈y∑ x Ìâg y çâg f
‹	else f
∞

=GFT
app_thm1 = 
	Ù µf x∑ (∂â1y∑ x Ìâg y çâg f)
	  ¥ x Ìâg (f âg x) çâg f

app_thm2 = 
	Ù µf x y∑ fun f ± (x Ìâg y çâg f)
	  ¥ f âg x = y

app_thm3 = 
	Ù µf x∑ fun f ± x çâg dom f
	  ¥ x Ìâg f âg x çâg f

oâg_âg_thm = 
	Ù µf g x∑ fun f ± fun g ± x çâg dom g ± ran g Äâg dom f
	  ¥ (f oâg g) âg x = f âg g âg x
=TEX
\ignore{
=SML

set_goal([],¨µf x∑ (∂â1y∑ x Ìâg y çâg f)
	¥ x Ìâg (f âg x) çâg fÆ);
a (prove_tac[get_spec¨$âgÆ]);
a (LEMMA_T ¨∂ y∑ x Ìâg y çâg fÆ
	(fn x=> rewrite_tac[x])
	THEN1 (
		∂_tac ¨yÆ
		THEN prove_tac[]));
a (all_≈_tac);
a (∂_tac ¨yÆ THEN prove_tac[]);
val app_thm1 = save_pop_thm "app_thm1";
=TEX

Note that the result is not conditional on f being a function.

The next theorem applies to functions only and obtains the necessary uniqueness of image from that assumption.

=SML
set_goal([],¨
µf x y∑ fun f ± (x Ìâg y çâg f)
	¥ f âg x = y
Æ);
a (prove_tac[get_spec¨$âgÆ,
	get_spec ¨funÆ]);
a (LEMMA_T
	¨∂ y∑ x Ìâg y çâg fÆ
	(fn x=> rewrite_tac[x])
	THEN1 (
		∂_tac ¨yÆ
		THEN prove_tac[]));
a (all_≈_tac);
a (∂_tac ¨yÆ
	THEN prove_tac[]);
a (REPEAT (asm_fc_tac[]));
val app_thm2 = save_pop_thm "app_thm2";

set_goal([], ¨µf x∑ fun f ± x çâg dom f ¥ x Ìâg f âg x çâg fÆ);
a (rewrite_tac [get_spec ¨funÆ, get_spec ¨$âgÆ]
	THEN REPEAT strip_tac);
a (POP_ASM_T (strip_asm_tac o (rewrite_rule [dom_thm])));
a (LEMMA_T ¨∂y∑ x Ìâg y çâg fÆ rewrite_thm_tac
	THEN1 (∂_tac ¨x'Æ THEN asm_rewrite_tac[dom_thm]));
a (≈_tac ¨≈ y∑ x Ìâg y çâg fÆ);
a (∂_tac ¨x'Æ THEN strip_tac);
val app_thm3 = save_pop_thm "app_thm3";

set_goal([], ¨µf g x∑ fun f ± fun g ± x çâg dom g ± ran g Äâg dom f
	¥ (f oâg g) âg x = f âg g âg xÆ);
a (REPEAT strip_tac);
a (lemma_tac ¨fun (f oâg g)Æ THEN1 all_fc_tac [oâg_fun_thm]);
a (LEMMA_T ¨x çâg dom (f oâg g)Æ asm_tac
	THEN1 all_fc_tac [once_rewrite_rule [gst_relext_clauses] dom_oâg_thm]);
(* *** Goal "1" *** *)
a (all_fc_tac [dom_oâg_thm2]
	THEN pure_asm_rewrite_tac[]
	THEN asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a (PC_T "hol" (strip_asm_tac (list_µ_elim [¨f oâg gÆ, ¨xÆ] app_thm3)));
a (GET_NTH_ASM_T 1 strip_asm_tac);
a (LEMMA_T ¨g âg x = zÆ rewrite_thm_tac THEN1 all_fc_tac [app_thm2]); 
a (LEMMA_T ¨f âg z = (f oâg g) âg xÆ rewrite_thm_tac THEN1 all_fc_tac [app_thm2]); 
val oâg_âg_thm = save_pop_thm "oâg_âg_thm"; 
=TEX
}%ignore

\subsubsection{The "Type" of an Application (1)}

The following theorem states that the result of applying a partial function to a value in its domain is a value in its codomain.

=SML
set_goal([],
	¨µf s t u∑ f çâg s ﬂâg t ±
	u çâg dom f ¥
	f âg u çâg tÆ); 
a (prove_tac[
	get_spec ¨$ﬂâgÆ,
	get_spec ¨domÆ]);
a (all_fc_tac [app_thm2] THEN asm_rewrite_tac[]);
a (all_fc_tac [fÌâgs_thm1]);
a (all_fc_tac [çâg™âg_thm]); 
a (POP_ASM_T ante_tac THEN asm_rewrite_tac []);
val âgçâg_thm = save_pop_thm "âgçâg_thm";
=TEX

\subsubsection{The "Type" of an Application (2)}

The following theorem states that the result of applying a total function to a value in its domain is a value in its codomain.

=GFT
=TEX

\ignore{
=SML
set_goal([],
	¨µf s t u∑ f çâg s ≠âg t ±
	u çâg s ¥
	f âg u çâg tÆ); 
a (prove_tac[
	get_spec ¨$≠âgÆ]);
a (bc_thm_tac âgçâg_thm);
a (∂_tac ¨sÆ
	THEN pure_asm_rewrite_tac[]
	THEN contr_tac); 
val âgçâg_thm1 = save_pop_thm "âgçâg_thm1";
=TEX
}%ignore

\subsubsection{Partial functions are total}

Every partial function is total over its domain.
(there is an ambiguity in the use of the term "domain" for a partial function.
It might mean the left hand operand of some partial function space construction within which the partial function concerned may be found, or it might mean the set of values over which the function is defined.
Here we are saying that if f is a partial function over A, then its domain is some subset of A and f is a total function over that subset of A.)

=GFT
çâgﬂâg¥çâg≠âg_thm =
	Ù µf s t u∑ f çâg s ﬂâg t ¥ f çâg dom f ≠âg t
=TEX

\ignore{
=SML
set_goal([],¨µf s t u∑ f çâg s ﬂâg t ¥ f çâg dom f ≠âg tÆ); 
a (rewrite_tac[
	get_spec ¨$≠âgÆ,
	get_spec ¨$™âgÆ,
	get_spec ¨domÆ,
	get_spec ¨$ﬂâgÆ]);
a (once_rewrite_tac[gst_relext_clauses]); 
a (REPEAT strip_tac); 
a (rewrite_tac[∏âg_spec]); 
a (asm_fc_tac[]); 
a (all_fc_tac[
	fÌâgs_thm,
	vçâg∏âg_thm]); 
a (∂_tac ¨fst eÆ
	THEN ∂_tac ¨snd eÆ
	THEN asm_rewrite_tac[]
	THEN strip_tac); 
(* *** Goal "1" *** *)
a (LEMMA_T ¨Pairâg (fst e) (snd e) çâg Gx (fst e Ìâg snd e)Æ ante_tac
	THEN1 rewrite_tac [Ìâg_spec_thm]);
a (pure_rewrite_tac[asm_rule ¨fst e Ìâg snd e = eÆ]
	THEN strip_tac);
a (LEMMA_T ¨Gx e Äâg Gx fÆ ante_tac THEN1 fc_tac [Gx_mono_thm2]);
a (rewrite_tac [gst_relext_clauses] THEN strip_tac THEN asm_fc_tac[]);
a (LEMMA_T ¨fst e çâg Pairâg (fst e) (snd e)Æ asm_tac THEN1 rewrite_tac[]);
a (all_fc_tac [Gx_trans_thm3]);
(* *** Goal "2" *** *)
a (∂_tac ¨snd eÆ	THEN asm_rewrite_tac[]); 
val çâgﬂâg¥çâg≠âg_thm = save_pop_thm "çâgﬂâg¥çâg≠âg_thm";
=TEX
}%ignore

\subsection{The Identity Function}

\subsubsection{specification}

πHOLCONST
‹ id : GS ≠ GS
˜¸¸¸¸¸¸¸¸
‹ µs∑ id s = Sep
‹	(s ∏âg s)
‹	Ãx∑ fst x = snd x
∞

\subsubsection{lemmas}

=GFT
id_thm1 =
	Ù µs x∑ x çâg id s	
	  § ∂y∑ y çâg s ± x = y Ìâg y

id_ap_thm =
	Ù µs x∑ x çâg s	
	  ¥ (id s) âg x = x

idçâgﬂâg_thm1 =
	Ù µs t u∑ s Äâg t °âg u
	  ¥ id s çâg t ﬂâg u

idçâgﬂâg_thm2 =
	Ù µs t u∑ s Äâg t
	  ¥ id s çâg t ﬂâg t

id_clauses =
	Ù µs∑ rel(id s) ± fun (id s)
	  ± dom(id s) = s ± ran(id s) = s
=TEX

\ignore{
=SML
val idg_def = get_spec ¨idÆ;

set_goal([],¨µs x∑
	x çâg id s	
	§ ∂y∑ y çâg s
	± x = y Ìâg yÆ);
a (prove_tac[get_spec ¨idÆ]
	THEN_TRY (asm_rewrite_tac[
	get_spec¨$™âgÆ,
	∏âg_spec]));
(* *** Goal "1" *** *)
a (fc_tac[∏âg_spec]);
a (asm_ante_tac ¨fst x = snd xÆ
	THEN asm_rewrite_tac[]
	THEN strip_tac
	THEN all_var_elim_asm_tac);
a (∂_tac ¨rÆ THEN asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a (REPEAT (∂_tac ¨yÆ) THEN asm_rewrite_tac[]);
val id_thm1 =
	save_pop_thm "id_thm1";

set_goal([],¨µs x∑
	x çâg s	
	¥ (id s) âg x = xÆ);
a (once_rewrite_tac[gst_relext_clauses]);
a (rewrite_tac[get_spec ¨$âgÆ, id_thm1]);
a (REPEAT_N 4 strip_tac);
a (LEMMA_T ¨∂ y y'∑ y' çâg s ± x = y' ± y = y'Æ
	(fn x=> rewrite_tac[x] THEN asm_tac x)
	THEN1 (REPEAT_N 2 (∂_tac ¨xÆ)
		THEN asm_rewrite_tac[]));
a (all_≈_tac
	THEN asm_rewrite_tac[]);
val id_ap_thm = save_pop_thm "id_ap_thm"; 

set_goal([],¨µs t u∑ s Äâg t °âg u ¥ id s çâg t ﬂâg uÆ);
a (rewrite_tac[gst_relext_clauses]);
a (prove_tac[get_spec ¨$ﬂâgÆ,
	get_spec ¨idÆ,
	get_spec ¨$™âgÆ,
	∏âg_spec]);
(* *** Goal "1" *** *)
a (once_rewrite_tac[gst_relext_clauses]);
a (prove_tac[∏âg_spec]);
a (MAP_EVERY ∂_tac [¨lÆ, ¨rÆ] THEN REPEAT strip_tac
	THEN (REPEAT (asm_fc_tac[])));
(* *** Goal "2" *** *)
a (prove_tac[get_spec ¨funÆ,
	get_spec ¨relÆ,
	∏âg_spec]);
val idçâgﬂâg_thm1 = save_pop_thm "idçâgﬂâg_thm1";

set_goal([],¨µs t u∑ s Äâg t ¥ id s çâg t ﬂâg tÆ);
a (prove_tac[]);
a (bc_thm_tac idçâgﬂâg_thm1);
a (asm_rewrite_tac [
	prove_rule [gst_relext_clauses]
	¨t °âg t = tÆ]);
val idçâgﬂâg_thm2 = save_pop_thm "idçâgﬂâg_thm2";

set_goal ([], ¨µs∑ rel (id s)Æ);
a (rewrite_tac [get_spec ¨relÆ, get_spec ¨idÆ]
	THEN REPEAT strip_tac);
a (fc_tac [∏âg_spec]);
a (∂_tac ¨lÆ THEN ∂_tac ¨rÆ
	THEN asm_rewrite_tac[]);
val rel_id_lem = pop_thm();

set_goal([], ¨µs∑ rel(id s) ± fun (id s) ± dom(id s) = s ± ran(id s) = sÆ);
a (rewrite_tac [rel_id_lem] THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a (rewrite_tac [fun_def, rel_id_lem, get_spec ¨idÆ]
	THEN REPEAT strip_tac
	THEN all_var_elim_asm_tac
	THEN strip_tac);
(* *** Goal "2" *** *)
a (rewrite_tac[get_spec ¨domÆ]);
a (once_rewrite_tac [gst_relext_clauses]);
a (rewrite_tac[get_spec ¨idÆ] THEN REPEAT strip_tac);
(* *** Goal "2.1" *** *)
a (LEMMA_T ¨e Ìâg e çâg (Sep (s ∏âg s) (Ã x∑ fst x = snd x))Æ asm_tac
	THEN1 (rewrite_tac[] THEN strip_tac));
a (fc_tac [Gx_trans_thm2]);
a (LEMMA_T ¨Pairâg e e çâg Gx (e Ìâg e)Æ asm_tac THEN1 rewrite_tac []);
a (lemma_tac ¨galaxy (Gx (Sep (s ∏âg s) (Ã x∑ fst x = snd x)))Æ THEN1 rewrite_tac [galaxy_Gx]);
a (all_fc_tac [get_spec ¨GxÆ]);
a (LEMMA_T ¨e çâg Pairâg e eÆ asm_tac THEN1 prove_tac[]);
a (all_fc_tac [Gx_trans_thm3]);
(* *** Goal "2.2" *** *)
a (∂_tac ¨eÆ THEN asm_rewrite_tac[]);
(* *** Goal "3" *** *)
a (rewrite_tac[get_spec ¨ranÆ]);
a (once_rewrite_tac [gst_relext_clauses]);
a (rewrite_tac[get_spec ¨idÆ] THEN REPEAT strip_tac);
(* *** Goal "3.1" *** *)
a (LEMMA_T ¨e Ìâg e çâg (Sep (s ∏âg s) (Ã x∑ fst x = snd x))Æ asm_tac
	THEN1 (rewrite_tac[] THEN strip_tac));
a (fc_tac [Gx_trans_thm2]);
a (LEMMA_T ¨Pairâg e e çâg Gx (e Ìâg e)Æ asm_tac THEN1 rewrite_tac []);
a (lemma_tac ¨galaxy (Gx (Sep (s ∏âg s) (Ã x∑ fst x = snd x)))Æ THEN1 rewrite_tac [galaxy_Gx]);
a (all_fc_tac [get_spec ¨GxÆ]);
a (LEMMA_T ¨e çâg Pairâg e eÆ asm_tac THEN1 prove_tac[]);
a (all_fc_tac [Gx_trans_thm3]);
(* *** Goal "3.2" *** *)
a (∂_tac ¨eÆ THEN asm_rewrite_tac[]);
val id_clauses = save_pop_thm "id_clauses";

add_pc_thms "'gst-fun" ([id_clauses]);
set_merge_pcs ["basic_hol", "'gst-ax", "'gst-fun"];
=TEX
}%ignore

\subsection{Override}

Override is an operator over sets which is intended primarily for use with functions.
It may be used to change the value of the function over any part of its domain by overriding it with a function which is defined only for those values.

=SML
declare_infix (250,"´âg");
=TEX

πHOLCONST
‹ $€´âg› : GS ≠ GS ≠ GS
˜¸¸¸¸¸¸¸¸¸¸¸¸¸
‹ µs t∑ s ´âg t = Sep (s ¿âg t)
‹	Ãx∑ if fst x çâg dom t then x çâg t else x çâg s 
∞

=GFT
€çâg´âg_thm› =
   Ù µ s t x∑ x çâg s ´âg t = (if fst x çâg dom t then x çâg t else x çâg s)

€Ìâgçâg´âg_thm› =
   Ù µ s t x y
     ∑ x Ìâg y çâg s ´âg t = (x Ìâg y çâg t ≤ ≥ x çâg dom t ± x Ìâg y çâg s)

€´âg_rel_thm› =
   Ù µ s t∑ rel s ± rel t ¥ rel (s ´âg t)

€´âg_fun_thm› =
   Ù µ s t∑ fun s ± fun t ¥ fun (s ´âg t)
=TEX

\ignore{
=SML
set_goal ([], ¨µs t x∑ x çâg (s ´âg t) §
	   if fst x çâg dom t then x çâg t else x çâg sÆ);
a (rewrite_tac [get_spec ¨$´âgÆ]
	THEN REPEAT strip_tac);
val çâg´âg_thm = save_pop_thm "çâg´âg_thm";

set_goal ([], ¨µs t x y∑ x Ìâg y çâg (s ´âg t) §
	   x Ìâg y çâg t
	≤ ≥ (x çâg dom t)
	   ± x Ìâg y çâg s
Æ);
a (rewrite_tac [get_spec ¨$´âgÆ] THEN REPEAT strip_tac);
a (POP_ASM_T ante_tac THEN rewrite_tac [dom_thm]
	THEN REPEAT strip_tac);
a (asm_fc_tac[]);
val Ìâgçâg´âg_thm = save_pop_thm "Ìâgçâg´âg_thm";

set_goal([], ¨µs t∑ rel s ± rel t ¥ rel (s ´âg t)Æ);
a (rewrite_tac [get_spec ¨relÆ, çâg´âg_thm]
	THEN REPEAT strip_tac
	THEN all_asm_fc_tac[]
	THEN ∂_tac ¨s'Æ THEN ∂_tac ¨t'Æ THEN strip_tac);
val ´âg_rel_thm = save_pop_thm "´âg_rel_thm";

set_goal([], ¨µs t∑ fun s ± fun t ¥ fun (s ´âg t)Æ);
a (rewrite_tac [get_spec ¨funÆ]
	THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a (all_fc_tac[´âg_rel_thm]);
(* *** Goal "2" *** *)
a (REPEAT_N 2 (POP_ASM_T ante_tac)
	THEN rewrite_tac [Ìâgçâg´âg_thm, dom_thm]
	THEN REPEAT strip_tac
	THEN all_asm_fc_tac[]);
val ´âg_fun_thm = save_pop_thm "´âg_fun_thm";
=TEX
}%ignore

\subsection{Proof Contexts}

Finalisation of a proof context.

\subsubsection{Proof Context}

=SML
add_pc_thms "'gst-fun" ([
	field_öâg_thm,
	fun_öâg_thm,
	öâgçâgﬂâg_thm]);
set_merge_pcs ["basic_hol", "'gst-ax", "'gst-fun"];
commit_pc "'gst-fun";
=TEX

\section{Ordinals}

A new "gst-ord" theory is created as a child of "gst-ax".
The theory will contain the definitions of ordinals and related material for general use, roughly following "Set Theory" by Frank Drake, chapter 2 section 2.
The subsections in this document correspondend to the subsections in the book.

\subsubsection{Motivation}

This is really motivated purely by interest and self-education.
Since its so fundamental I think it likely to turn out handy.
Some of the material required is not specific to set theory and is quite widely applicable (in which case I actually develop it elsewhere and then just use it here.
Well-foundedness and induction over well-founded relations is the obvious case relevant to this part of Drake.
The recursion theorem is the important more general result which appears in the next section in Drake.
"more general" means "can be developed as a polymorphic theory in HOL and applied outside the context of set theory".
In fact these things have to be developed in the more general context to be used in the ways they are required in the development of set theory, since, for example, one wants to do definitions by recursion over the set membership relation where neither the function defined nor the relevant well-founded relation are actually sets.

\subsubsection{Divergence}

I have not followed Drake slavishly.
More or less, I follow him where it works out OK and looks reasonable and doesn't trigger any of my prejudices.

Sometimes the context in which I am doing the work makes some divergence desirable or necessary.
For example, I am doing the work in the context of a slightly eccentric set theory ("Galactic Set Theory") which mainly makes no difference, but has a non-standard formulation of the axiom of foundation.
Mainly this is covered by deriving the standard formulation and its consequences and using them where this is used by Drake (in proving the trichotomy theorem).
However, the machinery for dealing with well-foundedness makes a difference to how induction principles are best formulated and derived.

Sometimes I look at what he has done and I think, "no way am I going to do that".
Not necessarily big things, for example, I couldn't use his definition of successor ordinal which he pretty much admits himself is what we nerds call a kludge.

\subsubsection{The Theory ord}

The new theory is first created, together with a proof context which we will build up as we develop the theory.

=SML
open_theory "gst-ax";
force_new_theory "gst-ord";
(* new_parent "wf_recp"; *)
force_new_pc "'gst-ord";
merge_pcs ["'savedthm_cs_∂_proof"] "'gst-ord";
set_merge_pcs ["basic_hol", "'gst-ax", "'gst-ord"];
=TEX

\subsection{Definitions 2.1 and 2.3}

An ordinal is defined as a transitive and connected set.
The usual ordering over the ordinals is defined and also the successor function.

\subsubsection{The Definition}

The concept of transitive set has already been defined in theory {\it gst-ax}.
The concepts {\it connected} and {\it ordinal} are now defined.

πHOLCONST
 €connected› : GS ≠ BOOL
˜
  µs :GS∑ connected s §
	µt u :GS∑ t çâg s ± u çâg s ¥ t çâg u ≤ t = u ≤ u çâg t
∞

πHOLCONST
 €ordinal› : GS ≠ BOOL
˜
  µs :GS∑ ordinal s § transitive s ± connected s
∞

We now introduce infix ordering relations over ordinals.

=SML
declare_infix(240,"<âo");
declare_infix(240,"ºâo");

πHOLCONST
 $€<âo› : GS ≠ GS ≠ BOOL
˜
  µx y:GS∑ x <âo y § ordinal x ± ordinal y ± x çâg y
∞

=GFT
€less_mem_thm› =
	Ù µ ¡ ¬∑ ¡ <âo ¬ ¥ ordinal ¡ ± ordinal ¬ ± ¡ çâg ¬

€mem_less_thm› =
	Ù µ ¡ ¬∑ ordinal ¡ ± ordinal ¬ ± ¡ çâg ¬ ¥ ¡ <âo ¬

€ord_mem_psub_thm› =
	Ù µ ¡∑ ordinal ¡ ¥ (µ ¬∑ ¬ çâg ¡ ¥ ¬ †âg ¡)

€lto_psub_thm› =
	Ù µ ¡ ¬∑ ¡ <âo ¬ ¥ ¡ †âg ¬

€lo_trans_thm› =
	Ù µ ¡ ¬ «∑ ¡ <âo ¬ ± ¬ <âo « ¥ ¡ <âo «
=TEX

\ignore{
=SML
set_goal([], ¨µ¡ ¬∑ ordinal ¡ ± ordinal ¬ ± ¡ çâg ¬ ¥ ¡ <âo ¬Æ);
a (REPEAT strip_tac THEN asm_rewrite_tac [get_spec ¨$<âoÆ]);
val mem_less_thm = save_pop_thm "mem_less_thm";

set_goal([], ¨µ¡ ¬∑ ¡ <âo ¬ ¥ ordinal ¡ ± ordinal ¬ ± ¡ çâg ¬Æ);
a (rewrite_tac [get_spec ¨$<âoÆ]
	THEN REPEAT strip_tac
	THEN asm_rewrite_tac []);
val less_mem_thm = save_pop_thm "less_mem_thm";

set_goal([], ¨µ¡∑ ordinal ¡ ¥ µ¬∑ ¬ çâg ¡ ¥ ¬ †âg ¡Æ);
a (REPEAT strip_tac
	THEN fc_tac [get_spec ¨ordinalÆ]
	THEN fc_tac [get_spec ¨transitiveÆ]);
a (rewrite_tac [get_spec ¨$†âgÆ]);
a (asm_fc_tac []
	THEN asm_rewrite_tac [get_spec ¨$ÄâgÆ]
	THEN REPEAT strip_tac);
a (∂_tac ¨¬Æ THEN asm_rewrite_tac[wf_l1]);
val ord_mem_psub_thm = save_pop_thm "ord_mem_psub_thm";

set_goal([], ¨µ¡ ¬∑ ¡ <âo ¬ ¥ ¡ †âg ¬Æ);
a (REPEAT strip_tac THEN fc_tac [less_mem_thm]);
a (fc_tac [µ_elim ¨¬Æ ord_mem_psub_thm]);
a (asm_fc_tac[]);
val lto_psub_thm = save_pop_thm "lto_psub_thm";

set_goal([], ¨µ¡ ¬ «∑ ¡ <âo ¬ ± ¬ <âo  « ¥ ¡ <âo «Æ);
a (rewrite_tac [get_spec ¨$<âoÆ] THEN REPEAT strip_tac);
a (lemma_tac ¨transitive «Æ THEN1 fc_tac [get_spec ¨ordinalÆ]);
a (all_fc_tac [get_spec ¨transitiveÆ]);
a (all_fc_tac [get_spec ¨$ÄâgÆ]);
val lo_trans_thm = save_pop_thm "lo_trans_thm";

=TEX
}%ignore


πHOLCONST
 $€ºâo› : GS ≠ GS ≠ BOOL
˜
  µx y:GS∑ x ºâo y § ordinal x ± ordinal y ± (x çâg y ≤ x = y)
∞

=GFT
€leo_lo_thm› =
	Ù µ x y∑ x ºâo y § ordinal x ± ordinal y ± (x <âo y ≤ x = y)

€leo_sub_thm› =
	Ù µ ¡ ¬∑ ¡ ºâo ¬ ¥ ¡ Äâg ¬

€leo_trans_thm› =
	Ù µ ¡ ¬ «∑ ¡ ºâo ¬ ± ¬ ºâo « ¥ ¡ ºâo «

€leo_lo_trans_thm› =
	Ù µ ¡ ¬ «∑ ¡ ºâo ¬ ± ¬ <âo « ¥ ¡ <âo «

€lo_leo_trans_thm› =
	Ù µ ¡ ¬ «∑ ¡ <âo ¬ ± ¬ ºâo « ¥ ¡ <âo «
=TEX

\ignore{
=SML
set_goal([], ¨µx y:GS∑ x ºâo y § ordinal x ± ordinal y ± (x <âo y ≤ x = y)Æ);
a (rewrite_tac [get_spec ¨$ºâoÆ, get_spec ¨$<âoÆ]);
a (REPEAT strip_tac);
val leo_lo_thm = save_pop_thm "leo_lo_thm";

set_goal([], ¨µ¡ ¬∑ ¡ ºâo ¬ ¥ ¡ Äâg ¬Æ);
a (REPEAT strip_tac);
a (fc_tac [leo_lo_thm]);
(* *** Goal "1" *** *)
a (fc_tac[lto_psub_thm]);
a (fc_tac[get_spec ¨$†âgÆ]);
(* *** Goal "2" *** *)
a (asm_rewrite_tac []);
val leo_sub_thm = save_pop_thm "leo_sub_thm";

set_goal([], ¨µ¡ ¬ «∑ ¡ ºâo ¬ ± ¬ ºâo « ¥ ¡ ºâo «Æ);
a (rewrite_tac [get_spec ¨$ºâoÆ]
	THEN REPEAT strip_tac
	THEN_TRY all_var_elim_asm_tac
	THEN_TRY rewrite_tac[]);
a (lemma_tac ¨transitive «Æ THEN1 fc_tac [get_spec ¨ordinalÆ]);
a (all_fc_tac [get_spec ¨transitiveÆ]);
a (all_fc_tac [get_spec ¨$ÄâgÆ]);
val leo_trans_thm = save_pop_thm "leo_trans_thm";

set_goal([], ¨µ¡ ¬ «∑ ¡ ºâo ¬ ± ¬ <âo « ¥ ¡ <âo «Æ);
a (rewrite_tac [get_spec ¨$ºâoÆ] THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a (all_fc_tac [mem_less_thm]);
a (all_fc_tac [lo_trans_thm]);
(* *** Goal "2" *** *)
a (asm_rewrite_tac[]);
val leo_lo_trans_thm = save_pop_thm "leo_lo_trans_thm";

set_goal([], ¨µ¡ ¬ «∑ ¡ <âo ¬ ± ¬ ºâo « ¥ ¡ <âo «Æ);
a (rewrite_tac [get_spec ¨$ºâoÆ] THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a (strip_asm_tac (list_µ_elim [¨¬Æ, ¨«Æ] mem_less_thm));
a (all_fc_tac [lo_trans_thm]);
(* *** Goal "2" *** *)
a (all_var_elim_asm_tac);
val lo_leo_trans_thm = save_pop_thm "lo_leo_trans_thm";
=TEX
}%ignore

The following definition gives the successor function over the ordinals (this appears later in Drake).

πHOLCONST
 €sucâo› : GS ≠ GS
˜
  µx:GS∑ sucâo x = x ¿âg (Sing x)
∞

\ignore{
=IGN
add_pc_thms "'gst-ord" [get_spec ¨connectedÆ, get_spec ¨ordinalÆ];
set_merge_pcs ["basic_hol", "'gst-ax", "'gst-ord"];
=TEX
}%ignore

\subsection{Theorem 2.2}

We prove that the empty set is an ordinal, and that the members of an ordinal and the successor of an ordinal are ordinals.

\subsubsection{The Empty Set is an Ordinal}

First we prove that the empty set is an ordinal, which requires only rewriting with the relevant definitions.

\ignore{
=SML
set_goal([],¨	ordinal öâg	Æ);
a (rewrite_tac[get_spec ¨ordinalÆ, get_spec ¨transitiveÆ, get_spec ¨connectedÆ]);
val ordinal_öâg = save_pop_thm "ordinal_öâg";
=TEX
}

\subsubsection{The Successor of an Ordinal is an Ordinal}

Next we prove that the successor of an ordinal is an ordinal.
This is done in two parts, transitivity and connectedness.

=SML
set_goal([], ¨	µ x:GS∑ transitive x ¥ transitive (sucâo x)	Æ);
=TEX

\ignore{
=SML
a (rewrite_tac[get_spec ¨transitiveÆ, get_spec ¨sucâoÆ]
	THEN REPEAT strip_tac
	THEN once_rewrite_tac [gst_relext_clauses]
	THEN asm_rewrite_tac[]
	THEN REPEAT strip_tac);
a (spec_nth_asm_tac 4 ¨eÆ);
a (POP_ASM_T ante_tac);
a (once_rewrite_tac [get_spec¨$ÄâgÆ]
	THEN strip_tac);
a (all_asm_fc_tac[]);
val trans_suc_trans = save_pop_thm "trans_suc_trans";
=TEX
}%ignore

=SML
set_goal([],¨µ x:GS∑
	connected x ¥ connected (sucâo x)
Æ);
=TEX

\ignore{
=SML
a (rewrite_tac[get_spec ¨connectedÆ, get_spec ¨sucâoÆ]);
a (REPEAT strip_tac
	THEN all_asm_fc_tac[]
	THEN all_var_elim_asm_tac);
val conn_suc_conn = save_pop_thm "conn_suc_conn";
=TEX
}%ignore

These together enable us to prove:

=SML
set_goal([], ¨µ x:GS∑ ordinal x ¥ ordinal (sucâo x)Æ);
=TEX

The proof expands using the definition of ordinal, strips the goal and reasons forward from the resulting assumptions using the two lemmas proved above.

=SML
a (rewrite_tac[get_spec ¨ordinalÆ]
	THEN REPEAT strip_tac
	THEN fc_tac [trans_suc_trans, conn_suc_conn]);
val ord_suc_ord_thm = save_pop_thm "ord_suc_ord_thm";
=TEX

\subsubsection{The Ordinal Zero is not a successor}

=GFT
€öâg_not_sucâo_thm› =
	Ù ≥ (∂ ¡∑ sucâo ¡ = öâg)

€not_in_suco_thm› =
	Ù µ ¡∑ ≥ ¡ = sucâo ¡

€leo_suc_thm› =
	Ù µ ¡∑ ordinal ¡ ¥ ¡ ºâo sucâo ¡

€lo_suc_thm› =
	Ù µ ¡∑ ordinal ¡ ¥ ¡ <âo sucâo ¡
=TEX

\ignore{
=SML
set_goal([], ¨≥ ∂¡∑ sucâo ¡ = öâgÆ);
a ( strip_tac THEN strip_tac);
a (rewrite_tac [get_spec ¨sucâoÆ]);
a (once_rewrite_tac [gs_ext_axiom]);
a (rewrite_tac [get_spec ¨$¿âgÆ]);
a (contr_tac);
a (spec_nth_asm_tac 1 ¨¡Æ);
val öâg_not_sucâo_thm = save_pop_thm "öâg_not_sucâo_thm";

set_goal ([], ¨µ¡∑ ≥ ¡ = sucâo ¡Æ);
a (strip_tac
	THEN rewrite_tac [get_spec ¨sucâoÆ]);
a (once_rewrite_tac [gs_ext_axiom]
	THEN REPEAT strip_tac);
a (∂_tac ¨¡Æ THEN rewrite_tac [wf_l1]);
val not_in_suco_thm = save_pop_thm "not_in_suco_thm";

set_goal ([], ¨µ¡∑ ordinal ¡ ¥ ¡ ºâo sucâo ¡Æ);
a (rewrite_tac [get_spec ¨$ºâoÆ]
	THEN REPEAT strip_tac);
a (fc_tac [ord_suc_ord_thm]);
a (POP_ASM_T ante_tac THEN rewrite_tac [get_spec ¨sucâoÆ]);
val leo_suc_thm = save_pop_thm "leo_suc_thm";

set_goal ([], ¨µ¡∑ ordinal ¡ ¥ ¡ <âo sucâo ¡Æ);
a (rewrite_tac [get_spec ¨$<âoÆ]
	THEN REPEAT strip_tac);
a (fc_tac [ord_suc_ord_thm]);
a (POP_ASM_T ante_tac THEN rewrite_tac [get_spec ¨sucâoÆ]);
val lo_suc_thm = save_pop_thm "lo_suc_thm";
=TEX
}%ignore

\subsubsection{The members of an Ordinal are Ordinals}

We now aim to prove that the members of an ordinal are ordinals.
We do this by proving first that they are connected and then that they are transitive.
First however, we show that any subset of a connected set is connected.
=SML
set_goal([],¨
	µ x:GS∑ connected x ¥ µ y:GS∑ y Äâg x ¥ connected y
Æ);
=TEX
The proof consists of expanding appropriate definitions, stripping the goal and then reasoning forward from the assumptions.
=SML
a (rewrite_tac (map get_spec [¨connectedÆ, ¨$ÄâgÆ])
	THEN REPEAT_N 7 strip_tac);
=GFT
(* *** Goal "" *** *)

(*  4 *)  ¨µ t u∑ t çâg x ± u çâg x ¥ t çâg u ≤ t = u ≤ u çâg tÆ
(*  3 *)  ¨µ e∑ e çâg y ¥ e çâg xÆ
(*  2 *)  ¨t çâg yÆ
(*  1 *)  ¨u çâg yÆ

(* ?Ù *)  ¨t çâg u ≤ t = u ≤ u çâg tÆ
=SML
a (all_asm_fc_tac[]);
a (REPEAT_N 2 (asm_fc_tac[]) THEN REPEAT strip_tac);
val conn_sub_conn = save_pop_thm "conn_sub_conn";
=TEX
Now we show that any member of an ordinal is an ordinal.
=SML
set_goal([],¨
	µ x:GS∑ ordinal x ¥ µ y:GS∑ y çâg x ¥ connected y
Æ);
=TEX
Expanding the definition of ordinal and making use of transitivity enables us to infer that members of an ordinals are subsets and permits application of the previous result to obtain connectedness.
=SML
a (rewrite_tac (map get_spec [¨ordinalÆ, ¨transitiveÆ])
	THEN REPEAT strip_tac);
a (all_asm_fc_tac []);
a (all_asm_fc_tac [conn_sub_conn]);
val conn_mem_ord = save_pop_thm "conn_mem_ord";
=TEX
To prove that the members of an ordinal are transitive, well-foundedness is needed.
Now we are ready to prove that the members of an ordinal are transitive.
=SML
set_goal([], ¨µ x:GS∑ ordinal x ¥ µ y:GS∑ y çâg x ¥ transitive yÆ);
=TEX
\ignore{
=SML
a (rewrite_tac (map get_spec [¨ordinalÆ, ¨transitiveÆ]));
a (REPEAT strip_tac);
a (rewrite_tac[get_spec ¨$ÄâgÆ]
	THEN REPEAT strip_tac);
a (REPEAT_N 4 (all_asm_fc_tac[çâgÄâg_thm]));
a (fc_tac[get_spec¨connectedÆ]);
a (lemma_tac ¨y çâg e' ≤ y = e' ≤ e' çâg yÆ);
(* *** Goal "1" *** *)
a (list_spec_nth_asm_tac 1 [¨e'Æ, ¨yÆ]
	THEN REPEAT strip_tac);
a( POP_ASM_T ante_tac THEN once_asm_rewrite_tac[]);
a (rewrite_tac[]);
(* *** Goal "2" *** *)
a (asm_tac wf_l3);
a (list_spec_nth_asm_tac 1 [¨eÆ, ¨yÆ, ¨e'Æ]);
(* *** Goal "3" *** *)
a (all_var_elim_asm_tac);
a (asm_tac wf_l2);
a (list_spec_nth_asm_tac 1 [¨eÆ, ¨e'Æ]);
val tran_mem_ord = save_pop_thm "tran_mem_ord";
=TEX
}%ignore

Finally we prove that all members of an ordinal are ordinals.
=SML
set_goal([], ¨µ x:GS∑ ordinal x ¥ µ y:GS∑ y çâg x ¥ ordinal yÆ);
=TEX

\ignore{
=SML
a (REPEAT strip_tac);
a (rewrite_tac [get_spec ¨ordinalÆ]);
a (all_fc_tac [tran_mem_ord, conn_mem_ord]);
a contr_tac;
val ord_mem_ord = save_pop_thm "ord_mem_ord";
=TEX
}%ignore

\subsubsection{Galaxies are Closed under suc}

=GFT
GCloseSuc = Ù µg∑ galaxy g ¥ µx∑ x çâg g ¥ sucâo x çâg g
=TEX

\ignore{
=SML
set_goal ([], ¨µg∑ galaxy g ¥ µx∑ x çâg g ¥ sucâo x çâg gÆ);
a (rewrite_tac [get_spec ¨sucâoÆ]);
a (REPEAT strip_tac);
a (REPEAT (all_fc_tac [GClose¿âg, GCloseSing]));
val GCloseSuc = save_pop_thm "GCloseSuc";
=TEX
}%ignore

\subsection{Theorem 2.4}

We prove that the ordinals are linearly ordered by $<âo$.

\subsubsection{}

First we prove some lemmas:
=SML
set_goal([], ¨µ x y:GS∑ transitive x ± transitive y ¥ transitive (x °âg y)Æ);
=TEX
\ignore{
=SML
a (rewrite_tac[get_spec ¨transitiveÆ]);
a (REPEAT strip_tac);
a (ALL_ASM_FC_T (MAP_EVERY ante_tac) []);
a (rewrite_tac [get_spec ¨$ÄâgÆ]
	THEN prove_tac[]);
val tran_°_thm = save_pop_thm "tran_°_thm";
=TEX
}%ignore
=SML
set_goal([], ¨µ x y:GS∑ transitive x ± transitive y ¥ transitive (x ¿âg y)Æ);
=TEX
\ignore{
=SML
a (rewrite_tac[get_spec ¨transitiveÆ]);
a (REPEAT strip_tac);
(* *** Goal "1" *** *)
a (ALL_ASM_FC_T (MAP_EVERY ante_tac) []);
a (rewrite_tac [get_spec ¨$ÄâgÆ]
	THEN prove_tac[]);
(* *** Goal "2" *** *)
a (ALL_ASM_FC_T (MAP_EVERY ante_tac) []);
a (rewrite_tac [get_spec ¨$ÄâgÆ]
	THEN prove_tac[]);
val tran_¿_thm = save_pop_thm "tran_¿_thm";
=TEX
}%ignore
=SML
set_goal([], ¨µ x y:GS∑ connected x ± connected y ¥ connected (x °âg y)Æ);
=TEX
\ignore{
=SML
a (rewrite_tac[get_spec ¨connectedÆ]);
a (REPEAT strip_tac);
a (list_spec_nth_asm_tac 8 [¨tÆ, ¨uÆ]);
val conn_°_thm = save_pop_thm "conn_°_thm";
=TEX
}%ignore
=SML
set_goal([], ¨µ x y:GS∑ ordinal x ± ordinal y ¥ ordinal (x °âg y)Æ);
=TEX
\ignore{
=SML
a (rewrite_tac[get_spec ¨ordinalÆ]);
a (REPEAT_N 3 strip_tac);
a (all_asm_fc_tac [tran_°_thm, conn_°_thm]
	THEN contr_tac);
val ord_°_thm = save_pop_thm "ord_°_thm";
=TEX
}%ignore
=SML
set_goal([], ¨µ x y:GS∑ ordinal x ± ordinal y ± x Äâg y ± ≥ x = y ¥ x çâg yÆ);
=TEX
\ignore{
=SML
a (REPEAT strip_tac);
a (lemma_tac ¨∂z∑ z = Sep y (Ãv∑ ≥ v çâg x)Æ
	THEN1 prove_∂_tac);
a (DROP_NTH_ASM_T 2 (fn x=> strip_asm_tac (rewrite_rule [gs_ext_axiom] x)));
(* *** Goal "1" *** *)
a (GET_NTH_ASM_T 4 (fn x=> all_asm_fc_tac [rewrite_rule [get_spec ¨$ÄâgÆ] x]));
(* *** Goal "2" *** *)
a (lemma_tac ¨e çâg zÆ THEN1 asm_rewrite_tac[]);
a (strip_asm_tac gs_wf_min_thm);
a (spec_nth_asm_tac 1 ¨zÆ);
(* *** Goal "2.1" *** *)
a (spec_nth_asm_tac 1 ¨eÆ);
(* *** Goal "2.2" *** *)
a (lemma_tac ¨z' çâg y ± ≥ z' çâg xÆ
	THEN1 (DROP_NTH_ASM_T 2 ante_tac
		THEN asm_rewrite_tac[]));
a (lemma_tac ¨z' = xÆ
	THEN (DROP_NTH_ASM_T 3 ante_tac
		THEN asm_rewrite_tac[gs_ext_axiom]
		THEN REPEAT strip_tac));
(* *** Goal "2.2.1" *** *)
a (lemma_tac ¨e' çâg  yÆ);
(* *** Goal "2.2.1.1" *** *)
a (lemma_tac ¨transitive yÆ
	THEN1 (all_asm_fc_tac [get_spec ¨ordinalÆ]));
a (LEMMA_T ¨z' Äâg yÆ ante_tac THEN1 (all_asm_fc_tac [get_spec ¨transitiveÆ]));
a (rewrite_tac [get_spec ¨$ÄâgÆ]
	THEN REPEAT strip_tac
	THEN all_asm_fc_tac[]);
(* *** Goal "2.2.1.2" *** *)
a (spec_nth_asm_tac 3 ¨e'Æ);
(* *** Goal "2.2.2" *** *)
a (lemma_tac ¨e' çâg yÆ
	THEN1 (GET_NTH_ASM_T 11 ante_tac
		THEN rewrite_tac [get_spec ¨$ÄâgÆ]
		THEN asm_prove_tac[]));
a (LEMMA_T ¨connected yÆ (fn x=> asm_tac(rewrite_rule [get_spec ¨connectedÆ] x)) 
	THEN1 (all_asm_fc_tac [get_spec ¨ordinalÆ]));
a (list_spec_nth_asm_tac 1 [¨e'Æ, ¨z'Æ]);
(* *** Goal "2.2.2.1" *** *)
a (swap_nth_asm_concl_tac 4 THEN asm_rewrite_tac[]);
(* *** Goal "2.2.2.2" *** *)
a (lemma_tac ¨transitive xÆ
	THEN1 (all_asm_fc_tac [get_spec ¨ordinalÆ]));
a (LEMMA_T ¨e' Äâg xÆ ante_tac THEN1 (all_asm_fc_tac [get_spec ¨transitiveÆ]));
a (rewrite_tac [get_spec ¨$ÄâgÆ]
	THEN REPEAT strip_tac
	THEN all_asm_fc_tac[]);
val trichot_lemma = pop_thm();
=TEX

=IGN
set_goal([], ¨µ x y:GS∑ ordinal x ± ordinal y ¥ ordinal (x ¿âg y)Æ);
a (REPEAT strip_tac);
a (strip_asm_tac (list_µ_elim [¨xÆ, ¨yÆ] trich_for_ords_thm));
(* *** Goal "1" *** *)
a 

a (spec_nth_asm_tac 1  

a (rewrite_tac[get_spec ¨ordinalÆ]);
a (REPEAT strip_tac);
(* *** Goal "1" *** *)
a (all_asm_fc_tac [tran_¿_thm]);
(* *** Goal "2" *** *)
a (all_asm_ante_tac);
a (rewrite_tac[get_spec ¨connectedÆ, get_spec ¨transitiveÆ]);
a (REPEAT_N 6 strip_tac);

val ord_¿_thm = save_pop_thm "ord_¿_thm";
=TEX
}%ignore

=GFT
€trich_for_ords_thm› =
	Ù µ x y∑ ordinal x ± ordinal y ¥ x <âo y ≤ x = y ≤ y <âo x

€sub_leo_thm› =
	Ù µ x y∑ ordinal x ± ordinal y ¥ (x Äâg y § x ºâo y)

€sub_leo_thm1› =
	Ù µ x y∑ ordinal x ± ordinal y ± x Äâg y ¥ x ºâo y
=TEX


\ignore{
=SML
set_goal([], ¨µ x y:GS∑ ordinal x ± ordinal y ¥ x <âo y ≤ x = y ≤ y <âo xÆ);
a (rewrite_tac[get_spec ¨$<âoÆ]);
a (REPEAT_N 3 strip_tac THEN asm_rewrite_tac[]);
a (lemma_tac ¨ordinal (x °âg y)Æ
	THEN1 (all_fc_tac [ord_°_thm]));
a (lemma_tac ¨x °âg y Äâg x ± x °âg y Äâg yÆ
	THEN1 (prove_tac[gst_relext_clauses, gst_opext_clauses]));
a (lemma_tac ¨x °âg y = x ≤ x °âg y = yÆ
	THEN1 contr_tac);
(* *** Goal "1" *** *)
a (strip_asm_tac trichot_lemma);
a (all_asm_fc_tac []);
(*
a (list_spec_nth_asm_tac 2 [¨x °âg yÆ, ¨xÆ]);
*)
a (strip_asm_tac wf_l1);
a (spec_nth_asm_tac 1 ¨x °âg yÆ);
a (swap_nth_asm_concl_tac 1);
a (asm_rewrite_tac [gst_relext_clauses, gst_opext_clauses]);
(* *** Goal "2" *** *)
a (lemma_tac ¨x Äâg yÆ
	THEN1 (POP_ASM_T ante_tac
		THEN prove_tac [gst_relext_clauses, gst_opext_clauses]));
a (strip_asm_tac (list_µ_elim [¨xÆ, ¨yÆ] trichot_lemma)
	THEN contr_tac);
a (asm_fc_tac []);
(* *** Goal "3" *** *)
a (lemma_tac ¨y Äâg xÆ
	THEN1 (POP_ASM_T ante_tac
		THEN prove_tac [gst_relext_clauses, gst_opext_clauses]));
a (strip_asm_tac (list_µ_elim [¨yÆ, ¨xÆ] trichot_lemma)
	THEN asm_rewrite_tac[]);
val trich_for_ords_thm = save_pop_thm "trich_for_ords_thm";

set_goal([], ¨µx y:GS∑ ordinal x ± ordinal y ¥ (x Äâg y § x ºâo y)Æ);
a (REPEAT strip_tac);
(* *** Goal "1" *** *)
a (asm_rewrite_tac [leo_lo_thm]);
a contr_tac;
a (all_fc_tac [trich_for_ords_thm]);
a (fc_tac [lto_psub_thm]);
a (POP_ASM_T ante_tac THEN DROP_NTH_ASM_T 4 ante_tac);
a (rewrite_tac [gst_relext_clauses, get_spec ¨$†âgÆ]
	THEN prove_tac[]);
(* *** Goal "2" *** *)
a (fc_tac [leo_sub_thm]);
val sub_leo_thm = save_pop_thm "sub_leo_thm";

=IGN
set_goal([], ¨µx y:GS∑ ordinal x ± ordinal y ¥ (x †âg y § x <âo y)Æ);
a (REPEAT strip_tac);
(* *** Goal "1" *** *)
a contr_tac;
a (all_fc_tac [trich_for_ords_thm]);
a (fc_tac [leo_sub_thm]);
a (POP_ASM_T ante_tac THEN DROP_NTH_ASM_T 4 ante_tac);
a (rewrite_tac [gst_relext_clauses, get_spec ¨$†âgÆ]
	THEN prove_tac[]);
(* *** Goal "2" *** *)
a (fc_tac [leo_sub_thm]);
val sub_leo_thm = save_pop_thm "sub_leo_thm";

=SML
set_goal([], ¨µx y:GS∑ ordinal x ± ordinal y ± x Äâg y ¥ x ºâo yÆ);
a (REPEAT strip_tac);
a (fc_tac [sub_leo_thm]);
a (asm_fc_tac[]);
val sub_leo_thm1 = save_pop_thm "sub_leo_thm1";

=IGN
set_goal([], ¨µx y:GS∑ ordinal x ± ordinal y ± x †âg y ¥ x <âo yÆ);
a (REPEAT strip_tac);
a (fc_tac [psub_lo_thm]);
a (asm_fc_tac[]);
val sub_leo_thm1 = save_pop_thm "sub_leo_thm1";

=TEX
}%ignore

\subsection{Definition 2.6}

Successor and limit ordinals are defined.
Natural numbers are defined.

\subsubsection{}

These definitions are not the ones used by Drake, and not only the names but the concepts differ.
My successor predicate does not hold of the empty set.
I use the name "natural number" where he talks of integers, and generally I'm chosing longer names.

πHOLCONST
 €successor› : GS ≠ BOOL
˜
  µs :GS∑ successor s § ∂t∑ ordinal t ± s = sucâo t
∞

πHOLCONST
 €limit_ordinal› : GS ≠ BOOL
˜
  µs :GS∑ limit_ordinal s § ordinal s ± ≥ successor s ± ≥ s = öâg
∞

\subsection{Theorem 2.7}

Induction theorems over ordinals.

\subsubsection{Successors are Ordinals}

=SML
set_goal([],¨	µ x:GS∑ successor x ¥ ordinal x	Æ);
a (rewrite_tac[get_spec ¨successorÆ]
	THEN REPEAT strip_tac
	THEN fc_tac [ord_suc_ord_thm]
	THEN asm_rewrite_tac[]);
val successor_ord_thm = save_pop_thm "successor_ord_thm";
=TEX

\subsubsection{Well-foundedness of the ordinals}

First we prove that $<âo$ is well-founded.

=GFT
=TEX

\ignore{
=SML
set_goal([],¨well_founded $<âoÆ);
a (asm_tac gs_wf_thm1);
a (fc_tac [wf_restrict_wf_thm]);
a (SPEC_NTH_ASM_T 1 ¨Ãx y∑ ordinal x ± ordinal yÆ ante_tac
	THEN rewrite_tac[]);
a (lemma_tac ¨$<âo = (Ã x y∑ (ordinal x ± ordinal y) ± x çâg y)Æ);
(* *** Goal "1" *** *)
a (once_rewrite_tac [ext_thm]);
a (once_rewrite_tac [ext_thm]);
a (prove_tac[get_spec ¨$<âoÆ]);
(* *** Goal "2" *** *)
a (asm_rewrite_tac[]);
val wf_ordinals_thm = save_pop_thm "wf_ordinals_thm";

set_goal([],¨UWellFounded $<âoÆ);
a (rewrite_tac [UWellFounded_well_founded_thm, wf_ordinals_thm]);
val UWellFounded_ordinals_thm = pop_thm ();
=TEX
}%ignore

\subsubsection{An Ordinal is Zero, a successor or a limit}

=GFT
€ordinal_kind_thm› =
	µn∑ ordinal n ¥ n = öâg ≤ successor n  ≤ limit_ordinal n
=TEX

\ignore{
=SML
set_goal ([], ¨µn∑ ordinal n ¥ n = öâg ≤ successor n  ≤ limit_ordinal nÆ);
a (rewrite_tac [get_spec ¨limit_ordinalÆ, get_spec ¨successorÆ]);
a (REPEAT strip_tac);
a (spec_nth_asm_tac 2 ¨tÆ);
val ordinal_kind_thm = save_pop_thm "ordinal_kind_thm";
=TEX
}%ignore

\subsection{Supremum and Strict Supremum}

The supremum of a set of ordinals is the smallest ordinal greater than or equal to every ordinal in the set.
With the Von Neumann representation of ordinals this is just the union of the set of ordinals.

=SML
declare_infix (200, "ub");
declare_infix (200, "sub");
=TEX

πHOLCONST
 $€ub› : GS ≠ GS ≠ BOOL
˜
  µ¡ ¬∑ ¡ ub ¬ § µ«∑ « çâg ¡ ¥ « ºâo ¬
∞

πHOLCONST
 €sup› : GS ≠ GS
˜
  µ¡∑ sup ¡ = ﬁâg ¡
∞

=GFT
€ordinal_limit_thm› =
	Ù µ ¡∑ (µ ¬∑ ¬ çâg ¡ ¥ ordinal ¬) ¥ ordinal (ﬁâg ¡)

€sup_lub_thm› =
	Ù µ ¡ ∑	(µ ¬∑ ¬ çâg ¡ ¥ ordinal ¬)
		¥ ¡ ub sup ¡
		± (µ «∑ ordinal « ± ¡ ub « ¥ sup ¡ ºâo «)
=TEX

\ignore{
=SML
set_goal ([], ¨µ¡∑ (µ¬∑ ¬ çâg ¡ ¥ ordinal ¬) ¥ ordinal (ﬁâg ¡)Æ);
a (REPEAT strip_tac);
a (rewrite_tac [get_spec ¨ordinalÆ, get_spec ¨transitiveÆ] THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a (rewrite_tac [gst_relext_clauses] THEN REPEAT strip_tac);
a (spec_nth_asm_tac 4 ¨e'Æ);
a (fc_tac [get_spec ¨ordinalÆ]);
a (fc_tac [get_spec ¨transitiveÆ]);
a (∂_tac ¨e'Æ THEN asm_rewrite_tac[]);
a (SPEC_NTH_ASM_T 1 ¨eÆ (ante_tac o (rewrite_rule [gst_relext_clauses])));
a (asm_rewrite_tac [] THEN REPEAT strip_tac);
a (asm_fc_tac[]);
(* *** Goal "2" *** *)
a (rewrite_tac [get_spec ¨connectedÆ] THEN REPEAT strip_tac);
a (spec_nth_asm_tac 7 ¨eÆ);
a (spec_nth_asm_tac 8 ¨e'Æ);
a (strip_asm_tac (list_µ_elim [¨eÆ, ¨e'Æ] trich_for_ords_thm));
(* *** Goal "2.1" *** *)
a (fc_tac [get_spec ¨$<âoÆ]);
a (lemma_tac ¨e Äâg e'Æ
	THEN1 (fc_tac [get_spec ¨ordinalÆ]
	     THEN fc_tac [get_spec ¨transitiveÆ]
		THEN asm_fc_tac[]));
a (lemma_tac ¨t çâg e'Æ
	THEN1 (POP_ASM_T (asm_tac o (rewrite_rule [get_spec ¨$ÄâgÆ]))
		THEN asm_fc_tac []));
a (lemma_tac ¨connected e'Æ THEN1 fc_tac [get_spec ¨ordinalÆ]);
a (fc_tac [get_spec¨connectedÆ]
	THEN all_asm_fc_tac[]);
(* *** Goal "2.2" *** *)
a (all_var_elim_asm_tac);
a (lemma_tac ¨connected e'Æ THEN1 fc_tac [get_spec ¨ordinalÆ]);
a (fc_tac [get_spec¨connectedÆ]
	THEN all_asm_fc_tac[]);
(* *** Goal "2.3" *** *)
a (fc_tac [get_spec ¨$<âoÆ]);
a (lemma_tac ¨e' Äâg eÆ
	THEN1 (fc_tac [get_spec ¨ordinalÆ]));
a (REPEAT_N 2 (POP_ASM_T discard_tac));
a (POP_ASM_T ante_tac THEN rewrite_tac [get_spec ¨transitiveÆ] THEN strip_tac);
a (asm_fc_tac[]);
a (lemma_tac ¨u çâg eÆ
	THEN1 (POP_ASM_T (asm_tac o (rewrite_rule [get_spec ¨$ÄâgÆ]))
		THEN asm_fc_tac []));
a (lemma_tac ¨connected eÆ THEN1 fc_tac [get_spec ¨ordinalÆ]);
a (fc_tac [get_spec¨connectedÆ]
	THEN all_asm_fc_tac[]);
val ordinal_limit_thm = save_pop_thm "ordinal_limit_thm";

set_goal([], ¨µ¡∑ (µ¬∑ ¬ çâg ¡ ¥ ordinal ¬)
	¥ ¡ ub (sup ¡) ± µ«∑ ordinal « ± ¡ ub « ¥ (sup ¡) ºâo «Æ);
a (rewrite_tac [get_spec ¨$ubÆ, get_spec ¨$supÆ] THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a (fc_tac [ordinal_limit_thm]);
a (asm_fc_tac[]);
a (LEMMA_T ¨« Äâg ﬁâg ¡ ¥ « ºâo ﬁâg ¡Æ (fn x => bc_tac [x]));
(* *** Goal "1.1" *** *)
a (strip_tac);
a (all_fc_tac [sub_leo_thm1]);
(* *** Goal "1.2" *** *)
a (rewrite_tac[gst_relext_clauses]);
a (REPEAT strip_tac);
a (∂_tac ¨«Æ THEN asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a (all_fc_tac [ordinal_limit_thm]);
a (bc_tac [sub_leo_thm1]
	THEN_TRY asm_rewrite_tac[gst_relext_clauses]);
a (REPEAT strip_tac);
a (asm_fc_tac[]);
a (fc_tac [leo_sub_thm]);
a (POP_ASM_T ante_tac
	THEN rewrite_tac [gst_relext_clauses]
	THEN REPEAT strip_tac
	THEN asm_fc_tac[]);
val sup_lub_thm = save_pop_thm "sup_lub_thm"; 
=TEX
}%ignore

The operand here is intended to be an arbitrary set of ordinals and the result is the smallest ordinal strictly greater than any in the set.

πHOLCONST
 $€sub› : GS ≠ GS ≠ BOOL
˜
  µ¡ ¬∑ ¡ sub ¬ § µ«∑ « çâg ¡ ¥ « <âo ¬
∞

πHOLCONST
 €ssup› : GS ≠ GS
˜
  µ¡∑ ssup ¡ = ﬁâg(Imagep sucâo ¡)
∞

=GFT
€ordinal_ssup_thm› =
	Ù µ ¡∑ (µ ¬∑ ¬ çâg ¡ ¥ ordinal ¬) ¥ ordinal (ssup ¡)
=TEX

\ignore{
=SML
set_goal ([], ¨µ¡∑ (µ¬∑ ¬ çâg ¡ ¥ ordinal ¬) ¥ ordinal (ssup ¡)Æ);
a (REPEAT strip_tac);
a (rewrite_tac [(*get_spec ¨ordinalÆ, get_spec ¨transitiveÆ, *)get_spec ¨ssupÆ] THEN REPEAT strip_tac);
a (lemma_tac ¨µ¬∑ ¬ çâg Imagep sucâo ¡ ¥ ordinal ¬Æ);
(* *** Goal "1" *** *)
a (rewrite_tac[]);
a (REPEAT strip_tac);
a (asm_fc_tac []);
a (fc_tac [ord_suc_ord_thm]);
a (once_asm_rewrite_tac[]);
a strip_tac;
(* *** Goal "2" *** *)
a (fc_tac [ordinal_limit_thm]);
val ordinal_ssup_thm = save_pop_thm "ordinal_ssup_thm";

=IGN
stop;
set_goal([], ¨µ¡∑ (µ¬∑ ¬ çâg ¡ ¥ ordinal ¬)
	¥ ¡ sub (ssup ¡) ± µ«∑ ordinal « ± ¡ sub « ¥ (sup ¡) ºâo «Æ);
a (rewrite_tac (map get_spec [¨$subÆ])
	THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a (asm_fc_tac[]);
a (fc_tac[ordinal_ssup_thm]);
a (fc_tac[]);


=TEX
}%ignore

\subsection{Rank}

We define the rank of a set.

\subsubsection{The Consistency Proof}

Before introducing the definition of rank we undertake the proof necessary to establish that the definition is conservative.
The key lemma in this proof is the proof that the relevant functional "respects" the membership relation.

=GFT
€respect_lemma› =
	Ù (Ã f x∑ ﬁâg (Imagep (sucâo o f) x)) respects $çâg
=TEX

\ignore{
=SML
set_goal([],¨(Ãf∑ Ãx∑ ﬁâg (Imagep (sucâo o f) x)) respects $çâgÆ);
a (rewrite_tac [get_spec ¨$respectsÆ]
	THEN REPEAT strip_tac);
a (once_rewrite_tac [gst_relext_clauses]
	THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a (∂_tac ¨e'Æ THEN REPEAT strip_tac);
a (∂_tac ¨e''Æ THEN REPEAT strip_tac);
a (POP_ASM_T ante_tac
	THEN rewrite_tac[get_spec¨$o:(('a≠'c)≠(('b≠'a)≠('b≠'c)))Æ]
	THEN strip_tac);
a (lemma_tac ¨h e'' = g e''Æ
	THEN1 (REPEAT_N 2 (asm_fc_tac[tc_incr_thm])
		THEN asm_rewrite_tac[]));
a (asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a (∂_tac ¨e'Æ THEN REPEAT strip_tac);
a (∂_tac ¨e''Æ THEN REPEAT strip_tac);
a (POP_ASM_T ante_tac
	THEN rewrite_tac[get_spec¨$o:(('a≠'c)≠(('b≠'a)≠('b≠'c)))Æ]
	THEN strip_tac);
a (lemma_tac ¨h e'' = g e''Æ
	THEN1 (REPEAT_N 2 (asm_fc_tac[tc_incr_thm])
		THEN asm_rewrite_tac[]));
a (asm_rewrite_tac[]);
val respect_lemma = pop_thm();
=TEX
}%ignore

Armed with that lemma we can now prove that the function which we will call "rank" exists.

\ignore{
=SML
set_goal([],¨∂rank∑ µx∑ rank x = ﬁâg (Imagep (sucâo o rank) x)Æ);
a (∂_tac ¨fix (Ãf∑ Ãx∑ ﬁâg (Imagep (sucâo o f) x))Æ
	THEN strip_tac);
a (asm_tac gs_wf_thm1);
a (asm_tac respect_lemma);
a (fc_tac [µ_elim ¨Ãf∑ Ãx∑ ﬁâg (Imagep (sucâo o f) x)Æ (get_spec ¨fixÆ)]);
a (asm_fc_tac []);
a (POP_ASM_T (rewrite_thm_tac o rewrite_rule [ext_thm]));
val _ = save_cs_∂_thm (pop_thm());
=TEX
}%ignore

πHOLCONST
 €rank› : GS ≠ GS
˜
  µx∑ rank x = ﬁâg (Imagep (sucâo o rank) x)
∞

\subsection{Ordinal Arithmetic}

\subsubsection{Addition}

The following lemma is used to demonstrate well-foundedness of the definition of ordinal addition:

=GFT
€plusâo_respect_lemma› =
   Ù µ x∑ (Ã x_+ y∑ if y = öâg then x else ssup (Imagep x_+ y)) respects $çâg
=TEX

\ignore{
=IGN
set_goal([],¨µx∑ (Ãx_+:GS ≠ GS∑ Ãy∑ if y = öâg then x else ﬁâg(Imagep (sucâo o x_+) y)) respects $çâgÆ);
a (rewrite_tac [get_spec ¨$respectsÆ]
	THEN REPEAT strip_tac);
a (cases_tac ¨x' = öâgÆ THEN asm_rewrite_tac[]);
a (LEMMA_T ¨Imagep (sucâo o g) x' = Imagep (sucâo o h) x'Æ rewrite_thm_tac);
a (once_rewrite_tac [gs_ext_axiom]);
a (rewrite_tac [get_spec ¨ImagepÆ]);
a (REPEAT strip_tac);
(* ** Goal "1" *** *)
a (∂_tac ¨e'Æ THEN asm_rewrite_tac[get_spec ¨$o:(('a≠'c)≠(('b≠'a)≠('b≠'c)))Æ]);
a (fc_tac [tc_incr_thm]);
a (asm_fc_tac[] THEN (ALL_ASM_FC_T rewrite_tac []));
(* *** Goal "2" *** *)
a (∂_tac ¨e'Æ THEN asm_rewrite_tac[get_spec ¨$o:(('a≠'c)≠(('b≠'a)≠('b≠'c)))Æ]);
a (fc_tac [tc_incr_thm]);
a (asm_fc_tac[] THEN (ALL_ASM_FC_T rewrite_tac []));
val plusâo_respect_lemma = pop_thm ();
=SML
set_goal([],¨µx∑ (Ãx_+:GS ≠ GS∑ Ãy∑ if y = öâg then x else ssup (Imagep x_+ y)) respects $çâgÆ);
a (rewrite_tac [get_spec ¨$respectsÆ]
	THEN REPEAT strip_tac);
a (cases_tac ¨x' = öâgÆ THEN asm_rewrite_tac[]);
a (LEMMA_T ¨Imagep g x' = Imagep h x'Æ rewrite_thm_tac);
a (once_rewrite_tac [gs_ext_axiom]);
a (rewrite_tac [get_spec ¨ImagepÆ]);
a (REPEAT strip_tac);
(* *** Goal "1" *** *)
a (∂_tac ¨e'Æ THEN asm_rewrite_tac[get_spec ¨$o:(('a≠'c)≠(('b≠'a)≠('b≠'c)))Æ]);
a (fc_tac [tc_incr_thm]);
a (asm_fc_tac[] THEN (ALL_ASM_FC_T rewrite_tac []));
(* *** Goal "2" *** *)
a (∂_tac ¨e'Æ THEN asm_rewrite_tac[get_spec ¨$o:(('a≠'c)≠(('b≠'a)≠('b≠'c)))Æ]);
a (fc_tac [tc_incr_thm]);
a (asm_fc_tac[] THEN (ALL_ASM_FC_T rewrite_tac []));
val plusâo_respect_lemma = pop_thm ();

declare_infix (300, "+âo");
declare_infix (300, "--âo");

set_goal([], ¨∂$+âo:GS ≠ GS ≠ GS∑ µ¡ ¬:GS∑ ¡ +âo ¬
	= if ¬ = öâg then ¡ else ssup (Imagep ($+âo ¡) ¬)Æ);
a (∂_tac ¨Ã¡∑ fix (Ã x_+ y∑ if y = öâg then ¡ else ssup (Imagep x_+ y))Æ
	THEN REPEAT strip_tac THEN rewrite_tac[]);
a (asm_tac gs_wf_thm1);
a (asm_tac plusâo_respect_lemma);
a (fc_tac [µ_elim ¨(Ã x_+ y∑ if y = öâg then ¡ else ssup (Imagep x_+ y))Æ (get_spec ¨fixÆ)]);
a (spec_nth_asm_tac 2 ¨¡Æ);
a (spec_nth_asm_tac 2 ¨¡Æ);
a (POP_ASM_T (asm_tac o (rewrite_rule[ext_thm])));
a (SYM_ASMS_T rewrite_tac);
save_cs_∂_thm (pop_thm());
=TEX
}%ignore

πHOLCONST
 $€+âo› : GS ≠ GS ≠ GS
˜
  µ¡ ¬∑ ¡ +âo ¬ = if ¬ = öâg then ¡ else ssup (Imagep ($+âo ¡) ¬)
∞

=GFT
ord_plus_thm =
	Ù µ ¡ ¬∑ ordinal ¡ ± ordinal ¬ ¥ ordinal (¡ +âo ¬)
=TEX

\ignore{
=SML
set_goal ([], ¨µ¡ ¬∑ ordinal ¡ ± ordinal ¬ ¥ ordinal (¡ +âo ¬)Æ);
a (REPEAT µ_tac);
a (wf_induction_tac gs_wf_thm1 ¨¬Æ);
a (rewrite_tac [get_spec ¨$+âoÆ]);
a (REPEAT strip_tac);
a (cases_tac ¨t = öâgÆ THEN asm_rewrite_tac[]);
a (lemma_tac ¨µ«∑ ordinal « ± « çâg t ¥ ordinal (¡ +âo «)Æ);
(* *** Goal "1" *** *)
a (REPEAT strip_tac);
a (fc_tac [tc_incr_thm]);
a (asm_fc_tac[]);
(* *** Goal "2" *** *)
a (lemma_tac ¨µŒ∑ Œ çâg (Imagep ($+âo ¡) t) ¥ ordinal ŒÆ);
(* *** Goal "2.1" *** *)
a (rewrite_tac []);
a (REPEAT strip_tac);
a (asm_rewrite_tac[]);
a (fc_tac[ord_mem_ord]);
a (spec_nth_asm_tac 1 ¨eÆ);
a (spec_nth_asm_tac 6 ¨eÆ);
(* *** Goal "2.2" *** *)
a (fc_tac[ordinal_ssup_thm]);
val ord_plus_thm = save_pop_thm "ord_plus_thm";
=IGN
stop;
set_goal ([], ¨µ¡ ¬∑ ordinal ¡ ± ordinal ¬ ¥ ¡ +âo ¬ = ﬁâg {« | ∂»∑ » <âo ¬ ± « = sucâo(¡ +âo »)}Æ);



set_goal ([], ¨µ¡∑ ordinal ¡ ¥ öâg +âo ¡ = ¡Æ);
a (strip_tac);
a (wf_induction_tac gs_wf_thm1 ¨¡Æ);
a (wf_induction_tac wf_ordinals_thm ¨¡Æ);
a (rewrite_tac [get_spec ¨$+âoÆ]);
a (cases_tac ¨t = öâgÆ THEN asm_rewrite_tac[]);
a (once_rewrite_tac [gst_relext_clauses]);
a (rewrite_tac[]);
a (REPEAT strip_tac);
a (POP_ASM_T ante_tac
	THEN rewrite_tac [get_spec ¨$o:(('a≠'c)≠(('b≠'a)≠('b≠'c)))Æ,
			get_spec ¨$+âoÆ]);

set_goal ([], ¨µ¡ ¬ «∑ ordinal ¡ ± ordinal ¬ ± ordinal «
		¥ (¡ +âo (¬ +âo «)) = ((¡ +âo ¬) +âo «)Æ);
a (rewrite_tac [get_spec ¨$+âoÆ] THEN REPEAT µ_tac THEN strip_tac);
a (cases_tac ¨« = öâgÆ THEN asm_rewrite_tac[]);
a (cases_tac ¨¬ = öâgÆ THEN asm_rewrite_tac[]);
(* *** Goal "1" *** *)
a (LEMMA_T ¨≥ ﬁâg (Imagep (sucâo o $+âo öâg) «) = öâgÆ rewrite_thm_tac);
(* *** Goal "1.1" *** *)
a (once_rewrite_tac [gs_ext_axiom]);
a (rewrite_tac []);
a strip_tac;
a (rewrite_tac []);
a (GET_NTH_ASM_T 2 (strip_asm_tac o (rewrite_rule [gs_ext_axiom])));
a (∂_tac ¨eÆ THEN ∂_tac ¨(sucâo o $+âo öâg) eÆ);
a (strip_tac);
(* *** Goal "1.1.1" *** *)
a (rewrite_tac [get_spec ¨$o:(('a≠'c)≠(('b≠'a)≠('b≠'c)))Æ,
	get_spec ¨$+âoÆ]);
a (cases_tac ¨e = öâgÆ THEN asm_rewrite_tac[]);
(* *** Goal "1.1.1.1" *** *)
a (rewrite_tac [get_spec ¨sucâoÆ]);
(* *** Goal "1.1.1.2" *** *)
a (rewrite_tac (map get_spec [¨sucâoÆ, ¨$o:(('a≠'c)≠(('b≠'a)≠('b≠'c)))Æ]));
a (REPEAT strip_tac);
a (once_rewrite_tac [gst_relext_clauses]);
a (rewrite_tac[get_spec ¨$o:(('a≠'c)≠(('b≠'a)≠('b≠'c)))Æ]);
a (REPEAT strip_tac);
(* *** Goal "1.1.1.2.1" *** *)
a (∂_tac ¨sucâo e'Æ THEN once_rewrite_tac [prove_rule [get_spec ¨sucâoÆ] ¨e' çâg sucâo e'Æ]);
a (rewrite_tac [] THEN ∂_tac ¨e'Æ THEN asm_rewrite_tac []);

a (rewrite_tac (map get_spec [¨sucâoÆ, ¨$o:(('a≠'c)≠(('b≠'a)≠('b≠'c)))Æ]));

a (lemma_tac ¨sucâo o $+âo öâg = öâgÆ);
=TEX
}%ignore

\subsubsection{Subtraction}

The following definition is of reverse subtraction, i.e. the right operand is subtracted from the left and is taken from the left of that operand so that the following lemma (as yet unproven) obtains:

=GFT
€--âo_lemma› =
	µ¡ ¬∑ ¡ ºâo ¬ ¥ ¡ +âo (¬ --âo ¡) = ¬
=TEX

\ignore{
=IGN
set_goal([], ¨µ¡ ¬:GS∑ ¡ ºâo ¬ ¥ ∂«∑  ¡ +âo « = ¬Æ);
a (REPEAT µ_tac);
a (wf_induction_tac gs_wf_thm1 ¨¬Æ);
a (strip_tac);
a (∂_tac ¨Imagep (Ãu∑ ≈«∑ ¡ +âo « = u) (Sep t (ÃŒ∑ ¡ ºâo Œ))Æ);
a (lemma_tac ¨µ»∑ » çâg Imagep (Ã u∑ ≈ «∑ ¡ +âo « = u) (Sep t (Ã Œ∑ ¡ ºâo Œ))
	§ ∂À∑ À çâg t ± ¡ ºâo À ± » = ≈ «∑ ¡ +âo « = ÀÆ);
(* *** Goal "1" *** *)
a (strip_tac THEN rewrite_tac [get_spec ¨ImagepÆ]);
a (REPEAT strip_tac);
(* *** Goal "1.1" *** *)
a (∂_tac ¨eÆ THEN asm_rewrite_tac[]);
(* *** Goal "1.2" *** *)
a (∂_tac ¨ÀÆ THEN asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a (rewrite_tac [get_spec ¨$+âoÆ]);
a (rewrite_tac [gs_ext_axiom]);

a (rewrite_tac [get_spec ¨ImagepÆ]);
a (cases_tac ¨¡ = tÆ THEN_TRY asm_rewrite_tac[]);

;

set_goal([], ¨∂$--âo∑ µ¡ ¬:GS∑ ¡ ºâo ¬ ¥ ¡ +âo (¡ --âo ¬) = ¬Æ);
a (∂_tac ¨Ã¡ ¬∑ if ¡ ºâo ¬ then ≈«∑ ¡ +âo « = ¬ else öâgÆ);
a (rewrite_tac[]);

frees¨Ã¡ ¬∑ if ¡ ºâo ¬ then ≈«∑ ¡ +âo « = ¬ else öâgÆ;
get_spec ¨$ºâoÆ;
=TEX
}%ignore

πHOLCONST
 $€--âo› : GS ≠ GS ≠ GS
˜
  T
∞


\subsection{Proof Context}

In this section we define a proof context for ordinals.

\subsubsection{Proof Context}

=SML
add_pc_thms "'gst-ord" ([]);
set_merge_pcs ["basic_hol", "'gst-ax", "'gst-ord"];
commit_pc "'gst-ord";
=TEX

\section{Natural Numbers}

=SML
open_theory "gst-ord";
force_new_theory "gst-nat";
force_new_pc "'gst-nat";
merge_pcs ["'savedthm_cs_∂_proof"] "'gst-nat";
set_merge_pcs ["basic_hol", "'gst-ax", "'gst-ord", "'gst-nat"];
=TEX

πHOLCONST
 €natural_number› : GS ≠ BOOL
˜
  µs :GS∑ natural_number s § s = öâg ≤ (successor s ± µt∑ tçâg s ¥ t = öâg ≤ successor t)
∞

\subsubsection{Ordering the Natural Numbers}

To get an induction principle for the natural numbers we first define a well-founded ordering over them.
Since I don't plan to use this a lot I use the name $<âgân$ (less than over the natural numbers defined in galactic set theory).

=SML
declare_infix(240,"<âgân");
=TEX

πHOLCONST
 $€<âgân› : GS ≠ GS ≠ BOOL
˜
  µx y:GS∑ x <âgân y § natural_number x ± natural_number y ± x çâg y
∞

Now we try to find a better proof that the one above that this is well-founded.
And fail, this is just a more compact rendition of the same proof.

=SML
set_goal([],¨well_founded $<âgânÆ);
a (asm_tac gs_wf_thm1);
a (fc_tac [wf_restrict_wf_thm]);
a (SPEC_NTH_ASM_T 1 ¨Ãx y∑ natural_number x ± natural_number yÆ ante_tac
	THEN rewrite_tac[]);
a (lemma_tac ¨$<âgân = (Ã x y∑ (natural_number x ± natural_number y) ± x çâg y)Æ
	THEN1 (REPEAT_N 2 (once_rewrite_tac [ext_thm])
		THEN prove_tac[get_spec ¨$<âgânÆ]));
a (asm_rewrite_tac[]);
val wf_nat_thm = save_pop_thm "wf_nat_thm";
=TEX
This allows us to do well-founded induction over the natural number which the way I have implemented it is "course-of-values" induction.
However, for the sake of form I will prove that induction principle as an explicit theorem.
This is just what you get by expanding the definition of well-foundedness in the above theorem.
=SML
val nat_induct_thm = save_thm ("nat_induct_thm",
	(rewrite_rule [get_spec ¨well_foundedÆ] wf_nat_thm));
=TEX
Note that this theorem can only be used to prove properties which are true of all sets, so you have to make it conditional 
=INLINEFT
(natural_number n ¥ whatever)
=TEX
I suppose I'd better do another one.
=SML
set_goal([], ¨µ p∑ (µ x∑ natural_number x ± (µ y∑ y <âgân x ¥ p y) ¥ p x)
	¥ (µ x∑ natural_number x ¥ p x)Æ);
a (asm_tac (rewrite_rule []
	(all_µ_intro (µ_elim ¨Ãx∑ natural_number x ¥ p xÆ nat_induct_thm))));
a (rewrite_tac [all_µ_intro (taut_rule ¨a ± b ¥ c § b ¥ a ¥ cÆ)]);
a (lemma_tac ¨µ p x∑ (µ y∑ y <âgân x ¥ p y)
	§ (µ y∑ y <âgân x ¥ natural_number y ¥ p y)Æ);
(* *** Goal "1" *** *)
a (rewrite_tac [get_spec ¨$<âgânÆ]);
a (REPEAT strip_tac THEN all_asm_fc_tac[]);
(* *** Goal "2" *** *)
a (asm_rewrite_tac[]);
val nat_induct_thm2 = save_pop_thm "nat_induct_thm2";
=TEX
I've tried using that principle and it too has disadvantages.
Because $<âgân$ is used the induction hypothesis is more awkward to use (weaker) than it would have been if $çâg$ had been used.
Unfortunately the proof of an induction theorem using plain set membership is not entirely trivial, so its proof has to be left til later.
=SML
set_goal([], ¨µ p∑ (µ x∑ natural_number x ± (µ y∑ y çâg x ¥ p y) ¥ p x)
	¥ (µ x∑ natural_number x ¥ p x)Æ);
=IGN
a (asm_tac (rewrite_rule []
	(all_µ_intro (µ_elim ¨Ãx∑ natural_number x ¥ p xÆ nat_induct_thm))));
a (rewrite_tac [all_µ_intro (taut_rule ¨a ± b ¥ c § b ¥ a ¥ cÆ)]);
a (lemma_tac ¨µ p x∑ ((µ y∑ y çâg x ¥ p y) ¥ natural_number x ¥ p x)
	§ (µ y∑ y <âgân x ¥ natural_number y ¥ p y) ¥ natural_number x ¥ p xÆ);
(* *** Goal "1" *** *)
a (rewrite_tac [get_spec ¨$<âgânÆ]);
a (REPEAT strip_tac THEN all_asm_fc_tac[]);
(* *** Goal "2" *** *)
a (asm_rewrite_tac[]);
val nat_induct_thm2 = save_pop_thm "nat_induct_thm2";
=TEX

\subsection{Theorem 2.8}

The set of natural numbers.

\subsubsection{Natural Numbers are Ordinals}

=SML
set_goal ([], ¨µn∑ natural_number n ¥ ordinal nÆ);
a (rewrite_tac [get_spec ¨natural_numberÆ, get_spec ¨successorÆ]);
a (REPEAT strip_tac THEN_TRY asm_rewrite_tac[ordinal_öâg]);
a (all_fc_tac [ord_suc_ord_thm]);
val ord_nat_thm = save_pop_thm "ord_nat_thm";
=TEX

\subsubsection{Members of Natural Numbers are Ordinals}

=SML
set_goal ([], ¨µn∑ natural_number n ¥ µm∑ m çâg n ¥ ordinal mÆ);
a (REPEAT strip_tac);
a (REPEAT (all_fc_tac[ord_nat_thm, ord_mem_ord]));
val mem_nat_ord_thm = save_pop_thm "mem_nat_ord_thm";
=TEX

\subsubsection{A Natural Number is not a Limit Ordinal}

=SML
set_goal ([], ¨µn∑ natural_number n ¥ ≥ limit_ordinal nÆ);
a (rewrite_tac [get_spec ¨limit_ordinalÆ, get_spec ¨natural_numberÆ]);
a (REPEAT strip_tac);
val nat_not_lim_thm = save_pop_thm "nat_not_lim_thm";
=TEX

\subsubsection{A Natural Number is zero or a successor}

=SML
set_goal ([], ¨µn∑ natural_number n ¥ successor n ≤ n = öâgÆ);
a (rewrite_tac [get_spec ¨natural_numberÆ]);
a (REPEAT strip_tac);
val nat_zero_or_suc_thm = save_pop_thm "nat_zero_or_suc_thm";
=TEX

\subsubsection{A Natural Number does not contain a Limit Ordinal}

=SML
set_goal ([], ¨µm n∑ natural_number n ± m çâg n ¥ ≥ limit_ordinal mÆ);
a (rewrite_tac [get_spec ¨limit_ordinalÆ, get_spec ¨natural_numberÆ]);
a (REPEAT strip_tac);
(* *** Goal "1" *** *)
a (all_fc_tac [mem_not_empty_thm]);
(* *** Goal "2" *** *)
a (all_asm_fc_tac[]);
val mem_nat_not_lim_thm = save_pop_thm "mem_nat_not_lim_thm";
=TEX

\subsubsection{All Members of Natural Numbers are Natural Numbers}

=SML
set_goal ([], ¨µn∑ natural_number n ¥ µm∑ m çâg n ¥ natural_number mÆ);
a (rewrite_tac [get_spec ¨natural_numberÆ]);
a (REPEAT strip_tac THEN_TRY all_asm_fc_tac [mem_not_empty_thm]);
a (lemma_tac ¨transitive nÆ THEN1
	 (REPEAT (all_fc_tac [get_spec ¨ordinalÆ, successor_ord_thm])));
a (lemma_tac ¨t çâg nÆ THEN1 (EVERY [all_fc_tac [get_spec ¨transitiveÆ],
	POP_ASM_T ante_tac, rewrite_tac [gst_relext_clauses], asm_prove_tac[]]));
a (all_asm_fc_tac[]);
val mem_nat_nat_thm = save_pop_thm "mem_nat_nat_thm";
=TEX

\subsubsection{Natural Numbers are in the Smallest Galaxy}

=SML
set_goal ([], ¨µn∑ natural_number n ¥ n çâg Gx öâgÆ);
a (strip_tac THEN gen_induction_tac1 nat_induct_thm2);
a (fc_tac [nat_zero_or_suc_thm]);
(* *** Goal "1" *** *)
a (fc_tac [get_spec ¨successorÆ]);
a (lemma_tac ¨t <âgân nÆ
	THEN1 asm_rewrite_tac [get_spec ¨$<âgânÆ, get_spec ¨sucâoÆ]);
(* *** Goal "1.1" *** *)
a (lemma_tac ¨t çâg nÆ
	THEN1 asm_rewrite_tac [get_spec ¨sucâoÆ]);
a (all_fc_tac [mem_nat_nat_thm]);
(* *** Goal "1.2" *** *)
a (asm_tac (µ_elim ¨öâgÆ galaxy_Gx));
a (asm_rewrite_tac[]);
a (REPEAT (all_asm_fc_tac[GCloseSuc]));
(* *** Goal "2" *** *)
a (asm_rewrite_tac[]);
val nat_in_Göâg_thm = save_pop_thm "nat_in_Göâg_thm";
=TEX

\subsubsection{The Existence of w}

This comes from the axiom of infinity, however, in galactic set theory we get that from the existence of galaxies, so the following proof is a little unusual.

=SML
set_goal ([], ¨∂w∑ µz∑ z çâg w § natural_number zÆ);
a (∂_tac ¨Sep (Gx öâg) natural_numberÆ
	THEN rewrite_tac [gst_opext_clauses]);
a (rewrite_tac [all_µ_intro (taut_rule ¨(a ± b § b) § b ¥ aÆ)]);
a strip_tac;
a (gen_induction_tac1 nat_induct_thm2);
a (fc_tac [nat_zero_or_suc_thm]);
(* *** Goal "1" *** *)
a (fc_tac [get_spec ¨successorÆ, nat_in_Göâg_thm]);
(* *** Goal "2" *** *)
a (asm_rewrite_tac []);
val w_exists_thm = save_pop_thm "w_exists_thm";
=TEX

\subsection{Naming the Natural Numbers}

It will be useful to be able to have names for the finite ordinals, which are used as tags in the syntax:

πHOLCONST
‹ €Natâg›: Ó ≠ GS
˜¸¸¸¸¸¸¸¸¸¸¸
‹       Natâg 0 = öâg
‹ ± µn∑ Natâg (n+1) = sucâo (Natâg n)
∞

We will need to know that these are all distinct ordinals.

=GFT
€ord_nat_thm2› =
	Ù µ n∑ ordinal (Natâg n)

€not_suc_nat_zero_thm› =
	Ù µ n∑ ≥ sucâo (Natâg n) = öâg

€less_sum_thm› =
	Ù µ x y∑ x º y ¥ (∂ z∑ x + z = y)

€natg_mono_thm› =
	Ù µ x y∑ Natâg x ºâo Natâg (x + y)

€natg_one_one_thm› =
	Ù µ x y∑ Natâg x = Natâg y ¥ x = y

€natg_one_one_thm2› =
	Ù µ x y∑ Natâg x = Natâg y § x = y
=TEX

\ignore{
=SML
set_goal([], ¨µn∑ ordinal (Natâg n)Æ);
a (strip_tac);
a (induction_tac ¨nÆ);
a (rewrite_tac [get_spec ¨NatâgÆ, ordinal_öâg]);
a (rewrite_tac [get_spec ¨NatâgÆ]);
a (fc_tac [ord_suc_ord_thm]);
val ord_nat_thm2 = save_pop_thm "ord_nat_thm2";

set_goal([], ¨µn∑ ≥ sucâo (Natâg n) = öâgÆ);
a (asm_tac ord_nat_thm2);
a (strip_asm_tac öâg_not_sucâo_thm);
a strip_tac;
a (spec_nth_asm_tac 1 ¨Natâg nÆ);
val not_suc_nat_zero_thm = save_pop_thm "not_suc_nat_zero_thm";

set_goal([], ¨µx y:Ó∑ x º y ¥ ∂z∑ x + z = yÆ);
a (REPEAT µ_tac);
a (induction_tac ¨yÆ);
(* *** Goal "1" *** *)
a (strip_tac THEN ∂_tac ¨0Æ THEN asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a (strip_tac THEN ∂_tac ¨0Æ
	THEN (PC_T1 "lin_arith" asm_prove_tac[]));
(* *** Goal "3" *** *)
a (strip_tac THEN ∂_tac ¨z + 1Æ
	THEN (PC_T1 "lin_arith" asm_prove_tac[]));
val less_sum_thm = save_pop_thm "less_sum_thm";

set_goal([], ¨µx y:Ó∑ Natâg x ºâo Natâg (x + y)Æ);
a (REPEAT µ_tac);
a (induction_tac ¨yÆ);
(* *** Goal "1" *** *)
a (rewrite_tac [leo_lo_thm, ord_nat_thm2]);
(* *** Goal "2" *** *)
a (rewrite_tac [get_spec ¨NatâgÆ,
	pc_rule1 "lin_arith" prove_rule [] ¨x + y + 1 = (x + y) + 1Æ]);
a (asm_tac leo_suc_thm);
a (asm_tac ord_nat_thm2);
a (spec_nth_asm_tac 1 ¨x+yÆ);
a (asm_fc_tac []);
a (all_asm_fc_tac [leo_trans_thm]);
val natg_mono_thm = save_pop_thm "natg_mono_thm";

set_goal([], ¨µx y∑ Natâg x = Natâg y ¥ x = yÆ);
a (REPEAT µ_tac);
a (strip_asm_tac (list_µ_elim [¨xÆ, ¨yÆ] º_cases_thm));
(* *** Goal "1" *** *)
a (fc_tac [less_sum_thm]);
a (POP_ASM_T ante_tac THEN induction_tac ¨zÆ);
(* *** Goal "1.1" *** *)
a (rewrite_tac[] THEN REPEAT strip_tac);
(* *** Goal "1.2" *** *)
a (strip_tac);
a (SYM_ASMS_T rewrite_tac);
a (lemma_tac ¨Natâg x ºâo Natâg (x + z)Æ
	THEN1 rewrite_tac [natg_mono_thm]);
a (lemma_tac ¨Natâg (x + z) <âo Natâg (x + z + 1)Æ);
(* *** Goal "1.2.1" *** *)
a (rewrite_tac [pc_rule1 "lin_arith" prove_rule [] ¨x + z + 1 = (x + z) + 1Æ]);
a (rewrite_tac [get_spec ¨NatâgÆ]);
a (asm_tac (µ_elim ¨x+zÆ ord_nat_thm2));
a (FC_T rewrite_tac [lo_suc_thm]);
(* *** Goal "1.2.2" *** *)
a (all_fc_tac [leo_lo_trans_thm]);
a (POP_ASM_T ante_tac
	THEN (rewrite_tac [get_spec ¨$<âoÆ])
	THEN REPEAT strip_tac);
a (swap_nth_asm_concl_tac 1);
a (asm_rewrite_tac [wf_l1]);
(* *** Goal "1.3" *** *)
a (asm_rewrite_tac[]);
(* *** Goal "1.4" *** *)
a (asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a (fc_tac [less_sum_thm]);
a (POP_ASM_T ante_tac THEN induction_tac ¨zÆ);
(* *** Goal "2.1" *** *)
a (rewrite_tac[] THEN REPEAT strip_tac THEN asm_rewrite_tac[]);
(* *** Goal "2.2" *** *)
a (strip_tac);
a (SYM_ASMS_T rewrite_tac);
a (lemma_tac ¨Natâg y ºâo Natâg (y + z)Æ
	THEN1 rewrite_tac [natg_mono_thm]);
a (lemma_tac ¨Natâg (y + z) <âo Natâg (y + z + 1)Æ);
(* *** Goal "2.2.1" *** *)
a (rewrite_tac [pc_rule1 "lin_arith" prove_rule [] ¨y + z + 1 = (y + z) + 1Æ]);
a (rewrite_tac [get_spec ¨NatâgÆ]);
a (asm_tac (µ_elim ¨y+zÆ ord_nat_thm2));
a (FC_T rewrite_tac [lo_suc_thm]);
(* *** Goal "2.2.2" *** *)
a (all_fc_tac [leo_lo_trans_thm]);
a (POP_ASM_T ante_tac
	THEN (rewrite_tac [get_spec ¨$<âoÆ])
	THEN REPEAT strip_tac);
a (swap_nth_asm_concl_tac 1);
a (asm_rewrite_tac [wf_l1]);
(* *** Goal "2.3" *** *)
a (asm_rewrite_tac[]);
(* *** Goal "2.4" *** *)
a (asm_rewrite_tac[]);
val natg_one_one_thm = save_pop_thm "natg_one_one_thm";

set_goal([], ¨µx y∑ Natâg x = Natâg y § x = yÆ);
a (REPEAT strip_tac THEN_TRY asm_rewrite_tac[]);
a (asm_fc_tac [natg_one_one_thm]);
val natg_one_one_thm2 = save_pop_thm "natg_one_one_thm2";

=IGN
set_goal([], ¨µx y∑ Natâg (x+y) = (Natâg x) +âo (Natâg y)Æ);
a (REPEAT µ_tac);
a (induction_tac ¨yÆ);
a (rewrite_tac[get_spec ¨$+âoÆ, get_spec ¨NatâgÆ]);
a (rewrite_tac [pc_rule1 "lin_arith" prove_rule [] ¨x + y + 1 = (x + y) + 1Æ]);
a (asm_rewrite_tac[get_spec¨NatâgÆ]);
=TEX
}%ignore

\subsection{Proof Context}

In this section we define a proof context for natural numbers.

\subsubsection{Proof Context}

=SML
add_pc_thms "'gst-nat" ([natg_one_one_thm2]);
set_merge_pcs ["basic_hol", "'gst-ax", "'gst-ord", "'gst-nat"];
commit_pc "'gst-nat";
=TEX

\section{Closing}

=SML
open_theory "gst-fun";
force_new_theory "GS";
(* new_parent "gst-sumprod";
new_parent "gst-fixp"; *)
new_parent "gst-ord";
new_parent "gst-nat";
force_new_pc "GS";
force_new_pc "'GS1";
val rewrite_thms = ref ([]:THM list);

merge_pcs ["'gst-ax", "'gst-fun"(*, "'gst-sumprod", "'gst-fixp", "'gst-lists"*),"'gst-ord", "'gst-nat"]
	"'GS1";
commit_pc "'GS1";
merge_pcs ["basic_hol", "'GS1"] "GS";
commit_pc "GS";
=TEX

%{\raggedright
%\bibliographystyle{fmu}
%\bibliography{rbj,fmu}
%} %\raggedright

{\let\Section\section
\newcounter{ThyNum}
\def\section#1{\Section{#1}
\addtocounter{ThyNum}{1}\label{Theory\arabic{ThyNum}}}
\include{gst-ax.th}
\include{gst-fun.th}
\include{gst-ord.th}
\include{gst-nat.th}
\include{GS.th}
}674  %\let

\twocolumn[\section{INDEX}\label{index}]
{\small\printindex}

\end{document}
