=IGN
$Id: t025.doc,v 1.11 2008/12/03 20:57:12 rbj Exp $
open_theory "ifol";
set_merge_pcs ["rbjmisc", "'GS1", "'misc2", "'ifol"];
=TEX
\documentclass[11pt,a4paper]{article}
\usepackage{latexsym}
\usepackage{ProofPower}
\ftlinepenalty=9999
\usepackage{A4}

%\def\ExpName{\mbox{{\sf exp}
%\def\Exp#1{\ExpName(#1)}

\tabstop=0.4in
\newcommand{\ignore}[1]{}

\title{More Miscellanea}
\makeindex
\usepackage[unicode,pdftex]{hyperref}
\hypersetup{pdfauthor={Roger Bishop Jones}}
\hypersetup{colorlinks=true, urlcolor=black, citecolor=black, filecolor=black, linkcolor=black}

\author{Roger Bishop Jones}
\date{\ }

\begin{document}
\begin{titlepage}
\maketitle
\begin{abstract}
This theory is for miscellanea which cannot be put in theory ``rbjmisc'' because of dependencies on other theories.
It consists primarily of things required in the documents on non well-founded set theories but not specific to that work which make use of galactic set theory or fixed point theory.
\end{abstract}

\vfill

\begin{centering}

{\footnotesize

Created: 2008/07/11

Last Change $ $Date: 2008/12/03 20:57:12 $ $

\href{http://www.rbjones.com/rbjpub/pp/doc/t025.pdf}
{http://www.rbjones.com/rbjpub/pp/doc/t025.pdf}

$ $Id: t025.doc,v 1.11 2008/12/03 20:57:12 rbj Exp $ $

\copyright\ Roger Bishop Jones; Licenced under Gnu LGPL

}%footnotesize

\end{centering}

\thispagestyle{empty}
\end{titlepage}

\newpage
\addtocounter{page}{1}
%\section{DOCUMENT CONTROL}
%\subsection{Contents list}
{\parskip=0pt\tableofcontents}
%\newpage
%\subsection{Document cross references}
IS
\subsection*{To Do}
\begin{itemize}
\item 
\item 
\end{itemize}

{\raggedright
\bibliographystyle{fmu}
\bibliography{rbj,fmu}
} %\raggedright

\newpage
\section{INTRODUCTION}

This was originally material which used to be in t024 and is moved here so that it can also be used in t026.

It should only contain material which cannot be put in ``rbjmisc'' because it depends on other theories, at this point GS adn fixp.
Some of it should therefore be moved up to ``rbjmisc''.

This contains the theory ``misc2'', which includes:

\begin{itemize}
\item some lemmas relevant to type definitions
\item the type OPT
\item the type DPO (discrete partial orders)
\item indexed sets
\item material on orders and preorders
\end{itemize}

=SML
open_theory "rbjmisc";
force_new_theory "€misc2›";
new_parent "GS";
new_parent "fixp";
force_new_pc "€'misc2›";
merge_pcs ["'savedthm_cs_∂_proof"] "'misc2";
set_merge_pcs ["rbjmisc", "'GS1", "'misc2"];
=TEX

\section{SET THEORY}

\subsection{Mapping Functions over Sets}

The following function makes recursive definition of functions over sets of type GS just a little more compact.

πHOLCONST
‹ €FunImageâg› : (GS ≠ 'a) ≠ GS ≠ ('a SET)
˜¸¸¸¸¸¸¸¸¸¸¸
‹ µf s∑ FunImageâg f s = {x | ∂y∑ y çâg s ± x = f y}
∞

=GFT
€funimageâg_fc_lemma› =
	Ù µ f s x∑ x çâg s ¥ f x ç FunImageâg f s
=TEX

\ignore{
=SML
set_flag("subgoal_package_quiet", true);


set_goal([], ¨µf s x∑ x çâg s ¥ f x ç FunImageâg f sÆ);
a (µ_tac THEN rewrite_tac [get_spec ¨FunImageâgÆ] THEN REPEAT strip_tac);
a (∂_tac ¨xÆ THEN asm_rewrite_tac[]);
val funimageâg_fc_lemma = save_pop_thm "funimageâg_fc_lemma";

set_merge_pcs ["rbjmisc1", "'misc2"];
=TEX
}%ignore


\section{DISCRETE PARTIAL ORDERS}

=SML
new_type_defn (["DPO"], "DPO", ["'a"],
	tac_proof (([], ¨∂x:'a+BOOL∑ (Ãy∑T) xÆ), ∂_tac ¨InR TÆ THEN prove_tac []));
=TEX

=IGN
declare_type_abbrev("€DPO›", ["'a"], î'a + BOOLÆ);
=TEX


\ignore{
=SML
set_goal([], ¨∂ absDPO (repDPO: 'a DPO ≠ 'a + BOOL)
         ∑ (µ a∑ absDPO (repDPO a) = a) ± (µ r∑ repDPO (absDPO r) = r)Æ);
a (strip_asm_tac (get_defn "-" "DPO"));
a (fc_tac [type_lemmas_thm2]);
a (∂_tac ¨absÆ THEN ∂_tac ¨repÆ THEN asm_rewrite_tac[]);
a (DROP_NTH_ASM_T 2 (rewrite_thm_tac o (rewrite_rule[])));
save_cs_∂_thm (pop_thm());
=TEX
}%

πHOLCONST
‹ €absDPO›: 'a + BOOL ≠ 'a DPO;
‹ €repDPO›: 'a DPO ≠ 'a + BOOL
˜¸¸¸¸¸¸¸¸¸¸¸
‹   (µ a∑ absDPO (repDPO a) = a)
‹ ± (µ r∑ repDPO (absDPO r) = r)
∞

=GFT
one_one_DPO_lemma =
	Ù OneOne repDPO ± OneOne absDPO 
=TEX

\ignore{
=SML
set_goal([], ¨OneOne (repDPO: 'a DPO ≠ 'a + BOOL) ± OneOne (absDPO: 'a + BOOL ≠ 'a DPO)Æ);
a (strip_asm_tac (get_spec ¨repDPOÆ));
a (rewrite_tac[get_spec ¨OneOneÆ]);
a (fc_tac [type_defn_lemma1] THEN asm_rewrite_tac[]);
val one_one_DPO_lemma = save_pop_thm "one_one_DPO_lemma";
=TEX
}%ignore

πHOLCONST
‹ €dpoB› : 'a DPO
˜¸¸¸¸¸¸¸¸¸¸¸
‹ dpoB = absDPO(InR F)
∞

πHOLCONST
‹ €dpoT› : 'a DPO
˜¸¸¸¸¸¸¸¸¸¸¸
‹ dpoT = absDPO(InR T)
∞

πHOLCONST
‹ €dpoE› : 'a ≠ 'a DPO
˜¸¸¸¸¸¸¸¸¸¸¸
‹ µe∑ dpoE e = absDPO(InL e)
∞

πHOLCONST
‹ €dpoV› : 'a DPO ≠ 'a
˜¸¸¸¸¸¸¸¸¸¸¸
‹ µx∑ dpoV x = OutL (repDPO x)
∞

πHOLCONST
‹ €dpoUdef› : 'a DPO ≠ BOOL
˜¸¸¸¸¸¸¸¸¸¸¸
‹ µx∑ dpoUdef x § x = dpoB
∞

πHOLCONST
‹ €dpoOdef› : 'a DPO ≠ BOOL
˜¸¸¸¸¸¸¸¸¸¸¸
‹ µx∑ dpoOdef x § x = dpoT
∞

=GFT
€dpo_distinct_clauses› =
   Ù ≥ dpoT = dpoB
       ± ≥ dpoB = dpoT
       ± (µ e
       ∑ ≥ dpoE e = dpoT
           ± ≥ dpoE e = dpoB
           ± ≥ dpoT = dpoE e
           ± ≥ dpoB = dpoE e)

€dpoe_inj_thm› =
	Ù µ e f∑ (dpoE e = dpoE f) = e = f

€dpoe_inj_lemma› =
	Ù µ e f∑ (dpoE e = dpoE f) = e = f

€dpove_lemma1› =
	Ù µ e∑ dpoV (dpoE e) = e

€dpodef_lemma1› =
   Ù dpoUdef dpoB
       ± dpoOdef dpoT
       ± ≥ dpoUdef dpoT
       ± ≥ dpoOdef dpoB
       ± (µ e∑ ≥ dpoUdef (dpoE e) ± ≥ dpoOdef (dpoE e))

€dpo_cases_thm› =
	Ù µ x∑ x = dpoB ≤ x = dpoT ≤ (∂ e∑ x = dpoE e)

€dpoev_lemma1› =
	Ù µ x∑ ≥ dpoUdef x ± ≥ dpoOdef x ¥ dpoE (dpoV x) = x

€dpo_rpou_lemma› =
	Ù RpoU Dpo

€dpo_glbs_exist_thm› =
	Ù GlbsExist Dpo

€dpo_lubs_exist_thm› =
	Ù LubsExist Dpo
=TEX

\ignore{
=SML
set_goal([], ¨≥ dpoT = (dpoB:'a DPO)
	± ≥ dpoB = (dpoT:'a DPO)
	± (µe:'a∑ ≥ dpoE e = dpoT
		± ≥ dpoE e = dpoB
		± ≥ dpoT = dpoE e
		± ≥ dpoB = dpoE e)Æ);
a (rewrite_tac (map get_spec [¨dpoTÆ, ¨dpoBÆ, ¨dpoEÆ]));
a (strip_asm_tac (get_spec ¨absDPOÆ));
a (strip_asm_tac one_one_DPO_lemma);
a (fc_tac [oneone_contrapos_lemma]);
a (lemma_tac ¨≥ InR T = InR F:'a + BOOLÆ THEN1 rewrite_tac[]);
a (ASM_FC_T rewrite_tac []);
a (POP_ASM_T discard_tac);
a (lemma_tac ¨≥ InR F = InR T:'a + BOOLÆ THEN1 rewrite_tac[]);
a (ASM_FC_T rewrite_tac []);
a (strip_tac);
a (POP_ASM_T discard_tac);
a (lemma_tac ¨≥ InL e = InR T:'a + BOOLÆ THEN1 rewrite_tac[]);
a (ASM_FC_T rewrite_tac []);
a (POP_ASM_T discard_tac);
a (lemma_tac ¨≥ InL e = InR F:'a + BOOLÆ THEN1 rewrite_tac[]);
a (ASM_FC_T rewrite_tac []);
a (POP_ASM_T discard_tac);
a (lemma_tac ¨≥ InR T = InL e:'a + BOOLÆ THEN1 rewrite_tac[]);
a (ASM_FC_T rewrite_tac []);
a (POP_ASM_T discard_tac);
a (lemma_tac ¨≥ InR F = InL e:'a + BOOLÆ THEN1 rewrite_tac[]);
a (ASM_FC_T rewrite_tac []);
val dpo_distinct_clauses = save_pop_thm "dpo_distinct_clauses";

add_pc_thms "'misc2" [dpo_distinct_clauses, get_spec ¨absDPOÆ];
set_merge_pcs ["rbjmisc1", "'misc2"];

set_goal([], ¨(µe f:'a∑ ≥ e = f ¥ ≥ dpoE e = dpoE f)
	± (µe f:'a∑ dpoE e = dpoE f ¥ e = f)Æ);
a (rewrite_tac (map get_spec [¨dpoEÆ]));
a (lemma_tac ¨µ e f∑ ≥ e = f ¥ ≥ absDPO (InL e) = absDPO (InL f)Æ THEN_TRY asm_rewrite_tac[]);
(* *** Goal "1" *** *)
a (contr_tac);
a (LEMMA_T ¨repDPO(absDPO(InL (e:'a))) = repDPO(absDPO(InL f))Æ (strip_asm_tac o (rewrite_rule[]))
	THEN1 (pure_rewrite_tac[asm_rule ¨absDPO (InL (e:'a)) = absDPO (InL f)Æ]
		THEN rewrite_tac[]));
(* *** Goal "2" *** *)
a (contr_tac THEN asm_fc_tac[]);
val dpo_distinct_fc_clauses = pop_thm ();

set_goal([], ¨µe f∑ dpoE e = dpoE f § e = fÆ);
a (REPEAT strip_tac THEN_TRY all_asm_fc_tac [dpo_distinct_fc_clauses]
	THEN asm_rewrite_tac[]);
val dpoe_inj_lemma = save_pop_thm "dpoe_inj_lemma";

add_pc_thms "'misc2" [dpoe_inj_lemma];
set_merge_pcs ["rbjmisc1", "'misc2"];

set_goal([], ¨µx∑ x = dpoB ≤ x = dpoT ≤ (∂e∑ x = dpoE e)Æ);
a (rewrite_tac [get_spec ¨dpoBÆ, get_spec ¨dpoTÆ, get_spec ¨dpoEÆ]
	THEN REPEAT strip_tac);
a (strip_asm_tac (µ_elim ¨repDPO xÆ sum_cases_thm));
(* *** Goal "1" *** *)
a (∂_tac ¨yÆ THEN (SYM_ASMS_T rewrite_tac));
(* *** Goal "2" *** *)
a (strip_asm_tac (one_one_DPO_lemma));
a (fc_tac [oneone_contrapos_lemma]);
a (ASM_FC_T (MAP_EVERY (ante_tac)) []);
a (cases_tac ¨zÆ THEN_TRY asm_rewrite_tac[]);
val dpo_cases_thm = save_pop_thm "dpo_cases_thm";

set_goal([], ¨µe∑ dpoV(dpoE e) = eÆ);
a (REPEAT strip_tac THEN rewrite_tac [get_spec ¨dpoEÆ, get_spec ¨dpoVÆ]
	THEN asm_rewrite_tac[]);
val dpove_lemma1 = save_pop_thm "dpove_lemma1";

add_pc_thms "'misc2" [dpove_lemma1];
set_merge_pcs ["rbjmisc1", "'misc2"];

set_goal([], ¨dpoUdef dpoB ± dpoOdef dpoT
	± ≥ dpoUdef dpoT ± ≥ dpoOdef dpoB
	± µe∑ ≥ dpoUdef (dpoE e) ± ≥ dpoOdef (dpoE e)Æ);
a (REPEAT strip_tac THEN_TRY asm_rewrite_tac [get_spec ¨dpoUdefÆ, get_spec ¨dpoOdefÆ]);
val dpodef_lemma1 = save_pop_thm "dpodef_lemma1";

add_pc_thms "'misc2" [dpodef_lemma1];
set_merge_pcs ["rbjmisc1", "'misc2"];

set_goal([], ¨µx∑ ≥ dpoUdef x ± ≥ dpoOdef x ¥ dpoE(dpoV x) = xÆ);
a (REPEAT µ_tac);
a (strip_asm_tac (µ_elim ¨xÆ dpo_cases_thm) THEN_TRY asm_rewrite_tac[]);
val dpoev_lemma1 = save_pop_thm "dpoev_lemma1";
=TEX
}%ignore

\ignore{
=SML
add_pc_thms "'misc2" (map get_spec [¨IsDefinedÆ, ¨ValueOfÆ] @ [value_not_undefined_lemma, value_oneone_lemma]);
set_merge_pcs ["rbjmisc1", "'misc2"];
=TEX
}%ignore

πHOLCONST
‹ €Dpo› : 'a DPO ≠ 'a DPO ≠ BOOL
˜¸¸¸¸¸¸¸¸¸¸¸
‹ µx y∑ Dpo x y § x = y ≤ x = dpoB ≤ y = dpoT
∞

\ignore{
=SML
set_goal([], ¨RpoU DpoÆ);
a (rewrite_tac (map get_spec [¨RpoUÆ, ¨RpoÆ, ¨ReflÆ, ¨PartialOrderÆ, ¨TransÆ, ¨AntisymÆ, ¨DpoÆ])
	THEN contr_tac
	THEN_TRY var_elim_nth_asm_tac 1
	THEN_TRY rewrite_tac [dpo_distinct_clauses]
	THEN_TRY all_var_elim_asm_tac);
val dpo_rpou_lemma = save_pop_thm "dpo_rpou_lemma";

set_goal([], ¨GlbsExist DpoÆ);
a (rewrite_tac [get_spec ¨GlbsExistÆ, get_spec ¨IsGlbÆ, get_spec ¨IsLbÆ, get_spec ¨DpoÆ]
	THEN REPEAT strip_tac);
a (cases_tac ¨dpoB ç sÆ THEN_TRY asm_rewrite_tac[]);
(* *** Goal "1" *** *)
a (∂_tac ¨dpoBÆ THEN_TRY asm_rewrite_tac[]
	THEN REPEAT strip_tac);
a (spec_nth_asm_tac 1 ¨dpoBÆ);
(* *** Goal "2" *** *)
a (PC_T1 "hol" cases_tac ¨s = {dpoT}Æ THEN_TRY asm_rewrite_tac[]);
(* *** Goal "2.1" *** *)
a (∂_tac ¨dpoTÆ THEN asm_rewrite_tac []
	THEN REPEAT strip_tac);
(* *** Goal "2.2" *** *)
a (PC_T1 "hol" cases_tac ¨s = {}Æ THEN_TRY asm_rewrite_tac[]);
(* *** Goal "2.2.1" *** *)
a (∂_tac ¨dpoTÆ THEN_TRY asm_rewrite_tac[]);
(* *** Goal "2.2.2" *** *)
a (PC_T1 "hol" cases_tac ¨∂e∑ s = {dpoE e} Æ THEN_TRY asm_rewrite_tac[]);
(* *** Goal "2.2.2.1" *** *)
a (∂_tac ¨dpoE eÆ THEN_TRY asm_rewrite_tac[]
	THEN REPEAT strip_tac THEN_TRY asm_rewrite_tac[]);
(* *** Goal "2.2.2.1.1" *** *)
a (DROP_ASM_T ¨≥ dpoE e = xÆ ante_tac THEN asm_rewrite_tac[]);
(* *** Goal "2.2.2.1.2" *** *)
a (spec_nth_asm_tac 2 ¨dpoE eÆ);
(* *** Goal "2.2.2.2" *** *)
a (cases_tac ¨∂f g∑ ≥ f = g ± dpoE f ç s ± dpoE g ç sÆ THEN_TRY asm_rewrite_tac[]);
(* *** Goal "2.2.2.2.1" *** *)
a (∂_tac ¨dpoBÆ THEN_TRY asm_rewrite_tac[]
	THEN REPEAT strip_tac THEN_TRY asm_rewrite_tac[]);
a (spec_nth_asm_tac 1 ¨dpoE fÆ);
a (spec_nth_asm_tac 2 ¨dpoE gÆ);
a (POP_ASM_T ante_tac THEN asm_rewrite_tac[]);
(* *** Goal "2.2.2.2.2" *** *)
a (cases_tac ¨∂h∑ dpoE h ç sÆ THEN_TRY asm_rewrite_tac[]);
(* *** Goal "2.2.2.2.2.1" *** *)
a (∂_tac ¨dpoE hÆ THEN_TRY asm_rewrite_tac[]
	THEN REPEAT strip_tac THEN_TRY asm_rewrite_tac[]);
(* *** Goal "2.2.2.2.2.1.1" *** *)
a (asm_fc_tac[]);
a (LEMMA_T ¨s = {dpoE h; dpoT}Æ asm_tac
	THEN1 (asm_rewrite_tac [] THEN strip_tac));
(* *** Goal "2.2.2.2.2.1.1.1" *** *)
a (strip_asm_tac (µ_elim ¨x'Æ dpo_cases_thm)
	THEN_TRY asm_rewrite_tac[]);
(* *** Goal "2.2.2.2.2.1.1.1.1" *** *)
a (lemma_tac ¨x = dpoTÆ
	THEN1 (strip_asm_tac (µ_elim ¨xÆ dpo_cases_thm)
		THEN_TRY asm_rewrite_tac[]));
(* *** Goal "2.2.2.2.2.1.1.1.1.1" *** *)
a (var_elim_asm_tac ¨x = dpoBÆ);
(* *** Goal "2.2.2.2.2.1.1.1.1.2" *** *)
a (var_elim_asm_tac ¨x = dpoE eÆ);
a (var_elim_asm_tac ¨x' = dpoTÆ);
a (all_asm_fc_tac[]);
a (var_elim_asm_tac ¨e = hÆ);
(* *** Goal "2.2.2.2.2.1.1.1.1.3" *** *)
a (var_elim_asm_tac ¨x = dpoTÆ);
(* *** Goal "2.2.2.2.2.1.1.1.2" *** *)
a (var_elim_asm_tac ¨x' = dpoE eÆ);
a (REPEAT strip_tac);
(* *** Goal "2.2.2.2.2.1.1.1.2.1" *** *)
a (all_asm_fc_tac[]);
(* *** Goal "2.2.2.2.2.1.1.1.2.2" *** *)
a (asm_rewrite_tac[]);
(* *** Goal "2.2.2.2.2.1.1.2" *** *)
a (var_elim_asm_tac ¨s = {dpoE h; dpoT}Æ);
(* *** Goal "2.2.2.2.2.1.1.2.1" *** *)
a (DROP_ASM_T ¨≥ dpoE h = xÆ ante_tac
	THEN asm_rewrite_tac[]);
(* *** Goal "2.2.2.2.2.1.1.2.2" *** *)
a (DROP_ASM_T ¨≥ dpoE h = xÆ ante_tac
	THEN asm_rewrite_tac[]);
(* *** Goal "2.2.2.2.2.1.2" *** *)
a (spec_nth_asm_tac 2 ¨dpoE hÆ);
(* *** Goal "2.2.2.2.2.2" *** *)
a (swap_nth_asm_concl_tac 4
	THEN rewrite_tac[]
	THEN contr_tac);
a (strip_asm_tac (µ_elim ¨xÆ dpo_cases_thm));
(* *** Goal "2.2.2.2.2.2.1" *** *)
a (var_elim_asm_tac ¨x = dpoBÆ);
(* *** Goal "2.2.2.2.2.2.2" *** *)
a (var_elim_asm_tac ¨x = dpoTÆ);
a (DROP_NTH_ASM_T 6 ante_tac
	THEN asm_rewrite_tac[]
	THEN contr_tac);
(* *** Goal "2.2.2.2.2.2.2.1" *** *)
a (strip_asm_tac (µ_elim ¨xÆ dpo_cases_thm));
(* *** Goal "2.2.2.2.2.2.2.1.1" *** *)
a (var_elim_asm_tac ¨x = dpoBÆ);
(* *** Goal "2.2.2.2.2.2.2.1.2" *** *)
a (var_elim_asm_tac ¨x = dpoE eÆ);
a (all_asm_fc_tac[]);
(* *** Goal "2.2.2.2.2.2.2.2" *** *)
a (POP_ASM_T ante_tac THEN asm_rewrite_tac[]);
(* *** Goal "2.2.2.2.2.2.3" *** *)
a (var_elim_asm_tac ¨x = dpoE eÆ);
a (all_asm_fc_tac[]);
val dpo_glbs_exist_thm = save_pop_thm "dpo_glbs_exist_thm";

set_goal([], ¨LubsExist DpoÆ);
a (rewrite_tac [get_spec ¨LubsExistÆ, get_spec ¨IsLubÆ, get_spec ¨IsUbÆ, get_spec ¨DpoÆ]
	THEN REPEAT strip_tac);
a (cases_tac ¨dpoT ç sÆ THEN_TRY asm_rewrite_tac[]);
(* *** Goal "1" *** *)
a (∂_tac ¨dpoTÆ THEN_TRY asm_rewrite_tac[]
	THEN REPEAT strip_tac);
a (spec_nth_asm_tac 2 ¨dpoTÆ);
(* *** Goal "2" *** *)
a (PC_T1 "hol" cases_tac ¨s = {dpoB}Æ THEN_TRY asm_rewrite_tac[]);
(* *** Goal "2.1" *** *)
a (∂_tac ¨dpoBÆ THEN asm_rewrite_tac []
	THEN REPEAT strip_tac);
(* *** Goal "2.2" *** *)
a (PC_T1 "hol" cases_tac ¨s = {}Æ THEN_TRY asm_rewrite_tac[]);
(* *** Goal "2.2.1" *** *)
a (∂_tac ¨dpoBÆ THEN_TRY asm_rewrite_tac[]);
(* *** Goal "2.2.2" *** *)
a (PC_T1 "hol" cases_tac ¨∂f∑ s = {dpoE f} Æ THEN_TRY asm_rewrite_tac[]);
(* *** Goal "2.2.2.1" *** *)
a (∂_tac ¨dpoE fÆ THEN_TRY asm_rewrite_tac[]
	THEN REPEAT strip_tac THEN_TRY asm_rewrite_tac[]);
a (spec_nth_asm_tac 2 ¨dpoE fÆ);
(* *** Goal "2.2.2.2" *** *)
a (cases_tac ¨∂f g∑ ≥ f = g ± dpoE f ç s ± dpoE g ç sÆ THEN_TRY asm_rewrite_tac[]);
(* *** Goal "2.2.2.2.1" *** *)
a (∂_tac ¨dpoTÆ THEN_TRY asm_rewrite_tac[]
	THEN REPEAT strip_tac THEN_TRY asm_rewrite_tac[]);
a (spec_nth_asm_tac 2 ¨dpoE fÆ);
a (spec_nth_asm_tac 3 ¨dpoE gÆ);
a (POP_ASM_T ante_tac THEN SYM_ASMS_T rewrite_tac);
(* *** Goal "2.2.2.2.2" *** *)
a (cases_tac ¨∂h∑ dpoE h ç sÆ THEN_TRY asm_rewrite_tac[]);
(* *** Goal "2.2.2.2.2.1" *** *)
a (∂_tac ¨dpoE hÆ THEN_TRY asm_rewrite_tac[]
	THEN REPEAT strip_tac THEN_TRY asm_rewrite_tac[]);
(* *** Goal "2.2.2.2.2.1.1" *** *)
a (asm_fc_tac[]);
a (LEMMA_T ¨s = {dpoE h; dpoB}Æ asm_tac
	THEN1 (asm_rewrite_tac [] THEN strip_tac));
(* *** Goal "2.2.2.2.2.1.1.1" *** *)
a (strip_asm_tac (µ_elim ¨x'Æ dpo_cases_thm)
	THEN_TRY asm_rewrite_tac[]);
(* *** Goal "2.2.2.2.2.1.1.1.1" *** *)
a (lemma_tac ¨x = dpoBÆ
	THEN1 (strip_asm_tac (µ_elim ¨xÆ dpo_cases_thm)
		THEN_TRY asm_rewrite_tac[]));
(* *** Goal "2.2.2.2.2.1.1.1.1.1" *** *)
a (var_elim_asm_tac ¨x = dpoTÆ);
(* *** Goal "2.2.2.2.2.1.1.1.1.2" *** *)
a (var_elim_asm_tac ¨x = dpoE eÆ);
a (var_elim_asm_tac ¨x' = dpoBÆ);
a (all_asm_fc_tac[]);
a (var_elim_asm_tac ¨e = hÆ);
(* *** Goal "2.2.2.2.2.1.1.1.1.3" *** *)
a (var_elim_asm_tac ¨x = dpoBÆ);
(* *** Goal "2.2.2.2.2.1.1.1.2" *** *)
a (var_elim_asm_tac ¨x' = dpoE eÆ);
a (REPEAT strip_tac);
(* *** Goal "2.2.2.2.2.1.1.1.2.1" *** *)
a (all_asm_fc_tac[]);
a (var_elim_asm_tac ¨e = hÆ);
(* *** Goal "2.2.2.2.2.1.1.2" *** *)
a (var_elim_asm_tac ¨s = {dpoE h; dpoB}Æ);
(* *** Goal "2.2.2.2.2.1.2" *** *)
a (spec_nth_asm_tac 2 ¨dpoE hÆ);
(* *** Goal "2.2.2.2.2.2" *** *)
a (swap_nth_asm_concl_tac 4
	THEN rewrite_tac[]
	THEN contr_tac);
a (strip_asm_tac (µ_elim ¨xÆ dpo_cases_thm));
(* *** Goal "2.2.2.2.2.2.1" *** *)
a (var_elim_asm_tac ¨x = dpoBÆ);
a (DROP_NTH_ASM_T 6 ante_tac
	THEN asm_rewrite_tac[]
	THEN contr_tac);
(* *** Goal "2.2.2.2.2.2.1.1" *** *)
a (strip_asm_tac (µ_elim ¨xÆ dpo_cases_thm));
(* *** Goal "2.2.2.2.2.2.1.1.1" *** *)
a (var_elim_asm_tac ¨x = dpoTÆ);
(* *** Goal "2.2.2.2.2.2.1.1.2" *** *)
a (var_elim_asm_tac ¨x = dpoE eÆ);
a (all_asm_fc_tac[]);
(* *** Goal "2.2.2.2.2.2.1.2" *** *)
a (var_elim_asm_tac ¨x = dpoBÆ);
(* *** Goal "2.2.2.2.2.2.2" *** *)
a (var_elim_asm_tac ¨x = dpoTÆ);
(* *** Goal "2.2.2.2.2.2.3" *** *)
a (var_elim_asm_tac ¨x = dpoE eÆ);
a (all_asm_fc_tac[]);
val dpo_lubs_exist_thm = save_pop_thm "dpo_lubs_exist_thm";
=TEX
}%ignore

\section{TRUTH VALUES}

I am uncertain at this point whether to work with three or four truth values, so both of these are provided for here.

\subsection{Three Valued}

=SML
declare_type_abbrev("€TTV›", [], îBOOL OPTÆ);
=TEX

πHOLCONST
‹ €pTrue› : TTV
˜¸¸¸¸¸¸¸¸¸¸¸
‹ pTrue = Value T
∞

πHOLCONST
‹ €pFalse› : TTV
˜¸¸¸¸¸¸¸¸¸¸¸
‹ pFalse = Value F
∞

πHOLCONST
‹ €pU› : TTV
˜¸¸¸¸¸¸¸¸¸¸¸
‹ pU = Undefined
∞

=GFT
€tv_cases_thm› =
	Ù µ x∑ x = pTrue ≤ x = pFalse ≤ x = pU

€tv_distinct_clauses› =
	Ù ≥ pTrue = pFalse
             ± ≥ pTrue = pU
             ± ≥ pFalse = pTrue
             ± ≥ pFalse = pU
             ± ≥ pU = pTrue
             ± ≥ pU = pFalse
=TEX

\ignore{
=SML
set_merge_pcs ["rbjmisc", "'GS1", "'misc2"];

set_goal([], ¨µx∑ x = pTrue ≤ x = pFalse ≤ x = pUÆ);
a (rewrite_tac (map get_spec [¨pTrueÆ, ¨pFalseÆ, ¨pUÆ]) THEN prove_tac[]);
a (ante_tac (µ_elim ¨xÆ opt_cases_thm));
a (PC_T "hol" strip_tac);
(* *** Goal "1" *** *)
a (POP_ASM_T ante_tac);
a (LEMMA_T ¨y = T ≤ y = FÆ (STRIP_THM_THEN asm_tac) THEN1 prove_tac[]
	THEN var_elim_nth_asm_tac 1
	THEN strip_tac);
val tv_cases_thm = save_pop_thm "tv_cases_thm";

set_goal([], ¨≥ pTrue = pFalse
	± ≥ pTrue = pU
	± ≥ pFalse = pTrue
	± ≥ pFalse = pU
	± ≥ pU = pTrue
	± ≥ pU = pFalse
Æ);
a (rewrite_tac (map get_spec [¨pTrueÆ, ¨pFalseÆ, ¨pUÆ]));
val tv_distinct_clauses = save_pop_thm "tv_distinct_clauses";

add_pc_thms "'misc2" (map get_spec [] @ [tv_distinct_clauses]);
set_merge_pcs ["rbjmisc", "'GS1", "'misc2"];
=TEX
}%ignore

=SML
declare_infix(300, "ºâtâ3");
=TEX

=SML
declare_type_abbrev ("REL", ["'a"], î'a ≠ 'a ≠ BOOLÆ);
=TEX

First an ordering on the ``truth values'' is defined.

πHOLCONST
‹ €$ºâtâ3› : TTV REL
˜¸¸¸¸¸¸¸¸¸¸¸
‹ µ t1 t2∑ 
‹	t1 ºâtâ3 t2 § t1 = t2 ≤ t1 = pU	
∞

=GFT
€ºâtâ3_refl_thm› =
	Ù µ x∑ x ºâtâ3 x

€ºâtâ3_trans_thm› =
	Ù µ x y z∑ x ºâtâ3 y ± y ºâtâ3 z ¥ x ºâtâ3 z

€ºâtâ3_antisym_thm› =
	Ù µ x y∑ x ºâtâ3 y ± y ºâtâ3 x ¥ x = y

€ºâtâ3_partialorder_thm› =
	Ù µ Y∑ PartialOrder (Y, $ºâtâ3)

€ºâtâ3_clauses› =
   Ù pU ºâtâ3 pTrue
       ± pU ºâtâ3 pFalse
       ± ≥ pTrue ºâtâ3 pU
       ± ≥ pFalse ºâtâ3 pU
       ± ≥ pFalse ºâtâ3 pTrue
       ± ≥ pTrue ºâtâ3 pFalse

€lin_ºâtâ3_lemma› =
   Ù µ Y∑ LinearOrder (Y, $ºâtâ3) § ≥ pTrue ç Y ≤ ≥ pFalse ç Y

€lin_ºâtâ3_cases_lemma› =
   Ù µ Y
     ∑ LinearOrder (Y, $ºâtâ3)
         § Y = {}
           ≤ Y = {pU}
           ≤ Y = {pTrue}
           ≤ Y = {pFalse}
           ≤ Y = {pU; pTrue}
           ≤ Y = {pU; pFalse}

€ºâtâ3_isub_cases_lemma› =
   Ù µ Y
     ∑ IsUb $ºâtâ3 {} = (Ã x∑ T)
         ± IsUb $ºâtâ3 {pU} = (Ã x∑ T)
         ± IsUb $ºâtâ3 {pTrue} = (Ã x∑ x = pTrue)
         ± IsUb $ºâtâ3 {pFalse} = (Ã x∑ x = pFalse)
         ± IsUb $ºâtâ3 {pU; pTrue} = (Ã x∑ x = pTrue)
         ± IsUb $ºâtâ3 {pU; pFalse} = (Ã x∑ x = pFalse)

€ºâtâ3_islub_clauses› =
   Ù µ Y
     ∑ IsLub $ºâtâ3 {} pU
         ± IsLub $ºâtâ3 {pU} pU
         ± IsLub $ºâtâ3 {pTrue} pTrue
         ± IsLub $ºâtâ3 {pFalse} pFalse
         ± IsLub $ºâtâ3 {pU; pTrue} pTrue
         ± IsLub $ºâtâ3 {pU; pFalse} pFalse

€chaincomplete_ºâtâ3_kemma› =
	Ù ChainComplete (Universe, $ºâtâ3)

€ccrpou_ºâtâ3_thm› =
	Ù CcRpoU $ºâtâ3
=TEX

\ignore{
=SML
set_goal([], ¨µx∑ x ºâtâ3 xÆ);
a (rewrite_tac [get_spec ¨$ºâtâ3Æ]);
val ºâtâ3_refl_thm = save_pop_thm "ºâtâ3_refl_thm";

set_goal([], ¨µx y z∑ x ºâtâ3 y ± y ºâtâ3 z ¥ x ºâtâ3 zÆ);
a (rewrite_tac [get_spec ¨$ºâtâ3Æ]
	THEN REPEAT strip_tac
	THEN_TRY asm_rewrite_tac[]);
a (all_var_elim_asm_tac);
val ºâtâ3_trans_thm = save_pop_thm "ºâtâ3_trans_thm";

set_goal([], ¨µx y∑ x ºâtâ3 y ± y ºâtâ3 x ¥ x = yÆ);
a (rewrite_tac [get_spec ¨$ºâtâ3Æ]
	THEN REPEAT strip_tac
	THEN_TRY asm_rewrite_tac[]);
val ºâtâ3_antisym_thm = save_pop_thm "ºâtâ3_antisym_thm";

set_goal([], ¨(µx∑ pU ºâtâ3 x)
	± ≥ pTrue ºâtâ3 pU
	± ≥ pFalse ºâtâ3 pU
	± ≥ pFalse ºâtâ3 pTrue
	± ≥ pTrue ºâtâ3 pFalseÆ);
a (rewrite_tac [get_spec ¨$ºâtâ3Æ] THEN prove_tac[]);
val ºâtâ3_clauses = save_pop_thm "ºâtâ3_clauses";

add_pc_thms "'misc2" (map get_spec [] @ [ºâtâ3_refl_thm, ºâtâ3_clauses]);
set_merge_pcs ["rbjmisc", "'GS1", "'misc2"];

set_goal([], ¨µY∑ PartialOrder (Y, $ºâtâ3)Æ);
a (rewrite_tac (map get_spec [¨PartialOrderÆ, ¨AntisymÆ, ¨TransÆ])
	THEN contr_tac);
a (all_fc_tac [ºâtâ3_antisym_thm]);
a (all_fc_tac [ºâtâ3_trans_thm]);
val ºâtâ3_partialorder_thm = save_pop_thm "ºâtâ3_partialorder_thm";

set_goal([], ¨µY∑ LinearOrder (Y, $ºâtâ3) § ≥ pTrue ç Y ≤ ≥ pFalse ç YÆ);
a (rewrite_tac [get_spec ¨LinearOrderÆ, get_spec ¨TrichÆ, ºâtâ3_partialorder_thm]
	THEN contr_tac);
(* *** Goal "1" *** *)
a (REPEAT (asm_fc_tac[]));
(* *** Goal "2" *** *)
a (strip_asm_tac (list_µ_elim [¨xÆ] tv_cases_thm)
	THEN asm_prove_tac[]);
a (strip_asm_tac (list_µ_elim [¨yÆ] tv_cases_thm)
	THEN asm_prove_tac[]);
(* *** Goal "3" *** *)
a (strip_asm_tac (list_µ_elim [¨xÆ] tv_cases_thm)
	THEN asm_prove_tac[]);
a (strip_asm_tac (list_µ_elim [¨yÆ] tv_cases_thm)
	THEN asm_prove_tac[]);
val lin_ºâtâ3_lemma = save_pop_thm "lin_ºâtâ3_lemma";

set_merge_pcs ["rbjmisc", "'GS1", "'misc2"];

set_goal([], ¨µY∑ LinearOrder (Y, $ºâtâ3) §
	  Y = {}
	≤ Y = {pU} ≤ Y = {pTrue} ≤ Y = {pFalse}
	≤ Y = {pU; pTrue} ≤ Y = {pU; pFalse}Æ);
a (rewrite_tac [lin_ºâtâ3_lemma] THEN REPEAT µ_tac);
a (		cases_tac ¨pTrue ç YÆ
	THEN	cases_tac ¨pFalse ç YÆ
	THEN	cases_tac ¨pU ç YÆ
	THEN_TRY asm_rewrite_tac[]);
(* *** Goal "1" *** *)
a (contr_tac THEN var_elim_nth_asm_tac 1);
(* *** Goal "2" *** *)
a (contr_tac THEN var_elim_nth_asm_tac 1);
(* *** Goal "3" *** *)
set_merge_pcs ["rbjmisc1", "'GS1", "'misc2"];
a (LEMMA_T ¨Y = {pU; pTrue}Æ asm_tac
	THEN1 (asm_rewrite_tac[]
		THEN µ_tac
		THEN (strip_asm_tac (µ_elim ¨x:TTVÆ tv_cases_thm)
		THEN asm_rewrite_tac[]))
	THEN asm_rewrite_tac[]);
(* *** Goal "4" *** *)
a (LEMMA_T ¨Y = {pTrue}Æ asm_tac
	THEN1 (asm_rewrite_tac[]
		THEN µ_tac
		THEN (strip_asm_tac (µ_elim ¨x:TTVÆ tv_cases_thm)
		THEN asm_rewrite_tac[]))
	THEN asm_rewrite_tac[]);
(* *** Goal "5" *** *)
a (LEMMA_T ¨Y = {pU; pFalse}Æ asm_tac
	THEN1 (asm_rewrite_tac[]
		THEN µ_tac
		THEN (strip_asm_tac (µ_elim ¨x:TTVÆ tv_cases_thm)
		THEN asm_rewrite_tac[]))
	THEN asm_rewrite_tac[]);
(* *** Goal "6" *** *)
a (LEMMA_T ¨Y = {pFalse}Æ asm_tac
	THEN1 (asm_rewrite_tac[]
		THEN µ_tac
		THEN (strip_asm_tac (µ_elim ¨x:TTVÆ tv_cases_thm)
		THEN asm_rewrite_tac[]))
	THEN asm_rewrite_tac[]);
(* *** Goal "7" *** *)
a (LEMMA_T ¨Y = {pU}Æ asm_tac
	THEN1 (asm_rewrite_tac[]
		THEN µ_tac
		THEN (strip_asm_tac (µ_elim ¨x:TTVÆ tv_cases_thm)
		THEN asm_rewrite_tac[]))
	THEN asm_rewrite_tac[]);
(* *** Goal "8" *** *)
a (LEMMA_T ¨Y = {}Æ asm_tac
	THEN1 (asm_rewrite_tac[]
		THEN µ_tac
		THEN (strip_asm_tac (µ_elim ¨x:TTVÆ tv_cases_thm)
		THEN asm_rewrite_tac[]))
	THEN asm_rewrite_tac[]);
val lin_ºâtâ3_cases_lemma = pop_thm ();

set_goal([], ¨µY∑ 
	  IsUb $ºâtâ3 {} = (Ãx∑ T)
	± IsUb $ºâtâ3 {pU} = (Ãx∑ T) ± IsUb $ºâtâ3 {pTrue} = (Ãx∑ x = pTrue) ± IsUb $ºâtâ3 {pFalse} = (Ãx∑ x = pFalse)
	± IsUb $ºâtâ3 {pU; pTrue} = (Ãx∑ x = pTrue) ± IsUb $ºâtâ3 {pU; pFalse} = (Ãx∑ x = pFalse)Æ);
a (rewrite_tac [get_spec ¨IsUbÆ]);
a (REPEAT strip_tac THEN_TRY asm_rewrite_tac[]);
(* *** Goal "1" *** *)
a (spec_nth_asm_tac 1 ¨pTrueÆ);
a (strip_asm_tac (µ_elim ¨xÆ tv_cases_thm) THEN_TRY asm_rewrite_tac[]
	THEN var_elim_nth_asm_tac 1);
(* *** Goal "2" *** *)
a (spec_nth_asm_tac 1 ¨pFalseÆ);
a (strip_asm_tac (µ_elim ¨xÆ tv_cases_thm) THEN_TRY asm_rewrite_tac[]
	THEN var_elim_nth_asm_tac 1);
(* *** Goal "3" *** *)
a (spec_nth_asm_tac 1 ¨pTrueÆ);
a (strip_asm_tac (µ_elim ¨xÆ tv_cases_thm) THEN_TRY asm_rewrite_tac[]
	THEN var_elim_nth_asm_tac 1);
(* *** Goal "4" *** *)
a (spec_nth_asm_tac 1 ¨pFalseÆ);
a (strip_asm_tac (µ_elim ¨xÆ tv_cases_thm) THEN_TRY asm_rewrite_tac[]
	THEN var_elim_nth_asm_tac 1);
val ºâtâ3_isub_cases_lemma = pop_thm ();

set_goal([], ¨µY∑ 
	  IsLub $ºâtâ3 {} pU
	± IsLub $ºâtâ3 {pU} pU ± IsLub $ºâtâ3 {pTrue} pTrue ± IsLub $ºâtâ3 {pFalse} pFalse
	± IsLub $ºâtâ3 {pU; pTrue} pTrue ± IsLub $ºâtâ3 {pU; pFalse} pFalseÆ);
a (rewrite_tac [get_spec ¨IsLubÆ]);
a (rewrite_tac [ºâtâ3_isub_cases_lemma]);
a (REPEAT strip_tac THEN asm_rewrite_tac[]);
val ºâtâ3_islub_clauses = pop_thm ();

set_merge_pcs ["rbjmisc", "'GS1", "'misc2"];

set_goal([], ¨ChainComplete (Universe, $ºâtâ3)Æ);
a (rewrite_tac (map get_spec [¨ChainCompleteÆ]));
a (rewrite_tac [lin_ºâtâ3_cases_lemma]);
a (REPEAT strip_tac THEN asm_rewrite_tac[]);
a (∂_tac ¨pUÆ THEN rewrite_tac [ºâtâ3_islub_clauses]);
a (∂_tac ¨pUÆ THEN rewrite_tac [ºâtâ3_islub_clauses]);
a (∂_tac ¨pTrueÆ THEN rewrite_tac [ºâtâ3_islub_clauses]);
a (∂_tac ¨pFalseÆ THEN rewrite_tac [ºâtâ3_islub_clauses]);
a (∂_tac ¨pTrueÆ THEN rewrite_tac [ºâtâ3_islub_clauses]);
a (∂_tac ¨pFalseÆ THEN rewrite_tac [ºâtâ3_islub_clauses]);
val chaincomplete_ºâtâ3_kemma = pop_thm ();

set_goal([], ¨CcRpoU $ºâtâ3Æ);
a (rewrite_tac (map get_spec [¨CcRpoUÆ, ¨CcRpoÆ, ¨RpoÆ, ¨ReflÆ]
	@ [ºâtâ3_partialorder_thm, chaincomplete_ºâtâ3_kemma]));
val ccrpou_ºâtâ3_thm = save_pop_thm "ccrpou_ºâtâ3_thm";
=TEX
}%ignore

\subsection{Four Valued}

=SML
declare_type_abbrev("€FTV›", [], îBOOL DPOÆ);
=TEX

πHOLCONST
‹ €fTrue› : FTV
˜¸¸¸¸¸¸¸¸¸¸¸
‹ fTrue = dpoE T
∞

πHOLCONST
‹ €fFalse› : FTV
˜¸¸¸¸¸¸¸¸¸¸¸
‹ fFalse = dpoE F
∞

πHOLCONST
‹ €fB› : FTV
˜¸¸¸¸¸¸¸¸¸¸¸
‹ fB = dpoB
∞

πHOLCONST
‹ €fT› : FTV
˜¸¸¸¸¸¸¸¸¸¸¸
‹ fT = dpoT
∞

=GFT
€ftv_cases_thm› =
	Ù µ x∑ x = fTrue ≤ x = fFalse ≤ x = fB ≤ x = fT
€ftv_distinct_clauses› =
	Ù ≥ fTrue = fFalse
       ± ≥ fTrue = fB
       ± ≥ fTrue = fT
       ± ≥ fFalse = fTrue
       ± ≥ fFalse = fB
       ± ≥ fFalse = fT
       ± ≥ fB = fTrue
       ± ≥ fB = fFalse
       ± ≥ fB = fT
       ± ≥ fT = fTrue
       ± ≥ fT = fFalse
       ± ≥ fT = fB

€ftvs_cases_thm› =
   Ù µ x
     ∑ x = {}
         ≤ x = {fB}
         ≤ x = {fFalse}
         ≤ x = {fTrue}
         ≤ x = {fT}
         ≤ x = {fB; fFalse}
         ≤ x = {fB; fTrue}
         ≤ x = {fB; fT}
         ≤ x = {fFalse; fTrue}
         ≤ x = {fFalse; fT}
         ≤ x = {fTrue; fT}
         ≤ x = {fB; fFalse; fTrue}
         ≤ x = {fB; fFalse; fT}
         ≤ x = {fB; fTrue; fT}
         ≤ x = {fFalse; fTrue; fT}
         ≤ x = {fB; fFalse; fTrue; fT}
=TEX

\ignore{
=SML
set_merge_pcs ["rbjmisc1", "'GS1", "'misc2"];

set_goal([], ¨µx∑ x = fTrue ≤ x = fFalse ≤ x = fB ≤ x = fTÆ);
a (rewrite_tac (map get_spec [¨fTrueÆ, ¨fFalseÆ, ¨fBÆ, ¨fTÆ]) THEN strip_tac);
a (strip_asm_tac (µ_elim ¨xÆ dpo_cases_thm)
	THEN asm_rewrite_tac[]);
a (cases_tac ¨eÆ THEN asm_rewrite_tac[]);
val ftv_cases_thm = save_pop_thm "ftv_cases_thm";

set_goal([], ¨≥ fTrue = fFalse
	± ≥ fTrue = fB
	± ≥ fTrue = fT
	± ≥ fFalse = fTrue
	± ≥ fFalse = fB
	± ≥ fFalse = fT
	± ≥ fB = fTrue
	± ≥ fB = fFalse
	± ≥ fB = fT
	± ≥ fT = fTrue
	± ≥ fT = fFalse
	± ≥ fT = fB
Æ);
a (LEMMA_T ¨≥ F = TÆ asm_tac THEN1 prove_tac[]);
a (fc_tac [dpo_distinct_fc_clauses]);
a (rewrite_tac (map get_spec [¨fTrueÆ, ¨fFalseÆ, ¨fBÆ, ¨fTÆ]) THEN prove_tac[dpo_distinct_clauses]);
val ftv_distinct_clauses = save_pop_thm "ftv_distinct_clauses";

add_pc_thms "'misc2" (map get_spec [] @ [ftv_distinct_clauses]);
set_merge_pcs ["rbjmisc1", "'GS1", "'misc2"];

set_goal([], ¨µx∑
	x = {}
	≤ x = {fB}
	≤ x = {fFalse}
	≤ x = {fTrue}
	≤ x = {fT}
	≤ x = {fB; fFalse}
	≤ x = {fB; fTrue}
	≤ x = {fB; fT}
	≤ x = {fFalse; fTrue}
	≤ x = {fFalse; fT}
	≤ x = {fTrue; fT}
	≤ x = {fB; fFalse; fTrue}
	≤ x = {fB; fFalse; fT}
	≤ x = {fB; fTrue; fT}
	≤ x = {fFalse; fTrue; fT}
	≤ x = {fB; fFalse; fTrue; fT}
Æ);
a (	strip_tac);
a (	cases_tac ¨fTrue ç xÆ
	THEN	cases_tac ¨fFalse ç xÆ
	THEN	cases_tac ¨fB ç xÆ
	THEN	cases_tac ¨fT ç xÆ);
(* *** Goal "1" *** *)
a (LEMMA_T  ¨x = {fB; fFalse; fTrue; fT}Æ rewrite_thm_tac
	THEN1 PC_T1 "hol1" rewrite_tac[]
		THEN strip_tac);
a (strip_asm_tac (µ_elim ¨x'Æ ftv_cases_thm) THEN asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a (LEMMA_T  ¨x = {fB; fFalse; fTrue}Æ (PC_T1 "hol1" rewrite_thm_tac)
	THEN1 PC_T1 "hol1" rewrite_tac[]
		THEN strip_tac);
a (strip_asm_tac (µ_elim ¨x'Æ ftv_cases_thm) THEN asm_rewrite_tac[]);
(* *** Goal "3" *** *)
a (LEMMA_T  ¨x = {fFalse; fTrue; fT}Æ rewrite_thm_tac
	THEN1 PC_T1 "hol1" rewrite_tac[]
		THEN strip_tac);
a (strip_asm_tac (µ_elim ¨x'Æ ftv_cases_thm) THEN asm_rewrite_tac[]);
(* *** Goal "4" *** *)
a (LEMMA_T  ¨x = {fFalse; fTrue}Æ rewrite_thm_tac
	THEN1 PC_T1 "hol1" rewrite_tac[]
		THEN strip_tac);
a (strip_asm_tac (µ_elim ¨x'Æ ftv_cases_thm) THEN asm_rewrite_tac[]);
(* *** Goal "5" *** *)
a (LEMMA_T  ¨x = {fB; fTrue; fT}Æ rewrite_thm_tac
	THEN1 PC_T1 "hol1" rewrite_tac[]
		THEN strip_tac);
a (strip_asm_tac (µ_elim ¨x'Æ ftv_cases_thm) THEN asm_rewrite_tac[]);
(* *** Goal "6" *** *)
a (LEMMA_T  ¨x = {fB; fTrue}Æ rewrite_thm_tac
	THEN1 PC_T1 "hol1" rewrite_tac[]
		THEN strip_tac);
a (strip_asm_tac (µ_elim ¨x'Æ ftv_cases_thm) THEN asm_rewrite_tac[]);
(* *** Goal "7" *** *)
a (LEMMA_T  ¨x = {fTrue; fT}Æ rewrite_thm_tac
	THEN1 PC_T1 "hol1" rewrite_tac[]
		THEN strip_tac);
a (strip_asm_tac (µ_elim ¨x'Æ ftv_cases_thm) THEN asm_rewrite_tac[]);
(* *** Goal "8" *** *)
a (LEMMA_T  ¨x = {fTrue}Æ rewrite_thm_tac
	THEN1 PC_T1 "hol1" rewrite_tac[]
		THEN strip_tac);
a (strip_asm_tac (µ_elim ¨x'Æ ftv_cases_thm) THEN asm_rewrite_tac[]);
(* *** Goal "9" *** *)
a (LEMMA_T  ¨x = {fB; fFalse; fT}Æ rewrite_thm_tac
	THEN1 PC_T1 "hol1" rewrite_tac[]
		THEN strip_tac);
a (strip_asm_tac (µ_elim ¨x'Æ ftv_cases_thm) THEN asm_rewrite_tac[]);
(* *** Goal "10" *** *)
a (LEMMA_T  ¨x = {fB; fFalse}Æ rewrite_thm_tac
	THEN1 PC_T1 "hol1" rewrite_tac[]
		THEN strip_tac);
a (strip_asm_tac (µ_elim ¨x'Æ ftv_cases_thm) THEN asm_rewrite_tac[]);
(* *** Goal "11" *** *)
a (LEMMA_T  ¨x = {fFalse; fT}Æ rewrite_thm_tac
	THEN1 PC_T1 "hol1" rewrite_tac[]
		THEN strip_tac);
a (strip_asm_tac (µ_elim ¨x'Æ ftv_cases_thm) THEN asm_rewrite_tac[]);
(* *** Goal "12" *** *)
a (LEMMA_T  ¨x = {fFalse}Æ rewrite_thm_tac
	THEN1 PC_T1 "hol1" rewrite_tac[]
		THEN strip_tac);
a (strip_asm_tac (µ_elim ¨x'Æ ftv_cases_thm) THEN asm_rewrite_tac[]);
(* *** Goal "13" *** *)
a (LEMMA_T  ¨x = {fB; fT}Æ rewrite_thm_tac
	THEN1 PC_T1 "hol1" rewrite_tac[]
		THEN strip_tac);
a (strip_asm_tac (µ_elim ¨x'Æ ftv_cases_thm) THEN asm_rewrite_tac[]);
(* *** Goal "14" *** *)
a (LEMMA_T  ¨x = {fB}Æ rewrite_thm_tac
	THEN1 PC_T1 "hol1" rewrite_tac[]
		THEN strip_tac);
a (strip_asm_tac (µ_elim ¨x'Æ ftv_cases_thm) THEN asm_rewrite_tac[]);
(* *** Goal "15" *** *)
a (LEMMA_T  ¨x = {fT}Æ rewrite_thm_tac
	THEN1 PC_T1 "hol1" rewrite_tac[]
		THEN strip_tac);
a (strip_asm_tac (µ_elim ¨x'Æ ftv_cases_thm) THEN asm_rewrite_tac[]);
(* *** Goal "16" *** *)
a (LEMMA_T  ¨x = {}Æ rewrite_thm_tac
	THEN1 PC_T1 "hol1" rewrite_tac[]
		THEN strip_tac);
a (strip_asm_tac (µ_elim ¨x'Æ ftv_cases_thm) THEN asm_rewrite_tac[]);
val ftvs_cases_thm = save_pop_thm "ftvs_cases_thm";
=TEX
}%ignore

=SML
declare_infix(300, "ºâtâ4");
=TEX

Now an ordering on these truth values is defined.

πHOLCONST
‹ €$ºâtâ4› : FTV REL
˜¸¸¸¸¸¸¸¸¸¸¸
‹ µ t1 t2∑ 
‹	t1 ºâtâ4 t2 § t1 = t2 ≤ t1 = fB ≤ t2 = fT
∞

=GFT
€ºâtâ4_dpo_thm› =
	Ù $ºâtâ4 = Dpo

€ºâtâ4_refl_thm› =
	Ù µ x∑ x ºâtâ4 x

€ºâtâ4_trans_thm› =
	Ù µ x y z∑ x ºâtâ4 y ± y ºâtâ4 z ¥ x ºâtâ4 z

€ºâtâ4_antisym_thm› =
	Ù µ x y∑ x ºâtâ4 y ± y ºâtâ4 x ¥ x = y

€ºâtâ4_antisym_thm2› =
	Ù Antisym (Universe, $ºâtâ4)

€ft_fb_thm› =
	Ù µ x∑ (fT ºâtâ4 x § x = fT) ± (x ºâtâ4 fB § x = fB)

€ºâtâ4_partialorder_thm› =
	Ù µ Y∑ PartialOrder (Y, $ºâtâ4)

€ºâtâ4_lin_lemma› =
	Ù µ Y∑ LinearOrder (Y, $ºâtâ4) = (≥ fTrue ç Y ≤ ≥ fFalse ç Y)

€ºâtâ4_clauses› =
   Ù (µ x∑ fB ºâtâ4 x)
       ± (µ x∑ x ºâtâ4 fT)
       ± ≥ fTrue ºâtâ4 fB
       ± ≥ fFalse ºâtâ4 fB
       ± ≥ fT ºâtâ4 fB
       ± ≥ fFalse ºâtâ4 fTrue
       ± ≥ fT ºâtâ4 fTrue
       ± ≥ fTrue ºâtâ4 fFalse
       ± ≥ fT ºâtâ4 fFalse

€ºâtâ4_lin_cases_lemma› =
   Ù µ Y
     ∑ LinearOrder (Y, $ºâtâ4)
         = (Y = {}
           ≤ Y = {fB}
           ≤ Y = {fTrue}
           ≤ Y = {fFalse}
           ≤ Y = {fT}
           ≤ Y = {fB; fTrue}
           ≤ Y = {fB; fFalse}
           ≤ Y = {fB; fT}
           ≤ Y = {fTrue; fT}
           ≤ Y = {fFalse; fT}
           ≤ Y = {fB; fTrue; fT}
           ≤ Y = {fB; fFalse; fT})

€gt_false_true_lemma› =
   Ù µ x∑ fFalse ºâtâ4 x ± fTrue ºâtâ4 x ¥ x = fT

€lt_false_true_lemma› =
   Ù µ x∑ x ºâtâ4 fFalse ± x ºâtâ4 fTrue ¥ x = fB

€gt_ft_lemma› =
   Ù µ x∑ fT ºâtâ4 x ¥ x = fT

€lt_fb_lemma› =
   Ù µ x∑ x ºâtâ4 fB ¥ x = fB

€sg_ftrue_lemma› =
   Ù µ x∑ fTrue ºâtâ4 x ± ≥ x = fTrue ¥ x = fT

€sl_ftrue_lemma› =
   Ù µ x∑ x ºâtâ4 fTrue ± ≥ x = fTrue ¥ x = fB

€sg_ffalse_lemma› =
   Ù µ x∑ fFalse ºâtâ4 x ± ≥ x = fFalse ¥ x = fT

€sl_ffalse_lemma› =
   Ù µ x∑ x ºâtâ4 fFalse ± ≥ x = fFalse ¥ x = fB

€eq_ft_fc_clauses› =
   Ù µ x
     ∑ fFalse ºâtâ4 x ± ≥ x = fFalse
           ≤ fTrue ºâtâ4 x ± ≥ x = fTrue
           ≤ fT ºâtâ4 x
           ≤ fFalse ºâtâ4 x ± fTrue ºâtâ4 x
         ¥ x = fT

€eq_fb_fc_clauses› =
   Ù µ x
     ∑ x ºâtâ4 fFalse ± ≥ x = fFalse
           ≤ x ºâtâ4 fTrue ± ≥ x = fTrue
           ≤ x ºâtâ4 fB
           ≤ x ºâtâ4 fTrue ± x ºâtâ4 fFalse
         ¥ x = fB
€ºâtâ4_isub_clauses› =
   Ù (µx∑ IsUb {x} x)
	± IsUb $ºâtâ4 {} = (Ã x∑ T)
         ± IsUb $ºâtâ4 {fB} = (Ã x∑ T)
         ± IsUb $ºâtâ4 {fTrue} = (Ã x∑ x = fTrue ≤ x = fT)
         ± IsUb $ºâtâ4 {fFalse} = (Ã x∑ x = fFalse ≤ x = fT)
         ± IsUb $ºâtâ4 {fB; fTrue} = (Ã x∑ x = fTrue ≤ x = fT)
         ± IsUb $ºâtâ4 {fB; fFalse} = (Ã x∑ x = fFalse ≤ x = fT)
         ± IsUb $ºâtâ4 {fFalse; fTrue} = (Ã x∑ x = fT)
         ± IsUb $ºâtâ4 {fB; fFalse; fTrue} = (Ã x∑ x = fT)
         ± IsUb $ºâtâ4 {fT} = (Ã x∑ x = fT)
         ± IsUb $ºâtâ4 {fB; fT} = (Ã x∑ x = fT)
         ± IsUb $ºâtâ4 {fFalse; fT} = (Ã x∑ x = fT)
         ± IsUb $ºâtâ4 {fTrue; fT} = (Ã x∑ x = fT)
         ± IsUb $ºâtâ4 {fB; fFalse; fT} = (Ã x∑ x = fT)
         ± IsUb $ºâtâ4 {fB; fTrue; fT} = (Ã x∑ x = fT)
         ± IsUb $ºâtâ4 {fB; fFalse; fTrue; fT} = (Ã x∑ x = fT)
         ± IsUb $ºâtâ4 {fFalse; fTrue; fT} = (Ã x∑ x = fT)

€ºâtâ4_islb_clauses› =
   Ù (µ x∑ IsLb $ºâtâ4 {x} x)
       ± IsLb $ºâtâ4 {} = (Ã x∑ T)
       ± IsLb $ºâtâ4 {fB} = (Ã x∑ x = fB)
       ± IsLb $ºâtâ4 {fTrue} = (Ã x∑ x = fTrue ≤ x = fB)
       ± IsLb $ºâtâ4 {fFalse} = (Ã x∑ x = fFalse ≤ x = fB)
       ± IsLb $ºâtâ4 {fB; fTrue} = (Ã x∑ x = fB)
       ± IsLb $ºâtâ4 {fB; fFalse} = (Ã x∑ x = fB)
       ± IsLb $ºâtâ4 {fFalse; fTrue} = (Ã x∑ x = fB)
       ± IsLb $ºâtâ4 {fB; fFalse; fTrue} = (Ã x∑ x = fB)
       ± IsLb $ºâtâ4 {fT} = (Ã x∑ T)
       ± IsLb $ºâtâ4 {fB; fT} = (Ã x∑ x = fB)
       ± IsLb $ºâtâ4 {fFalse; fT} = (Ã x∑ x = fFalse ≤ x = fB)
       ± IsLb $ºâtâ4 {fTrue; fT} = (Ã x∑ x = fTrue ≤ x = fB)
       ± IsLb $ºâtâ4 {fB; fFalse; fT} = (Ã x∑ x = fB)
       ± IsLb $ºâtâ4 {fB; fTrue; fT} = (Ã x∑ x = fB)
       ± IsLb $ºâtâ4 {fB; fFalse; fTrue; fT} = (Ã x∑ x = fB)
       ± IsLb $ºâtâ4 {fFalse; fTrue; fT} = (Ã x∑ x = fB)

€ºâtâ4_islub_clauses› =
   Ù (µx∑ IsLub $ºâtâ4 {x} x)
         ± IsLub $ºâtâ4 {} fB
         ± IsLub $ºâtâ4 {fB; fTrue} fTrue
         ± IsLub $ºâtâ4 {fB; fFalse} fFalse
         ± IsLub $ºâtâ4 {fFalse; fTrue} fT
         ± IsLub $ºâtâ4 {fB; fFalse; fTrue} fT
         ± IsLub $ºâtâ4 {fB; fT} fT
         ± IsLub $ºâtâ4 {fB; fTrue; fT} fT
         ± IsLub $ºâtâ4 {fB; fFalse; fT} fT
         ± IsLub $ºâtâ4 {fB; fTrue; fFalse; fT} fT
         ± IsLub $ºâtâ4 {fTrue; fT} fT
         ± IsLub $ºâtâ4 {fFalse; fT} fT
         ± IsLub $ºâtâ4 {fTrue; fFalse; fT} fT

€ºâtâ4_isglb_clauses› =
   Ù (µ x∑ IsGlb $ºâtâ4 {x} x)
       ± IsGlb $ºâtâ4 {} fT
       ± IsGlb $ºâtâ4 {fB; fFalse} fB
       ± IsGlb $ºâtâ4 {fB; fTrue} fB
       ± IsGlb $ºâtâ4 {fFalse; fTrue} fB
       ± IsGlb $ºâtâ4 {fB; fFalse; fTrue} fB
       ± IsGlb $ºâtâ4 {fB; fT} fB
       ± IsGlb $ºâtâ4 {fB; fFalse; fT} fB
       ± IsGlb $ºâtâ4 {fB; fTrue; fT} fB
       ± IsGlb $ºâtâ4 {fB; fFalse; fTrue; fT} fB
       ± IsGlb $ºâtâ4 {fFalse; fT} fFalse
       ± IsGlb $ºâtâ4 {fTrue; fT} fTrue
       ± IsGlb $ºâtâ4 {fFalse; fTrue; fT} fB

€ºâtâ4_lin_cases_lemma› =
   Ù µ Y
     ∑ LinearOrder (Y, $ºâtâ4)
         § Y = {}
           ≤ Y = {fB}
           ≤ Y = {fTrue}
           ≤ Y = {fFalse}
           ≤ Y = {fT}
           ≤ Y = {fB; fTrue}
           ≤ Y = {fB; fFalse}
           ≤ Y = {fB; fT}
           ≤ Y = {fTrue; fT}
           ≤ Y = {fFalse; fT}
           ≤ Y = {fB; fTrue; fT}
           ≤ Y = {fB; fFalse; fT}

€ºâtâ4_glbs_exist_thm› =
	Ù GlbsExist $ºâtâ4

€ºâtâ4_lubs_exist_thm› =
	Ù LubsExist $ºâtâ4

€ºâtâ4_lub_islub_lemma› =
   Ù µ s e∑ Lub $ºâtâ4 s = e § IsLub $ºâtâ4 s e
=TEX

\ignore{
=SML
set_goal([], ¨$ºâtâ4 = DpoÆ);
a (rewrite_tac (map get_spec [¨$ºâtâ4Æ, ¨DpoÆ, ¨fBÆ, ¨fTÆ, ¨fTrueÆ, ¨fFalseÆ])
	THEN REPEAT strip_tac);
val ºâtâ4_dpo_thm = save_pop_thm "ºâtâ4_dpo_thm";

set_goal([], ¨µx∑ x ºâtâ4 xÆ);
a (rewrite_tac [get_spec ¨$ºâtâ4Æ]);
val ºâtâ4_refl_thm = save_pop_thm "ºâtâ4_refl_thm";

set_goal([], ¨µx y z∑ x ºâtâ4 y ± y ºâtâ4 z ¥ x ºâtâ4 zÆ);
a (rewrite_tac [get_spec ¨$ºâtâ4Æ]
	THEN REPEAT strip_tac
	THEN_TRY all_var_elim_asm_tac
	THEN_TRY asm_rewrite_tac[]);
val ºâtâ4_trans_thm = save_pop_thm "ºâtâ4_trans_thm";

set_goal([], ¨µx y∑ x ºâtâ4 y ± y ºâtâ4 x ¥ x = yÆ);
a (rewrite_tac [get_spec ¨$ºâtâ4Æ]
	THEN REPEAT strip_tac
	THEN_TRY all_var_elim_asm_tac
	THEN_TRY asm_rewrite_tac[]);
val ºâtâ4_antisym_thm = save_pop_thm "ºâtâ4_antisym_thm";

set_goal([], ¨Antisym (Universe, $ºâtâ4)Æ);
a (rewrite_tac[get_spec ¨AntisymÆ]
	THEN contr_tac
	THEN all_fc_tac [ºâtâ4_antisym_thm]);
val ºâtâ4_antisym_thm2 = save_pop_thm "ºâtâ4_antisym_thm2";

set_goal([], ¨(µx∑ fB ºâtâ4 x)
	± (µx∑ x ºâtâ4 fT)
	± ≥ fTrue ºâtâ4 fB
	± ≥ fFalse ºâtâ4 fB
	± ≥ fT ºâtâ4 fB
	± ≥ fFalse ºâtâ4 fTrue
	± ≥ fT ºâtâ4 fTrue
	± ≥ fTrue ºâtâ4 fFalse
	± ≥ fT ºâtâ4 fFalseÆ);
a (rewrite_tac [get_spec ¨$ºâtâ4Æ] THEN prove_tac[]);
val ºâtâ4_clauses = pop_thm ();

set_goal ([], ¨µx∑ (fT ºâtâ4 x § x = fT) ± (x ºâtâ4 fB § x = fB)Æ);
a (prove_tac [get_spec ¨$ºâtâ4Æ]);
val ft_fb_thm = save_pop_thm "ft_fb_thm";

add_pc_thms "'misc2" (map get_spec [] @ [ºâtâ4_refl_thm, ºâtâ4_clauses, ºâtâ4_antisym_thm2]);
set_merge_pcs ["rbjmisc", "'GS1", "'misc2"];

set_goal([], ¨µY∑ PartialOrder (Y, $ºâtâ4)Æ);
a (rewrite_tac (map get_spec [¨PartialOrderÆ, ¨AntisymÆ, ¨TransÆ])
	THEN contr_tac);
a (all_fc_tac [ºâtâ4_antisym_thm]);
a (all_fc_tac [ºâtâ4_trans_thm]);
val ºâtâ4_partialorder_thm = save_pop_thm "ºâtâ4_partialorder_thm";

set_goal([], ¨µY∑ LinearOrder (Y, $ºâtâ4) § ≥ fTrue ç Y ≤ ≥ fFalse ç YÆ);
a (rewrite_tac [get_spec ¨LinearOrderÆ, get_spec ¨TrichÆ, ºâtâ4_partialorder_thm]
	THEN contr_tac);
(* *** Goal "1" *** *)
a (REPEAT (asm_fc_tac[]));
(* *** Goal "2" *** *)
a (strip_asm_tac (list_µ_elim [¨xÆ] ftv_cases_thm)
	THEN asm_prove_tac[]);
a (strip_asm_tac (list_µ_elim [¨yÆ] ftv_cases_thm)
	THEN asm_prove_tac[]);
(* *** Goal "3" *** *)
a (strip_asm_tac (list_µ_elim [¨xÆ] ftv_cases_thm)
	THEN asm_prove_tac[]);
a (strip_asm_tac (list_µ_elim [¨yÆ] ftv_cases_thm)
	THEN asm_prove_tac[]);
val ºâtâ4_lin_lemma = save_pop_thm "ºâtâ4_lin_lemma";

add_pc_thms1 "'misc2" (map get_spec [] @ [ºâtâ4_partialorder_thm]);
set_merge_pcs ["rbjmisc", "'GS1", "'misc2"];

set_goal([], ¨µY∑ LinearOrder (Y, $ºâtâ4) §
	  Y = {}
	≤ Y = {fB} ≤ Y = {fTrue} ≤ Y = {fFalse} ≤ Y = {fT}
	≤ Y = {fB; fTrue} ≤ Y = {fB; fFalse} ≤ Y = {fB; fT}
	≤ Y = {fTrue; fT} ≤ Y = {fFalse; fT}
	≤ Y = {fB; fTrue; fT} ≤ Y = {fB; fFalse; fT}
Æ);
a (rewrite_tac [ºâtâ4_lin_lemma] THEN REPEAT µ_tac);
a (strip_asm_tac (µ_elim ¨YÆ ftvs_cases_thm)
	THEN asm_rewrite_tac[]
	THEN_TRY (conv_tac (MAP_C false_enum_eq_conv))
	THEN_TRY PC_T1 "hol1" prove_tac[ftv_distinct_clauses]);
val ºâtâ4_lin_cases_lemma = pop_thm ();

set_goal([], ¨µx∑ fFalse ºâtâ4 x ± fTrue ºâtâ4 x ¥ x = fTÆ);
a (µ_tac);
a (strip_asm_tac (µ_elim ¨xÆ ftv_cases_thm) THEN asm_rewrite_tac[]);
val gt_false_true_lemma = pop_thm ();

set_goal([], ¨µx∑ x ºâtâ4 fFalse ± x ºâtâ4 fTrue ¥ x = fBÆ);
a (µ_tac);
a (strip_asm_tac (µ_elim ¨xÆ ftv_cases_thm) THEN asm_rewrite_tac[]);
val lt_false_true_lemma = pop_thm ();

set_goal([], ¨µx∑ fT ºâtâ4 x ¥ x = fTÆ);
a (µ_tac);
a (strip_asm_tac (µ_elim ¨xÆ ftv_cases_thm) THEN asm_rewrite_tac[]);
val gt_ft_lemma = pop_thm ();

set_goal([], ¨µx∑ x ºâtâ4 fB ¥ x = fBÆ);
a (µ_tac);
a (strip_asm_tac (µ_elim ¨xÆ ftv_cases_thm) THEN asm_rewrite_tac[]);
val lt_fb_lemma = pop_thm ();

set_goal([], ¨µx∑ x ºâtâ4 fB ¥ x = fBÆ);
a (µ_tac);
a (strip_asm_tac (µ_elim ¨xÆ ftv_cases_thm) THEN asm_rewrite_tac[]);
val lt_fb_lemma = pop_thm ();

set_goal([], ¨µx∑ fTrue ºâtâ4 x ± ≥ x = fTrue ¥ x = fTÆ);
a (µ_tac);
a (strip_asm_tac (µ_elim ¨xÆ ftv_cases_thm) THEN asm_rewrite_tac[]);
val sg_ftrue_lemma = pop_thm ();

set_goal([], ¨µx∑ x ºâtâ4 fTrue ± ≥ x = fTrue ¥ x = fBÆ);
a (µ_tac);
a (strip_asm_tac (µ_elim ¨xÆ ftv_cases_thm) THEN asm_rewrite_tac[]);
val sl_ftrue_lemma = pop_thm ();

set_goal([], ¨µx∑ fFalse ºâtâ4 x ± ≥ x = fFalse ¥ x = fTÆ);
a (µ_tac);
a (strip_asm_tac (µ_elim ¨xÆ ftv_cases_thm) THEN asm_rewrite_tac[]);
val sg_ffalse_lemma = pop_thm ();

set_goal([], ¨µx∑ x ºâtâ4 fFalse ± ≥ x = fFalse ¥ x = fBÆ);
a (µ_tac);
a (strip_asm_tac (µ_elim ¨xÆ ftv_cases_thm) THEN asm_rewrite_tac[]);
val sl_ffalse_lemma = pop_thm ();

set_goal([], ¨µx∑ (fFalse ºâtâ4 x ± ≥ x = fFalse
		≤ fTrue ºâtâ4 x ± ≥ x = fTrue
		≤ fT ºâtâ4 x
		≤ fFalse ºâtâ4 x ± fTrue ºâtâ4 x) ¥ x = fTÆ);
a (REPEAT strip_tac THEN fc_tac [sg_ffalse_lemma, sg_ftrue_lemma, gt_ft_lemma, gt_false_true_lemma]);
val eq_ft_fc_clauses = save_pop_thm "eq_ft_fc_clauses";

set_goal([], ¨µx∑ ( x ºâtâ4 fFalse ± ≥ x = fFalse
		≤ x ºâtâ4 fTrue ± ≥ x = fTrue
		≤ x ºâtâ4 fB
		≤ x ºâtâ4 fTrue ± x ºâtâ4 fFalse) ¥ x = fBÆ);
a (REPEAT strip_tac THEN fc_tac [sl_ffalse_lemma, sl_ftrue_lemma, lt_fb_lemma, lt_false_true_lemma]);
val eq_fb_fc_clauses = save_pop_thm "eq_fb_fc_clauses";

set_merge_pcs ["rbjmisc1", "'GS1", "'misc2"];

set_goal([], ¨(µx∑ IsUb $ºâtâ4 {x} x)
	± IsUb $ºâtâ4 {} = (Ã x∑ T)
         ± IsUb $ºâtâ4 {fB} = (Ã x∑ T)
         ± IsUb $ºâtâ4 {fTrue} = (Ã x∑ x = fTrue ≤ x = fT)
         ± IsUb $ºâtâ4 {fFalse} = (Ã x∑ x = fFalse ≤ x = fT)
         ± IsUb $ºâtâ4 {fB; fTrue} = (Ã x∑ x = fTrue ≤ x = fT)
         ± IsUb $ºâtâ4 {fB; fFalse} = (Ã x∑ x = fFalse ≤ x = fT)
         ± IsUb $ºâtâ4 {fFalse; fTrue} = (Ã x∑ x = fT)
         ± IsUb $ºâtâ4 {fB; fFalse; fTrue} = (Ã x∑ x = fT)
         ± IsUb $ºâtâ4 {fT} = (Ã x∑ x = fT)
         ± IsUb $ºâtâ4 {fB; fT} = (Ã x∑ x = fT)
         ± IsUb $ºâtâ4 {fFalse; fT} = (Ã x∑ x = fT)
         ± IsUb $ºâtâ4 {fTrue; fT} = (Ã x∑ x = fT)
         ± IsUb $ºâtâ4 {fB; fFalse; fT} = (Ã x∑ x = fT)
         ± IsUb $ºâtâ4 {fB; fTrue; fT} = (Ã x∑ x = fT)
         ± IsUb $ºâtâ4 {fB; fFalse; fTrue; fT} = (Ã x∑ x = fT)
         ± IsUb $ºâtâ4 {fFalse; fTrue; fT} = (Ã x∑ x = fT)Æ);
a (rewrite_tac[get_spec ¨IsUbÆ]);
a (REPEAT strip_tac THEN_TRY asm_rewrite_tac[]
	THEN_TRY (spec_nth_asm_tac 1 ¨fTÆ THEN fc_tac[gt_ft_lemma]));
a ((spec_nth_asm_tac 2 ¨fTrueÆ) THEN fc_tac [eq_ft_fc_clauses]);
a ((spec_nth_asm_tac 2 ¨fFalseÆ) THEN fc_tac [eq_ft_fc_clauses]);
a ((spec_nth_asm_tac 2 ¨fTrueÆ) THEN fc_tac [eq_ft_fc_clauses]);
a ((spec_nth_asm_tac 2 ¨fFalseÆ) THEN fc_tac [eq_ft_fc_clauses]);
a ((spec_nth_asm_tac 3 ¨fFalseÆ) THEN fc_tac [eq_ft_fc_clauses]);
a ((spec_nth_asm_tac 6 ¨fTrueÆ));
a ((spec_nth_asm_tac 4 ¨fTrueÆ)
	THEN (spec_nth_asm_tac 5 ¨fFalseÆ)
	THEN fc_tac [eq_ft_fc_clauses]);
val ºâtâ4_isub_clauses = pop_thm ();

set_goal([], ¨(µx∑ IsLb $ºâtâ4 {x} x)
	± IsLb $ºâtâ4 {} = (Ã x∑ T)
         ± IsLb $ºâtâ4 {fB} = (Ã x∑ x = fB)
         ± IsLb $ºâtâ4 {fTrue} = (Ã x∑ x = fTrue ≤ x = fB)
         ± IsLb $ºâtâ4 {fFalse} = (Ã x∑ x = fFalse ≤ x = fB)
         ± IsLb $ºâtâ4 {fB; fTrue} = (Ã x∑ x = fB)
         ± IsLb $ºâtâ4 {fB; fFalse} = (Ã x∑ x = fB)
         ± IsLb $ºâtâ4 {fFalse; fTrue} = (Ã x∑ x = fB)
         ± IsLb $ºâtâ4 {fB; fFalse; fTrue} = (Ã x∑ x = fB)
         ± IsLb $ºâtâ4 {fT} = (Ã x∑ T)
         ± IsLb $ºâtâ4 {fB; fT} = (Ã x∑ x = fB)
         ± IsLb $ºâtâ4 {fFalse; fT} = (Ã x∑ x = fFalse ≤ x = fB)
         ± IsLb $ºâtâ4 {fTrue; fT} = (Ã x∑ x = fTrue ≤ x = fB)
         ± IsLb $ºâtâ4 {fB; fFalse; fT} = (Ã x∑ x = fB)
         ± IsLb $ºâtâ4 {fB; fTrue; fT} = (Ã x∑ x = fB)
         ± IsLb $ºâtâ4 {fB; fFalse; fTrue; fT} = (Ã x∑ x = fB)
         ± IsLb $ºâtâ4 {fFalse; fTrue; fT} = (Ã x∑ x = fB)Æ);
a (rewrite_tac[get_spec ¨IsLbÆ]);
a (REPEAT strip_tac THEN_TRY asm_rewrite_tac[]
	THEN_TRY (spec_nth_asm_tac 1 ¨fBÆ THEN fc_tac[lt_fb_lemma]));
a ((spec_nth_asm_tac 2 ¨fTrueÆ) THEN fc_tac [eq_fb_fc_clauses]);
a ((spec_nth_asm_tac 2 ¨fFalseÆ) THEN fc_tac [eq_fb_fc_clauses]);
a ((spec_nth_asm_tac 3 ¨fTrueÆ) THEN (spec_nth_asm_tac 4 ¨fFalseÆ)
	THEN fc_tac [eq_fb_fc_clauses]);
a ((spec_nth_asm_tac 2 ¨fFalseÆ) THEN fc_tac [eq_fb_fc_clauses]);
a ((spec_nth_asm_tac 2 ¨fTrueÆ) THEN fc_tac [eq_fb_fc_clauses]);
a ((spec_nth_asm_tac 4 ¨fTrueÆ)
	THEN (spec_nth_asm_tac 5 ¨fFalseÆ)
	THEN fc_tac [eq_fb_fc_clauses]);
val ºâtâ4_islb_clauses = pop_thm ();

set_goal([], ¨(µx∑ IsLub $ºâtâ4 {x} x)
         ± IsLub $ºâtâ4 {} fB
         ± IsLub $ºâtâ4 {fB; fFalse} fFalse
         ± IsLub $ºâtâ4 {fB; fTrue} fTrue
         ± IsLub $ºâtâ4 {fFalse; fTrue} fT
         ± IsLub $ºâtâ4 {fB; fFalse; fTrue} fT
         ± IsLub $ºâtâ4 {fB; fT} fT
         ± IsLub $ºâtâ4 {fB; fFalse; fT} fT
         ± IsLub $ºâtâ4 {fB; fTrue; fT} fT
         ± IsLub $ºâtâ4 {fB; fFalse; fTrue; fT} fT
         ± IsLub $ºâtâ4 {fFalse; fT} fT
         ± IsLub $ºâtâ4 {fTrue; fT} fT
         ± IsLub $ºâtâ4 {fFalse; fTrue; fT} fTÆ);
a (rewrite_tac [get_spec ¨IsLubÆ, ºâtâ4_isub_clauses]
	THEN REPEAT strip_tac THEN_TRY asm_rewrite_tac[ºâtâ4_isub_clauses]);
a (fc_tac [get_spec ¨IsUbÆ]);
val ºâtâ4_islub_clauses = pop_thm ();

set_goal([], ¨(µx∑ IsGlb $ºâtâ4 {x} x)
         ± IsGlb $ºâtâ4 {} fT
         ± IsGlb $ºâtâ4 {fB; fFalse} fB
         ± IsGlb $ºâtâ4 {fB; fTrue} fB
         ± IsGlb $ºâtâ4 {fFalse; fTrue} fB
         ± IsGlb $ºâtâ4 {fB; fFalse; fTrue} fB
         ± IsGlb $ºâtâ4 {fB; fT} fB
         ± IsGlb $ºâtâ4 {fB; fFalse; fT} fB
         ± IsGlb $ºâtâ4 {fB; fTrue; fT} fB
         ± IsGlb $ºâtâ4 {fB; fFalse; fTrue; fT} fB
         ± IsGlb $ºâtâ4 {fFalse; fT} fFalse
         ± IsGlb $ºâtâ4 {fTrue; fT} fTrue
         ± IsGlb $ºâtâ4 {fFalse; fTrue; fT} fBÆ);
a (rewrite_tac [get_spec ¨IsGlbÆ, ºâtâ4_islb_clauses]
	THEN REPEAT strip_tac THEN_TRY asm_rewrite_tac[ºâtâ4_islb_clauses]);
a (fc_tac [get_spec ¨IsLbÆ]);
val ºâtâ4_isglb_clauses = pop_thm ();

set_goal([], ¨GlbsExist $ºâtâ4Æ);
a (rewrite_tac[ºâtâ4_dpo_thm, dpo_glbs_exist_thm]);
val ºâtâ4_glbs_exist_thm = save_pop_thm "ºâtâ4_glbs_exist_thm";

set_goal([], ¨LubsExist $ºâtâ4Æ);
a (rewrite_tac[ºâtâ4_dpo_thm, dpo_lubs_exist_thm]);
val ºâtâ4_lubs_exist_thm = save_pop_thm "ºâtâ4_lubs_exist_thm";

set_goal([], ¨µs e∑ Lub $ºâtâ4 s = e § IsLub $ºâtâ4 s eÆ);
a (REPEAT µ_tac);
a (asm_tac ºâtâ4_lubs_exist_thm);
a (fc_tac [lub_lub_lemma2]);
a (strip_asm_tac (prove_rule [] ¨PartialOrder (Universe, $ºâtâ4)Æ));
a (fc_tac [get_spec ¨PartialOrderÆ]);
a (fc_tac [lub_unique_lemma]);
a (REPEAT strip_tac);
(* *** Goal "1" *** *)
a (SPEC_NTH_ASM_T 4 ¨sÆ ante_tac
	THEN rewrite_tac[asm_rule (¨Lub $ºâtâ4 s = eÆ)]);
(* *** Goal "2" *** *)
a (spec_nth_asm_tac 4 ¨sÆ);
a (all_fc_tac [rewrite_rule [] (list_µ_elim [¨sÆ, ¨$ºâtâ4Æ] lub_unique_lemma)]);
val ºâtâ4_lub_islub_lemma = save_pop_thm "ºâtâ4_lub_islub_lemma";

set_goal([], ¨CRpoU $ºâtâ4Æ);
a (rewrite_tac [get_spec ¨CRpoUÆ, get_spec ¨RpoUÆ,
	ºâtâ4_glbs_exist_thm, ºâtâ4_lubs_exist_thm, get_spec ¨RpoÆ,
	ºâtâ4_partialorder_thm, get_spec ¨ReflÆ]);
val ºâtâ4_crpou_thm = save_pop_thm "ºâtâ4_crpou_thm";

add_pc_thms "'misc2" (map get_spec [] @ [ºâtâ4_isub_clauses, ºâtâ4_islub_clauses, ºâtâ4_islb_clauses, ºâtâ4_isglb_clauses]);
add_pc_thms1 "'misc2" (map get_spec [] @ [ºâtâ4_lubs_exist_thm, ºâtâ4_glbs_exist_thm, ºâtâ4_crpou_thm]);
set_merge_pcs ["rbjmisc", "'GS1", "'misc2"];
=TEX
}%ignore

=GFT
€ºâtâ4_lub_clauses› =
   Ù Lub $ºâtâ4 {} = fB
       ± Lub $ºâtâ4 {fT} = fT
       ± Lub $ºâtâ4 {fTrue} = fTrue
       ± Lub $ºâtâ4 {fTrue; fT} = fT
       ± Lub $ºâtâ4 {fFalse} = fFalse
       ± Lub $ºâtâ4 {fFalse; fT} = fT
       ± Lub $ºâtâ4 {fFalse; fTrue} = fT
       ± Lub $ºâtâ4 {fFalse; fTrue; fT} = fT
       ± Lub $ºâtâ4 {fB} = fB
       ± Lub $ºâtâ4 {fB; fT} = fT
       ± Lub $ºâtâ4 {fB; fTrue} = fTrue
       ± Lub $ºâtâ4 {fB; fTrue; fT} = fT
       ± Lub $ºâtâ4 {fB; fFalse} = fFalse
       ± Lub $ºâtâ4 {fB; fFalse; fT} = fT
       ± Lub $ºâtâ4 {fB; fFalse; fTrue} = fT
       ± Lub $ºâtâ4 {fB; fFalse; fTrue; fT} = fT

€ºâtâ4_lub_thm› =
   Ù µ s
     ∑ Lub $ºâtâ4 s
         = (if fT ç s
           then fT
           else if fTrue ç s
           then if fFalse ç s then fT else fTrue
           else if fFalse ç s
           then fFalse
           else fB)

€ºâtâ4_glb_clauses› =
   Ù Glb $ºâtâ4 {} = fT
       ± Glb $ºâtâ4 {fT} = fT
       ± Glb $ºâtâ4 {fTrue} = fTrue
       ± Glb $ºâtâ4 {fTrue; fT} = fTrue
       ± Glb $ºâtâ4 {fFalse} = fFalse
       ± Glb $ºâtâ4 {fFalse; fT} = fFalse
       ± Glb $ºâtâ4 {fFalse; fTrue} = fB
       ± Glb $ºâtâ4 {fFalse; fTrue; fT} = fB
       ± Glb $ºâtâ4 {fB} = fB
       ± Glb $ºâtâ4 {fB; fT} = fB
       ± Glb $ºâtâ4 {fB; fTrue} = fB
       ± Glb $ºâtâ4 {fB; fTrue; fT} = fB
       ± Glb $ºâtâ4 {fB; fFalse} = fB
       ± Glb $ºâtâ4 {fB; fFalse; fT} = fB
       ± Glb $ºâtâ4 {fB; fFalse; fTrue} = fB
       ± Glb $ºâtâ4 {fB; fFalse; fTrue; fT}
=TEX

\ignore{
=SML
set_goal([], ¨Lub $ºâtâ4 {} = fB
	± Lub $ºâtâ4 {fT} = fT
	± Lub $ºâtâ4 {fTrue} = fTrue
	± Lub $ºâtâ4 {fTrue; fT} = fT
	± Lub $ºâtâ4 {fFalse} = fFalse
	± Lub $ºâtâ4 {fFalse; fT} = fT
	± Lub $ºâtâ4 {fFalse; fTrue} = fT
	± Lub $ºâtâ4 {fFalse; fTrue; fT} = fT
	± Lub $ºâtâ4 {fB} = fB
	± Lub $ºâtâ4 {fB; fT} = fT
	± Lub $ºâtâ4 {fB; fTrue} = fTrue
	± Lub $ºâtâ4 {fB; fTrue; fT} = fT
	± Lub $ºâtâ4 {fB; fFalse} = fFalse
	± Lub $ºâtâ4 {fB; fFalse; fT} = fT
	± Lub $ºâtâ4 {fB; fFalse; fTrue} = fT
	± Lub $ºâtâ4 {fB; fFalse; fTrue; fT} = fTÆ);
a (asm_tac ºâtâ4_crpou_thm THEN fc_tac [islub_lub_crpou_lemma]);
a (MAP_EVERY asm_tac (strip_±_rule ºâtâ4_islub_clauses));
a (ASM_UFC_T rewrite_tac []); 
val ºâtâ4_lub_clauses = save_pop_thm "ºâtâ4_lub_clauses";

set_goal([], ¨µs∑ Lub $ºâtâ4 s =
	if fT ç s
	then	fT
	else	if fTrue ç s
		then	if fFalse ç s
			then fT
			else fTrue 
		else 	if fFalse ç s
			then fFalse
			else fBÆ);
a (strip_tac);
a (strip_asm_tac (µ_elim ¨sÆ ftvs_cases_thm)
	THEN asm_rewrite_tac [ºâtâ4_lub_clauses, ç_in_clauses]);
val ºâtâ4_lub_thm = save_pop_thm "ºâtâ4_lub_thm";

set_goal([], ¨Glb $ºâtâ4 {} = fT
	± Glb $ºâtâ4 {fT} = fT
	± Glb $ºâtâ4 {fTrue} = fTrue
	± Glb $ºâtâ4 {fTrue; fT} = fTrue
	± Glb $ºâtâ4 {fFalse} = fFalse
	± Glb $ºâtâ4 {fFalse; fT} = fFalse
	± Glb $ºâtâ4 {fFalse; fTrue} = fB
	± Glb $ºâtâ4 {fFalse; fTrue; fT} = fB
	± Glb $ºâtâ4 {fB} = fB
	± Glb $ºâtâ4 {fB; fT} = fB
	± Glb $ºâtâ4 {fB; fTrue} = fB
	± Glb $ºâtâ4 {fB; fTrue; fT} = fB
	± Glb $ºâtâ4 {fB; fFalse} = fB
	± Glb $ºâtâ4 {fB; fFalse; fT} = fB
	± Glb $ºâtâ4 {fB; fFalse; fTrue} = fB
	± Glb $ºâtâ4 {fB; fFalse; fTrue; fT} = fBÆ);
a (asm_tac ºâtâ4_crpou_thm THEN fc_tac [isglb_glb_crpou_lemma]);
a (MAP_EVERY asm_tac (strip_±_rule ºâtâ4_isglb_clauses));
a (ASM_UFC_T rewrite_tac []); 
val ºâtâ4_glb_clauses = save_pop_thm "ºâtâ4_glb_clauses";

add_pc_thms "'misc2" (map get_spec [] @ [ºâtâ4_lub_clauses, ºâtâ4_glb_clauses]);
set_merge_pcs ["rbjmisc", "'GS1", "'misc2"];
=TEX
}%ignore

The following definitions expresses compatibility of truth values.
This is useful when trying to obtain a boolean valued function as a total least fixed point of a monotonic four valued function.

I first define a notion of compatibility between truth values.

πHOLCONST
‹ €CompFTV› : FTV SET SET
˜¸¸¸¸¸¸¸¸¸¸¸
‹ CompFTV = {{}; {fB}; {fFalse}; {fTrue}; {fB; fFalse}; {fB; fTrue}}
∞

and its dual:

πHOLCONST
‹ €CoCompFTV› : FTV SET SET
˜¸¸¸¸¸¸¸¸¸¸¸
‹ CoCompFTV = {{}; {fT}; {fFalse}; {fTrue}; {fFalse; fT}; {fTrue; fT}}
∞

=GFT
€compftv_lemma› =
   Ù µ s
     ∑ s ç CompFTV § ≥ fT ç s ± (≥ fTrue ç s ≤ ≥ fFalse ç s)

€cocompftv_lemma› =
   Ù µ s
     ∑ s ç CoCompFTV § ≥ fB ç s ± (≥ fTrue ç s ≤ ≥ fFalse ç s)
=TEX
=GFT
€CompFTV_ç_clauses› =
   Ù {} ç CompFTV
       ± {fB} ç CompFTV
       ± {fFalse} ç CompFTV
       ± {fTrue} ç CompFTV
       ± ≥ {fT} ç CompFTV
       ± {fB; fFalse} ç CompFTV
       ± {fB; fTrue} ç CompFTV
       ± ≥ {fB; fT} ç CompFTV
       ± ≥ {fFalse; fTrue} ç CompFTV
       ± ≥ {fFalse; fT} ç CompFTV
       ± ≥ {fTrue; fT} ç CompFTV
       ± ≥ {fB; fFalse; fTrue} ç CompFTV
       ± ≥ {fB; fFalse; fT} ç CompFTV
       ± ≥ {fB; fTrue; fT} ç CompFTV
       ± ≥ {fFalse; fTrue; fT} ç CompFTV
       ± ≥ {fB; fFalse; fTrue; fT} ç CompFTV
=GFT
€CompFTV_Lub_lemma› =
   Ù µ s∑ s ç CompFTV § ≥ Lub $ºâtâ4 s = fT

€Lub_CompFTV_lemma› =
   Ù µ s∑ Lub $ºâtâ4 s = fT § ≥ s ç CompFTV
=TEX
=GFT
€CoCompFTV_Lub_lemma› =
   Ù µ s∑ s ç CoCompFTV § ≥ Glb $ºâtâ4 s = fB

€Glb_CoCompFTV_lemma› =
   Ù µ s∑ Glb $ºâtâ4 s = fB § ≥ s ç CoCompFTV
=TEX

\ignore{
=SML
set_goal([], ¨µs∑ s ç CompFTV § ≥ fT ç s ± (≥ fTrue ç s ≤ ≥ fFalse ç s)Æ);
a (µ_tac THEN rewrite_tac[get_spec ¨CompFTVÆ, ç_in_clauses]
	THEN strip_tac THEN strip_tac);
a (strip_tac THEN asm_rewrite_tac[ç_in_clauses]);
a (strip_asm_tac (µ_elim ¨sÆ ftvs_cases_thm)
	THEN asm_rewrite_tac[]);
val compftv_lemma = save_pop_thm "compftv_lemma";

set_goal([], ¨µs∑ s ç CoCompFTV § ≥ fB ç s ± (≥ fTrue ç s ≤ ≥ fFalse ç s)Æ);
a (µ_tac THEN rewrite_tac[get_spec ¨CoCompFTVÆ, ç_in_clauses]
	THEN REPEAT_N 2 strip_tac);
a (strip_tac THEN asm_rewrite_tac[ç_in_clauses]);
a (strip_asm_tac (µ_elim ¨sÆ ftvs_cases_thm)
	THEN asm_rewrite_tac[]);
val cocompftv_lemma = save_pop_thm "cocompftv_lemma";

set_goal([], ¨{} ç CompFTV
         ± {fB} ç CompFTV
         ± {fFalse} ç CompFTV
         ± {fTrue} ç CompFTV
         ± ≥ {fT} ç CompFTV
         ± {fB; fFalse} ç CompFTV
         ± {fB; fTrue} ç CompFTV
         ± ≥ {fB; fT} ç CompFTV
         ± ≥ {fFalse; fTrue} ç CompFTV
         ± ≥ {fFalse; fT} ç CompFTV
         ± ≥ {fTrue; fT} ç CompFTV
         ± ≥ {fB; fFalse; fTrue} ç CompFTV
         ± ≥ {fB; fFalse; fT} ç CompFTV
         ± ≥ {fB; fTrue; fT} ç CompFTV
         ± ≥ {fFalse; fTrue; fT} ç CompFTV
         ± ≥ {fB; fFalse; fTrue; fT} ç CompFTVÆ);
a (rewrite_tac [get_spec ¨CompFTVÆ, ç_in_clauses]
	THEN_TRY false_enum_eq_tac
	THEN rewrite_tac[]);
val CompFTV_ç_clauses = pop_thm ();

set_goal([], ¨{} ç CoCompFTV
         ± ≥ {fB} ç CoCompFTV
         ± {fFalse} ç CoCompFTV
         ± {fTrue} ç CoCompFTV
         ± {fT} ç CoCompFTV
         ± ≥ {fB; fFalse} ç CoCompFTV
         ± ≥ {fB; fTrue} ç CoCompFTV
         ± ≥ {fB; fT} ç CoCompFTV
         ± ≥ {fFalse; fTrue} ç CoCompFTV
         ± {fFalse; fT} ç CoCompFTV
         ± {fTrue; fT} ç CoCompFTV
         ± ≥ {fB; fFalse; fTrue} ç CoCompFTV
         ± ≥ {fB; fFalse; fT} ç CoCompFTV
         ± ≥ {fB; fTrue; fT} ç CoCompFTV
         ± ≥ {fFalse; fTrue; fT} ç CoCompFTV
         ± ≥ {fB; fFalse; fTrue; fT} ç CoCompFTVÆ);
a (rewrite_tac [get_spec ¨CoCompFTVÆ, ç_in_clauses]
	THEN_TRY false_enum_eq_tac
	THEN rewrite_tac[]);
val CoCompFTV_ç_clauses = pop_thm ();

set_goal([], ¨µs∑ s ç CompFTV § ≥ Lub $ºâtâ4 s = fTÆ);
a (strip_tac);
a (strip_asm_tac (µ_elim ¨sÆ ftvs_cases_thm)
	THEN asm_rewrite_tac [CompFTV_ç_clauses]);
val CompFTV_Lub_lemma = save_pop_thm "CompFTV_Lub_lemma";

set_goal([], ¨µs∑ Lub $ºâtâ4 s = fT § ≥ s ç CompFTVÆ);
a (strip_tac THEN rewrite_tac [CompFTV_Lub_lemma]);
val Lub_CompFTV_lemma = save_pop_thm "Lub_CompFTV_lemma";

set_goal([], ¨µs∑ s ç CoCompFTV § ≥ Glb $ºâtâ4 s = fBÆ);
a (strip_tac);
a (strip_asm_tac (µ_elim ¨sÆ ftvs_cases_thm)
	THEN asm_rewrite_tac [CoCompFTV_ç_clauses]);
val CoCompFTV_Glb_lemma = save_pop_thm "CoCompFTV_Glb_lemma";

set_goal([], ¨µs∑ Glb $ºâtâ4 s = fB § ≥ s ç CoCompFTVÆ);
a (strip_tac THEN rewrite_tac [CoCompFTV_Glb_lemma]);
val Glb_CoCompFTV_lemma = save_pop_thm "Glb_CoCompFTV_lemma";

add_pc_thms "'misc2" (map get_spec [] @ [CompFTV_ç_clauses, CoCompFTV_ç_clauses, Lub_CompFTV_lemma, Glb_CoCompFTV_lemma]);
set_merge_pcs ["rbjmisc", "'GS1", "'misc2"];
=TEX
}%ignore

=GFT
€ºâtâ4_lin_lub_lemma› =
   Ù µ X∑ LinearOrder (X, $ºâtâ4) ¥ fT ºâtâ4 Lub $ºâtâ4 X = fT ç X

€ºâtâ4_lin_lub_lemma2› =
   Ù µ X∑ LinearOrder (X, $ºâtâ4) ¥ (fT = Lub $ºâtâ4 X) = fT ç X

€ºâtâ4_lin_glb_lemma› =
   Ù µ X∑ LinearOrder (X, $ºâtâ4) ¥ Glb $ºâtâ4 X ºâtâ4 fB = fB ç X

€ºâtâ4_lin_glb_lemma2› =
   Ù µ X∑ LinearOrder (X, $ºâtâ4) ¥ (Glb $ºâtâ4 X = fB) = fB ç X 
=TEX

\ignore{
=SML
set_goal ([], ¨µX∑ LinearOrder (X, $ºâtâ4) ¥ (fT ºâtâ4 Lub $ºâtâ4 X § fT ç X)Æ);
a (REPEAT_N 2 strip_tac);
a (fc_tac [ºâtâ4_lin_cases_lemma]
	THEN asm_rewrite_tac[]
	THEN contr_tac);
val ºâtâ4_lin_lub_lemma = save_pop_thm "ºâtâ4_lin_lub_lemma";

set_goal ([], ¨µX∑ LinearOrder (X, $ºâtâ4) ¥ (fT = Lub $ºâtâ4 X § fT ç X)Æ);
a (REPEAT_N 2 strip_tac);
a (fc_tac [ºâtâ4_lin_cases_lemma]
	THEN asm_rewrite_tac[]
	THEN contr_tac);
val ºâtâ4_lin_lub_lemma2 = save_pop_thm "ºâtâ4_lin_lub_lemma2";

set_goal ([], ¨µX∑ LinearOrder (X, $ºâtâ4) ¥ (Glb $ºâtâ4 X ºâtâ4 fB § fB ç X)Æ);
a (REPEAT_N 2 strip_tac);
a (fc_tac [ºâtâ4_lin_cases_lemma]
	THEN asm_rewrite_tac[]
	THEN contr_tac);
val ºâtâ4_lin_glb_lemma = save_pop_thm "ºâtâ4_lin_glb_lemma";

set_goal ([], ¨µX∑ LinearOrder (X, $ºâtâ4) ¥ (Glb $ºâtâ4 X = fB § fB ç X)Æ);
a (REPEAT_N 2 strip_tac);
a (fc_tac [ºâtâ4_lin_cases_lemma]
	THEN asm_rewrite_tac[]
	THEN contr_tac);
val ºâtâ4_lin_glb_lemma2 = save_pop_thm "ºâtâ4_lin_glb_lemma2";
=TEX
}%ignore



\section{INDEXED SETS}

Two implementations of indexed sets are provided.
The first is as total functions yielding OPTional values.

In the second the functions yield DPOs.
This gives a complete partial order over the indexed sets which was required for some versions of infinitary first order logic.
This is more complicated of course and not to be used unless essential.

\subsection{Plain Version - IX}

In this implementation of indexed sets we use discrete partial orders in the codomain, so that the resulting partial orders are complete.

=SML
declare_type_abbrev(€"IX"›, ["'a", "'b"], î'a ≠ 'b OPTÆ);
=TEX

πHOLCONST
‹ €IxVal› : ('b, 'a) IX ≠ 'b ≠ 'a
˜¸¸¸¸¸¸¸¸¸¸¸
‹ µis g∑ IxVal is g = ValueOf (is g)
∞

πHOLCONST
‹ €IxRan› : ('b, 'a) IX ≠ 'a SET
˜¸¸¸¸¸¸¸¸¸¸¸
‹ µis∑ IxRan is = {v | ∂¡∑ Value v = is ¡}
∞

πHOLCONST
‹ €IxDom› : ('b, 'a) IX ≠ 'b SET
˜¸¸¸¸¸¸¸¸¸¸¸
‹ µis∑ IxDom is = {i | IsDefined (is i)}
∞

=GFT
€ix_domran_lemma› =
   Ù µ x y∑ x ç IxDom y ¥ IxVal y x ç IxRan y

€ix_valueof_ran_lemma› =
   Ù µ x y∑ ≥ x y = Undefined ¥ ValueOf (x y) ç IxRan x
=TEX

\ignore{
=SML
set_goal ([], ¨µx y∑ x ç IxDom y ¥ IxVal y x ç IxRan yÆ);
a (REPEAT µ_tac THEN rewrite_tac [get_spec ¨IxDomÆ, get_spec ¨IxValÆ, get_spec ¨IxRanÆ]);
a (strip_tac THEN ∂_tac ¨xÆ);
a (strip_asm_tac (µ_elim ¨y xÆ opt_cases_thm) THEN asm_rewrite_tac[]);
val ix_domran_lemma = save_pop_thm "ix_domran_lemma";

set_goal ([], ¨µx y∑ ≥ x y = Undefined ¥ ValueOf (x y) ç IxRan xÆ);
a (REPEAT µ_tac THEN rewrite_tac [get_spec ¨IxRanÆ]
	THEN REPEAT strip_tac);
a (strip_asm_tac (µ_elim ¨x yÆ (±_right_elim (±_right_elim (get_spec ¨ValueÆ)))));
a (∂_tac ¨yÆ THEN asm_rewrite_tac[]);
val ix_valueof_ran_lemma = save_pop_thm "ix_valueof_ran_lemma";
=TEX
}%ignore

πHOLCONST
‹ €IxUd› : ('a, 'b) IX ≠ 'a SET
˜¸¸¸¸¸¸¸¸¸¸¸
‹ µis∑ IxUd is = {i | is i = Undefined}
∞

πHOLCONST
‹ €IxOverRide› : ('a, 'b) IX ≠ ('a, 'b) IX ≠ ('a, 'b) IX
˜¸¸¸¸¸¸¸¸¸¸¸
‹ µis1 is2∑ IxOverRide is1 is2 =
‹	Ãi∑ if ≥ i ç IxUd is2 then is2 i else is1 i 
∞

=GFT
€ixud_eq_iff_ixdom_eq_lemma› =
   Ù µ x y∑ IxUd x = IxUd y § IxDom x = IxDom y

€ixoverride_ixdom_lemma› =
   Ù µ x y∑ IxDom (IxOverRide x y) = IxDom x ¿ IxDom y

€ixoverride_ixud_lemma› =
   Ù µ x y∑ IxUd (IxOverRide x y) = IxUd x \ IxDom y

€ixoverride_ixran_lemma› =
   Ù µ x y∑ IxRan (IxOverRide x y) Ä IxRan x ¿ IxRan y
=TEX

\ignore{
=SML
set_goal ([], ¨µx y∑ IxUd x = IxUd y § IxDom x = IxDom yÆ);
a (REPEAT µ_tac THEN rewrite_tac [get_spec ¨IxDomÆ, get_spec ¨IxUdÆ]
	THEN PC_T1 "hol1" prove_tac[]);
val ixud_eq_iff_ixdom_eq_lemma = save_pop_thm "ixud_eq_iff_ixdom_eq_lemma";

set_goal ([], ¨µx y∑ IxDom (IxOverRide x y) = IxDom x ¿ IxDom yÆ);
a (REPEAT µ_tac
	THEN rewrite_tac [get_spec ¨IxDomÆ, get_spec ¨IxOverRideÆ]
	THEN PC_T "hol1" strip_tac
	THEN strip_tac THEN rewrite_tac[ç_in_clauses, get_spec ¨IxUdÆ]);
a (cases_tac ¨y x' = UndefinedÆ THEN asm_rewrite_tac[]);
val ixoverride_ixdom_lemma = save_pop_thm "ixoverride_ixdom_lemma";

set_goal ([], ¨µx y∑ IxRan (IxOverRide x y) Ä IxRan x ¿ IxRan yÆ);
a (REPEAT µ_tac
	THEN rewrite_tac [get_spec ¨IxRanÆ, get_spec ¨IxOverRideÆ]
	THEN PC_T "hol1" strip_tac
	THEN strip_tac THEN rewrite_tac[ç_in_clauses, get_spec ¨IxUdÆ]
	THEN strip_tac THEN POP_ASM_T ante_tac);
a (cases_tac ¨y ¡ = UndefinedÆ THEN asm_rewrite_tac[] THEN strip_tac);
(* *** Goal "1" *** *)
a (≤_left_tac THEN ∂_tac ¨¡Æ THEN asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a (≤_right_tac THEN ∂_tac ¨¡Æ THEN asm_rewrite_tac[]);
val ixoverride_ixran_lemma = save_pop_thm "ixoverride_ixran_lemma";

set_goal ([], ¨µx y∑ IxUd (IxOverRide x y) = IxUd x \ IxDom y Æ);
a (REPEAT µ_tac
	THEN rewrite_tac [get_spec ¨IxUdÆ, get_spec ¨IxDomÆ, get_spec ¨IxOverRideÆ]
	THEN PC_T "hol1" strip_tac
	THEN strip_tac THEN rewrite_tac[ç_in_clauses, get_spec ¨UndefinedÆ]);
a (cases_tac ¨y x' = UndefinedÆ THEN asm_rewrite_tac[]);
val ixoverride_ixud_lemma = save_pop_thm "ixoverride_ixud_lemma";

add_pc_thms "'misc2" (map get_spec [] @ [ixud_eq_iff_ixdom_eq_lemma, ixoverride_ixdom_lemma, ixoverride_ixud_lemma]);
set_merge_pcs ["rbjmisc", "'GS1", "'misc2"];
=TEX
}%ignore

\subsection{DPO Version - IS}

In this implementation of indexed sets we use discrete partial orders in the codomain, so that the resulting partial orders are complete.

=SML
declare_type_abbrev("€IS›", ["'a"], îGS ≠ 'a DPOÆ);
=TEX

πHOLCONST
‹ €IsVal› : 'a IS ≠ GS ≠ 'a
˜¸¸¸¸¸¸¸¸¸¸¸
‹ µis g∑ IsVal is g = dpoV (is g)
∞

πHOLCONST
‹ €IsRan› : 'a IS ≠ 'a SET
˜¸¸¸¸¸¸¸¸¸¸¸
‹ µis∑ IsRan is = {v | ∂¡∑ dpoE v = is ¡}
∞

πHOLCONST
‹ €IsDom› : 'a IS ≠ GS SET
˜¸¸¸¸¸¸¸¸¸¸¸
‹ µis∑ IsDom is = {i | ≥ (is i) = dpoB}
∞

πHOLCONST
‹ €IsSDom› : 'a IS ≠ GS SET
˜¸¸¸¸¸¸¸¸¸¸¸
‹ µis∑ IsSDom is = {i | ≥ ((is i) = dpoB ≤ (is i) = dpoT)}
∞

=GFT
€is_domran_lemma› =
	Ù µ x y∑ x ç IsSDom y ¥ IsVal y x ç IsRan y
=TEX

\ignore{
=SML
set_goal ([], ¨µx y∑ x ç IsSDom y ¥ IsVal y x ç IsRan yÆ);
a (REPEAT µ_tac THEN rewrite_tac [get_spec ¨IsSDomÆ, get_spec ¨IsValÆ, get_spec ¨IsRanÆ]);
a (strip_tac THEN ∂_tac ¨xÆ); 
a (all_fc_tac [rewrite_rule [get_spec ¨dpoUdefÆ, get_spec ¨dpoOdefÆ] dpoev_lemma1]);
val is_domran_lemma = save_pop_thm "is_domran_lemma";
=TEX
}%ignore

πHOLCONST
‹ €IsOd› : 'a IS ≠ GS SET
˜¸¸¸¸¸¸¸¸¸¸¸
‹ µis∑ IsOd is = {i | is i = dpoT}
∞

πHOLCONST
‹ €IsUd› : 'a IS ≠ GS SET
˜¸¸¸¸¸¸¸¸¸¸¸
‹ µis∑ IsUd is = {i | is i = dpoB}
∞

πHOLCONST
‹ €IsTDom› : 'a IS ≠ (GS SET ∏ GS SET ∏ GS SET)
˜¸¸¸¸¸¸¸¸¸¸¸
‹ µis∑ IsTDom is = (IsSDom is, IsUd is, IsOd is)
∞

πHOLCONST
‹ €IsOverRide› : 'a IS ≠ 'a IS ≠ 'a IS
˜¸¸¸¸¸¸¸¸¸¸¸
‹ µis1 is2∑ IsOverRide is1 is2 =
‹	Ãi∑ if ≥ dpoUdef (is2 i) then is2 i else is1 i 
∞

=GFT
€istdom_eq_fc_lemma› =
   Ù µ x y
     ∑ IsTDom x = IsTDom y
         ¥ IsUd x = IsUd y
           ± IsOd x = IsOd y
           ± IsSDom x = IsSDom y
           ± IsDom x = IsDom y

€isoverride_isdom_lemma› =
   Ù µ x y∑ IsDom (IsOverRide x y) = IsDom x ¿ IsDom y

€isoverride_isud_lemma› =
   Ù µ x y∑ IsUd (IsOverRide x y) = IsUd x \ IsDom y

€isoverride_isod_lemma› =
   Ù µ x y∑ IsOd (IsOverRide x y) = IsOd y ¿ IsOd x \ IsDom y

isoverride_issdom_lemma =
   Ù µ x y∑ IsSDom (IsOverRide x y) = IsSDom y ¿ IsSDom x \ IsDom y
=TEX

\ignore{
=SML
set_goal ([], ¨µx y∑ IsTDom x = IsTDom y ¥
	IsUd x = IsUd y ± IsOd x = IsOd y ± IsSDom x = IsSDom y ± IsDom x = IsDom yÆ);
a (REPEAT µ_tac THEN rewrite_tac [get_spec ¨IsTDomÆ, get_spec ¨IsDomÆ] THEN REPEAT strip_tac
	THEN POP_ASM_T ante_tac THEN_TRY asm_rewrite_tac[]);
a (strip_tac THEN DROP_NTH_ASM_T 2 ante_tac THEN PC_T1 "hol1" rewrite_tac[get_spec ¨IsUdÆ]);
a (strip_tac THEN asm_rewrite_tac[]);
val istdom_eq_fc_lemma = save_pop_thm "istdom_eq_fc_lemma";

set_goal ([], ¨µx y∑ IsDom (IsOverRide x y) = IsDom x ¿ IsDom yÆ);
a (REPEAT µ_tac
	THEN rewrite_tac [get_spec ¨IsDomÆ, get_spec ¨IsOverRideÆ]
	THEN PC_T "hol1" strip_tac
	THEN strip_tac THEN rewrite_tac[ç_in_clauses, get_spec ¨dpoUdefÆ]);
a (cases_tac ¨y x' = dpoBÆ THEN asm_rewrite_tac[]);
val isoverride_isdom_lemma = save_pop_thm "isoverride_isdom_lemma";

set_goal ([], ¨µx y∑ IsUd (IsOverRide x y) = IsUd x \ IsDom y Æ);
a (REPEAT µ_tac
	THEN rewrite_tac [get_spec ¨IsUdÆ, get_spec ¨IsDomÆ, get_spec ¨IsOverRideÆ]
	THEN PC_T "hol1" strip_tac
	THEN strip_tac THEN rewrite_tac[ç_in_clauses, get_spec ¨dpoUdefÆ]);
a (cases_tac ¨y x' = dpoBÆ THEN asm_rewrite_tac[]);
val isoverride_isud_lemma = save_pop_thm "isoverride_isud_lemma";

set_goal ([], ¨µx y∑ IsOd (IsOverRide x y) = IsOd y ¿ (IsOd x \ IsDom y)Æ);
a (REPEAT µ_tac
	THEN rewrite_tac [get_spec ¨IsOdÆ, get_spec ¨IsDomÆ, get_spec ¨IsOverRideÆ]
	THEN PC_T "hol1" strip_tac
	THEN strip_tac THEN rewrite_tac[ç_in_clauses, get_spec ¨dpoUdefÆ]);
a (cases_tac ¨y x' = dpoBÆ THEN asm_rewrite_tac[]);
val isoverride_isod_lemma = save_pop_thm "isoverride_isod_lemma";

set_goal ([], ¨µx y∑ IsSDom (IsOverRide x y) = IsSDom y ¿ ((IsSDom x) \ (IsDom y))Æ);
a (REPEAT µ_tac
	THEN rewrite_tac [get_spec ¨IsSDomÆ, get_spec ¨IsDomÆ, get_spec ¨IsOverRideÆ]
	THEN PC_T "hol1" strip_tac
	THEN strip_tac THEN rewrite_tac[ç_in_clauses, get_spec ¨dpoUdefÆ]);
a (cases_tac ¨y x' = dpoBÆ THEN asm_rewrite_tac[]);
val isoverride_issdom_lemma = save_pop_thm "isoverride_issdom_lemma";
=IGN
set_goal ([], ¨µx y v w∑ IsSDom x = IsSDom y ± IsSDom v = IsSDom w ¥
	IsSDom (IsOverRide x v) = IsSDom (IsOverRide y w)Æ);

set_goal ([], ¨µx y v w∑ IsTDom x = IsTDom y ± IsTDom v = IsTDom w ¥
	IsTDom (IsOverRide x v) = IsTDom (IsOverRide y w)Æ);
a (REPEAT strip_tac THEN rewrite_tac [get_spec ¨IsTDomÆ]);


=TEX
}%ignore

\section{ORDERS AND PRE-ORDERS}

\subsection{Domain Restriction}

The following operator restricts a reflexive partial order to some subdomain of the type over which it is defined.

=SML
declare_infix(300, "Úâo");
=TEX

πHOLCONST
‹ €$Úâo›: 'a SET ≠ ('a ≠ 'a ≠ BOOL) ≠ ('a ≠ 'a ≠ BOOL)
˜¸¸¸¸¸¸¸¸¸¸¸
‹   µ V r∑ V Úâo r = Ãx y∑ if x ç V ± y ç V then r x y else x = y
∞

\subsection{Conjunction of Orders}

πHOLCONST
‹ €ConjOrder› : ('a ≠ 'a ≠ BOOL) ≠ ('a ≠ 'a ≠ BOOL) ≠ ('a ≠ 'a ≠ BOOL)
˜¸¸¸¸¸¸¸¸¸¸¸
‹ µr1 r2∑ ConjOrder r1 r2 = Ãx y∑ r1 x y ± r2 x y
∞

\subsection{Derived Orderings}

I don't know a good name for these, but a common way to impose an order on a collection is by defining a function which maps the collection into some collection for which we have a suitable ordering.
Often suitable means well-founded, but in our case it is completeness which is desired.

πHOLCONST
‹ €DerivedOrder› : ('b ≠ 'a) ≠ ('a ≠ 'a ≠ BOOL) ≠ ('b ≠ 'b ≠ BOOL)
˜¸¸¸¸¸¸¸¸¸¸¸
‹ µf r∑ DerivedOrder f r = Ãx y∑ r (f x) (f y)
∞

We require sufficient conditions for the result to be complete.

=GFT
€fi_isub_lemma› =
   Ù µ f r s e∑ IsUb r (FunImage f s) (f e) ¥ IsUb (DerivedOrder f r) s e

€do_isub_lemma› =
   Ù µ f r s x∑ IsUb (DerivedOrder f r) s x ¥ IsUb r (FunImage f s) (f x)

€fi_islub_lemma› =
   Ù µ f r s e
     ∑ IsLub r (FunImage f s) (f e) ¥ IsLub (DerivedOrder f r) s e

€do_lubs_exist_thm› =
   Ù µ f r∑ LubsExist r ± Onto f ¥ LubsExist (DerivedOrder f r)
=TEX
=GFT
€fi_islb_lemma› =
   Ù µ f r s e∑ IsLb r (FunImage f s) (f e) ¥ IsLb (DerivedOrder f r) s e

€do_islb_lemma› =
   Ù µ f r s x∑ IsLb (DerivedOrder f r) s x ¥ IsLb r (FunImage f s) (f x)

€fi_isglb_lemma› =
   Ù µ f r s e∑ IsGlb r (FunImage f s) (f e) ¥ IsGlb (DerivedOrder f r) s e

€do_glbs_exist_thm› =
   Ù µ f r∑ GlbsExist r ± Onto f ¥ GlbsExist (DerivedOrder f r)
=TEX

\ignore{
=SML
set_goal([], ¨µf r s e∑ IsUb r (FunImage f s) (f e) ¥ IsUb (DerivedOrder f r) s eÆ);
a (rewrite_tac (map get_spec [¨OntoÆ, ¨DerivedOrderÆ, ¨IsUbÆ, ¨FunImageÆ])
	THEN REPEAT strip_tac);
a (spec_nth_asm_tac 2 ¨f xÆ);
a (spec_nth_asm_tac 1 ¨xÆ);
val fi_isub_lemma = pop_thm ();

set_goal([], ¨µf r s x∑ IsUb (DerivedOrder f r) s x ¥ IsUb r (FunImage f s) (f x)Æ);
a (rewrite_tac (map get_spec [¨IsUbÆ, ¨DerivedOrderÆ, ¨FunImageÆ]) THEN REPEAT strip_tac);
a (asm_fc_tac[]);
a (POP_ASM_T ante_tac THEN asm_rewrite_tac[]);
val do_isub_lemma = pop_thm ();

set_goal([], ¨µf r s e∑ IsLub r (FunImage f s) (f e) ¥ IsLub (DerivedOrder f r) s e Æ);
a (rewrite_tac (map get_spec [¨OntoÆ, ¨IsLubÆ]) THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a (fc_tac [fi_isub_lemma]);
(* *** Goal "2" *** *)
a (fc_tac [do_isub_lemma]);
a (all_asm_fc_tac[]);
a (rewrite_tac (map get_spec [¨DerivedOrderÆ]) THEN REPEAT strip_tac);
val fi_islub_lemma = pop_thm ();

set_goal([], ¨µf r∑ LubsExist r ± Onto f ¥ LubsExist (DerivedOrder f r)Æ);
a (rewrite_tac (map get_spec [¨OntoÆ, ¨LubsExistÆ]) THEN REPEAT strip_tac);
a (spec_nth_asm_tac 2 ¨FunImage f sÆ);
a (spec_nth_asm_tac 2 ¨eÆ);
a (var_elim_asm_tac ¨e = f xÆ THEN ∂_tac ¨xÆ THEN fc_tac [fi_islub_lemma] THEN asm_rewrite_tac[]);
val do_lubs_exist_thm = save_pop_thm "do_lubs_exist_thm";

set_goal([], ¨µf r s e∑ IsLb r (FunImage f s) (f e) ¥ IsLb (DerivedOrder f r) s eÆ);
a (rewrite_tac (map get_spec [¨OntoÆ, ¨DerivedOrderÆ, ¨IsLbÆ, ¨FunImageÆ])
	THEN REPEAT strip_tac);
a (spec_nth_asm_tac 2 ¨f xÆ);
a (spec_nth_asm_tac 1 ¨xÆ);
val fi_islb_lemma = pop_thm ();

set_goal([], ¨µf r s x∑ IsLb (DerivedOrder f r) s x ¥ IsLb r (FunImage f s) (f x)Æ);
a (rewrite_tac (map get_spec [¨IsLbÆ, ¨DerivedOrderÆ, ¨FunImageÆ]) THEN REPEAT strip_tac);
a (asm_fc_tac[]);
a (POP_ASM_T ante_tac THEN asm_rewrite_tac[]);
val do_islb_lemma = pop_thm ();

set_goal([], ¨µf r s e∑ IsGlb r (FunImage f s) (f e) ¥ IsGlb (DerivedOrder f r) s e Æ);
a (rewrite_tac (map get_spec [¨OntoÆ, ¨IsGlbÆ]) THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a (fc_tac [fi_islb_lemma]);
(* *** Goal "2" *** *)
a (fc_tac [do_islb_lemma]);
a (all_asm_fc_tac[]);
a (rewrite_tac (map get_spec [¨DerivedOrderÆ]) THEN REPEAT strip_tac);
val fi_isglb_lemma = pop_thm ();

set_goal([], ¨µf r∑ GlbsExist r ± Onto f ¥ GlbsExist (DerivedOrder f r)Æ);
a (rewrite_tac (map get_spec [¨OntoÆ, ¨GlbsExistÆ]) THEN REPEAT strip_tac);
a (spec_nth_asm_tac 2 ¨FunImage f sÆ);
a (spec_nth_asm_tac 2 ¨eÆ);
a (var_elim_asm_tac ¨e = f xÆ THEN ∂_tac ¨xÆ THEN fc_tac [fi_isglb_lemma] THEN asm_rewrite_tac[]);
val do_glbs_exist_thm = save_pop_thm "do_glbs_exist_thm";
=TEX
}%ignore

\subsection{Projections}

Projections are a special case of derived orderings in which the onto requirement can be taken for granted.

=GFT
€projections_onto_lemma› =
   Ù Onto Fst ± Onto Snd

€lubsexist_dofst_thm› =
   Ù µ f r∑ LubsExist r ¥ LubsExist (DerivedOrder Fst r)

€glbsexist_dofst_thm› =
   Ù µ f r∑ GlbsExist r ¥ GlbsExist (DerivedOrder Fst r)

€lubsexist_dosnd_thm› =
   Ù µ f r∑ LubsExist r ¥ LubsExist (DerivedOrder Snd r)

€glbsexist_dosnd_thm› =
   Ù µ f r∑ GlbsExist r ¥ GlbsExist (DerivedOrder Snd r)
=TEX


\ignore{
=SML
set_goal([], ¨Onto Fst ± Onto SndÆ);
a (rewrite_tac (map get_spec [¨OntoÆ]) THEN REPEAT strip_tac);
a (∂_tac ¨(y, z)Æ THEN rewrite_tac[]);
a (∂_tac ¨(z, y)Æ THEN rewrite_tac[]);
val projections_onto_lemma = pop_thm ();

set_goal([], ¨µf r∑ LubsExist r ¥ LubsExist (DerivedOrder Fst r)Æ);
a (REPEAT strip_tac THEN bc_tac [do_lubs_exist_thm]
	THEN_TRY asm_rewrite_tac[projections_onto_lemma]);
val lubsexist_dofst_thm = save_pop_thm "lubsexist_dofst_thm";

set_goal([], ¨µf r∑ GlbsExist r ¥ GlbsExist (DerivedOrder Fst r)Æ);
a (REPEAT strip_tac THEN bc_tac [do_glbs_exist_thm]
	THEN_TRY asm_rewrite_tac[projections_onto_lemma]);
val glbsexist_dofst_thm = save_pop_thm "glbsexist_dofst_thm";

set_goal([], ¨µf r∑ LubsExist r ¥ LubsExist (DerivedOrder Snd r)Æ);
a (REPEAT strip_tac THEN bc_tac [do_lubs_exist_thm]
	THEN_TRY asm_rewrite_tac[projections_onto_lemma]);
val lubsexist_dosnd_thm = save_pop_thm "lubsexist_dosnd_thm";

set_goal([], ¨µf r∑ GlbsExist r ¥ GlbsExist (DerivedOrder Snd r)Æ);
a (REPEAT strip_tac THEN bc_tac [do_glbs_exist_thm]
	THEN_TRY asm_rewrite_tac[projections_onto_lemma]);
val glbsexist_dosnd_thm = save_pop_thm "glbsexist_dosnd_thm";
=TEX
}%ignore

\subsection{Functions}

Most of our orderings are orderings of functions obtained from orderings of truth values by the following operation.

πHOLCONST
‹ €Pw› : ('a ≠ 'a ≠ BOOL) ≠ (('b ≠ 'a) ≠ ('b ≠ 'a) ≠ BOOL)
˜¸¸¸¸¸¸¸¸¸¸¸
‹ µ r∑ Pw r = Ã lo ro∑ µx∑ r (lo x) (ro x)
∞

=GFT
€pw_isub_lemma› =
   Ù µ r G f∑ (µ v∑ IsUb r {w|∂ g∑ g ç G ± w = g v} (f v)) ¥ IsUb (Pw r) G f

€pw_isub_lemma2› =
   Ù µ r G f∑ IsUb (Pw r) G f § (µ v∑ IsUb r {w|∂ g∑ g ç G ± w = g v} (f v))

€pw_islb_lemma› =
   Ù µ r G f∑ (µ v∑ IsLb r {w|∂ g∑ g ç G ± w = g v} (f v)) ¥ IsLb (Pw r) G f

€pw_islb_lemma2› =
   Ù µ r G f∑ IsLb (Pw r) G f § (µ v∑ IsLb r {w|∂ g∑ g ç G ± w = g v} (f v))

€pw_islub_lemma› =
   Ù µ r G f
     ∑ (µ v∑ IsLub r {w|∂ g∑ g ç G ± w = g v} (f v)) ¥ IsLub (Pw r) G f

€pw_islub_lemma2› =
   Ù µ r G f
     ∑ IsLub (Pw r) G f § (µ v∑ IsLub r {w|∂ g∑ g ç G ± w = g v} (f v))

€pw_isglb_lemma› =
   Ù µ r G f
     ∑ (µ v∑ IsGlb r {w|∂ g∑ g ç G ± w = g v} (f v)) ¥ IsGlb (Pw r) G f

€pw_isglb_lemma2› =
   Ù µ r G f
     ∑ IsGlb (Pw r) G f § (µ v∑ IsGlb r {w|∂ g∑ g ç G ± w = g v} (f v))

€pw_rpo_lemma› =
	Ù µ r∑ Rpo (Universe, r) ¥ Rpo (Universe, Pw r)

€pw_cc_lemma› =
	Ù µ r∑ CcRpo (Universe, r) ¥ ChainComplete (Universe, Pw r)

€pw_ccrpou_thm› =
	Ù µ r∑ CcRpoU r ¥ CcRpoU (Pw r)

€pw_lubs_exist_thm› =
	Ù µ r∑ LubsExist r ¥ LubsExist (Pw r)

€pw_glbs_exist_thm› =
	Ù µ r∑ GlbsExist r ¥ GlbsExist (Pw r)

€pw_crpou_thm› =
	Ù µ r∑ CRpoU r ¥ CRpoU (Pw r)
=TEX

\ignore{
=SML
set_goal([], ¨µr G f∑ (µ v∑ IsUb r {w | ∂g∑ g ç G ± w = g v} (f v))
	¥ IsUb (Pw r) G fÆ);
a (rewrite_tac [get_spec ¨IsUbÆ, get_spec ¨PwÆ] THEN REPEAT strip_tac);
a (list_spec_nth_asm_tac 2 [¨x'Æ, ¨x x'Æ]);
a (spec_nth_asm_tac 1 ¨xÆ);
val pw_isub_lemma = pop_thm ();

set_goal([], ¨µr G f∑ IsUb (Pw r) G f § (µ v∑ IsUb r {w | ∂g∑ g ç G ± w = g v} (f v))Æ);
a (REPEAT strip_tac THEN all_fc_tac [pw_isub_lemma]);
a (POP_ASM_T ante_tac THEN rewrite_tac [get_spec ¨IsUbÆ, get_spec ¨PwÆ] THEN REPEAT strip_tac);
a (asm_fc_tac[] THEN asm_rewrite_tac[]);
val pw_isub_lemma2 = pop_thm ();

set_goal([], ¨µr G f∑ (µ v∑ IsLb r {w | ∂g∑ g ç G ± w = g v} (f v))
	¥ IsLb (Pw r) G fÆ);
a (rewrite_tac [get_spec ¨IsLbÆ, get_spec ¨PwÆ] THEN REPEAT strip_tac);
a (list_spec_nth_asm_tac 2 [¨x'Æ, ¨x x'Æ]);
a (spec_nth_asm_tac 1 ¨xÆ);
val pw_islb_lemma = pop_thm ();

set_goal([], ¨µr G f∑ IsLb (Pw r) G f
	§ (µ v∑ IsLb r {w | ∂g∑ g ç G ± w = g v} (f v))Æ);
a (REPEAT strip_tac THEN all_fc_tac [pw_islb_lemma]);
a (POP_ASM_T ante_tac THEN rewrite_tac [get_spec ¨IsLbÆ, get_spec ¨PwÆ] THEN REPEAT strip_tac);
a (asm_fc_tac[] THEN asm_rewrite_tac[]);
val pw_islb_lemma2 = pop_thm ();

set_goal([], ¨µr G f∑ (µ v∑ IsLub r {w | ∂g∑ g ç G ± w = g v} (f v))
	¥ IsLub (Pw r) G fÆ);
a (REPEAT strip_tac THEN rewrite_tac [get_spec ¨IsLubÆ] THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a (lemma_tac ¨µ v∑ IsUb r {w|∂ g∑ g ç G ± w = g v} (f v)Æ
	THEN1 (POP_ASM_T (strip_asm_tac o (rewrite_rule [get_spec ¨IsLubÆ]))
		THEN asm_rewrite_tac[]));
a (fc_tac [pw_isub_lemma]);
(* *** Goal "2" *** *)
a (rewrite_tac [get_spec ¨PwÆ]
	THEN REPEAT strip_tac);
a (spec_nth_asm_tac 2 ¨x'Æ);
a (fc_tac [get_spec ¨IsLubÆ]);
a (spec_nth_asm_tac 2 ¨x x'Æ);
a (GET_ASM_T ¨IsUb (Pw r) G xÆ ante_tac
	THEN rewrite_tac [get_spec ¨PwÆ]);
a (swap_nth_asm_concl_tac 1);
a (DROP_NTH_ASM_T 6 ante_tac
	THEN rewrite_tac [get_spec ¨PwÆ, get_spec ¨IsUbÆ]
	THEN REPEAT strip_tac);
a (all_asm_fc_tac[]);
a (spec_nth_asm_tac 2 ¨x'Æ
	THEN POP_ASM_T ante_tac
	THEN asm_rewrite_tac[]);
val pw_islub_lemma = pop_thm ();

set_goal([], ¨µr G f∑ IsLub (Pw r) G f
	§ (µ v∑ IsLub r {w | ∂g∑ g ç G ± w = g v} (f v))Æ);
a (REPEAT strip_tac THEN all_fc_tac [pw_islub_lemma]);
a (POP_ASM_T ante_tac THEN rewrite_tac [get_spec ¨IsLubÆ] THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a (fc_tac [pw_isub_lemma2] THEN asm_rewrite_tac []);
(* *** Goal "2" *** *)
a (spec_nth_asm_tac 2 ¨Ãz∑ if z = v then x else f zÆ);
(* *** Goal "2.1" *** *)
a (swap_nth_asm_concl_tac 1);
a (DROP_NTH_ASM_T 4 ante_tac);
a (DROP_NTH_ASM_T 2 ante_tac);
a (rewrite_tac [pw_isub_lemma2]);
a (rewrite_tac[get_spec ¨IsUbÆ]);
a (REPEAT strip_tac);
a (cond_cases_tac ¨v' = vÆ);
(* *** Goal "2.1.1" *** *)
a (var_elim_asm_tac ¨v' = vÆ);
a (var_elim_asm_tac ¨x' = g vÆ);
a (spec_nth_asm_tac 3 ¨g vÆ);
a (spec_nth_asm_tac 1 ¨gÆ);
(* *** Goal "2.1.2" *** *)
a (var_elim_asm_tac ¨x' = g v'Æ);
a (list_spec_nth_asm_tac 3 [¨v'Æ, ¨g v'Æ]);
a (spec_nth_asm_tac 1 ¨gÆ);
(* *** Goal "2.2" *** *)
a (POP_ASM_T ante_tac THEN rewrite_tac [get_spec ¨PwÆ]);
a (strip_tac THEN spec_nth_asm_tac 1 ¨vÆ);
a (POP_ASM_T ante_tac THEN rewrite_tac[]);
val pw_islub_lemma2 = pop_thm ();

set_goal([], ¨µr G f∑ (µ v∑ IsGlb r {w | ∂g∑ g ç G ± w = g v} (f v))
	¥ IsGlb (Pw r) G fÆ);
a (REPEAT strip_tac THEN rewrite_tac [get_spec ¨IsGlbÆ] THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a (lemma_tac ¨µ v∑ IsLb r {w|∂ g∑ g ç G ± w = g v} (f v)Æ
	THEN1 (POP_ASM_T (strip_asm_tac o (rewrite_rule [get_spec ¨IsGlbÆ]))
		THEN asm_rewrite_tac[]));
a (fc_tac [pw_islb_lemma]);
(* *** Goal "2" *** *)
a (rewrite_tac [get_spec ¨PwÆ]
	THEN REPEAT strip_tac);
a (spec_nth_asm_tac 2 ¨x'Æ);
a (fc_tac [get_spec ¨IsGlbÆ]);
a (spec_nth_asm_tac 2 ¨x x'Æ);
a (GET_ASM_T ¨IsLb (Pw r) G xÆ ante_tac
	THEN rewrite_tac [get_spec ¨PwÆ]);
a (swap_nth_asm_concl_tac 1);
a (DROP_NTH_ASM_T 6 ante_tac
	THEN rewrite_tac [get_spec ¨PwÆ, get_spec ¨IsLbÆ]
	THEN REPEAT strip_tac);
a (all_asm_fc_tac[]);
a (spec_nth_asm_tac 2 ¨x'Æ
	THEN POP_ASM_T ante_tac
	THEN asm_rewrite_tac[]);
val pw_isglb_lemma = pop_thm ();

set_goal([], ¨µr G f∑ IsGlb (Pw r) G f
	§ (µ v∑ IsGlb r {w | ∂g∑ g ç G ± w = g v} (f v))Æ);
a (REPEAT strip_tac THEN all_fc_tac [pw_isglb_lemma]);
a (POP_ASM_T ante_tac THEN rewrite_tac [get_spec ¨IsGlbÆ] THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a (fc_tac [pw_islb_lemma2] THEN asm_rewrite_tac []);
(* *** Goal "2" *** *)
a (spec_nth_asm_tac 2 ¨Ãz∑ if z = v then x else f zÆ);
(* *** Goal "2.1" *** *)
a (swap_nth_asm_concl_tac 1);
a (DROP_NTH_ASM_T 4 ante_tac);
a (DROP_NTH_ASM_T 2 ante_tac);
a (rewrite_tac [pw_islb_lemma2]);
a (rewrite_tac[get_spec ¨IsLbÆ]);
a (REPEAT strip_tac);
a (cond_cases_tac ¨v' = vÆ);
(* *** Goal "2.1.1" *** *)
a (var_elim_asm_tac ¨v' = vÆ);
a (var_elim_asm_tac ¨x' = g vÆ);
a (spec_nth_asm_tac 3 ¨g vÆ);
a (spec_nth_asm_tac 1 ¨gÆ);
(* *** Goal "2.1.2" *** *)
a (var_elim_asm_tac ¨x' = g v'Æ);
a (list_spec_nth_asm_tac 3 [¨v'Æ, ¨g v'Æ]);
a (spec_nth_asm_tac 1 ¨gÆ);
(* *** Goal "2.2" *** *)
a (POP_ASM_T ante_tac THEN rewrite_tac [get_spec ¨PwÆ]);
a (strip_tac THEN spec_nth_asm_tac 1 ¨vÆ);
a (POP_ASM_T ante_tac THEN rewrite_tac[]);
val pw_isglb_lemma2 = pop_thm ();

set_merge_pcs ["rbjmisc1", "'GS1", "'misc2"];

set_goal([], ¨µr∑ Rpo (Universe, r) ¥ Rpo (Universe, Pw r)Æ);
a (REPEAT strip_tac
	THEN fc_tac[rpou_fc_clauses]
	THEN rewrite_tac (map get_spec [¨RpoÆ, ¨PwÆ, ¨PartialOrderÆ, ¨AntisymÆ, ¨TransÆ, ¨ReflÆ])
	THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a (list_spec_nth_asm_tac 3 [¨x x'Æ, ¨y x'Æ]);
(* *** Goal "1.1" *** *)
a (∂_tac ¨x'Æ THEN strip_tac);
a (asm_fc_tac[]);
(* *** Goal "2" *** *)
a (REPEAT_N 2 (spec_nth_asm_tac 2 ¨x'Æ)
	THEN all_asm_fc_tac[]);
(* *** Goal "3" *** *)
a (asm_rewrite_tac[]);
val pw_rpo_lemma = pop_thm ();

set_goal([], ¨µr∑ RpoU r ¥ RpoU (Pw r)Æ);
a (rewrite_tac [get_spec ¨RpoUÆ] THEN REPEAT strip_tac);
a (fc_tac [pw_rpo_lemma]);
val pw_rpou_lemma = pop_thm ();

set_merge_pcs ["rbjmisc1", "'GS1", "'misc2"];

set_goal([], ¨µr∑ CcRpo (Universe, r) ¥ ChainComplete (Universe, Pw r)Æ);
a (rewrite_tac (map get_spec [¨CcRpoÆ, ¨RpoÆ, ¨PartialOrderÆ, ¨AntisymÆ, ¨ChainCompleteÆ])
	THEN REPEAT strip_tac);
a (lemma_tac ¨µv∑ LinearOrder ({w | ∂f∑ f ç Y ± w = f v}, r)Æ);
(* *** Goal "1" *** *)
a (rewrite_tac (map get_spec [¨LinearOrderÆ, ¨PartialOrderÆ, ¨AntisymÆ, ¨TransÆ, ¨TrichÆ])
	THEN REPEAT strip_tac);
(* *** Goal "1.1" *** *)
a (all_asm_fc_tac[]);
(* *** Goal "1.2" *** *)
a (FC_T (MAP_EVERY (asm_tac o (rewrite_rule[]))) [get_spec ¨TransÆ]);
a (all_asm_fc_tac[]);
(* *** Goal "1.3" *** *)
a (fc_tac [get_spec ¨LinearOrderÆ]);
a (fc_tac [get_spec ¨TrichÆ]);
(* a (POP_ASM_T ante_tac THEN rewrite_tac [get_spec ¨PwÆ]
	THEN REPEAT strip_tac); *)
a (list_spec_nth_asm_tac 1 [¨fÆ, ¨f'Æ]);
(* *** Goal "1.3.1" *** *)
a (DROP_NTH_ASM_T 6 ante_tac THEN asm_rewrite_tac[]);
(* *** Goal "1.1.2" *** *)
a (POP_ASM_T ante_tac THEN rewrite_tac [get_spec ¨PwÆ] THEN strip_tac);
a (spec_nth_asm_tac 1 ¨vÆ);
a (DROP_NTH_ASM_T 6 ante_tac THEN asm_rewrite_tac[]);
(* *** Goal "1.3.3" *** *)
a (POP_ASM_T ante_tac THEN rewrite_tac [get_spec ¨PwÆ] THEN strip_tac);
a (asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a (lemma_tac ¨∂f∑ µv∑ IsLub r {w|∂ f∑ f ç Y ± w = f v} (f v)Æ
	THEN1 prove_∂_tac);
(* *** Goal "2.1" *** *)
a (strip_tac);
a (spec_nth_asm_tac 1 ¨v'Æ);
a (all_asm_fc_tac[]);
a (∂_tac ¨xÆ THEN strip_tac);
(* *** Goal "2.2" *** *)
a (∂_tac ¨fÆ);
a (bc_tac [pw_islub_lemma]);
a (asm_rewrite_tac[]);
val pw_cc_lemma = pop_thm ();

set_goal([], ¨µr∑ CcRpoU r ¥ CcRpoU (Pw r)Æ);
a (REPEAT strip_tac);
a (fc_tac [get_spec ¨CcRpoUÆ]);
a (fc_tac [get_spec ¨CcRpoÆ]);
a (fc_tac [pw_rpo_lemma]);
a (fc_tac [pw_cc_lemma]);
a (asm_rewrite_tac (map get_spec [¨CcRpoUÆ, ¨CcRpoÆ]));
val pw_ccrpou_thm = save_pop_thm "pw_ccrpou_thm";

set_goal([], ¨µr∑ LubsExist r ¥ LubsExist (Pw r)Æ);
a (rewrite_tac [get_spec ¨LubsExistÆ] THEN REPEAT strip_tac);
a (lemma_tac ¨∂f∑ µv∑ IsLub r {w|∂ g∑ g ç s ± w = g v} (f v)Æ
	THEN1 prove_∂_tac);
(* *** Goal "1" *** *)
a (strip_tac);
a (spec_nth_asm_tac 1 ¨{w|∂ g∑ g ç s ± w = g v'}Æ);
a (∂_tac ¨eÆ THEN asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a (fc_tac [pw_islub_lemma]);
a (∂_tac ¨fÆ THEN asm_rewrite_tac[]);
val pw_lubs_exist_thm = save_pop_thm "pw_lubs_exist_thm";

set_goal([], ¨µr∑ GlbsExist r ¥ GlbsExist (Pw r)Æ);
a (rewrite_tac [get_spec ¨GlbsExistÆ] THEN REPEAT strip_tac);
a (lemma_tac ¨∂f∑ µv∑ IsGlb r {w|∂ g∑ g ç s ± w = g v} (f v)Æ
	THEN1 prove_∂_tac);
(* *** Goal "1" *** *)
a (strip_tac);
a (spec_nth_asm_tac 1 ¨{w|∂ g∑ g ç s ± w = g v'}Æ);
a (∂_tac ¨eÆ THEN asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a (fc_tac [pw_isglb_lemma]);
a (∂_tac ¨fÆ THEN asm_rewrite_tac[]);
val pw_glbs_exist_thm = save_pop_thm "pw_glbs_exist_thm";

set_goal([], ¨µr∑ CRpoU r ¥ CRpoU (Pw r)Æ);
a (rewrite_tac (map get_spec [¨CRpoUÆ, ¨RpoUÆ]) THEN REPEAT strip_tac);
a (fc_tac [pw_rpo_lemma]);
a (fc_tac [pw_lubs_exist_thm]);
a (fc_tac [pw_glbs_exist_thm]);
val pw_crpou_thm = save_pop_thm "pw_crpou_thm";
=TEX
}%ignore

=GFT
€pw_ºâtâ4_lubsexist_thm› = Ù LubsExist (Pw $ºâtâ4)

€pw_ºâtâ4_glbsexist_thm› = Ù GlbsExist (Pw $ºâtâ4)

€pw_ºâtâ4_crpou_thm› = Ù CRpoU (Pw $ºâtâ4)
=TEX

\ignore{
=SML
set_goal([], ¨LubsExist (Pw $ºâtâ4)Æ);
a (bc_tac [pw_lubs_exist_thm]);
a (rewrite_tac []);
val pw_ºâtâ4_lubsexist_thm = save_pop_thm "pw_ºâtâ4_lubsexist_thm";

set_goal([], ¨GlbsExist (Pw $ºâtâ4)Æ);
a (bc_tac [pw_glbs_exist_thm]);
a (rewrite_tac []);
val pw_ºâtâ4_glbsexist_thm = save_pop_thm "pw_ºâtâ4_glbsexist_thm";

set_goal([], ¨CRpoU (Pw $ºâtâ4)Æ);
a (bc_tac [pw_crpou_thm]);
a (rewrite_tac []);
val pw_ºâtâ4_cprou_thm = save_pop_thm "pw_ºâtâ4_crpou_thm";
=TEX
}%ignore

=GFT
€crpou_lub_pw_lemma› =
   Ù µ r
     ∑ CRpoU r ¥ (µ G∑ Lub (Pw r) G = (Ã x∑ Lub r {w|∂ g∑ g ç G ± w = g x}))

€crpou_lub_pw_pw_lemma› =
   Ù µ r
     ∑ CRpoU r
         ¥ (µ G
         ∑ Lub (Pw (Pw r)) G = (Ã x y∑ Lub r {w|∂ g∑ g ç G ± w = g x y}))
=TEX

\ignore{
=SML
set_goal([], ¨µr∑ CRpoU r ¥ µG∑ Lub (Pw r) G = Ãx∑ Lub r {w | ∂g∑ g ç G ± w = g x}Æ);
a (REPEAT strip_tac);
a (lemma_tac ¨IsLub (Pw r) G Ãx∑ Lub r {w | ∂g∑ g ç G ± w = g x}Æ);
(* *** Goal "1" *** *)
a (REPEAT strip_tac THEN fc_tac [crpou_fc_clauses]);
a (rewrite_tac [pw_islub_lemma2] THEN strip_tac);
a (strip_asm_tac (µ_elim ¨{w|∂ g∑ g ç G ± w = g v}Æ (µ_elim ¨rÆ lub_lub_lemma2)));
(* *** Goal "2" *** *)
a (lemma_tac ¨IsLub (Pw r) G (Lub (Pw r) G)Æ);
(* *** Goal "2.1" *** *)
a (fc_tac [inst_type_rule [(î'aÆ, î'bÆ), (î'bÆ, î'aÆ)] pw_crpou_thm]);
a (fc_tac [crpou_fc_clauses]);
a (strip_asm_tac (µ_elim ¨GÆ (µ_elim ¨Pw rÆ lub_lub_lemma2)));
(* *** Goal "2.2" *** *)
a (fc_tac [inst_type_rule [(î'aÆ, î'bÆ), (î'bÆ, î'aÆ)] pw_crpou_thm]);
a (fc_tac [get_spec ¨CRpoUÆ]);
a (fc_tac [get_spec ¨RpoUÆ]);
a (fc_tac [get_spec ¨RpoÆ]);
a (fc_tac [get_spec ¨PartialOrderÆ]);
a (all_fc_tac [lub_unique_lemma]);
a (POP_ASM_T discard_tac THEN once_asm_rewrite_tac [] THEN strip_tac);
val crpou_lub_pw_lemma = pop_thm ();

set_goal([], ¨µr∑ CRpoU r ¥ µG:('b ≠ 'c ≠ 'a) SET∑ Lub (Pw (Pw r)) G
		= Ãx y∑ Lub r {w | ∂g∑ g ç G ± w = g x y}Æ);
a (REPEAT strip_tac);
a (fc_tac [inst_type_rule [(î'cÆ, î'aÆ), (î'aÆ, î'bÆ)] pw_crpou_thm]);
a (fc_tac [crpou_lub_pw_lemma]);
a (asm_rewrite_tac[]);
a (rewrite_tac [µ_elim ¨{w|∂ g∑ g ç G ± (µ x'∑ w x' = g x x')}Æ
	(¥_elim (µ_elim ¨rÆ crpou_lub_pw_lemma) (asm_rule ¨CRpoU rÆ))]);
a (LEMMA_T ¨{w|∂ g∑ (∂ g'∑ g' ç G ± (µ x'∑ g x' = g' x x')) ± w = g x'}
             = {w|∂ g∑ g ç G ± w = g x x'}Æ rewrite_thm_tac);
a (rewrite_tac[] THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a (∂_tac ¨g'Æ THEN asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a (∂_tac ¨g xÆ THEN asm_rewrite_tac[]);
a (∂_tac ¨gÆ THEN asm_rewrite_tac[]);
val crpou_lub_pw_pw_lemma = pop_thm ();
=TEX
}%ignore


Sometimes we are only interested in the behaviour of a function over some subset of its domain type.
The following version of {\it Pw} is parameterised by a set which gives the subdomain over which the values of the function are significant to the resulting ordering.

This is not a partial order since it is not antisymmetric.
It is a pre-order.

πHOLCONST
‹ €PwS› : 'b SET ≠ ('a ≠ 'a ≠ BOOL) ≠ (('b ≠ 'a) ≠ ('b ≠ 'a) ≠ BOOL)
˜¸¸¸¸¸¸¸¸¸¸¸
‹ µV r∑ PwS V r = Ã lo ro∑ µx∑ x ç V ¥ r (lo x) (ro x)
∞

=GFT
€pws_isub_lemma› =
   Ù µV r G f∑ (µ v∑ v ç V ¥ IsUb r {w | ∂g∑ g ç G ± w = g v} (f v))
	¥ IsUb (PwS V r) G f

€pws_isub_lemma3› =
   Ù µ V r G f
     ∑ IsUb (PwS V r) G f
         § (µ v∑ v ç V ¥ IsUb r {w|∂ g∑ g ç G ± w = g v} (f v))
=TEX
=GFT
€pws_islb_lemma› =
   Ù µ V r G f∑ (µ v∑ v ç V ¥ IsLb r {w|∂ g∑ g ç G ± w = g v} (f v))
	¥ IsLb (PwS V r) G f

€pws_islb_lemma2› =
   Ù µ V r G f
     ∑ IsLb (PwS V r) G f
         ¥ (µ v∑ v ç V ¥ IsLb r {w|∂ g∑ g ç G ± w = g v} (f v))

€pws_islb_lemma3› =
   Ù µ V r G f
     ∑ IsLb (PwS V r) G f
         § (µ v∑ v ç V ¥ IsLb r {w|∂ g∑ g ç G ± w = g v} (f v))
=TEX
=GFT
€pws_islub_lemma› =
   Ù µ V r G f
     ∑ (µ v∑ v ç V ¥ IsLub r {w|∂ g∑ g ç G ± w = g v} (f v))
	¥ IsLub (PwS V r) G f

€pws_islub_lemma2› =
   Ù µ V r G f
     ∑ IsLub (PwS V r) G f
         ¥ (µ v∑ v ç V ¥ IsLub r {w|∂ g∑ g ç G ± w = g v} (f v))

€pws_islub_lemma3› =
   Ù µ V r G f
     ∑ IsLub (PwS V r) G f
         § (µ v∑ v ç V ¥ IsLub r {w|∂ g∑ g ç G ± w = g v} (f v))
=TEX
=GFT
€pws_isglb_lemma› =
   Ù µ V r G f
     ∑ (µ v∑ v ç V ¥ IsGlb r {w|∂ g∑ g ç G ± w = g v} (f v))
	¥ IsGlb (PwS V r) G f

€pws_isglb_lemma2› =
   Ù µ V r G f
     ∑ IsGlb (PwS V r) G f
         ¥ (µ v∑ v ç V ¥ IsGlb r {w|∂ g∑ g ç G ± w = g v} (f v))

€pws_isglb_lemma3› =
   Ù µ V r G f
     ∑ (µ v∑ v ç V ¥ IsGlb r {w|∂ g∑ g ç G ± w = g v} (f v))
         § IsGlb (PwS V r) G f
=TEX
=GFT
€pws_lubs_exist_thm› =
	Ù µ V r∑ LubsExist r ¥ LubsExist (PwS V r)

€pws_glbs_exist_thm› =
	Ù µ V r∑ GlbsExist r ¥ GlbsExist (PwS V r)
=TEX

\ignore{
=SML
set_goal([], ¨µV r G f∑ (µ v∑ v ç V ¥ IsUb r {w | ∂g∑ g ç G ± w = g v} (f v))
	¥ IsUb (PwS V r) G fÆ);
a (rewrite_tac [get_spec ¨IsUbÆ, get_spec ¨PwSÆ] THEN REPEAT strip_tac);
a (spec_nth_asm_tac 3 ¨x'Æ);
a (list_spec_nth_asm_tac 1 [¨x x'Æ]);
a (spec_nth_asm_tac 1 ¨xÆ);
val pws_isub_lemma = pop_thm ();

set_goal([], ¨µV r G f∑ IsUb (PwS V r) G f ¥ (µ v∑ v ç V
		¥ IsUb r {w | ∂g∑ g ç G ± w = g v} (f v))Æ);
a (rewrite_tac [get_spec ¨IsUbÆ, get_spec ¨PwSÆ] THEN REPEAT strip_tac);
a (spec_nth_asm_tac 4 ¨gÆ);
a (list_spec_nth_asm_tac 1 [¨vÆ]);
a (asm_rewrite_tac[]);
val pws_isub_lemma2 = pop_thm ();

set_goal([], ¨µV r G f∑ IsUb (PwS V r) G f
	§ (µ v∑ v ç V ¥ IsUb r {w | ∂g∑ g ç G ± w = g v} (f v))Æ);
a (REPEAT_N 7 strip_tac THEN asm_fc_tac [pws_isub_lemma, pws_isub_lemma2]);
val pws_isub_lemma3 = pop_thm ();

set_goal([], ¨µV r G f∑ (µ v∑ v ç V ¥ IsLb r {w | ∂g∑ g ç G ± w = g v} (f v))
	¥ IsLb (PwS V r) G fÆ);
a (rewrite_tac [get_spec ¨IsLbÆ, get_spec ¨PwSÆ] THEN REPEAT strip_tac);
a (spec_nth_asm_tac 3 ¨x'Æ);
a (spec_nth_asm_tac 1 ¨x x'Æ);
a (spec_nth_asm_tac 1 ¨xÆ);
val pws_islb_lemma = pop_thm ();

set_goal([], ¨µV r G f∑ IsLb (PwS V r) G f
	¥ (µ v∑ v ç V ¥ IsLb r {w | ∂g∑ g ç G ± w = g v} (f v))Æ);
a (rewrite_tac [get_spec ¨IsLbÆ, get_spec ¨PwSÆ] THEN REPEAT strip_tac);
a (spec_nth_asm_tac 4 ¨gÆ);
a (spec_nth_asm_tac 1 ¨vÆ);
a (asm_rewrite_tac []);
val pws_islb_lemma2 = pop_thm ();

set_goal([], ¨µV r G f∑ IsLb (PwS V r) G f
	§ (µ v∑ v ç V ¥ IsLb r {w | ∂g∑ g ç G ± w = g v} (f v))Æ);
a (REPEAT_N 7 strip_tac THEN asm_fc_tac [pws_islb_lemma, pws_islb_lemma2]);
val pws_islb_lemma3 = pop_thm ();

set_goal([], ¨µV r G f∑ (µ v∑ v ç V ¥ IsLub r {w | ∂g∑ g ç G ± w = g v} (f v))
	¥ IsLub (PwS V r) G fÆ);
a (REPEAT strip_tac THEN rewrite_tac [get_spec ¨IsLubÆ] THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a (lemma_tac ¨µ v∑ v ç V ¥ IsUb r {w|∂ g∑ g ç G ± w = g v} (f v)Æ
	THEN1 (REPEAT strip_tac THEN asm_fc_tac [] 
		THEN POP_ASM_T (strip_asm_tac o (rewrite_rule [get_spec ¨IsLubÆ]))
		THEN asm_rewrite_tac[]));
a (fc_tac [pws_isub_lemma]);
(* *** Goal "2" *** *)
a (rewrite_tac [get_spec ¨PwSÆ]
	THEN REPEAT strip_tac);
a (spec_nth_asm_tac 3 ¨x'Æ);
a (fc_tac [get_spec ¨IsLubÆ]);
a (spec_nth_asm_tac 2 ¨x x'Æ);
a (GET_ASM_T ¨IsUb (PwS V r) G xÆ ante_tac
	THEN rewrite_tac [get_spec ¨PwSÆ]);
a (swap_nth_asm_concl_tac 1);
a (DROP_NTH_ASM_T 7 ante_tac
	THEN rewrite_tac [get_spec ¨PwSÆ, get_spec ¨IsUbÆ]
	THEN REPEAT strip_tac);
a (all_asm_fc_tac[]);
a (asm_rewrite_tac[]);
val pws_islub_lemma = pop_thm ();

set_goal([], ¨µV r G f∑ IsLub (PwS V r) G f
	¥ (µ v∑ v ç V ¥ IsLub r {w | ∂g∑ g ç G ± w = g v} (f v))Æ);
a (REPEAT µ_tac THEN rewrite_tac [get_spec ¨IsLubÆ, pws_isub_lemma3, get_spec ¨PwSÆ] THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a (all_asm_fc_tac[]);
(* *** Goal "2" *** *)
a (lemma_tac ¨∂h∑ µz∑ h z = if z = v then x else f zÆ
	THEN1 prove_∂_tac);
a (spec_nth_asm_tac 4 ¨hÆ);
(* *** Goal "2.1" *** *)
a (swap_nth_asm_concl_tac 1);
a (asm_rewrite_tac[get_spec ¨IsUbÆ]
		THEN REPEAT strip_tac THEN asm_rewrite_tac[]);
a (var_elim_nth_asm_tac 1);
a (cond_cases_tac ¨v' = vÆ);
(* *** Goal "2.1.1" *** *)
a (var_elim_nth_asm_tac 1);
a (DROP_NTH_ASM_T 4 (asm_tac o (rewrite_rule [get_spec ¨IsUbÆ])));
a (spec_nth_asm_tac 1 ¨g vÆ);
a (spec_nth_asm_tac 1 ¨gÆ);
(* *** Goal "2.1.2" *** *)
a (all_asm_fc_tac[]);
a (DROP_NTH_ASM_T 2 (asm_tac o (rewrite_rule [get_spec ¨IsUbÆ])));
a (spec_nth_asm_tac 1 ¨g v'Æ);
a (spec_nth_asm_tac 1 ¨gÆ);
(* *** Goal "2.2" *** *)
a (spec_nth_asm_tac 1 ¨vÆ);
a (POP_ASM_T ante_tac THEN asm_rewrite_tac[]);
val pws_islub_lemma2 = pop_thm ();

set_goal([], ¨µV r G f∑ IsLub (PwS V r) G f
	§ (µ v∑ v ç V ¥ IsLub r {w | ∂g∑ g ç G ± w = g v} (f v))Æ);
a (REPEAT_N 7 strip_tac THEN asm_fc_tac [pws_islub_lemma, pws_islub_lemma2]);
val pws_islub_lemma3 = pop_thm ();

set_goal([], ¨µV r G f∑ (µ v∑ v ç V ¥ IsGlb r {w | ∂g∑ g ç G ± w = g v} (f v))
	¥ IsGlb (PwS V r) G fÆ);
a (REPEAT strip_tac THEN rewrite_tac [get_spec ¨IsGlbÆ] THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a (lemma_tac ¨µ v∑ v ç V ¥ IsLb r {w|∂ g∑ g ç G ± w = g v} (f v)Æ
	THEN1 (REPEAT strip_tac THEN asm_fc_tac [] 
		THEN POP_ASM_T (strip_asm_tac o (rewrite_rule [get_spec ¨IsGlbÆ]))
		THEN asm_rewrite_tac[]));
a (fc_tac [pws_islb_lemma]);
(* *** Goal "2" *** *)
a (rewrite_tac [get_spec ¨PwSÆ]
	THEN REPEAT strip_tac);
a (spec_nth_asm_tac 3 ¨x'Æ);
a (fc_tac [get_spec ¨IsGlbÆ]);
a (spec_nth_asm_tac 2 ¨x x'Æ);
a (GET_ASM_T ¨IsLb (PwS V r) G xÆ ante_tac
	THEN rewrite_tac [get_spec ¨PwSÆ]);
a (swap_nth_asm_concl_tac 1);
a (DROP_NTH_ASM_T 7 ante_tac
	THEN rewrite_tac [get_spec ¨PwSÆ, get_spec ¨IsLbÆ]
	THEN REPEAT strip_tac);
a (all_asm_fc_tac[]);
a (asm_rewrite_tac[]);
val pws_isglb_lemma = pop_thm ();

set_goal([], ¨µV r G f∑ IsGlb (PwS V r) G f
	¥ (µ v∑ v ç V ¥ IsGlb r {w | ∂g∑ g ç G ± w = g v} (f v))Æ);
a (REPEAT µ_tac THEN rewrite_tac [get_spec ¨IsGlbÆ, pws_islb_lemma3, get_spec ¨PwSÆ] THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a (all_asm_fc_tac[]);
(* *** Goal "2" *** *)
a (lemma_tac ¨∂h∑ µz∑ h z = if z = v then x else f zÆ
	THEN1 prove_∂_tac);
a (spec_nth_asm_tac 4 ¨hÆ);
(* *** Goal "2.1" *** *)
a (swap_nth_asm_concl_tac 1);
a (asm_rewrite_tac[get_spec ¨IsLbÆ]
		THEN REPEAT strip_tac THEN asm_rewrite_tac[]);
a (var_elim_nth_asm_tac 1);
a (cond_cases_tac ¨v' = vÆ);
(* *** Goal "2.1.1" *** *)
a (var_elim_nth_asm_tac 1);
a (DROP_NTH_ASM_T 4 (asm_tac o (rewrite_rule [get_spec ¨IsLbÆ])));
a (spec_nth_asm_tac 1 ¨g vÆ);
a (spec_nth_asm_tac 1 ¨gÆ);
(* *** Goal "2.1.2" *** *)
a (all_asm_fc_tac[]);
a (DROP_NTH_ASM_T 2 (asm_tac o (rewrite_rule [get_spec ¨IsLbÆ])));
a (spec_nth_asm_tac 1 ¨g v'Æ);
a (spec_nth_asm_tac 1 ¨gÆ);
(* *** Goal "2.2" *** *)
a (spec_nth_asm_tac 1 ¨vÆ);
a (POP_ASM_T ante_tac THEN asm_rewrite_tac[]);
val pws_isglb_lemma2 = pop_thm ();

set_goal([], ¨µV r G f∑ IsGlb (PwS V r) G f
	§ (µ v∑ v ç V ¥ IsGlb r {w | ∂g∑ g ç G ± w = g v} (f v))Æ);
a (REPEAT_N 7 strip_tac THEN asm_fc_tac [pws_isglb_lemma, pws_isglb_lemma2]);
val pws_isglb_lemma3 = pop_thm ();

set_merge_pcs ["rbjmisc1", "'GS1", "'misc2"];

set_goal([], ¨µV r∑ LubsExist r ¥ LubsExist (PwS V r)Æ);
a (rewrite_tac [get_spec ¨LubsExistÆ] THEN REPEAT strip_tac);
a (lemma_tac ¨∂f∑ µv∑ v ç V ¥ IsLub r {w|∂ g∑ g ç s ± w = g v} (f v)Æ
	THEN1 prove_∂_tac);
(* *** Goal "1" *** *)
a (strip_tac);
a (spec_nth_asm_tac 1 ¨{w|∂ g∑ g ç s ± w = g v'}Æ);
a (∂_tac ¨eÆ THEN asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a (fc_tac [pws_islub_lemma]);
a (∂_tac ¨fÆ THEN asm_rewrite_tac[]);
val pws_lubs_exist_thm = save_pop_thm "pws_lubs_exist_thm";

set_goal([], ¨µV r∑ GlbsExist r ¥ GlbsExist (PwS V r)Æ);
a (rewrite_tac [get_spec ¨GlbsExistÆ] THEN REPEAT strip_tac);
a (lemma_tac ¨∂f∑ µv∑ v ç V ¥ IsGlb r {w|∂ g∑ g ç s ± w = g v} (f v)Æ
	THEN1 prove_∂_tac);
(* *** Goal "1" *** *)
a (strip_tac);
a (spec_nth_asm_tac 1 ¨{w|∂ g∑ g ç s ± w = g v'}Æ);
a (∂_tac ¨eÆ THEN asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a (fc_tac [pws_isglb_lemma]);
a (∂_tac ¨fÆ THEN asm_rewrite_tac[]);
val pws_glbs_exist_thm = save_pop_thm "pws_glbs_exist_thm";
=TEX
}%ignore


\subsection{Products}

We also need the following ordering over products.

πHOLCONST
‹ €PrO› : ('a ≠ 'a ≠ BOOL) ≠ ('b ≠ 'b ≠ BOOL) ≠ (('a ∏ 'b) ≠ ('a ∏ 'b) ≠ BOOL)
˜¸¸¸¸¸¸¸¸¸¸¸
‹ µ ra rb∑ PrO ra rb = Ãl r∑ ra (Fst l) (Fst r) ± rb (Snd l) (Snd r)
∞

=GFT
€pro_isub_lemma› =
   Ù µ ra rb s lub rub
     ∑ IsUb ra {w|∂ g∑ g ç s ± w = Fst g} lub
           ± IsUb rb {w|∂ g∑ g ç s ± w = Snd g} rub
         § IsUb (PrO ra rb) s (lub, rub)

€pro_islb_lemma› =
   Ù µ ra rb s llb rlb
     ∑ IsLb ra {w|∂ g∑ g ç s ± w = Fst g} llb
           ± IsLb rb {w|∂ g∑ g ç s ± w = Snd g} rlb
         § IsLb (PrO ra rb) s (llb, rlb)

€pro_islub_lemma› =
   Ù µ ra rb s llub rlub
     ∑ IsLub ra {w|∂ g∑ g ç s ± w = Fst g} llub
           ± IsLub rb {w|∂ g∑ g ç s ± w = Snd g} rlub
         ¥ IsLub (PrO ra rb) s (llub, rlub)

€pro_isglb_lemma› =
   Ù µ ra rb s lglb rglb
     ∑ IsGlb ra {w|∂ g∑ g ç s ± w = Fst g} lglb
           ± IsGlb rb {w|∂ g∑ g ç s ± w = Snd g} rglb
         ¥ IsGlb (PrO ra rb) s (lglb, rglb)

€pro_refl_lemma› =
   Ù µ ra rb
     ∑ Refl (Universe, ra) ± Refl (Universe, rb) ¥ Refl (Universe, PrO ra rb)

€pro_partialorder_lemma› =
   Ù µ ra rb
     ∑ PartialOrder (Universe, ra) ± PartialOrder (Universe, rb)
         ¥ PartialOrder (Universe, PrO ra rb)

€pro_rpo_lemma› =
   Ù µ ra rb
     ∑ Rpo (Universe, ra) ± Rpo (Universe, rb) ¥ Rpo (Universe, PrO ra rb)

€pro_lubs_exist_thm› =
   Ù µ ra rb∑ LubsExist ra ± LubsExist rb ¥ LubsExist (PrO ra rb)

€pro_glbs_exist_thm› =
   Ù µ ra rb∑ GlbsExist ra ± GlbsExist rb ¥ GlbsExist (PrO ra rb)

€pro_crpou_thm› =
   Ù µ ra rb∑ CRpoU ra ± CRpoU rb ¥ CRpoU (PrO ra rb)
=TEX

\ignore{
=SML
set_goal([], ¨µra rb s lub rub ∑
	  IsUb ra {w | ∂g∑ g ç s ± w = Fst g} lub
	± IsUb rb {w | ∂g∑ g ç s ± w = Snd g} rub
	§ IsUb (PrO ra rb) s (lub, rub)Æ);
a (rewrite_tac [get_spec ¨IsUbÆ, get_spec ¨PrOÆ] THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a (list_spec_nth_asm_tac 3 [¨Fst xÆ]);
a (spec_nth_asm_tac 1 ¨xÆ);
(* *** Goal "2" *** *)
a (list_spec_nth_asm_tac 2 [¨Snd xÆ]);
a (spec_nth_asm_tac 1 ¨xÆ);
(* *** Goal "3" *** *)
a (asm_fc_tac [] THEN asm_rewrite_tac[]);
(* *** Goal "4" *** *)
a (asm_fc_tac [] THEN asm_rewrite_tac[]);
val pro_isub_lemma = pop_thm ();

set_goal([], ¨µra rb s llb rlb∑
	  IsLb ra {w | ∂g∑ g ç s ± w = Fst g} llb
	± IsLb rb {w | ∂g∑ g ç s ± w = Snd g} rlb
	§ IsLb (PrO ra rb) s (llb, rlb)Æ);
a (rewrite_tac [get_spec ¨IsLbÆ, get_spec ¨PrOÆ] THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a (list_spec_nth_asm_tac 3 [¨Fst xÆ]);
a (spec_nth_asm_tac 1 ¨xÆ);
(* *** Goal "2" *** *)
a (list_spec_nth_asm_tac 2 [¨Snd xÆ]);
a (spec_nth_asm_tac 1 ¨xÆ);
(* *** Goal "3" *** *)
a (asm_fc_tac [] THEN asm_rewrite_tac[]);
(* *** Goal "4" *** *)
a (asm_fc_tac [] THEN asm_rewrite_tac[]);
val pro_islb_lemma = pop_thm ();

set_goal([], ¨µra rb s llub rlub ∑
	  IsLub ra {w | ∂g∑ g ç s ± w = Fst g} llub
	± IsLub rb {w | ∂g∑ g ç s ± w = Snd g} rlub
	¥ IsLub (PrO ra rb) s (llub, rlub)Æ);
a (rewrite_tac [get_spec ¨IsLubÆ] THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a (all_fc_tac [pro_isub_lemma]);
(* *** Goal "2" *** *)
a (strip_asm_tac (rewrite_rule [] (list_µ_elim [¨raÆ, ¨rbÆ, ¨sÆ, ¨Fst xÆ, ¨Snd xÆ]
	(map_eq_sym_rule pro_isub_lemma))));
a (rewrite_tac [get_spec ¨PrOÆ]);
a (all_asm_fc_tac[] THEN contr_tac);
val pro_islub_lemma = pop_thm ();

set_goal([], ¨µra rb s lglb rglb ∑
	  IsGlb ra {w | ∂g∑ g ç s ± w = Fst g} lglb
	± IsGlb rb {w | ∂g∑ g ç s ± w = Snd g} rglb
	¥ IsGlb (PrO ra rb) s (lglb, rglb)Æ);
a (rewrite_tac [get_spec ¨IsGlbÆ] THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a (all_fc_tac [pro_islb_lemma]);
(* *** Goal "2" *** *)
a (strip_asm_tac (rewrite_rule [] (list_µ_elim [¨raÆ, ¨rbÆ, ¨sÆ, ¨Fst xÆ, ¨Snd xÆ]
	(map_eq_sym_rule pro_islb_lemma))));
a (rewrite_tac [get_spec ¨PrOÆ]);
a (all_asm_fc_tac[] THEN contr_tac);
val pro_isglb_lemma = pop_thm ();

set_goal([], ¨µra rb∑ Refl (Universe, ra) ± Refl (Universe, rb) ¥ Refl (Universe, (PrO ra rb))Æ);
a (rewrite_tac [get_spec ¨ReflÆ, get_spec ¨PrOÆ]
	THEN REPEAT strip_tac
	THEN_TRY asm_rewrite_tac[]);
val pro_refl_lemma = save_pop_thm "pro_refl_lemma";

set_goal([], ¨µra rb∑ PartialOrder (Universe, ra) ± PartialOrder (Universe, rb)
	¥ PartialOrder (Universe, (PrO ra rb))Æ);
a (rewrite_tac [get_spec ¨PartialOrderÆ, get_spec ¨PrOÆ, get_spec ¨AntisymÆ, get_spec ¨TransÆ]
	THEN REPEAT strip_tac
	THEN_TRY asm_rewrite_tac[]);
(* *** Goal "1" *** *)
a (contr_tac THEN all_asm_fc_tac[]);
a (rename_tac[]);
a (lemma_tac ¨≥ (Fst x = Fst y ± Snd x = Snd y)Æ
	THEN1 contr_tac);
a (DROP_NTH_ASM_T 11 ante_tac THEN pure_once_asm_rewrite_tac [prove_rule [] ¨µx∑ x = (Fst x, Snd x)Æ]); 
a (asm_rewrite_tac []); 
(* *** Goal "1.2" *** *)
a (asm_fc_tac[]);
(* *** Goal "1.3" *** *)
a (asm_fc_tac[]);
(* *** Goal "2" *** *)
a (all_asm_fc_tac[]);
(* *** Goal "3" *** *)
a (all_asm_fc_tac[]);
val pro_partialorder_lemma = save_pop_thm "pro_partialorder_lemma";

set_goal([], ¨µra rb∑ Rpo (Universe, ra) ± Rpo (Universe, rb) ¥ Rpo (Universe, (PrO ra rb))Æ);
a (rewrite_tac [get_spec ¨RpoÆ]
	THEN REPEAT strip_tac
	THEN all_fc_tac [pro_refl_lemma, pro_partialorder_lemma]);
val pro_rpo_lemma = save_pop_thm "pro_rpo_lemma";

set_goal([], ¨µra rb∑ LubsExist ra ± LubsExist rb ¥ LubsExist (PrO ra rb)Æ);
a (rewrite_tac [get_spec ¨LubsExistÆ] THEN REPEAT strip_tac);
a (spec_nth_asm_tac 2 ¨{w | ∂ g∑ g ç s ± w = Fst g}Æ);
a (spec_nth_asm_tac 2 ¨{w | ∂ g∑ g ç s ± w = Snd g}Æ);
a (all_fc_tac [pro_islub_lemma]);
a (∂_tac ¨(e, e')Æ THEN asm_rewrite_tac[]);
val pro_lubs_exist_thm = save_pop_thm "pro_lubs_exist_thm";

set_goal([], ¨µra rb∑ GlbsExist ra ± GlbsExist rb ¥ GlbsExist (PrO ra rb)Æ);
a (rewrite_tac [get_spec ¨GlbsExistÆ] THEN REPEAT strip_tac);
a (spec_nth_asm_tac 2 ¨{w | ∂ g∑ g ç s ± w = Fst g}Æ);
a (spec_nth_asm_tac 2 ¨{w | ∂ g∑ g ç s ± w = Snd g}Æ);
a (all_fc_tac [pro_isglb_lemma]);
a (∂_tac ¨(e, e')Æ THEN asm_rewrite_tac[]);
val pro_glbs_exist_thm = save_pop_thm "pro_glbs_exist_thm";

set_goal([], ¨µra rb∑ CRpoU ra ± CRpoU rb ¥ CRpoU (PrO ra rb)Æ);
a (rewrite_tac [get_spec ¨CRpoUÆ, get_spec ¨RpoUÆ]
	THEN REPEAT strip_tac
	THEN all_fc_tac [pro_rpo_lemma, pro_glbs_exist_thm, pro_lubs_exist_thm]);
val pro_crpou_thm = save_pop_thm "pro_crpou_thm";
=TEX
}%ignore

\subsection{OPT}

πHOLCONST
‹ €OptO› : ('a ≠ 'a ≠ BOOL) ≠ ('a OPT ≠ 'a OPT ≠ BOOL)
˜¸¸¸¸¸¸¸¸¸¸¸
‹ µrl∑ OptO rl = Ãl r∑ l = Undefined
‹		 ≤ IsDefined l ± IsDefined r ± rl (ValueOf l) (ValueOf r)
∞

\subsection{Discrete Partial Orders}

The things I am calling discrete partial orders come with the ordering of a discrete lattice.

When these are used to construct indexed sets whose elements have some ordering then there will be another ordering which is derived from the ordering on the elements.
This is defined for use in defining orderings over indexed sets.

πHOLCONST
‹ €DpoEO› : ('a ≠ 'a ≠ BOOL) ≠ ('a DPO ≠ 'a DPO ≠ BOOL)
˜¸¸¸¸¸¸¸¸¸¸¸
‹ µrl∑ DpoEO rl = Ãl r∑ dpoUdef l ≤ dpoOdef r
‹		≤ ∂le re∑ rl le re ± l = dpoE le ± r = dpoE re
∞

To get the discrete ordering apply this function to the equality relation.

=GFT
€is_isub_lemma› =
   Ù µ r G d
     ∑ IsUb r G d ¥ IsUb (DpoEO r) {w|∂ v∑ v ç G ± w = dpoE v} (dpoE d)

€is_islb_lemma› =
   Ù µ r G d
     ∑ IsLb r G d ¥ IsLb (DpoEO r) {w|∂ v∑ v ç G ± w = dpoE v} (dpoE d)

€is_isub_lemma2› =
   Ù µ r G d
     ∑ IsUb (DpoEO r) G d
         = (d = dpoT
           ≤ G Ä {dpoB} ± d = dpoB
           ≤ (∂ e∑ d = dpoE e ± IsUb r {w|dpoE w ç G} e) ± ≥ dpoT ç G)

€is_islb_lemma2› =
   Ù µ r G d
     ∑ IsLb (DpoEO r) G d
         = (d = dpoB
           ≤ G Ä {dpoT} ± d = dpoT
           ≤ (∂ e∑ d = dpoE e ± IsLb r {w|dpoE w ç G} e) ± ≥ dpoB ç G)

€is_islub_lemma› =
   Ù µ r G d
     ∑ IsLub (DpoEO r) G d
         = ((dpoT ç G ≤ (∂ w∑ dpoE w ç G) ± ≥ (∂ e∑ IsUb r {w|dpoE w ç G} e))
             ± d = dpoT
           ≤ G Ä {dpoB} ± d = dpoB
           ≤ ≥ G Ä {dpoB}
             ± (∂ e∑ d = dpoE e ± IsLub r {w|dpoE w ç G} e)
             ± ≥ dpoT ç G)

€is_isglb_lemma› =
   Ù µ r G d
     ∑ IsGlb (DpoEO r) G d
         = ((dpoB ç G ≤ (∂ w∑ dpoE w ç G) ± ≥ (∂ e∑ IsLb r {w|dpoE w ç G} e))
             ± d = dpoB
           ≤ G Ä {dpoT} ± d = dpoT
           ≤ ≥ G Ä {dpoT}
             ± (∂ e∑ d = dpoE e ± IsGlb r {w|dpoE w ç G} e)
             ± ≥ dpoB ç G)
=TEX

\ignore{
=SML
set_goal([], ¨µr G d∑ IsUb r G d
	¥ IsUb (DpoEO r) {w | ∂v∑ v ç G ± w = dpoE v} (dpoE d)Æ);
a (rewrite_tac [get_spec ¨IsUbÆ, get_spec ¨DpoEOÆ] THEN REPEAT strip_tac);
a (∂_tac ¨vÆ THEN ∂_tac ¨dÆ THEN all_asm_fc_tac [] THEN asm_rewrite_tac[]);
val dpoeo_isub_lemma = pop_thm ();

set_goal([], ¨µr G d∑ IsLb r G d
	¥ IsLb (DpoEO r) {w | ∂v∑ v ç G ± w = dpoE v} (dpoE d)Æ);
a (rewrite_tac [get_spec ¨IsLbÆ, get_spec ¨DpoEOÆ] THEN REPEAT strip_tac);
a (∂_tac ¨dÆ THEN ∂_tac ¨vÆ THEN all_asm_fc_tac [] THEN asm_rewrite_tac[]);
val dpoeo_islb_lemma = pop_thm ();

set_merge_pcs ["rbjmisc", "'GS1", "'misc2"];

set_goal([], ¨µr G d∑ IsUb (DpoEO r) G d
	§ d = dpoT
		≤ G Ä {dpoB} ± d = dpoB
		≤ (∂e∑ d = dpoE e ± IsUb r {w | dpoE w ç G} e) ± ≥ dpoT ç GÆ);
a (REPEAT µ_tac);
a (strip_asm_tac (µ_elim ¨dÆ dpo_cases_thm)
	THEN_TRY asm_rewrite_tac[get_spec ¨DpoEOÆ, get_spec ¨IsUbÆ, get_spec ¨dpoUdefÆ]);
(* *** Goal "1" *** *)
a (PC_T1 "hol1" prove_tac[]);
(* *** Goal "2" *** *)
a (REPEAT strip_tac THEN_TRY asm_rewrite_tac[]);
(* *** Goal "2.1" *** *)
a (∂_tac ¨eÆ THEN asm_rewrite_tac[get_spec ¨IsUbÆ]
	THEN REPEAT strip_tac
	THEN asm_fc_tac[]
	THEN asm_rewrite_tac[]);
(* *** Goal "2.2" *** *)
a (spec_nth_asm_tac 1 ¨dpoTÆ);
(* *** Goal "2.3" *** *)
a (strip_asm_tac (µ_elim ¨xÆ dpo_cases_thm));
(* *** Goal "2.3.1" *** *)
a (var_elim_asm_tac ¨x = dpoTÆ);
(* *** Goal "2.3.2" *** *)
a (∂_tac ¨dpoV xÆ THEN ∂_tac ¨eÆ
	THEN asm_rewrite_tac[]);
a (DROP_NTH_ASM_T 5 ante_tac
	THEN rewrite_tac[get_spec ¨IsUbÆ]
	THEN strip_tac);
a (var_elim_asm_tac ¨x = dpoE e''Æ
	THEN asm_fc_tac[]);
a (LEMMA_T ¨e = e'Æ (fn x => asm_rewrite_tac[x]));
a (var_elim_asm_tac ¨d = dpoE eÆ);
val dpoeo_isub_lemma2 = pop_thm ();

set_goal([], ¨µr G d∑ IsLb (DpoEO r) G d
	§ d = dpoB
		≤ G Ä {dpoT} ± d = dpoT
		≤ (∂e∑ d = dpoE e ± IsLb r {w | dpoE w ç G} e) ± ≥ dpoB ç GÆ);
a (REPEAT µ_tac);
a (strip_asm_tac (µ_elim ¨dÆ dpo_cases_thm)
	THEN_TRY asm_rewrite_tac[get_spec ¨DpoEOÆ, get_spec ¨IsLbÆ, get_spec ¨dpoOdefÆ]);
(* *** Goal "1" *** *)
a (PC_T1 "hol1" prove_tac[]);
(* *** Goal "2" *** *)
a (REPEAT strip_tac THEN_TRY asm_rewrite_tac[]);
(* *** Goal "2.1" *** *)
a (∂_tac ¨eÆ THEN asm_rewrite_tac[get_spec ¨IsLbÆ]
	THEN REPEAT strip_tac
	THEN asm_fc_tac[]
	THEN asm_rewrite_tac[]);
(* *** Goal "2.2" *** *)
a (spec_nth_asm_tac 1 ¨dpoBÆ);
(* *** Goal "2.3" *** *)
a (strip_asm_tac (µ_elim ¨xÆ dpo_cases_thm));
(* *** Goal "2.3.1" *** *)
a (var_elim_asm_tac ¨x = dpoBÆ);
(* *** Goal "2.3.2" *** *)
a (∂_tac ¨eÆ THEN ∂_tac ¨dpoV xÆ
	THEN asm_rewrite_tac[]);
a (DROP_NTH_ASM_T 5 ante_tac
	THEN rewrite_tac[get_spec ¨IsLbÆ]
	THEN strip_tac);
a (var_elim_asm_tac ¨x = dpoE e''Æ
	THEN asm_fc_tac[]);
a (LEMMA_T ¨e = e'Æ (fn x => asm_rewrite_tac[x]));
a (var_elim_asm_tac ¨d = dpoE eÆ);
val dpoeo_islb_lemma2 = pop_thm ();

set_goal([], ¨µr G d∑ IsLub (DpoEO r) G d
	§ (dpoT ç G ≤ (∂w∑ dpoE w ç G) ± ≥ (∂e∑ IsUb r {w | dpoE w ç G} e)) ± d = dpoT
		≤ G Ä {dpoB} ± d = dpoB
		≤ ≥ G Ä {dpoB} ± (∂e∑ d = dpoE e ± IsLub r {w | dpoE w ç G} e) ± ≥ dpoT ç GÆ);
a (REPEAT µ_tac);
a (strip_asm_tac (µ_elim ¨dÆ dpo_cases_thm)
	THEN_TRY asm_rewrite_tac[get_spec ¨IsLubÆ, dpoeo_isub_lemma2]);
(* *** Goal "1" *** *)
a (REPEAT strip_tac THEN_TRY asm_rewrite_tac [get_spec ¨DpoEOÆ]);
(* *** Goal "2" *** *)
a (asm_rewrite_tac [get_spec ¨DpoEOÆ]
	THEN REPEAT strip_tac
	THEN_TRY asm_rewrite_tac[]);
(* *** Goal "2.1" *** *)
a (spec_nth_asm_tac 2 ¨dpoBÆ);
a (DROP_NTH_ASM_T 2 ante_tac THEN PC_T "hol1" (REPEAT strip_tac));
a (strip_asm_tac (µ_elim ¨xÆ dpo_cases_thm)
	THEN_TRY asm_rewrite_tac[]);
(* *** Goal "2.1.1" *** *)
a (var_elim_asm_tac ¨x = dpoTÆ);
(* *** Goal "2.1.2" *** *)
a (var_elim_asm_tac ¨x = dpoE eÆ);
a (∂_tac ¨eÆ THEN asm_rewrite_tac[]);
(* *** Goal "2.2" *** *)
a (spec_nth_asm_tac 2 ¨dpoE eÆ
	THEN spec_nth_asm_tac 1 ¨eÆ);
(* *** Goal "2.3" *** *)
a (DROP_ASM_T ¨G Ä {dpoB}Æ ante_tac
	THEN PC_T "hol1" (REPEAT strip_tac)
	THEN asm_fc_tac[]);
(* *** Goal "2.4" *** *)
a (spec_nth_asm_tac 3 ¨dpoV dpoTÆ);
a (POP_ASM_T ante_tac
	THEN rewrite_tac [get_spec ¨IsUbÆ]
	THEN REPEAT strip_tac);
a (DROP_NTH_ASM_T 3 ante_tac
	THEN (PC_T "hol1" (REPEAT strip_tac))
	THEN asm_fc_tac[]);
(* *** Goal "2.5" *** *)
a (asm_fc_tac[]);
(* *** Goal "3" *** *)
a (asm_rewrite_tac [get_spec ¨DpoEOÆ]
	THEN REPEAT strip_tac
	THEN_TRY asm_rewrite_tac[]);
(* *** Goal "3.1" *** *)
a (spec_nth_asm_tac 1 ¨dpoBÆ);
(* *** Goal "3.2" *** *)
a (var_elim_asm_tac ¨d = dpoE e'Æ);
a (var_elim_asm_tac ¨e' = eÆ);
a (∂_tac ¨eÆ THEN asm_rewrite_tac[]);
a (asm_rewrite_tac [get_spec ¨IsLubÆ]
	THEN REPEAT strip_tac);
a (fc_tac [get_spec ¨IsUbÆ]);
(* *** Goal "3.2.1" *** *)
a (spec_nth_asm_tac 4 ¨dpoE xÆ);
(* *** Goal "3.2.1.1" *** *)
a (spec_nth_asm_tac 1 ¨xÆ);
(* *** Goal "3.2.1.2" *** *)
a (spec_nth_asm_tac 1 ¨xÆ);
(* *** Goal "3.2.1.3" *** *)
a (all_var_elim_asm_tac);
(* *** Goal "3.2.2" *** *)
a (spec_nth_asm_tac 4 ¨dpoE xÆ);
(* *** Goal "3.2.2.1" *** *)
a (spec_nth_asm_tac 1 ¨xÆ);
(* *** Goal "3.2.2.2" *** *)
a (spec_nth_asm_tac 1 ¨xÆ);
(* *** Goal "3.2.2.3" *** *)
a (all_var_elim_asm_tac);
(* *** Goal "3.3" *** *)
a (∂_tac ¨e'Æ THEN asm_rewrite_tac[]);
a (fc_tac [get_spec ¨IsLubÆ]);
(* *** Goal "3.4" *** *)
a (POP_ASM_T ante_tac THEN asm_rewrite_tac[]);
(* *** Goal "3.5" *** *)
a (var_elim_asm_tac ¨d = dpoE e'Æ);
a (var_elim_asm_tac ¨e' = eÆ);
a (∂_tac ¨eÆ THEN ∂_tac ¨e''Æ
	THEN asm_rewrite_tac[]);
a (fc_tac [get_spec ¨IsLubÆ]);
a (all_asm_fc_tac[]);
val dpoeo_islub_lemma = pop_thm ();

set_goal([], ¨µr G d∑ IsGlb (DpoEO r) G d
	§ (dpoB ç G ≤ (∂w∑ dpoE w ç G) ± ≥ (∂e∑ IsLb r {w | dpoE w ç G} e)) ± d = dpoB
		≤ G Ä {dpoT} ± d = dpoT
		≤ ≥ G Ä {dpoT} ± (∂e∑ d = dpoE e ± IsGlb r {w | dpoE w ç G} e) ± ≥ dpoB ç GÆ);
a (REPEAT µ_tac);
a (strip_asm_tac (µ_elim ¨dÆ dpo_cases_thm)
	THEN_TRY asm_rewrite_tac[get_spec ¨IsGlbÆ, dpoeo_islb_lemma2]);
(* *** Goal "2" *** *)
set_labelled_goal "2";
a (REPEAT strip_tac THEN_TRY asm_rewrite_tac [get_spec ¨DpoEOÆ]);
(* *** Goal "1" *** *)
a (asm_rewrite_tac [get_spec ¨DpoEOÆ]
	THEN REPEAT strip_tac
	THEN_TRY asm_rewrite_tac[]);
(* *** Goal "2.1" *** *)
a (spec_nth_asm_tac 2 ¨dpoTÆ);
a (DROP_NTH_ASM_T 2 ante_tac THEN PC_T "hol1" (REPEAT strip_tac));
a (strip_asm_tac (µ_elim ¨xÆ dpo_cases_thm)
	THEN_TRY asm_rewrite_tac[]);
(* *** Goal "2.1.1" *** *)
a (var_elim_asm_tac ¨x = dpoBÆ);
(* *** Goal "2.1.2" *** *)
a (var_elim_asm_tac ¨x = dpoE eÆ);
a (∂_tac ¨eÆ THEN asm_rewrite_tac[]);
(* *** Goal "2.2" *** *)
a (spec_nth_asm_tac 2 ¨dpoE eÆ
	THEN spec_nth_asm_tac 1 ¨eÆ);
(* *** Goal "2.3" *** *)
a (DROP_ASM_T ¨G Ä {dpoT}Æ ante_tac
	THEN PC_T "hol1" (REPEAT strip_tac)
	THEN asm_fc_tac[]);
(* *** Goal "2.4" *** *)
a (spec_nth_asm_tac 3 ¨dpoV dpoBÆ);
a (POP_ASM_T ante_tac
	THEN rewrite_tac [get_spec ¨IsLbÆ]
	THEN REPEAT strip_tac);
a (DROP_NTH_ASM_T 3 ante_tac
	THEN (PC_T "hol1" (REPEAT strip_tac))
	THEN asm_fc_tac[]);
(* *** Goal "2.5" *** *)
a (asm_fc_tac[]);
(* *** Goal "3" *** *)
a (asm_rewrite_tac [get_spec ¨DpoEOÆ]
	THEN REPEAT strip_tac
	THEN_TRY asm_rewrite_tac[]);
(* *** Goal "3.1" *** *)
a (spec_nth_asm_tac 1 ¨dpoTÆ);
(* *** Goal "3.2" *** *)
a (var_elim_asm_tac ¨d = dpoE e'Æ);
a (var_elim_asm_tac ¨e' = eÆ);
a (∂_tac ¨eÆ THEN asm_rewrite_tac[]);
a (asm_rewrite_tac [get_spec ¨IsGlbÆ]
	THEN REPEAT strip_tac);
a (fc_tac [get_spec ¨IsLbÆ]);
(* *** Goal "3.2.1" *** *)
a (spec_nth_asm_tac 4 ¨dpoE xÆ);
(* *** Goal "3.2.1.1" *** *)
a (spec_nth_asm_tac 1 ¨xÆ);
(* *** Goal "3.2.1.2" *** *)
a (spec_nth_asm_tac 1 ¨xÆ);
(* *** Goal "3.2.1.3" *** *)
a (all_var_elim_asm_tac);
(* *** Goal "3.2.2" *** *)
a (spec_nth_asm_tac 4 ¨dpoE xÆ);
(* *** Goal "3.2.2.1" *** *)
a (spec_nth_asm_tac 1 ¨xÆ);
(* *** Goal "3.2.2.2" *** *)
a (spec_nth_asm_tac 1 ¨xÆ);
(* *** Goal "3.2.2.3" *** *)
a (all_var_elim_asm_tac);
(* *** Goal "3.3" *** *)
a (∂_tac ¨e'Æ THEN asm_rewrite_tac[]);
a (fc_tac [get_spec ¨IsGlbÆ]);
(* *** Goal "3.4" *** *)
a (POP_ASM_T ante_tac THEN asm_rewrite_tac[]);
(* *** Goal "3.5" *** *)
a (var_elim_asm_tac ¨d = dpoE e'Æ);
a (var_elim_asm_tac ¨e' = eÆ);
a (∂_tac ¨e''Æ THEN ∂_tac ¨eÆ
	THEN asm_rewrite_tac[]);
a (fc_tac [get_spec ¨IsGlbÆ]);
a (all_asm_fc_tac[]);
val dpoeo_isglb_lemma = pop_thm ();

set_goal([], ¨µr∑ LubsExist r ¥ LubsExist (DpoEO r)Æ);
a (rewrite_tac [get_spec ¨LubsExistÆ, dpoeo_islub_lemma] THEN REPEAT strip_tac);
a (∂_tac ¨
	if dpoT ç s
	then dpoT
	else
		if s Ä {dpoB}
		then dpoB
		else dpoE (Lub r {y | dpoE y ç s})Æ);
a (cases_tac ¨dpoT ç sÆ THEN_TRY asm_rewrite_tac[]);
a (cases_tac ¨s Ä {dpoB}Æ THEN_TRY asm_rewrite_tac[]);
a (∂_tac ¨Lub r {y|dpoE y ç s}Æ THEN asm_rewrite_tac []);
a (spec_nth_asm_tac 3 ¨{w|dpoE w ç s}Æ);
a (all_fc_tac[lub_lub_lemma]);
val dpoeo_lubs_exist_thm = save_pop_thm "dpoeo_lubs_exist_thm";

set_goal([], ¨µr∑ GlbsExist r ¥ GlbsExist (DpoEO r)Æ);
a (rewrite_tac [get_spec ¨GlbsExistÆ, dpoeo_isglb_lemma] THEN REPEAT strip_tac);
a (∂_tac ¨
	if dpoB ç s
	then dpoB
	else
		if s Ä {dpoT}
		then dpoT
		else dpoE (Glb r {y | dpoE y ç s})Æ);
a (cases_tac ¨dpoB ç sÆ THEN_TRY asm_rewrite_tac[]);
a (cases_tac ¨s Ä {dpoT}Æ THEN_TRY asm_rewrite_tac[]);
a (∂_tac ¨Glb r {y|dpoE y ç s}Æ THEN asm_rewrite_tac []);
a (spec_nth_asm_tac 3 ¨{w | dpoE w ç s}Æ);
a (all_fc_tac[glb_glb_lemma]);
val dpoeo_glbs_exist_thm = save_pop_thm "dpoeo_glbs_exist_thm";
=TEX
}%ignore

=GFT
€ºâtâ4_trich_lub_ft_lemma› =
   Ù µ X z∑ Trich (X, $ºâtâ4) ± fT ºâtâ4 Lub $ºâtâ4 X ¥ fT ç X


=TEX

\ignore{
=SML
set_goal([], ¨µX z∑ Trich (X, $ºâtâ4) ± fT ºâtâ4 (Lub $ºâtâ4 X) ¥ fT ç XÆ);
a (REPEAT strip_tac THEN REPEAT_N 1 (POP_ASM_T ante_tac));
a (fc_tac [rewrite_rule [get_spec ¨LinearOrderÆ] (µ_elim ¨XÆ ºâtâ4_lin_cases_lemma)]
	THEN asm_rewrite_tac[]
	THEN contr_tac
	THEN asm_fc_tac[]);
val ºâtâ4_trich_lub_ft_lemma = save_pop_thm "ºâtâ4_trich_lub_ft_lemma";
=TEX
}%ignore

\subsection{Indexed Sets}

\subsubsection{IX}

The following function lifts an ordering on the elements of the codomain to an ordering on the indexed sets.

πHOLCONST
‹ €IxO› : ('b ≠ 'b ≠ BOOL) ≠ (('a, 'b) IX ≠ ('a, 'b) IX ≠ BOOL)
˜¸¸¸¸¸¸¸¸¸¸¸
‹ µr∑ IxO r = Pw (OptO r)
∞

It may be more convenient in some cases to use the following ordering in which the comparison is restricted to some subdomain.

(I should have used domain restriction here.)

πHOLCONST
‹ €IxO2› : ('a, 'b) IX SET ∏ ('b ≠ 'b ≠ BOOL) ≠ (('a, 'b) IX ≠ ('a, 'b) IX ≠ BOOL)
˜¸¸¸¸¸¸¸¸¸¸¸
‹ µd r∑ IxO2 (d, r) = Ãx y∑
‹		if x ç d ± y ç d
‹		then IxDom x = IxDom y ± IxO r x y
‹		else x = y
∞

\subsubsection{IS}

Indexed sets are functions whose codomain is a discrete partial order.
From any ordering of the codomain an ordering of the indexed sets may be obtained using {\it Pw}.
This can be done with the discrete order, but we also need to do this with other orders.

The following function lifts an ordering on the elements of the codomain to an ordering on the indexed sets.

πHOLCONST
‹ €IsEO› : ('a ≠ 'a ≠ BOOL) ≠ ('a IS ≠ 'a IS ≠ BOOL)
˜¸¸¸¸¸¸¸¸¸¸¸
‹ µr∑ IsEO r = Pw (DpoEO r)
∞

=GFT
€is_lubs_exist_thm› =
	Ù µ r∑ LubsExist r ¥ LubsExist (IsEO r)

€is_glbs_exist_thm› =
	Ù µ r∑ GlbsExist r ¥ GlbsExist (IsEO r)
=TEX

\ignore{
=SML
set_goal([], ¨µr∑ LubsExist r ¥ LubsExist (IsEO r)Æ);
a (REPEAT strip_tac
	THEN rewrite_tac [get_spec ¨IsEOÆ]
	THEN fc_tac [dpoeo_lubs_exist_thm]
	THEN fc_tac [inst_type_rule [(îGSÆ, î'aÆ)] pw_lubs_exist_thm]
	THEN strip_tac);
val is_lubs_exist_thm = save_pop_thm "is_lubs_exist_thm";

set_goal([], ¨µr∑ GlbsExist r ¥ GlbsExist (IsEO r)Æ);
a (REPEAT strip_tac
	THEN rewrite_tac [get_spec ¨IsEOÆ]
	THEN fc_tac [dpoeo_glbs_exist_thm]
	THEN fc_tac [inst_type_rule [(îGSÆ, î'aÆ)] pw_glbs_exist_thm]
	THEN strip_tac);
val is_glbs_exist_thm = save_pop_thm "is_glbs_exist_thm";
=TEX
}%ignore

\subsection{A Pre-order on Sets}

The following pre-order on sets based on a pre-order of the elements is used later with sets of truth values.

πHOLCONST
‹ €SetO› : ('a ≠ 'a ≠ BOOL) ≠ ('a SET) ≠ ('a SET) ≠ BOOL
˜¸¸¸¸¸¸¸¸¸¸¸
‹ µ r∑ SetO r = Ãm n∑
‹		(µx∑ x ç m ¥ ∂y∑ y ç n ± r x y)
‹	±	(µy∑ y ç n ¥ ∂x∑ x ç m ± r x y)
∞

That turns out to be stronger than we need, this one simplifies matters.

πHOLCONST
‹ €SetO2› : ('a ≠ 'a ≠ BOOL) ≠ ('a SET) ≠ ('a SET) ≠ BOOL
˜¸¸¸¸¸¸¸¸¸¸¸
‹ µ r∑ SetO2 r = Ãm n∑ µx∑ x ç m ¥ ∂y∑ r x y ± y ç n
∞

=GFT
€trans_seto_lemma› =
	Ù µ r∑ Trans (Universe, r) ¥ Trans (Universe, SetO r)

€trans_seto2_lemma› =
   Ù µ r∑ Trans (Universe, r) ¥ Trans (Universe, SetO2 r)
=TEX

\ignore{
=SML
set_goal([], ¨µr∑ Trans (Universe, r) ¥ Trans (Universe, SetO r)Æ);
a (rewrite_tac [get_spec ¨TransÆ, get_spec ¨SetOÆ] THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a (all_asm_fc_tac[]);
a (all_asm_fc_tac[]);
a (all_asm_fc_tac[]);
a (∂_tac ¨y''Æ THEN asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a (all_asm_fc_tac[]);
a (all_asm_fc_tac[]);
a (all_asm_fc_tac[]);
a (∂_tac ¨x''Æ THEN asm_rewrite_tac[]);
val trans_seto_lemma = pop_thm ();

set_goal([], ¨µr∑ Trans (Universe, r) ¥ Trans (Universe, SetO2 r)Æ);
a (rewrite_tac [get_spec ¨TransÆ, get_spec ¨SetO2Æ] THEN REPEAT strip_tac);
a (all_asm_fc_tac[]);
a (all_asm_fc_tac[]);
a (all_asm_fc_tac[]);
a (∂_tac ¨y''Æ THEN asm_rewrite_tac[]);
val trans_seto2_lemma = pop_thm ();
=TEX
}%ignore

=GFT
=TEX

\ignore{
=IGN
set_goal ([], ¨µV∑ Increasing (SetO2 $ºâtâ4) $¥ (Ãs∑ ≥ s ç CompFTV)Æ);
a (strip_tac);
a (PC_T1 "hol" rewrite_tac [get_spec ¨IncreasingÆ, get_spec ¨SetO2Æ, CompFTV_Lub_lemma]);
	THEN REPEAT strip_tac); 
=TEX
}%ignore



\subsection{A Pre-order for Sets of Functions}

To get a pre-order over sets of functions from an pre-order of the codomain of the functions, we could apply {\it Pw} and then {\it SetO}, however the following construction proves more useful.

[Though I don't appear to have used it!]

πHOLCONST
‹ €FunSetO› : ('a ≠ 'a ≠ BOOL) ≠ ('b ≠ 'a) SET ≠ ('b ≠ 'a) SET ≠ BOOL
˜¸¸¸¸¸¸¸¸¸¸¸
‹ µ r:('a ≠ 'a ≠ BOOL)∑ FunSetO r =
‹	Ãs t∑ Pw (SetO r) (Ãx∑ {v | ∂y∑ y ç s ± v = y x}) (Ãx∑ {v | ∂y∑ y ç t ± v = y x})
∞

=IGN
€trans_funseto_lemma› =
	µ r∑ Trans (Universe, r) ¥ Trans (Universe, FunSetO r)
=TEX

\ignore{
=IGN
set_goal([], ¨µr∑ Trans (Universe, r) ¥ Trans (Universe, FunSetO r)Æ);
a (rewrite_tac [get_spec ¨FunSetOÆ] THEN REPEAT strip_tac);
a (fc_tac [trans_seto_lemma]);
a (fc_tac [trans_seto_lemma]);
 THEN POP_ASM_T ante_tac
	THEN rewrite_tac [get_spec ¨TransÆ]);
	THEN REPEAT strip_tac
	THEN all_asm_ufc_tac[]
	THEN asm_rewrite_tac[]);
val trans_funseto_lemma = pop_thm ();
=TEX
}%ignore

\subsection{Partial Relations}

For this section a partial relation is taken to be a four valued relation.
In my applications these are membership relations so the ordering is suggestive of those applications.

=SML
declare_type_abbrev (€"BR"›, ["'a", "'b"], î'a ≠ 'a ≠ 'bÆ);
declare_infix (300, €"ºâç"›);
=TEX

πHOLCONST
‹ €$ºâç› : (GS, FTV)BR ≠ (GS, FTV)BR ≠ BOOL
˜¸¸¸¸¸¸¸¸¸¸¸
‹ $ºâç = Pw (Pw $ºâtâ4)
∞

=GFT
€crpou_ºâç_thm› = Ù CRpoU $ºâç

€ccrpou_ºâç_thm› = Ù CcRpoU $ºâç

€ºâç_clauses› = Ù GlbsExist $ºâç ± LubsExist $ºâç ± (µ x∑ x ºâç x)

€ºâç_fc_clauses› =
   Ù (µ x y z∑ x ºâç y ± y ºâç z ¥ x ºâç z)
       ± (µ x y∑ x ºâç y ± y ºâç x ¥ x = y)
=TEX

\ignore{
=SML
set_goal([], ¨CRpoU $ºâçÆ);
a (rewrite_tac [get_spec ¨$ºâçÆ]);
a (bc_tac [pw_crpou_thm]);
a (bc_tac [pw_crpou_thm]);
a (rewrite_tac[ºâtâ4_crpou_thm]);
val crpou_ºâç_thm = save_pop_thm "crpou_ºâç_thm";

set_goal([], ¨CcRpoU $ºâçÆ);
a (bc_tac [crpou_ccrpou_lemma]);
a (rewrite_tac[crpou_ºâç_thm]);
val ccrpou_ºâç_thm = save_pop_thm "ccrpou_ºâç_thm";

set_goal([], ¨GlbsExist $ºâç
       ± LubsExist $ºâç
       ± (µ x∑ x ºâç x)Æ);
a (rewrite_tac [rewrite_rule [crpou_ºâç_thm] (µ_elim ¨$ºâçÆ crpou_fc_clauses)]);
val ºâç_clauses = save_pop_thm "ºâç_clauses";

val ºâç_fc_clauses = prove_thm ("ºâç_fc_clauses",
	¨(µ x y z∑ x ºâç y ± y ºâç z ¥ x ºâç z)
      		± (µ x y∑ x ºâç y ± y ºâç x ¥ x = y)Æ,
	rewrite_tac [rewrite_rule [crpou_ºâç_thm] (µ_elim ¨$ºâçÆ crpou_fc_clauses)]);


add_pc_thms "'misc2" (map get_spec [] @ [ccrpou_ºâç_thm, crpou_ºâç_thm, ºâç_clauses]);
set_merge_pcs ["rbjmisc", "'GS1", "'misc2"];
=TEX
}%ignore

Because the ordering here is derived from the ordering on the four truth values there are some simplifications to reasoning about limits which are worth turning into theorems.

=GFT
€ºâç_lub_thm› =
   Ù µ G∑ Lub $ºâç G = (Ã x y∑ Lub $ºâtâ4 {w|∂ g∑ g ç G ± w = g x y})
=TEX

\ignore{
=SML
set_goal([], ¨µ G∑ Lub $ºâç G = (Ã x y∑ Lub $ºâtâ4 {w|∂ g∑ g ç G ± w = g x y})Æ);
a (REPEAT strip_tac THEN rewrite_tac [get_spec ¨$ºâçÆ, rewrite_rule [] (µ_elim ¨$ºâtâ4Æ crpou_lub_pw_pw_lemma)]);
val ºâç_lub_thm = save_pop_thm "ºâç_lub_thm";
=TEX
}%ignore


\section{MISCELLANEOUS THEOREMS}

\subsection{Monotonicity of Lub}

=GFT
€lub_increasing_lemma› =
	Ù µ r∑ RpoU r ± LubsExist r ¥ Increasing (SetO r) r (Lub r)

€lub_increasing2_lemma› =
	Ù µ r∑ RpoU r ± LubsExist r ¥ Increasing (SetO2 r) r (Lub r)

€lub_increasing_lemma2› =
	Ù µ r∑ CRpoU r ¥ Increasing (SetO r) r (Lub r)

€lub_increasing2_lemma2› =
	Ù µ r∑ CRpoU r ¥ Increasing (SetO2 r) r (Lub r)

€lub_increasing_lemma3› =
	Ù µ r∑ CRpoU r ¥ (µ x y∑ SetO r x y ¥ r (Lub r x) (Lub r y))

€lub_increasing2_lemma3› =
   Ù µ r∑ CRpoU r ¥ (µ x y∑ SetO2 r x y ¥ r (Lub r x) (Lub r y))
=TEX

\ignore{
=SML
set_goal([], ¨µr∑ RpoU r ± LubsExist r ¥ Increasing (SetO r) r (Lub r)Æ);
a (rewrite_tac (map get_spec [¨IncreasingÆ])
	THEN REPEAT strip_tac);
a (fc_tac [lub_lub_lemma2]);
a (spec_nth_asm_tac 1 ¨xÆ
	THEN spec_nth_asm_tac 2 ¨yÆ
	THEN fc_tac [get_spec ¨IsLubÆ]);
a (rename_tac[]);
a (lemma_tac ¨IsUb r x (Lub r y)Æ);
(* *** Goal "1" *** *)
a (DROP_ASM_T ¨SetO r x yÆ ante_tac THEN rewrite_tac [get_spec ¨SetOÆ]
	THEN strip_tac);
a (rewrite_tac [get_spec ¨IsUbÆ] THEN REPEAT strip_tac);
a (asm_fc_tac[]);
a (GET_NTH_ASM_T 8 ante_tac THEN rewrite_tac [get_spec ¨IsUbÆ] THEN REPEAT strip_tac);
a (asm_fc_tac[]);
a (fc_tac [rpou_fc_clauses2] THEN all_asm_fc_tac[]);
(* *** Goal "2" *** *)
a (asm_fc_tac[]);
val lub_increasing_lemma = save_pop_thm "lub_increasing_lemma";

set_goal([], ¨µr∑ RpoU r ± LubsExist r ¥ Increasing (SetO2 r) r (Lub r)Æ);
a (rewrite_tac (map get_spec [¨IncreasingÆ])
	THEN REPEAT strip_tac);
a (fc_tac [lub_lub_lemma2]);
a (spec_nth_asm_tac 1 ¨xÆ
	THEN spec_nth_asm_tac 2 ¨yÆ
	THEN fc_tac [get_spec ¨IsLubÆ]);
a (lemma_tac ¨IsUb r x (Lub r y)Æ);
(* *** Goal "1" *** *)
a (DROP_ASM_T ¨SetO2 r x yÆ ante_tac THEN rewrite_tac [get_spec ¨SetO2Æ]
	THEN strip_tac);
a (rewrite_tac [get_spec ¨IsUbÆ] THEN REPEAT strip_tac);
a (asm_fc_tac[]);
a (GET_NTH_ASM_T 7 ante_tac THEN rewrite_tac [get_spec ¨IsUbÆ] THEN REPEAT strip_tac);
a (asm_fc_tac[]);
a (fc_tac [rpou_fc_clauses2] THEN all_asm_fc_tac[]);
(* *** Goal "2" *** *)
a (asm_fc_tac[]);
val lub_increasing2_lemma = save_pop_thm "lub_increasing2_lemma";

set_goal([], ¨µ r∑ CRpoU r ¥ Increasing (SetO r) r (Lub r)Æ);
a (rewrite_tac [get_spec ¨CRpoUÆ, get_spec ¨RpoUÆ]
	THEN REPEAT strip_tac);
a (all_fc_tac [rewrite_rule [get_spec ¨RpoUÆ] lub_increasing_lemma]);
val lub_increasing_lemma2 = save_pop_thm "lub_increasing_lemma2";

set_goal([], ¨µ r∑ CRpoU r ¥ Increasing (SetO2 r) r (Lub r)Æ);
a (rewrite_tac [get_spec ¨CRpoUÆ, get_spec ¨RpoUÆ]
	THEN REPEAT strip_tac);
a (all_fc_tac [rewrite_rule [get_spec ¨RpoUÆ] lub_increasing2_lemma]);
val lub_increasing2_lemma2 = save_pop_thm "lub_increasing2_lemma2";

val lub_increasing_lemma3 = save_thm("lub_increasing_lemma3",
	rewrite_rule [get_spec¨IncreasingÆ] lub_increasing_lemma2);

val lub_increasing2_lemma3 = save_thm("lub_increasing2_lemma3",
	rewrite_rule [get_spec¨IncreasingÆ] lub_increasing2_lemma2);
=TEX
}%ignore

\subsection{Product of Functions}

We now define the product of two functions:

πHOLCONST
‹ €FunProd› : ('a ≠ 'b) ≠ ('a ≠ 'c) ≠ ('a ≠ 'b ∏ 'c)
˜¸¸¸¸¸¸¸¸¸¸¸
‹ µ f g∑ FunProd f g = Ãx∑ (f x, g x)
∞

And prove that the product of two increasing functions is increasing.

=GFT
€funprod_increasing_thm› =
   Ù µ f g ra rb rc
     ∑ Increasing ra rb f ± Increasing ra rc g
         ¥ Increasing ra (PrO rb rc) (FunProd f g)
=TEX

\ignore{
=SML
set_goal([], ¨µf g ra rb rc∑ Increasing ra rb f ± Increasing ra rc g
	¥ Increasing ra (PrO rb rc) (FunProd f g)Æ);
a (rewrite_tac [get_spec ¨IncreasingÆ, get_spec ¨PrOÆ, get_spec ¨FunProdÆ]
	THEN REPEAT strip_tac
	THEN asm_fc_tac[]);
val funprod_increasing_thm = save_pop_thm "funprod_increasing_thm";
=TEX
}%ignore

πHOLCONST
‹ €FunLeft› : ('a ∏ 'c ≠ 'b) ≠ ('a ∏ 'c ≠ 'b ∏ 'c)
˜¸¸¸¸¸¸¸¸¸¸¸
‹ µ f∑ FunLeft f = Ãx∑ (f x, Snd x)
∞

πHOLCONST
‹ €FunRight› : ('c ∏ 'a ≠ 'b) ≠ ('c ∏ 'a ≠ 'c ∏ 'b)
˜¸¸¸¸¸¸¸¸¸¸¸
‹ µ f∑ FunRight f = Ãx∑ (Fst x, f x)
∞

=GFT
€funleft_increasing_thm› =
   Ù µ f ra rb rc
     ∑ Increasing (PrO ra rc) rb f
         ¥ Increasing (PrO ra rc) (PrO rb rc) (FunLeft f)

€funright_increasing_thm› =
   Ù µ f ra rb rc
     ∑ Increasing (PrO rc ra) rb f
         ¥ Increasing (PrO rc ra) (PrO rc rb) (FunRight f)
=TEX

\ignore{
=SML
set_goal([], ¨µf ra rb rc∑ Increasing (PrO ra rc) rb f
	¥ Increasing (PrO ra rc) (PrO rb rc) (FunLeft f)Æ);
a (rewrite_tac [get_spec ¨IncreasingÆ, get_spec ¨PrOÆ, get_spec ¨FunLeftÆ]
	THEN REPEAT strip_tac
	THEN asm_fc_tac[]);
val funleft_increasing_thm = save_pop_thm "funleft_increasing_thm";

set_goal([], ¨µf ra rb rc∑ Increasing (PrO rc ra) rb f
	¥ Increasing (PrO rc ra) (PrO rc rb) (FunRight f)Æ);
a (rewrite_tac [get_spec ¨IncreasingÆ, get_spec ¨PrOÆ, get_spec ¨FunRightÆ]
	THEN REPEAT strip_tac
	THEN asm_fc_tac[]);
val funright_increasing_thm = save_pop_thm "funright_increasing_thm";

set_flag("subgoal_package_quiet", false);
=TEX
}%ignore

\subsection{FunImage Preserves Linearity}

The function must be a morphism and the target set must be a partial order (these are sufficient conditions).

=GFT
€trich_funimage_lemma› =
   Ù µ r1 r2 f X∑ Increasing r1 r2 f ¥ Trich (X, r1) ¥ Trich (FunImage f X, r2)

€linear_funimage_thm› =
   Ù µ r1 r2 f X∑ Increasing r1 r2 f
           ± LinearOrder (X, r1)
           ± PartialOrder (FunImage f X, r2)
         ¥ LinearOrder (FunImage f X, r2)
=TEX

\ignore{
=SML
set_goal([], ¨µr1 r2 f X∑ Increasing r1 r2 f ¥ Trich (X, r1) ¥ Trich (FunImage f X, r2)Æ);
a (REPEAT µ_tac
	THEN rewrite_tac [get_spec ¨IncreasingÆ, get_spec ¨TrichÆ, get_spec ¨FunImageÆ]
	THEN contr_tac);
a (DROP_NTH_ASM_T 4 (asm_tac o eq_sym_rule));
a (var_elim_nth_asm_tac 1);
a (DROP_NTH_ASM_T 5 (asm_tac o eq_sym_rule));
a (var_elim_nth_asm_tac 1);
a (list_spec_nth_asm_tac 7 [¨aÆ,¨a'Æ]);
a (list_spec_nth_asm_tac 8 [¨a'Æ,¨aÆ]);
a (list_spec_nth_asm_tac 8 [¨aÆ,¨a'Æ]);
a (var_elim_asm_tac ¨a = a'Æ);
val trich_funimage_lemma = pop_thm ();

set_goal([], ¨µr1 r2 f X∑ Increasing r1 r2 f ± LinearOrder (X, r1) ± PartialOrder (FunImage f X, r2)
			¥ LinearOrder (FunImage f X, r2)Æ);
a (REPEAT µ_tac
	THEN rewrite_tac [get_spec ¨LinearOrderÆ, get_spec ¨PartialOrderÆ]
	THEN contr_tac);
a (all_fc_tac [trich_funimage_lemma]);
val linear_funimage_thm = save_pop_thm "linear_funimage_thm";
=TEX
}%ignore

\subsection{Partial Relations}

=GFT
€ºâç_increasing_pointwise_thm› =
   Ù Increasing $ºâç $ºâtâ4 (Ã f∑ f x' y)
=TEX

\ignore{
=SML
set_goal([], ¨Increasing $ºâç $ºâtâ4 (Ã f∑ f x' y)Æ);
a (rewrite_tac [get_spec ¨IncreasingÆ, get_spec ¨$ºâçÆ, get_spec ¨PwÆ]
	THEN REPEAT strip_tac
	THEN asm_rewrite_tac[]);
val ºâç_increasing_pointwise_thm = save_pop_thm "ºâç_increasing_pointwise_thm";
=TEX
}%ignore



\subsection{Proof Contexts}

=SML
add_pc_thms "'misc2" [];
commit_pc "'misc2";

force_new_pc "€misc2›";
merge_pcs ["rbjmisc", "'GS1", "'misc2"] "misc2";
commit_pc "misc2";
force_new_pc "€misc21›";
merge_pcs ["rbjmisc1", "'GS1", "'misc2"] "misc21";
commit_pc "misc21";
=TEX

{\let\Section\section
\newcounter{ThyNum}
\def\section#1{\Section{#1}
\addtocounter{ThyNum}{1}\label{Theory\arabic{ThyNum}}}
\include{misc2.th}
}  %\let

\twocolumn[\section{INDEX}\label{index}]
{\small\printindex}

\end{document}
