=IGN
$Id: t051.doc,v 1.2 2013/02/01 09:02:00 rbj Exp $
=TEX
\documentclass[11pt,a4paper]{article}
%\usepackage{latexsym}
%\usepackage{ProofPower}
\usepackage{rbj}
\ftlinepenalty=9999
\usepackage{A4}

\def\ExpName{\mbox{{\sf exp}}}
\def\Exp#1{\ExpName(#1)}
\tabstop=0.4in
\newcommand{\ignore}[1]{}

\title{A Type of Infinitary Trees}
\makeindex
\usepackage[unicode,pdftex]{hyperref}
\hypersetup{pdfauthor={Roger Bishop Jones}}
\hypersetup{colorlinks=true, urlcolor=black, citecolor=black, filecolor=black, linkcolor=black}

\author{Roger Bishop Jones}
\date{\ }

\begin{document}
\begin{titlepage}
\maketitle
\begin{abstract}
This is an approach to developing and integrating into HOL a non-well-founded foundational ontology.
In common with my previous approaches this is based on non-conservative extension to HOL effectively giving stronger axioms of infinity so that the resulting foundation system is equivalent in strength to ZFC + a (weak) large cardinal axiom.
The distinctive feature of this approach is that the axiomatic set theory in which the strong axiom of infinity is expressed is given a minimalistic treatment.
The idea is that instead of working directly in such a set theory one obtains a type of infinitary trees and thenceforth work forwards with these trees rather than in the underlying set theory.
These trees are similar to the terms of the infinite combinatory logic which are a stage in the development of the theory previously approached in t041.
\end{abstract}

\vfill

\begin{centering}

{\footnotesize

Created 2013/01/20

Last Change $ $Date: 2013/02/01 09:02:00 $ $

\href{http://www.rbjones.com/rbjpub/pp/doc/t051.pdf}
{http://www.rbjones.com/rbjpub/pp/doc/t051.pdf}

$ $Id: t051.doc,v 1.2 2013/02/01 09:02:00 rbj Exp $ $

\copyright\ Roger Bishop Jones; Licenced under Gnu LGPL

}%footnotesize

\end{centering}

\thispagestyle{empty}
\end{titlepage}
\newpage
\addtocounter{page}{1}
{\parskip=0pt\tableofcontents}

\newpage

\section{Introduction}

Theory t041 \cite{rbjt041} approaches an illative combinatory logic working in a well-founded set theory with urelements.
The urelements were admitted because at the time I thought that integration of the resulting theory with HOL would be more straightforward if elements of other types were allowed in set theoretic constructions, and in the resulting combinatory logic.

I was also curious about how much the admission of urelements would add to the difficulty of developing the set theory.
In the very early stages in the development the extra costs seemed moderate.
More recently I have felt that they are significant, and at the same time I realised that good integration could be achieved without allowing urelements.

Alongside the question of whether to use a pure (well-founded) set theory or one with urelements, there is always a question in this kind of development about when to introduce new types and which new types to introduce.
In the work in t041 no new types were introduced (so far as it went, which is not very far).
I am now trying an approach in which certain new types are introduced sooner rather than later.
This will certainly involve a type of infinitary trees.
At this time I am not yet decided whether there should also be a type of ordinals, probably this will be necessary.

I am thinking of doing this in parallel in ProofPower and in hol4.

\section{Preparatory Materials}

This section is likely to mostly disappear.
It will then contain those materials on ordinals on cardinals which are independent of the types introduced in the next section.

=SML
open_theory "rbjmisc";
force_new_theory "Ûordcard0Ý";
new_parent "U_orders";
new_parent "trees";
new_parent "wf_relp";
new_parent "wf_recp";
force_new_pc "Û'ordcard0Ý";
merge_pcs ["'savedthm_cs_¶_proof"] "'ordcard0";
set_merge_pcs ["basic_hol", "'ordcard0"];
=TEX

The material in this section is moved here en-block from t009 \cite{rbjt009}, and was not therefore originally undertaken for the purposes in hand.
However, since I did not make use of it for any other purpose I now propose to use some of it here, expand the useful aspects, and discard some of the more obviously otiose material.

It is a treatment of cardinality as a property of sets which does not get so far as establishing types of ordinals or cardinals.
The definitions and theorems here and now considered as preliminaries to the establishment of ordinal and cardinal numbers in a way not originally envisages, in the following sections.

The original motivation is in fact not far removed from the present motivation, which is nice ways of expressing strong axioms of infinity.
Of course, the niceness which is most desirable is in the application of such axioms rather than in the aesthetics of their statement, and at the time when I starting the material in this section I didn't have much clue about the application.

The document as a whole reflects my present feeling that the applications (at least those of particular interest to me, but possible more generally) are best mediated by types of infinitary sequences and infinitary trees, and that other aspects of the set theories in which strong axioms are usually placed are less important in this context.
In particular, whereas I had at times felt that the development of the treatment of functions was important, I now feel that it is not, and that the notion of function already available in HOL is sufficient.
So the whole business of coding up functions as graphs of ordered pairs in set theory now seems unnecessary ({\it in this context}).

From here on in we have the original commentary (at least, {\it pro-tem}), which may not be entirely appropriate here.


The material in this section is primarily oriented towards expressing strong axioms of infinity.
It does this by treating well-orderings as if they were ordinals and cardinals.

The relations defined here with subscript \emph{s} on their names are cardinality comparisons on sets.

=SML
declare_infix(300, "¼‰s");
declare_infix(300, "<‰s");
declare_infix(300, "~‰s");
=TEX

¹HOLCONST
Ü $Û¼‰sÝ : 'a SET ­ 'b SET ­ BOOL
÷üüüüüü
Ü µ A B· A ¼‰s B ¤ ¶f·
Ü	µx y· x  A ± y  A ´ f x  B ± f y  B ± (f x = f y ´ x = y)
°

=GFT
Û¼‰s_reflÝ =
	ô µ A· A ¼‰s A
Û€_¼‰s_thmÝ =
	ô µ A B· A € B ´ A ¼‰s B
Û¼‰s_transÝ =
	ô µ A B C· A ¼‰s B ± B ¼‰s C ´ A ¼‰s C
=TEX

\ignore{
=SML
val ¼‰s_def = get_spec ¬$¼‰s®;

set_goal([], ¬µA:'a ð· A ¼‰s A®);
a (rewrite_tac[¼‰s_def] THEN strip_tac
	THEN ¶_tac ¬Ìx:'a·x®
	THEN rewrite_tac[]);
val ¼‰s_refl = save_pop_thm "¼‰s_refl";

set_goal([], ¬µA B· A € B ´ A ¼‰s B®);
a (rewrite_tac[¼‰s_def, sets_ext_clauses] THEN REPEAT strip_tac);
a (¶_tac ¬Ìx:'a·x® THEN asm_prove_tac[]);
val €_¼‰s_thm = save_pop_thm "€_¼‰s_thm";

set_goal([], ¬µA B C· A ¼‰s B ± B ¼‰s C ´ A ¼‰s C®);
a (rewrite_tac[¼‰s_def] THEN REPEAT strip_tac);
a (¶_tac ¬Ìx· f'(f x)®
	THEN asm_rewrite_tac[]
	THEN REPEAT strip_tac
	THEN (REPEAT_N 3 (TRY (all_asm_ufc_tac[]))));
val ¼‰s_trans = save_pop_thm "¼‰s_trans";
=TEX
}%ignore


¹HOLCONST
Ü $Û<‰sÝ : 'a SET ­ 'b SET ­ BOOL
÷üüüüüü
Ü µ A B· A <‰s B ¤ A ¼‰s B ± ³ B ¼‰s A
°

=GFT
Ûlt‰s_irreflÝ =
	ô µ A· ³ A <‰s A
Ûlt‰s_transÝ =
	ô µ A B C· A <‰s B ± B <‰s C ´ A <‰s C
Ûlt‰s_¼‰s_transÝ =
	ô µ A B C· A <‰s B ± B ¼‰s C ´ A <‰s C
Û¼‰s_lt‰s_transÝ =
	ô µ A B C· A ¼‰s B ± B <‰s C ´ A <‰s C
=TEX

\ignore{
=SML
val lt‰s_def = get_spec ¬$<‰s®;

set_goal([], ¬µA:'a ð· ³ A <‰s A®);
a (rewrite_tac[lt‰s_def] THEN REPEAT strip_tac);
val lt‰s_irrefl = save_pop_thm "lt‰s_irrefl";

set_goal([], ¬µA B C· A <‰s B ± B <‰s C ´ A <‰s C®);
a (rewrite_tac[lt‰s_def]
	THEN contr_tac
	THEN all_fc_tac [¼‰s_trans]);
val lt‰s_trans = save_pop_thm "lt‰s_trans";

set_goal([], ¬µA B C· A <‰s B ± B ¼‰s C ´ A <‰s C®);
a (rewrite_tac[lt‰s_def]
	THEN contr_tac
	THEN all_fc_tac [¼‰s_trans]);
val lt‰s_¼‰s_trans = save_pop_thm "lt‰s_¼‰s_trans";

set_goal([], ¬µA B C· A ¼‰s B ± B <‰s C ´ A <‰s C®);
a (rewrite_tac[lt‰s_def]
	THEN contr_tac
	THEN all_fc_tac [¼‰s_trans]);
val ¼‰s_lt‰s_trans = save_pop_thm "¼‰s_lt‰s_trans";

=TEX
}%ignore

¹HOLCONST
Ü $Û~‰sÝ : 'a SET ­ 'b SET ­ BOOL
÷üüüüüü
Ü µ A B·
Ü	A ~‰s B ¤ ¶f g·
Ü		(µx· x  A ´ f x  B ± g (f x) = x)
Ü	±	(µy· y  B ´ g y  A ± f (g y) = y)
°


=GFT
Ûcard_equiv_lemmaÝ =
   ô µ x y z· x ~‰c x ± (x ~‰c y ¤ y ~‰c x) ± (x ~‰c y ± y ~‰c z ´ x ~‰c z)

=TEX

\ignore{
=SML
val eq‰s_def = get_spec ¬$~‰s®;

set_flag("pp_show_HOL_types", false);
push_pc "hol";

set_goal([], ¬µx y z· (x ~‰s x)
		± (x ~‰s y ¤ y ~‰s x)
		± (x ~‰s y ± y ~‰s z ´ x ~‰s z)®);
a (rewrite_tac [get_spec ¬$~‰s®] THEN prove_tac[]);
(* *** Goal "1" *** *)
a (¶_tac ¬Ìx:'b· x® THEN ¶_tac ¬Ìx:'b· x® THEN prove_tac[]);
(* *** Goal "2" *** *)
a (¶_tac ¬f' o f® THEN ¶_tac ¬g o g'® THEN rewrite_tac[o_def]
	THEN REPEAT strip_tac);
(* *** Goal "2.1" *** *)
a (REPEAT (asm_fc_tac[]));
(* *** Goal "2.2" *** *)
a (asm_fc_tac[]);
a (spec_nth_asm_tac 5 ¬f x'®);
a (asm_rewrite_tac[]);
(* *** Goal "2.3" *** *)
a (REPEAT_N 2 (asm_fc_tac[]));
(* *** Goal "2.4" *** *)
a (asm_fc_tac[]);
a (spec_nth_asm_tac 6 ¬g' y'®);
a (asm_rewrite_tac[]);
val card_equiv_lemma = save_pop_thm "card_equiv_lemma";

=IGN
I think I need to refer to Schroeder-Bernstein here.

set_goal([], ¬µA B· A ~‰s B ¤ A ¼‰s B ± B ¼‰s A®);
a (REPEAT µ_tac
	THEN rewrite_tac[eq‰s_def, ¼‰s_def]
	THEN REPEAT strip_tac);

set_goal([], ¬µA B· A ~‰s B ¤ A ¼‰s B ± B ¼‰s A®);
a (rewrite_tac 
pop_pc();
=TEX
}%ignore


\section{Types of Ordinals and Cardinals}

I had at first intended to do a minimal set theory sufficient for defining a type of infinitary trees.
But I think the simplest development is to go straight to a type of ordinals and work forward from there.

=SML
open_theory "ordcard0";
force_new_theory "ÛordcardÝ";
new_parent "U_orders";
new_parent "wf_relp";
new_parent "wf_recp";
force_new_pc "Û'ordcardÝ";
merge_pcs ["'savedthm_cs_¶_proof"] "'ordcard";
set_merge_pcs ["basic_hol", "'ordcard"];
=TEX

The method is as follows.
First introduce a type of ordinals, then a type of cardinals which assists in formulation of a strong axiom of infinity.
Then a type of infinitary sequences, then a type of infinitary trees.

\subsection{The Type of Ordinals}

=SML
new_type ("ordinal", 0);
=TEX

We now use a well ordering theorem to define the ordering over the ordinals.
The consistency proof uses definitions and results from t009 \cite{rbjt009}.
The principal result is that every set can be well-ordered, but the definition of well-ordering does not entail well-foundedness or transitivity, since a well-ordering might be reflexive but well-foundedness does not admit reflexiveness.
So the proof (not shown) takes an arbitrary well-ordering makes it irreflexive and then proves that the result is a well-founded well-ordering.

\ignore{
=SML
set_goal([], ¬¶<‰o:ordinal ­ ordinal  ­ BOOL·
	WellOrdering(Universe, <‰o)
	± WellFounded(Universe, <‰o)®);
a (strip_asm_tac (µ_elim ¬Universe:ordinal ð® well_ordering_thm));
a (lemma_tac ¬¶g· g = Ìx y· x << y ± ³ x = y® THEN1 prove_¶_tac);
a (fc_tac [well_ordering_def_thm]);
a (¶_tac ¬g® THEN rewrite_tac[well_ordering_def_thm, well_founded_thm]
	THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a (POP_ASM_T ante_tac
	THEN asm_rewrite_tac (map get_spec [¬LinearOrder®, ¬PartialOrder®, ¬Trich®, ¬Antisym®, ¬Trans®])
	THEN REPEAT strip_tac);
(* *** Goal "1.1" *** *)
a (all_asm_fc_tac[]);
(* *** Goal "1.2" *** *)
a (all_asm_fc_tac[]);
(* *** Goal "1.3" *** *)
a (contr_tac THEN var_elim_asm_tac ¬x = z®);
a (all_asm_fc_tac[]);
(* *** Goal "1.4" *** *)
a (all_asm_fc_tac[]);
(* *** Goal "1.5" *** *)
a (contr_tac THEN var_elim_asm_tac ¬y = x®);
(* *** Goal "2" *** *)
a (DROP_NTH_ASM_T 2 ante_tac
	THEN asm_rewrite_tac (map get_spec [¬MinCond®, ¬WeakMinCond®, ¬Antisym®])
	THEN REPEAT strip_tac);
(* *** Goal "2.1" *** *)
a (contr_tac THEN all_asm_fc_tac[]);
(* *** Goal "2.2" *** *)
a (all_asm_ufc_tac[]);
a (¶_tac ¬x® THEN asm_rewrite_tac[] THEN REPEAT strip_tac);
(* *** Goal "2.2.1" *** *)
a (all_asm_ufc_tac[]);
(* *** Goal "2.2.2" *** *)
a (contr_tac THEN var_elim_asm_tac ¬x = y®);
(* *** Goal "3" *** *)
a (DROP_NTH_ASM_T 4 ante_tac
	THEN DROP_NTH_ASM_T 3 ante_tac
	THEN asm_rewrite_tac (map get_spec [¬MinCond®, ¬WeakMinCond®, ¬Antisym®, ¬LinearOrder®, ¬Trich®, ¬Universe®])
	THEN REPEAT strip_tac);
a (all_asm_ufc_tac[]);
a (¶_tac ¬x® THEN asm_rewrite_tac[] THEN REPEAT strip_tac);
a (contr_tac THEN all_asm_fc_tac[]);
a (all_asm_ufc_tac[]);
save_cs_¶_thm (pop_thm());
=TEX
}%ignore

¹HOLCONST
Ü Û<‰oÝ: ordinal ­ ordinal  ­ BOOL
÷üüüüüüüüüüü
Ü 	WellOrdering(Universe, <‰o)
Ü	± WellFounded(Universe, <‰o)
°

=SML
declare_infix(500, "<‰o");
=TEX

It is useful to extract from the definition the following consequences.

=GFT
Ûlt‰o_min_condÝ =
	ô µ A· ³ A = {} ´ (¶ x· x  A ± (µ y· y  A ´ ³ y <‰o x))
Ûlt‰o_transÝ =
	ô µ Â Ç È· Â <‰o Ç ± Ç <‰o È ´ Â <‰o È
Ûlt‰o_irreflÝ =
	ô µ Â· ³ Â <‰o Â
Ûlt‰o_trichÝ =
	ô µ Â Ç· Â <‰o Ç ² Ç <‰o Â ² Â = Ç
=TEX

\ignore{
=SML
val lt‰o_def = get_spec ¬$<‰o®;

set_goal([], ¬µA· ³ A = {} ´ ¶x· x  A ± µy· y  A ´ ³ y <‰o x®);
a (strip_asm_tac lt‰o_def);
a (fc_tac [get_spec ¬WellOrdering®]);
a (fc_tac [get_spec ¬WeakMinCond®]);
a (POP_ASM_T ante_tac THEN PC_T1 "hol1" rewrite_tac[] THEN REPEAT strip_tac);
a (all_asm_fc_tac[]);
a (¶_tac ¬x'® THEN REPEAT strip_tac);
a (fc_tac [get_spec ¬WellFounded®]);
a (fc_tac [get_spec ¬Irrefl®]);
a (POP_ASM_T ante_tac THEN PC_T1 "hol1" rewrite_tac[] THEN REPEAT strip_tac);
a (spec_nth_asm_tac 5 ¬y®);
(* *** Goal "1" *** *)
a (var_elim_asm_tac ¬y = x'® THEN asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a (fc_tac [get_spec ¬LinearOrder®]);
a (fc_tac [get_spec ¬PartialOrder®]);
a (fc_tac [get_spec ¬Antisym®]);
a (POP_ASM_T ante_tac THEN PC_T1 "hol1" rewrite_tac[] THEN contr_tac);
a (contr_tac THEN all_asm_ufc_tac[]);
a (lemma_tac ¬³ x' = y® THEN1 contr_tac);
(* *** Goal "2.1" *** *)
a (var_elim_asm_tac ¬x' = y® THEN asm_fc_tac[]);
(* *** Goal "2.2" *** *)
a (all_asm_fc_tac[]);
val lt‰o_min_cond = save_pop_thm "lt‰o_min_cond";

set_goal([], ¬µÂ Ç È· Â <‰o Ç ± Ç <‰o È ´ Â <‰o È®);
a (strip_asm_tac lt‰o_def);
a (fc_tac [well_ordering_def]);
a (fc_tac [linear_order_def]);
a (fc_tac [partial_order_def]);
a (fc_tac [trans_def]);
a (POP_ASM_T ante_tac
	THEN rewrite_tac[get_spec ¬Universe®]
	THEN REPEAT strip_tac
	THEN all_asm_fc_tac[]);
val lt‰o_trans = save_pop_thm "lt‰o_trans";

set_goal([], ¬µÂ· ³ Â <‰o Â®);
a (strip_asm_tac(lt‰o_def) THEN REPEAT strip_tac);
a (fc_tac [well_founded_def]);
a (fc_tac [irrefl_def]);
a (POP_ASM_T ante_tac THEN rewrite_tac[get_spec¬Universe®]);
a (prove_tac[]);
val lt‰o_irrefl = save_pop_thm "lt‰o_irrefl";

set_goal([], ¬µÂ Ç· Â <‰o Ç ² Ç <‰o Â ² Â = Ç®);
a (strip_asm_tac lt‰o_def);
a (fc_tac [well_ordering_def]);
a (fc_tac [linear_order_def]);
a (fc_tac [trich_def]);
a (POP_ASM_T ante_tac
	THEN rewrite_tac[get_spec ¬Universe®]
	THEN contr_tac
	THEN all_asm_fc_tac[]);
val lt‰o_trich = save_pop_thm "lt‰o_trich";
=TEX
}%ignore

=SML
declare_infix(500, "¼‰o");
=TEX

¹HOLCONST
Ü $Û¼‰oÝ: ordinal ­ ordinal  ­ BOOL
÷üüüüüüüüüüü
Ü µÂ Ç· Â ¼‰o Ç ¤  Â <‰o Ç ² Â = Ç
°

=GFT
Ûlt‰o_¼‰oÝ =
	ô µ Â Ç È· Â <‰o Ç ´ Â ¼‰o Ç
Û¼‰o_transÝ =
	ô µ Â Ç È· Â ¼‰o Ç ± Ç ¼‰o È ´ Â ¼‰o È
Û¼‰o_casesÝ =
	ô µ Â Ç· Â ¼‰o Ç ² Ç ¼‰o Â
=TEX

\ignore{
=SML
val ¼‰o_def = get_spec ¬$¼‰o®;

set_goal([], ¬µ Â Ç È· Â <‰o Ç ´ Â ¼‰o Ç®);
a (rewrite_tac[¼‰o_def] THEN REPEAT strip_tac);
val lt‰o_¼‰o = save_pop_thm "lt‰o_¼‰o";

set_goal([], ¬µÂ Ç È· Â ¼‰o Ç ± Ç ¼‰o È ´ Â ¼‰o È®);
a (rewrite_tac[¼‰o_def] THEN REPEAT strip_tac
	THEN_TRY all_var_elim_asm_tac
	THEN all_fc_tac [lt‰o_trans]
	THEN rewrite_tac[]);
val ¼‰o_trans = save_pop_thm "¼‰o_trans";

set_goal([], ¬µÂ Ç· Â ¼‰o Ç ² Ç ¼‰o Â®);
a (rewrite_tac[¼‰o_def] THEN contr_tac);
a (strip_asm_tac (all_µ_elim lt‰o_trich));
val ¼‰o_cases = save_pop_thm "¼‰o_cases";
=TEX
}%ignore

Every well-founded well-ordering is an initial segment of ordinals, so we have now a type of ordinals.
At this point we have no idea how many ordinals there are in the type, there might be only one.

So we will need at some point a strong axiom of infinity to tell us that we have enough ordinals for our purposes.

To get a nice formulation of such an axiom it helps to make a type of cardinals, which will be done in the next section.
However, it will be desirable to define functions over the ordinals, and so we now seek to obtain a basis for recursive definitions over the ordinals.

Of course the well-foundedness of the ordering supplies a basis for such definitions.

\subsection{The Type of Cardinals}

One could introduce cardinals in a manner similar to the introduction of ordinals, but we would then have no coupling between the two types.
We want the cardinals to be the initial ordinals, so that when we introduce a strong axiom of infinity both types are populated in sync.

The cardinality of an ordinal is conventionally the cardinality of the collection of strictly smaller ordinals.
It is therefore handy to have a function which delivers that set.

¹HOLCONST
Ü ÛX‰oÝ: ordinal ­ ordinal ð
÷üüüüüüüüüüü
Ü µÂ· X‰o Â = {È | È <‰o Â}
°

=GFT
Ûlt‰o_€Ý =
	ô µ Â Ç· Ç <‰o Â ´ X‰o Ç € X‰o Â
Ûlt‰o_ Ý =
	ô µ Â Ç· Ç <‰o Â ´ X‰o Ç   X‰o Â
Û¼‰o_€Ý =
	ô µÂ Ç· Ç ¼‰o Â ´ X‰o Ç € X‰o Â
=TEX

\ignore{
=SML
val X‰o_def = get_spec ¬X‰o®;

set_goal([], ¬µÂ Ç· Ç <‰o Â ´ X‰o Ç € X‰o Â®);
a (PC_T1 "hol1" rewrite_tac[X‰o_def] THEN REPEAT strip_tac);
a (all_fc_tac[lt‰o_trans]);
val lt‰o_€ = save_pop_thm "lt‰o_€";

set_goal([], ¬µÂ Ç· Ç <‰o Â ´ X‰o Ç   X‰o Â®);
a (PC_T1 "hol1" rewrite_tac[X‰o_def] THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a (all_fc_tac[lt‰o_trans]);
(* *** Goal "2" *** *)
a (¶_tac ¬Ç® THEN asm_rewrite_tac[lt‰o_irrefl]);
val lt‰o_  = save_pop_thm "lt‰o_ ";

set_goal([], ¬µÂ Ç· Ç ¼‰o Â ´ X‰o Ç € X‰o Â®);
a (PC_T1 "hol1" rewrite_tac[X‰o_def, ¼‰o_def] THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a (all_fc_tac[lt‰o_trans]);
(* *** Goal "2" *** *)
a (all_var_elim_asm_tac);
val ¼‰o_€ = save_pop_thm "¼‰o_€";
=TEX
}%ignore

The ordering of ordinals by cardinality is then:

=SML
declare_infix(400, "¼‰o‰c");
=TEX

¹HOLCONST
Ü $Û¼‰o‰cÝ: ordinal ­ ordinal ­ BOOL
÷üüüüüüüüüü
Ü µÂ Ç· Â ¼‰o‰c Ç ¤ X‰o Â ¼‰s X‰o Ç
°

=GFT
Û¼‰o‰c_reflÝ =
	ô µ Â· Â ¼‰o‰c Â
Ûlt‰o_¼‰o‰cÝ =
	ô µ Â Ç· Ç <‰o Â ´ Ç ¼‰o‰c Â
Û¼‰o‰c_transÝ =
	ô µ Â Ç È· Â ¼‰o‰c Ç ± Ç ¼‰o‰c È ´ Â ¼‰o‰c È
Û¼‰o‰c_casesÝ =
	ô µ Â Ç· Â ¼‰o‰c Ç ² Ç ¼‰o‰c Â
=TEX

\ignore{
=SML
val ¼‰o‰c_def = get_spec ¬$¼‰o‰c®;

set_goal([], ¬µÂ· Â ¼‰o‰c Â®);
a (strip_tac THEN rewrite_tac[¼‰o‰c_def, X‰o_def, ¼‰s_refl]);
val ¼‰o‰c_refl = save_pop_thm "¼‰o‰c_refl";

=IGN
set_goal([], ¬µÂ Ç· Â ¼‰o‰c Ç ² Ç ¼‰o‰c Â®);
=SML

set_goal([], ¬µÂ Ç· Ç <‰o Â ´ Ç ¼‰o‰c Â®);
a (rewrite_tac[¼‰o‰c_def] THEN REPEAT strip_tac
	THEN fc_tac [lt‰o_¼‰o]
	THEN fc_tac [¼‰o_€]);
a (POP_ASM_T ante_tac THEN PC_T1 "hol1" rewrite_tac[¼‰s_def]
	THEN REPEAT strip_tac);
a (¶_tac ¬Ìx:'a·x® THEN asm_rewrite_tac[]
	THEN REPEAT strip_tac
	THEN asm_fc_tac[]);
val lt‰o_¼‰o‰c = save_pop_thm "lt‰o_¼‰o‰c";

set_goal([], ¬µÂ Ç È· Â ¼‰o‰c Ç ± Ç ¼‰o‰c È ´ Â ¼‰o‰c È®);
a (rewrite_tac[¼‰o‰c_def] THEN REPEAT strip_tac);
a (all_asm_fc_tac [¼‰s_trans]);
val ¼‰o‰c_trans = save_pop_thm "¼‰o‰c_trans";

set_goal([], ¬µÂ Ç· Â ¼‰o‰c Ç ² Ç ¼‰o‰c Â®);
a (rewrite_tac[¼‰o‰c_def] THEN REPEAT µ_tac);
a (lemma_tac ¬X‰o Ç € X‰o Â ² X‰o Â € X‰o Ç®
	THEN_TRY (FC_T rewrite_tac [€_¼‰s_thm]));
a (PC_T1 "hol1" rewrite_tac[X‰o_def] THEN contr_tac);
a (strip_asm_tac (list_µ_elim [¬x®, ¬Â®] lt‰o_trich));
(* *** Goal "1" *** *)
a (strip_asm_tac (list_µ_elim [¬x'®, ¬Ç®] lt‰o_trich));
a (REPEAT (all_ufc_tac [lt‰o_trans]));
(* *** Goal "1.2" *** *)
a (all_var_elim_asm_tac THEN all_ufc_tac [lt‰o_trans]);
(* *** Goal "2" *** *)
a (all_var_elim_asm_tac THEN all_ufc_tac [lt‰o_trans]);
val ¼‰o‰c_cases = save_pop_thm "¼‰o‰c_cases";
=TEX
}%ignore

=SML
declare_infix(400, "<‰o‰c");
=TEX

¹HOLCONST
Ü $Û<‰o‰cÝ: ordinal ­ ordinal ­ BOOL
÷üüüüüüüüüü
Ü µÂ Ç· Â <‰o‰c Ç ¤ ³ Ç ¼‰o‰c Â
°

=GFT
Û<‰o‰c_irreflÝ =
	ô µ Â· ³ Â <‰o‰c Â
Û¼‰o‰c_³_lt‰o‰cÝ =
	ô µ Â Ç· Â ¼‰o‰c Ç ´ ³ Ç <‰o‰c Â
=TEX

\ignore{
=SML
val ¼‰o_def = get_spec ¬$¼‰o®;
val lt‰o‰c_def = get_spec ¬$<‰o‰c®;

set_goal([], ¬µÂ· ³ Â <‰o‰c Â®);
a (strip_tac THEN rewrite_tac[lt‰o‰c_def, ¼‰o‰c_refl]);
val lt‰o‰c_irrefl = save_pop_thm "lt‰o‰c_irrefl";

set_goal([], ¬µÂ Ç· Â ¼‰o‰c Ç ´ ³ Ç <‰o‰c Â®);
a (rewrite_tac[lt‰o‰c_def] THEN contr_tac);
val ¼‰o‰c_³_lt‰o‰c = save_pop_thm "¼‰o‰c_³_lt‰o‰c";
=TEX
}%ignore

=SML
declare_infix(400, "~‰o‰c");
=TEX

¹HOLCONST
Ü $Û~‰o‰cÝ: ordinal ­ ordinal ­ BOOL
÷üüüüüüüüüü
Ü µÂ Ç· Â ~‰o‰c Ç ¤ Â ¼‰o‰c Ç ± Ç ¼‰o‰c Â
°

=GFT
Û¼‰o‰c_cases2Ý =
	ô µ Â Ç· Â ¼‰o‰c Ç ¤ Â <‰o‰c Ç ² Â ~‰o‰c Ç
Û~‰o‰c_reflÝ =
	ô µ Â· Â ~‰o‰c Â
Ûeq‰o‰c_symÝ =
	ô µ Â Ç· Â ~‰o‰c Ç ´ Ç ~‰o‰c Â
Ûeq‰o‰c_transÝ =
	ô µ Â Ç È· Â ~‰o‰c Ç ± Ç ~‰o‰c È ´ Â ~‰o‰c È
Ûlt‰o‰c_trichÝ =
	ô µ Â Ç· Â <‰o‰c Ç ² Ç <‰o‰c Â ² Â ~‰o‰c Ç
=TEX

\ignore{
=SML
val eq‰o‰c_def = get_spec ¬$~‰o‰c®;

set_goal([], ¬µÂ Ç· Â ¼‰o‰c Ç  ¤ Â <‰o‰c Ç ² Â ~‰o‰c Ç®);
a (strip_tac
	THEN rewrite_tac[eq‰o‰c_def, lt‰o‰c_def]
	THEN contr_tac);
a (strip_asm_tac (all_µ_elim ¼‰o‰c_cases));
val ¼‰o‰c_cases2 = save_pop_thm "¼‰o‰c_cases2";

set_goal([], ¬µÂ· Â ~‰o‰c Â®);
a (strip_tac THEN rewrite_tac[eq‰o‰c_def, ¼‰o‰c_def, X‰o_def, ¼‰s_refl]);
val eq‰o‰c_refl = save_pop_thm "eq‰o‰c_refl";

set_goal([], ¬µÂ Ç· Â ~‰o‰c Ç ´ Ç ~‰o‰c Â®);
a (REPEAT µ_tac
	THEN rewrite_tac[eq‰o‰c_def]
	THEN contr_tac);
val eq‰o‰c_sym = save_pop_thm "eq‰o‰c_sym";

set_goal([], ¬µÂ Ç È· Â ~‰o‰c Ç ± Ç ~‰o‰c È ´ Â ~‰o‰c È®);
a (rewrite_tac[eq‰o‰c_def]
	THEN REPEAT strip_tac
	THEN REPEAT_N 3 (TRY (all_asm_fc_tac[¼‰o‰c_trans])));
val eq‰o‰c_trans  = save_pop_thm "eq‰o‰c_trans";

set_goal([], ¬µÂ Ç· Â <‰o‰c Ç ² Ç <‰o‰c Â ² Â ~‰o‰c Ç®);
a (rewrite_tac[lt‰o‰c_def] THEN contr_tac);
a (all_fc_tac [map_eq_sym_rule eq‰o‰c_def]);
val lt‰o‰c_trich = save_pop_thm "lt‰o‰c_trich";
=TEX
}%ignore

We have to define the notion of initiality.
A initial ordinal is one which is not smaller than or equal in cardinality with any smaller ordinal.

¹HOLCONST
Ü ÛInitialOrdinalÝ: ordinal ­ BOOL
÷üüüüüüüüüüü
Ü µÂ· InitialOrdinal Â ¤ µÇ· Ç <‰o Â ´ Ç <‰o‰c Â
°

Before introducing a type using this predicate we must prove that there exists an initial ordinal, for which the witness is the least ordinal, obtainable using the minimal condition.

=GFT
ÛInitialOrdinal_existsÝ =
	ô ¶ Â· InitialOrdinal Â

ÛInitialOrdinals_existÝ =
	ô µ Â· ¶ Ä· InitialOrdinal Ä ± Ä ~‰o‰c Â

ÛInitialOrdinal_eqÝ =
	ô µ Â Ç· InitialOrdinal Â ± InitialOrdinal Ç ± Â ~‰o‰c Ç ´ Â = Ç
=TEX

\ignore{
=SML
val InitialOrdinal_def = get_spec ¬InitialOrdinal®;

set_goal ([], ¬¶Â· InitialOrdinal Â®);
a (strip_asm_tac (pc_rule1 "hol1" rewrite_rule [] (µ_elim ¬Universe:ordinal ð® lt‰o_min_cond)));
a (¶_tac ¬x® THEN asm_rewrite_tac[InitialOrdinal_def]
	THEN REPEAT strip_tac);
val InitialOrdinal_exists = save_pop_thm "InitialOrdinal_exists";

set_goal([], ¬µÂ· ¶ Ä· InitialOrdinal Ä ± Ä ~‰o‰c Â®);
a (rewrite_tac[InitialOrdinal_def] THEN strip_tac);
a (strip_asm_tac (µ_elim ¬{È | È ~‰o‰c Â}® lt‰o_min_cond));
(* *** Goal "1" *** *)
a (swap_nth_asm_concl_tac 1 THEN PC_T "hol1" (REPEAT strip_tac));
a (¶_tac ¬Â® THEN PC_T1 "hol1" rewrite_tac[eq‰o‰c_refl]);
(* *** Goal "2" *** *)
a (¶_tac ¬x® THEN REPEAT strip_tac);
(* *** Goal "2.1" *** *)
a (spec_nth_asm_tac 2 ¬Ç®);
a (swap_nth_asm_concl_tac 1 THEN PC_T1 "hol1" rewrite_tac[]);
a (fc_tac[lt‰o_¼‰o‰c]);
a (fc_tac[¼‰o‰c_def]);
a (fc_tac[¼‰o‰c_cases2]);
a (DROP_NTH_ASM_T 7 (strip_asm_tac o (pc_rule1 "hol1" rewrite_rule[])));
a (all_fc_tac [eq‰o‰c_trans]);
(* *** Goal "2.2" *** *)
a (DROP_NTH_ASM_T 2 (strip_asm_tac o (pc_rule1 "hol1" rewrite_rule[])));
val InitialOrdinals_exist = save_pop_thm "InitialOrdinals_exist";

set_goal([], ¬µÂ Ç· InitialOrdinal Â ± InitialOrdinal Ç ± Â ~‰o‰c Ç
	´ Â = Ç®);
a (rewrite_tac[InitialOrdinal_def, eq‰o‰c_def]
	THEN REPEAT strip_tac);
a (fc_tac[¼‰o‰c_³_lt‰o‰c]);
a (spec_nth_asm_tac 6 ¬Ç®);
a (spec_nth_asm_tac 6 ¬Â®);
a (strip_asm_tac (all_µ_elim lt‰o_trich));
val InitialOrdinal_eq = save_pop_thm "InitialOrdinal_eq";
=TEX
}%ignore

Now we can introduce a new type represented by the initial ordinals.

=SML
val cardinal_def = new_type_defn(["cardinal"], "cardinal", [], InitialOrdinal_exists);
=TEX

There are various functions between the ordinals and cardinals which may be used in formulating a strong axiom of infinity.
The type definition defines the new type as having the same cardinality as the initial ordinals, and we use this bijection to determine the correspondence between cardinals and their alephs.
The abstraction function would normally be determined only over the alephs, but it will be more useful to have an abstraction function which yields the cardinality of any ordinal.

These two maps can be defined thus:

\ignore{
=SML
val [cardinal_lemma] = fc_rule [type_defn_lemma4] [cardinal_def];

set_goal([], ¬¶Ord‰c:cardinal ­ ordinal· ¶Card‰o· (µÂ:cardinal· Card‰o(Ord‰c Â) = Â)
	± (µÂ:ordinal· InitialOrdinal Â ¤ Ord‰c (Card‰o Â) = Â)
	± OneOne Ord‰c
	± (µ Â· InitialOrdinal (Ord‰c Â))
	± (µÂ Ç· Â ~‰o‰c Ç ´ Card‰o Â = Card‰o Ç)
®);
a (strip_asm_tac cardinal_lemma);
a (lemma_tac ¬¶g· g = ÌÇ:ordinal· ÅÂ:ordinal· InitialOrdinal Â ± Â ~‰o‰c Ç®
	THEN1 prove_¶_tac);
a (lemma_tac ¬µx· InitialOrdinal (g x)®
	THEN1 rewrite_tac[asm_rule
		¬g = Ì Ç· ÅÂ:ordinal· InitialOrdinal Â ± Â ~‰o‰c Ç®]);
(* *** Goal "1" *** *)
a (strip_tac);
a (Å_tac ¬Å Â· InitialOrdinal Â ± Â ~‰o‰c x®);
a (strip_asm_tac InitialOrdinals_exist);
a (spec_nth_asm_tac 1 ¬x®);
a (¶_tac ¬Ä® THEN asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a (¶_tac ¬rep® THEN ¶_tac ¬Ìx· abs(g x)®
	THEN rewrite_tac[]
	THEN REPEAT strip_tac);
(* *** Goal "2.1" *** *)
a (lemma_tac
	¬g (rep Â) = rep Â®
	THEN_LIST [TRY (rewrite_tac[]), asm_rewrite_tac[]]);
a (rewrite_tac[asm_rule ¬g = (Ì Ç· Å Â· InitialOrdinal Â ± Â ~‰o‰c Ç)®]);
a (Å_tac ¬Å $"Â'"· InitialOrdinal $"Â'" ± $"Â'" ~‰o‰c rep Â®);
(* *** Goal "2.1.1" *** *)
a (¶_tac ¬rep Â® THEN asm_rewrite_tac[eq‰o‰c_refl]);
(* *** Goal "2.1.2" *** *)
a (all_ufc_tac [InitialOrdinal_eq]);
(* *** Goal "2.2" *** *)
a (ALL_ASM_UFC_T rewrite_tac []);
a (rewrite_tac[asm_rule ¬g = (Ì Ç· Å Â· InitialOrdinal Â ± Â ~‰o‰c Ç)®]);
a (Å_tac ¬Å $"Â'"· InitialOrdinal $"Â'" ± $"Â'" ~‰o‰c Â®);
(* *** Goal "2.2.1" *** *)
a (¶_tac ¬Â® THEN asm_rewrite_tac[eq‰o‰c_refl]);
(* *** Goal "2.2.2" *** *)
a (all_ufc_tac [InitialOrdinal_eq]);
(* *** Goal "2.3" *** *)
a (SYM_ASMS_T once_rewrite_tac);
a (asm_rewrite_tac[]);
(* *** Goal "2.4" *** *)
a (asm_rewrite_tac[]);
(* *** Goal "2.5" *** *)
a (LEMMA_T ¬g Â = g Ç® rewrite_thm_tac);
a (lemma_tac ¬µx· g x ~‰o‰c x®
	THEN1 (strip_tac THEN asm_rewrite_tac[]));
(* *** Goal "2.5.1" *** *)
a (Å_tac ¬Å Â· rep (abs Â) = Â ± Â ~‰o‰c x®);
a (strip_asm_tac (µ_elim ¬x® InitialOrdinals_exist));
a (¶_tac ¬Ä® THEN ALL_ASM_UFC_T asm_rewrite_tac []);
(* *** Goal "2.5.2" *** *)
a (lemma_tac ¬g Â ~‰o‰c Â ± g Ç ~‰o‰c Ç® THEN1 rewrite_tac[asm_rule ¬µ x· g x ~‰o‰c x®]);
a (lemma_tac ¬g Ç ~‰o‰c g Â®
	THEN1 (all_ufc_tac[eq‰o‰c_sym]
		THEN REPEAT (all_ufc_tac[eq‰o‰c_trans])));
a (lemma_tac ¬InitialOrdinal (g Â) ± InitialOrdinal (g Ç)®
	THEN1 rewrite_tac[asm_rule ¬µ x· InitialOrdinal (g x)®]);
a (all_ufc_tac [list_µ_elim [¬g Ç®, ¬g Â®] InitialOrdinal_eq]);
a (asm_rewrite_tac[]);
save_cs_¶_thm (pop_thm());
=TEX
}%ignore

¹HOLCONST
Ü ÛOrd‰cÝ: cardinal ­ ordinal;
Ü ÛCard‰oÝ: ordinal ­ cardinal
÷üüüüüüüüüüü
Ü	  (µÂ:cardinal· Card‰o(Ord‰c Â) = Â)
Ü	± (µÂ:ordinal· InitialOrdinal Â ¤ Ord‰c (Card‰o Â) = Â)
Ü	± OneOne Ord‰c
Ü	± (µ Â· InitialOrdinal (Ord‰c Â))
Ü	± (µÂ Ç· Â ~‰o‰c Ç ´ Card‰o Â = Card‰o Ç)
°

\section{Definitions over Ordinals and Cardinals}

Some operations must be defined before we can proceed to sequences and trees?

\section{Strong Infinity}

Here are my ideas on how this can be done, which run parallel to my earlier axiomatisations of set theory.
These earlier axiomatisations are set theories with ``universes'' (galaxies I call them) satisfying the closure properties expected of the universe in ZFC.
The closure axiom asserts that every set is a member of such a universe (and also gives global replacement).

Since we only have ordinals here (and cardinals, but not sets in general), we assert that every ordinal is less than some ordinal such that the ordinals below it have the desired closure properties.
I suspect I could have managed without the cardinals, but I had in mind defining closure under power set via a definition of the power operation on the cardinals.

=IGN
strong_infinity_axiom = new_axiom(["strong_infinity_axiom"], ¬
	µÂ· ¶Î· 

®);
=TEX

\section{Infinitary Sequences}

Infinitary sequences are functions whose domain is an ordinal.
To make a type of them we will need to use HOL total functions over the type of ordinals, and the domain would then be fixed.
We therefore use an ordered pair consisting of an ordinal (which is the domain) together with a total function over the ordinals.
The values of this function outside the domain are immaterial, but the fact that the function has such values confuses the identity conditions and we must take steps to ensure that the identity conditions come out right.
We could either ensure that in the new type all functions take the same value everywhere outside the domain, or else we could use an equivalence class of functions which take the same values over the domain.

I don't know which of these two would be simplest; I shall plump for the first since it is more familiar to me.

The following predicate determines the representatives of infinitary sequences.

¹HOLCONST
Ü ÛISeqRepÝ: ordinal ¸ (ordinal ­ 'a) ­ BOOL
÷üüüüüüüüüüü
Ü µp· ISeqRep p ¤ µor· ³ or <‰o Fst p ´ Snd p or = Åx·T
°

\ignore{
=SML
val ISeqRep_def = get_spec ¬ISeqRep®;

set_goal([], ¬¶isr:ordinal ¸ (ordinal ­ 'a)· ISeqRep isr®);
a (¶_tac ¬((Åx:ordinal·T), Ìor· Åx:'a·T)® THEN rewrite_tac[ISeqRep_def]);
val ISeqRep_nonempty_thm = pop_thm();

val iseq_def = new_type_defn(["iseq"], "iseq", ["'a"], ISeqRep_nonempty_thm);

val [iseq_lemma] = fc_rule [type_defn_lemma4] [iseq_def];

set_goal([], ¬¶ MkISeq: ordinal ¸ (ordinal ­ 'a) ­ 'a iseq;
	DestISeq: 'a iseq ­ ordinal ¸ (ordinal ­ 'a)·
	(µÂ Ç· DestISeq Â = DestISeq Ç ´ Â = Ç) 
 ±	(µÂ· ISeqRep (DestISeq Â))
 ±	(µÂ· MkISeq (DestISeq Â) = Â)
 ±      (µp· ISeqRep p ´ DestISeq(MkISeq p) = p)®);
a (strip_asm_tac iseq_lemma);
a (DROP_ASM_T ¬OneOne rep® (asm_tac o (rewrite_rule [get_spec ¬OneOne®])));
a (¶_tac ¬abs® THEN ¶_tac ¬rep® THEN asm_rewrite_tac[]);
save_cs_¶_thm (pop_thm());
=TEX
}%ignore

We now define destructor/constructor operations over these sequences.

¹HOLCONST
Ü ÛMkISeqÝ: ordinal ¸ (ordinal ­ 'a) ­ 'a iseq;
Ü ÛDestISeqÝ: 'a iseq ­ ordinal ¸ (ordinal ­ 'a)
÷üüüüüüüüüüü
Ü	(µÂ Ç· DestISeq Â = DestISeq Ç ´ Â = Ç) 
 ±	(µÂ· ISeqRep (DestISeq Â))
 ±	(µÂ· MkISeq (DestISeq Â) = Â)
 ±      (µp· ISeqRep p ´ DestISeq(MkISeq p) = p)
°

¹HOLCONST
Ü ÛLength‰i‰sÝ: 'a iseq ­ ordinal
÷üüüüüüüüüüü
Ü	µis· Length‰i‰s is = Fst (DestISeq is) 
°

¹HOLCONST
Ü ÛElems‰i‰sÝ: 'a iseq ­ 'a ð
÷üüüüüüüüüüü
Ü	µis· Elems‰i‰s is = {e | ¶Â· Â <‰o Fst (DestISeq is) ± e = Snd (DestISeq is) Â}
°

\section{Infinitary Trees}

An infinitary tree is to be represented by a partial function from sequences of ordinals to some type of labels.
The sequences are the coordinates of nodes in the tree, and the labels label each node.
There is a well-formedness condition which ensures that the set of coordinates of branches from any node is an initial segment of the ordinals.

¹HOLCONST
Ü ÛITreeRepÝ: (ordinal LIST ­ 'a + ONE) ­ BOOL
÷üüüüüüüüüüü
Ü µf· ITreeRep f ¤
Ü	µl:ordinal LIST· ¶Â· {Ç | IsL (f (l @ [Ç]))} = X‰o Â
°

=GFT
ÛiTree_defÝ = ô ¶ f· TypeDefn ITreeRep f
=TEX

\ignore{
=SML
val ITreeRep_def = get_spec ¬ITreeRep®;

set_goal([], ¬¶itr: ordinal LIST ­ 'a + ONE· ITreeRep itr®);
a (¶_tac ¬(Ìx· InR One): ordinal LIST ­ 'a + ONE®);
a (rewrite_tac[ITreeRep_def]);
a (strip_asm_tac (µ_elim ¬{x:ordinal|T}® lt‰o_min_cond));
(* *** Goal "1" *** *)
a (POP_ASM_T ante_tac THEN PC_T1 "hol1" rewrite_tac[]);
(* *** Goal "2" *** *)
a (¶_tac ¬x® THEN POP_ASM_T ante_tac
	THEN PC_T1 "hol1" rewrite_tac[] THEN strip_tac);
a (PC_T1 "hol1" asm_rewrite_tac[X‰o_def]);
val iTree_exists = pop_thm();

val iTree_def = new_type_defn(["iTree"], "iTree", ["'a"], iTree_exists);
=TEX
}%ignore

=GFT

=TEX

\ignore{
=IGN
set_goal([], ¬¶®);

=TEX
}%ignore

\ignore{

\section{Graphs}

There may be no point in developing the Trees because it looks like Graphs would be more general an no less easily applicable to the kinds of problem for which one would have used Trees.

Not sure about that, so a bit of exploration is called for.

Graphs could be done in a manner closely similar to the Trees, using ordinals and infinitary sequences, and requiring that the children of a node are indexed by an initial segment of the ordinals.
Its not obvious that this is better than allowing the children to be any indexed set, in which case the construction becomes independent of the ordinals and ordinals need only be introduced where the specific application demands it.

So lets consider the notion of graph independently of the ordinals, but in such a way that the graphs are not assumed to be finitary.

A graph will be a collection of nodes (not necessarily a type) and a function which takes each node to a label (of some type) and an indexed collection of children.
That sounds like three type variables, do we really want that many?

Its not really my present aim to do something independent of the ordinals.
I am really interested here in whether the kind of thing which is done above for trees using ordinals would be as well generalised to graphs.
So here is a type of graphs in which the nodes are represented by ordinals and the children of a node must be a (possibly infinite) sequence.

The essential information in a graph is the mapping from nodes to label and sequences (which is very similar to the signature for the trees).
So we have to define when two such mappings are isomorphic.

Lets use a type abbreviation here:

 =SML
declare_type_abbrev("IG", ["'a"], ”ordinal LIST ­ ONE + 'a + ordinal LIST®);
 =TEX

The first ordinal is the "top" of the graph, and the extent of the graph is disovered by chasing through the graph.
The function must take a default value everywhere not in this reachable extent and the choice of ordinals for nodes must comply with a natural ordering of the paths throught the graph (it must be the least of the ordinals corresponding to paths which reach that node).
This means that when graphs are distroyed or created they must be renumbered, so it might be better to use functions over coordinate lists, which gets us closer to the tree representation.

There is a well-formedness condition on these (this one is not yet complete):

 ¹HOLCONST
Ü ÛIGraphRepÝ: 'a IG ­ BOOL
÷üüüüüüüüüüü
Ü µf· IGraphRep f ¤
Ü	µl:ordinal LIST· ¶Â· {Ç | IsR (f (l @ [Ç]))} = X‰o Â
 °

}%ignore

\subsubsection{Proof Context}

=SML
add_pc_thms "'ordcard" ([]);
add_rw_thms [] "'ordcard";
add_sc_thms [] "'ordcard";

set_merge_pcs ["basic_hol", "'ordcard"];
commit_pc "'ordcard";
=TEX



\section{Closing}

=IGN
val rewrite_thms = ref ([]:THM list);

merge_pcs ["rbjmisc", "'ordcard"] "ordcard";
commit_pc "ordcard";
=TEX

{\raggedright
\bibliographystyle{fmu}
\bibliography{rbj,fmu}
} %\raggedright

{\let\Section\section
\newcounter{ThyNum}
\def\section#1{\Section{#1}
\addtocounter{ThyNum}{1}\label{Theory\arabic{ThyNum}}}
\include{ordcard0.th}
\def\section#1{\Section{#1}
\addtocounter{ThyNum}{1}\label{Theory\arabic{ThyNum}}}
\include{ordcard.th}
}%\let

\twocolumn[\section{INDEX}\label{index}]
{\small\printindex}

\end{document}
