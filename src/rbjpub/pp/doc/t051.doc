=IGN
$Id: t051.doc,v 1.4 2013/03/01 12:26:30 rbj Exp $
=TEX
\documentclass[11pt,a4paper]{article}
%\usepackage{latexsym}
%\usepackage{ProofPower}
\usepackage{rbj}
\ftlinepenalty=9999
\usepackage{A4}

\def\ExpName{\mbox{{\sf exp}}}
\def\Exp#1{\ExpName(#1)}
\tabstop=0.4in
\newcommand{\ignore}[1]{}

\title{A Type of Infinitary Trees}
\makeindex
\usepackage[unicode,pdftex]{hyperref}
\hypersetup{pdfauthor={Roger Bishop Jones}}
\hypersetup{colorlinks=true, urlcolor=black, citecolor=black, filecolor=black, linkcolor=black}

\author{Roger Bishop Jones}
\date{\ }

\begin{document}
\begin{titlepage}
\maketitle
\begin{abstract}
This is an approach to developing and integrating into HOL a non-well-founded foundational ontology.
In common with my previous approaches this is based on non-conservative extension to HOL effectively giving stronger axioms of infinity so that the resulting foundation system is equivalent in strength to ZFC + a (weak) large cardinal axiom.
The distinctive feature of this approach is that the axiomatic set theory in which the strong axiom of infinity is expressed is given a minimalistic treatment.
The idea is that instead of working directly in such a set theory one obtains a type of infinitary trees and thenceforth work forwards with these trees rather than in the underlying set theory.
These trees are similar to the terms of the infinite combinatory logic which are a stage in the development of the theory previously approached in t041.
\end{abstract}

\vfill

\begin{centering}

{\footnotesize

Created 2013/01/20

Last Change $ $Date: 2013/03/01 12:26:30 $ $

\href{http://www.rbjones.com/rbjpub/pp/doc/t051.pdf}
{http://www.rbjones.com/rbjpub/pp/doc/t051.pdf}

$ $Id: t051.doc,v 1.4 2013/03/01 12:26:30 rbj Exp $ $

\copyright\ Roger Bishop Jones; Licenced under Gnu LGPL

}%footnotesize

\end{centering}

\thispagestyle{empty}
\end{titlepage}
\newpage
\addtocounter{page}{1}
{\parskip=0pt\tableofcontents}

\newpage

\section{INTRODUCTION}

Theory t041 \cite{rbjt041} approaches an illative combinatory logic working in a well-founded set theory with urelements.
The urelements were admitted because at the time I thought that integration of the resulting theory with HOL would be more straightforward if elements of other types were allowed in set theoretic constructions, and in the resulting combinatory logic.

I was also curious about how much the admission of urelements would add to the difficulty of developing the set theory.
In the very early stages in the development the extra costs seemed moderate.
More recently I have felt that they are significant, and at the same time I realised that good integration could be achieved without allowing urelements.

Alongside the question of whether to use a pure (well-founded) set theory or one with urelements, there is always a question in this kind of development about when to introduce new types and which new types to introduce.
In the work in t041 no new types were introduced (so far as it went, which is not very far).
I am now trying an approach in which certain new types are introduced sooner rather than later.
This will certainly involve a type of infinitary trees.
At this time I am not yet decided whether there should also be a type of ordinals, probably this will be necessary.

I am thinking of doing this in parallel in ProofPower and in hol4.

\section{PRELIMINARIES}

This section is likely to mostly disappear.
It will then contain those materials on ordinals on cardinals which are independent of the types introduced in the next section.

=SML
open_theory "rbjmisc";
force_new_theory "Ûordcard0Ý";
new_parent "U_orders";
new_parent "trees";
new_parent "wf_relp";
new_parent "wf_recp";
force_new_pc "Û'ordcard0Ý";
merge_pcs ["'savedthm_cs_¶_proof"] "'ordcard0";
set_merge_pcs ["rbjmisc", "'ordcard0"];
=TEX

The material in this section is moved here en-block from t009 \cite{rbjt009}, and was not therefore originally undertaken for the purposes in hand.
However, since I did not make use of it for any other purpose I now propose to use some of it here, expand the useful aspects, and discard some of the more obviously otiose material.

It is a treatment of cardinality as a property of sets which does not get so far as establishing types of ordinals or cardinals.
The definitions and theorems here and now considered as preliminaries to the establishment of ordinal and cardinal numbers in a way not originally envisages, in the following sections.

The original motivation is in fact not far removed from the present motivation, which is nice ways of expressing strong axioms of infinity.
Of course, the niceness which is most desirable is in the application of such axioms rather than in the aesthetics of their statement, and at the time when I starting the material in this section I didn't have much clue about the application.

The document as a whole reflects my present feeling that the applications (at least those of particular interest to me, but possible more generally) are best mediated by types of infinitary sequences and infinitary trees, and that other aspects of the set theories in which strong axioms are usually placed are less important in this context.
In particular, whereas I had at times felt that the development of the treatment of functions was important, I now feel that it is not, and that the notion of function already available in HOL is sufficient.
So the whole business of coding up functions as graphs of ordered pairs in set theory now seems unnecessary ({\it in this context}).

From here on in we have the original commentary (at least, {\it pro-tem}), which may not be entirely appropriate here.


The material in this section is primarily oriented towards expressing strong axioms of infinity.
It does this by treating well-orderings as if they were ordinals and cardinals.

The relations defined here with subscript \emph{s} on their names are cardinality comparisons on sets.

=SML
declare_infix(300, "¼‰s");
declare_infix(300, "<‰s");
declare_infix(300, "~‰s");
=TEX

¹HOLCONST
Ü $Û¼‰sÝ : 'a SET ­ 'b SET ­ BOOL
÷üüüüüü
Ü µ A B· A ¼‰s B ¤ ¶f·
Ü	µx y· x  A ± y  A ´ f x  B ± f y  B ± (f x = f y ´ x = y)
°

=GFT
Û¼‰s_reflÝ =
	ô µ A· A ¼‰s A
Û€_¼‰s_thmÝ =
	ô µ A B· A € B ´ A ¼‰s B
Û¼‰s_transÝ =
	ô µ A B C· A ¼‰s B ± B ¼‰s C ´ A ¼‰s C
=TEX

\ignore{
=SML
val ¼‰s_def = get_spec ¬$¼‰s®;

set_goal([], ¬µA:'a ð· A ¼‰s A®);
a (rewrite_tac[¼‰s_def] THEN strip_tac
	THEN ¶_tac ¬Ìx:'a·x®
	THEN rewrite_tac[]);
val ¼‰s_refl = save_pop_thm "¼‰s_refl";

set_goal([], ¬µA B· A € B ´ A ¼‰s B®);
a (rewrite_tac[¼‰s_def, sets_ext_clauses] THEN REPEAT strip_tac);
a (¶_tac ¬Ìx:'a·x® THEN asm_prove_tac[]);
val €_¼‰s_thm = save_pop_thm "€_¼‰s_thm";

set_goal([], ¬µA B C· A ¼‰s B ± B ¼‰s C ´ A ¼‰s C®);
a (rewrite_tac[¼‰s_def] THEN REPEAT strip_tac);
a (¶_tac ¬Ìx· f'(f x)®
	THEN asm_rewrite_tac[]
	THEN REPEAT strip_tac
	THEN (REPEAT_N 3 (TRY (all_asm_ufc_tac[]))));
val ¼‰s_trans = save_pop_thm "¼‰s_trans";

add_pc_thms "'ordcard0" [¼‰s_refl];
set_merge_pcs ["basic_hol", "'ordcard0"];
=TEX
}%ignore


¹HOLCONST
Ü $Û<‰sÝ : 'a SET ­ 'b SET ­ BOOL
÷üüüüüü
Ü µ A B· A <‰s B ¤ A ¼‰s B ± ³ B ¼‰s A
°

=GFT
Ûlt‰s_irreflÝ =
	ô µ A· ³ A <‰s A
Ûlt‰s_transÝ =
	ô µ A B C· A <‰s B ± B <‰s C ´ A <‰s C
Ûlt‰s_¼‰s_transÝ =
	ô µ A B C· A <‰s B ± B ¼‰s C ´ A <‰s C
Û¼‰s_lt‰s_transÝ =
	ô µ A B C· A ¼‰s B ± B <‰s C ´ A <‰s C
=TEX

\ignore{
=SML
val lt‰s_def = get_spec ¬$<‰s®;

set_goal([], ¬µA:'a ð· ³ A <‰s A®);
a (rewrite_tac[lt‰s_def] THEN REPEAT strip_tac);
val lt‰s_irrefl = save_pop_thm "lt‰s_irrefl";

set_goal([], ¬µA B C· A <‰s B ± B <‰s C ´ A <‰s C®);
a (rewrite_tac[lt‰s_def]
	THEN contr_tac
	THEN all_fc_tac [¼‰s_trans]);
val lt‰s_trans = save_pop_thm "lt‰s_trans";

set_goal([], ¬µA B C· A <‰s B ± B ¼‰s C ´ A <‰s C®);
a (rewrite_tac[lt‰s_def]
	THEN contr_tac
	THEN all_fc_tac [¼‰s_trans]);
val lt‰s_¼‰s_trans = save_pop_thm "lt‰s_¼‰s_trans";

set_goal([], ¬µA B C· A ¼‰s B ± B <‰s C ´ A <‰s C®);
a (rewrite_tac[lt‰s_def]
	THEN contr_tac
	THEN all_fc_tac [¼‰s_trans]);
val ¼‰s_lt‰s_trans = save_pop_thm "¼‰s_lt‰s_trans";

=TEX
}%ignore

¹HOLCONST
Ü $Û~‰sÝ : 'a SET ­ 'b SET ­ BOOL
÷üüüüüü
Ü µ A B·
Ü	A ~‰s B ¤ ¶f g·
Ü		(µx· x  A ´ f x  B ± g (f x) = x)
Ü	±	(µy· y  B ´ g y  A ± f (g y) = y)
°

=GFT
Ûcard_equiv_lemmaÝ =
	ô µ x y z· x ~‰c x ± (x ~‰c y ¤ y ~‰c x) ± (x ~‰c y ± y ~‰c z ´ x ~‰c z)
=TEX

\ignore{
=SML
val eq‰s_def = get_spec ¬$~‰s®;

set_flag("pp_show_HOL_types", false);
push_pc "hol";

set_goal([], ¬µx y z· (x ~‰s x)
		± (x ~‰s y ¤ y ~‰s x)
		± (x ~‰s y ± y ~‰s z ´ x ~‰s z)®);
a (rewrite_tac [get_spec ¬$~‰s®] THEN prove_tac[]);
(* *** Goal "1" *** *)
a (¶_tac ¬Ìx:'b· x® THEN ¶_tac ¬Ìx:'b· x® THEN prove_tac[]);
(* *** Goal "2" *** *)
a (¶_tac ¬f' o f® THEN ¶_tac ¬g o g'® THEN rewrite_tac[o_def]
	THEN REPEAT strip_tac);
(* *** Goal "2.1" *** *)
a (REPEAT (asm_fc_tac[]));
(* *** Goal "2.2" *** *)
a (asm_fc_tac[]);
a (spec_nth_asm_tac 5 ¬f x'®);
a (asm_rewrite_tac[]);
(* *** Goal "2.3" *** *)
a (REPEAT_N 2 (asm_fc_tac[]));
(* *** Goal "2.4" *** *)
a (asm_fc_tac[]);
a (spec_nth_asm_tac 6 ¬g' y'®);
a (asm_rewrite_tac[]);
val card_equiv_lemma = save_pop_thm "card_equiv_lemma";

=IGN
I think I need to refer to Schroeder-Bernstein here.

set_goal([], ¬µA B· A ~‰s B ¤ A ¼‰s B ± B ¼‰s A®);
a (REPEAT µ_tac
	THEN rewrite_tac[eq‰s_def, ¼‰s_def]
	THEN REPEAT strip_tac);

set_goal([], ¬µA B· A ~‰s B ¤ A ¼‰s B ± B ¼‰s A®);
a (rewrite_tac 
pop_pc();
=TEX
}%ignore


=SML
commit_pc "'ordcard0";
force_new_pc "ordcard0";
merge_pcs ["rbjmisc", "'ordcard0"] "ordcard0";
commit_pc "ordcard0";
force_new_pc "ordcard01";
merge_pcs ["rbjmisc1", "'ordcard0"] "ordcard01";
commit_pc "ordcard01";
=TEX

\section{ORDINALS}

I had at first intended to do a minimal set theory sufficient for defining a type of infinitary trees.
But I think the simplest development is to go straight to a type of ordinals and work forward from there.

=SML
open_theory "ordcard0";
force_new_theory "ÛordcardÝ";
new_parent "U_orders";
new_parent "wf_relp";
new_parent "wf_recp";
force_new_pc "Û'ordcardÝ";
merge_pcs ["'savedthm_cs_¶_proof"] "'ordcard";
set_merge_pcs ["ordcard0", "'ordcard"];
=TEX

The method is as follows.
First introduce a type of ordinals, then a type of cardinals which assists in formulation of a strong axiom of infinity.
Then a type of infinitary sequences, then a type of infinitary trees.

\subsection{The Type of Ordinals}

=SML
new_type ("ordinal", 0);
=TEX

We now use a well ordering theorem to define the ordering over the ordinals.
The consistency proof uses definitions and results from t009 \cite{rbjt009}.
The principal result is that every set can be well-ordered, but the definition of well-ordering does not entail well-foundedness or transitivity, since a well-ordering might be reflexive but well-foundedness does not admit reflexiveness.
So the proof (not shown) takes an arbitrary well-ordering makes it irreflexive and then proves that the result is a well-founded well-ordering.

\ignore{
=SML
set_goal([], ¬¶<‰o:ordinal ­ ordinal  ­ BOOL·
	WellOrdering(Universe, <‰o)
	± WellFounded(Universe, <‰o)®);
a (strip_asm_tac (µ_elim ¬Universe:ordinal ð® well_ordering_thm));
a (lemma_tac ¬¶g· g = Ìx y· x << y ± ³ x = y® THEN1 prove_¶_tac);
a (fc_tac [well_ordering_def_thm]);
a (¶_tac ¬g® THEN rewrite_tac[well_ordering_def_thm, well_founded_thm]
	THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a (POP_ASM_T ante_tac
	THEN asm_rewrite_tac (map get_spec [¬LinearOrder®, ¬PartialOrder®, ¬Trich®, ¬Antisym®, ¬Trans®])
	THEN REPEAT strip_tac);
(* *** Goal "1.1" *** *)
a (all_asm_fc_tac[]);
(* *** Goal "1.2" *** *)
a (all_asm_fc_tac[]);
(* *** Goal "1.3" *** *)
a (contr_tac THEN var_elim_asm_tac ¬x = z®);
a (all_asm_fc_tac[]);
(* *** Goal "1.4" *** *)
a (all_asm_fc_tac[]);
(* *** Goal "1.5" *** *)
a (contr_tac THEN var_elim_asm_tac ¬y = x®);
(* *** Goal "2" *** *)
a (DROP_NTH_ASM_T 2 ante_tac
	THEN asm_rewrite_tac (map get_spec [¬MinCond®, ¬WeakMinCond®, ¬Antisym®])
	THEN REPEAT strip_tac);
(* *** Goal "2.1" *** *)
a (contr_tac THEN all_asm_fc_tac[]);
(* *** Goal "2.2" *** *)
a (all_asm_ufc_tac[]);
a (¶_tac ¬x® THEN asm_rewrite_tac[] THEN REPEAT strip_tac);
(* *** Goal "2.2.1" *** *)
a (all_asm_ufc_tac[]);
(* *** Goal "2.2.2" *** *)
a (contr_tac THEN var_elim_asm_tac ¬x = y®);
(* *** Goal "3" *** *)
a (DROP_NTH_ASM_T 4 ante_tac
	THEN DROP_NTH_ASM_T 3 ante_tac
	THEN asm_rewrite_tac (map get_spec [¬MinCond®, ¬WeakMinCond®, ¬Antisym®, ¬LinearOrder®, ¬Trich®, ¬Universe®])
	THEN REPEAT strip_tac);
a (all_asm_ufc_tac[]);
a (¶_tac ¬x® THEN asm_rewrite_tac[] THEN REPEAT strip_tac);
a (contr_tac THEN all_asm_fc_tac[]);
a (all_asm_ufc_tac[]);
save_cs_¶_thm (pop_thm());
=TEX
}%ignore

¹HOLCONST
Ü Û<‰oÝ: ordinal ­ ordinal  ­ BOOL
÷üüüüüüüüüüü
Ü 	WellOrdering(Universe, <‰o)
Ü	± WellFounded(Universe, <‰o)
°

=SML
declare_infix(300, "<‰o");
=TEX

It proves helpful to have this alternative rendering of well-foundedness:

=GFT
Ûlt‰o_wfÝ =
	ô well_founded $<‰o
=TEX

\ignore{
=SML
val lt‰o_def = get_spec ¬$<‰o®;

set_goal ([], ¬well_founded $<‰o®);
a (LEMMA_T ¬well_founded $<‰o ¤ WellFounded(Universe, $<‰o)® rewrite_thm_tac
	THEN1 rewrite_tac 
	[get_spec ¬well_founded®, rewrite_rule [get_spec ¬UWellFounded®] u_well_founded_induction_thm]);
a (rewrite_tac[lt‰o_def]);
val lt‰o_wf = save_pop_thm "lt‰o_wf";
=TEX
}%ignore

=SML
val ÛORD_INDUCTION_TÝ = WF_INDUCTION_T lt‰o_wf;
val Ûord_induction_tacÝ = wf_induction_tac lt‰o_wf;
=TEX

Every well-founded well-ordering is an initial segment of ordinals, so we have now a type of ordinals.
At this point we have no idea how many ordinals there are in the type, there might be only one.

So we will need a strong axiom of infinity to tell us that we have enough ordinals for our purposes.

By analogy with a set theory with Universes, I assert that every ordinal is less than some inaccessible ordinal.
To get an analogue to global replacement (rather than replacement below any inaccessible ordinal corresponding to replacement within a ``universe''), we would need to require that the universe is regular.

To help in expressing the notion of strong limit ordinal the following definition is helpful:

The cardinality of a Von Neumann ordinal is the cardinality of the collection of strictly smaller ordinals.
The following function which delivers that set.
I also use the partial ordering of sets by cardinality ($<‰s$) which was defined above.

=SML
declare_infix(300, "¼‰o");
=TEX

¹HOLCONST
Ü $Û¼‰oÝ: ordinal ­ ordinal  ­ BOOL
÷üüüüüüüüüüü
Ü µÂ Ç· Â ¼‰o Ç ¤  Â <‰o Ç ² Â = Ç
°

¹HOLCONST
Ü ÛX‰oÝ: ordinal ­ ordinal ð
÷üüüüüüüüüüü
Ü µÂ· X‰o Â = {È | È <‰o Â}
°

=SML
val strong_infinity = new_axiom(["strong_infinity"], ¬
µÂ·
	¶Ç· Â <‰o Ç
±
	µÔ· Ô <‰o Ç ´ 
	   ð (X‰o Ô) <‰s X‰o Ç
	± (µf· (¶Ò· (µÎ· Î <‰o Ô ´ f Î <‰o Ò) ±
			(Ò ¼‰o Ç ´ Ò <‰o Ç)))
	
®);
=TEX

Later the essential ideas here may be expressed in more conventional terms and used to validate this definition.
Pro-tem, the following notes may illuminate the axiom.

The axiom is intended to state:
\begin{enumerate}
\item that every ordinal is less than some inaccessible ordinal
\item that the universe is the set of ordinals less than some regular ordinal
\end{enumerate}

Thus $Ç$ in the axiom is the name used for this supposedly inaccessible ordinal, but note that the least such $Ç$ will not be inaccessible, but will be $×$, the first limit ordinal.
Adding the requirement that $Ç$ be uncountable does not strengthen the axiom which still entails that every ordinal is less than some inaccessible ordinal.
What we assert of $Ç$ is first that it is a strong limit ordinal and then that it (and the universe as a whole) is regular.
These concepts are given formal definitions later, but the axiom is presented in concise form rather than through the definitions of the concepts.

It will be a while before any use is made of this axiom at all.
For the meantime the elementary theorems obtained hold even in a singleton ordinal type.

=GFT
Ûlt‰o_min_condÝ =
	ô µ A· ³ A = {} ´ (¶ x· x  A ± (µ y· y  A ´ ³ y <‰o x))
Ûlt‰o_transÝ =
	ô µ Â Ç È· Â <‰o Ç ± Ç <‰o È ´ Â <‰o È
Ûlt‰o_irreflÝ =
	ô µ Â· ³ Â <‰o Â
Ûlt‰o_trichÝ =
	ô µ Â Ç· Â <‰o Ç ² Ç <‰o Â ² Â = Ç
Ûlt‰o_trich_fcÝ =
	ô µ Â Ç· ³ Â <‰o Ç ± ³ Ç <‰o Â ´ Â = Ç
Ûlt‰o_trich_fc2Ý =
	ô µ Â Ç· ³ (³ Â <‰o Ç ± ³ Ç <‰o Â ± ³ Â = Ç)
Û¼‰o_reflÝ =
	ô µ Â· Â ¼‰o Â
Û¼‰o_lt‰oÝ =
	ô µ Â Ç· Â ¼‰o Ç ¤ ³ Ç <‰o Â
Û³‰o_clausesÝ =
	ô µ Â Ç· (³ Â <‰o Ç ¤ Ç ¼‰o Â) ± (³ Ç ¼‰o Â ¤ Â <‰o Ç)
=TEX

\ignore{
=SML
val lt‰o_def = get_spec ¬$<‰o®;
val ¼‰o_def = get_spec ¬$¼‰o®;
val X‰o_def = get_spec ¬X‰o®;

set_goal([], ¬µA· ³ A = {} ´ ¶x· x  A ± µy· y  A ´ ³ y <‰o x®);
a (strip_asm_tac lt‰o_def);
a (fc_tac [get_spec ¬WellOrdering®]);
a (fc_tac [get_spec ¬WeakMinCond®]);
a (POP_ASM_T ante_tac THEN PC_T1 "hol1" rewrite_tac[] THEN REPEAT strip_tac);
a (all_asm_fc_tac[]);
a (¶_tac ¬x'® THEN REPEAT strip_tac);
a (fc_tac [get_spec ¬WellFounded®]);
a (fc_tac [get_spec ¬Irrefl®]);
a (POP_ASM_T ante_tac THEN PC_T1 "hol1" rewrite_tac[] THEN REPEAT strip_tac);
a (spec_nth_asm_tac 5 ¬y®);
(* *** Goal "1" *** *)
a (var_elim_asm_tac ¬y = x'® THEN asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a (fc_tac [get_spec ¬LinearOrder®]);
a (fc_tac [get_spec ¬PartialOrder®]);
a (fc_tac [get_spec ¬Antisym®]);
a (POP_ASM_T ante_tac THEN PC_T1 "hol1" rewrite_tac[] THEN contr_tac);
a (contr_tac THEN all_asm_ufc_tac[]);
a (lemma_tac ¬³ x' = y® THEN1 contr_tac);
(* *** Goal "2.1" *** *)
a (var_elim_asm_tac ¬x' = y® THEN asm_fc_tac[]);
(* *** Goal "2.2" *** *)
a (all_asm_fc_tac[]);
val lt‰o_min_cond = save_pop_thm "lt‰o_min_cond";

set_goal([], ¬µÂ Ç È· Â <‰o Ç ± Ç <‰o È ´ Â <‰o È®);
a (strip_asm_tac lt‰o_def);
a (fc_tac [well_ordering_def]);
a (fc_tac [linear_order_def]);
a (fc_tac [partial_order_def]);
a (fc_tac [trans_def]);
a (POP_ASM_T ante_tac
	THEN rewrite_tac[get_spec ¬Universe®]
	THEN REPEAT strip_tac
	THEN all_asm_fc_tac[]);
val lt‰o_trans = save_pop_thm "lt‰o_trans";

set_goal([], ¬µÂ· ³ Â <‰o Â®);
a (strip_asm_tac(lt‰o_def) THEN REPEAT strip_tac);
a (fc_tac [well_founded_def]);
a (fc_tac [irrefl_def]);
a (POP_ASM_T ante_tac THEN rewrite_tac[get_spec¬Universe®]);
a (prove_tac[]);
val lt‰o_irrefl = save_pop_thm "lt‰o_irrefl";

set_goal([], ¬µÂ Ç· Â <‰o Ç ² Ç <‰o Â ² Â = Ç®);
a (strip_asm_tac lt‰o_def);
a (fc_tac [well_ordering_def]);
a (fc_tac [linear_order_def]);
a (fc_tac [trich_def]);
a (POP_ASM_T ante_tac
	THEN rewrite_tac[get_spec ¬Universe®]
	THEN contr_tac
	THEN all_asm_fc_tac[]);
val lt‰o_trich = save_pop_thm "lt‰o_trich";

set_goal([], ¬µÂ Ç· ³ Â <‰o Ç ± ³ Ç <‰o Â ´ Â = Ç®);
a contr_tac;
a (strip_asm_tac (list_µ_elim [¬Â®, ¬Ç®] lt‰o_trich));
val lt‰o_trich_fc = save_pop_thm "lt‰o_trich_fc";

set_goal([], ¬µÂ Ç· ³ (³ Â <‰o Ç ± ³ Ç <‰o Â ± ³ Â = Ç)®);
a contr_tac;
a (strip_asm_tac (list_µ_elim [¬Â®, ¬Ç®] lt‰o_trich));
val lt‰o_trich_fc2 = save_pop_thm "lt‰o_trich_fc2";

set_goal([], ¬µÂ· Â ¼‰o Â®);
a (rewrite_tac[¼‰o_def]);
val ¼‰o_refl = save_pop_thm "¼‰o_refl";

set_goal([], ¬µÂ Ç· Â ¼‰o Ç ¤ ³ Ç <‰o Â®);
a (REPEAT µ_tac THEN rewrite_tac [¼‰o_def]);
a (contr_tac
	THEN strip_asm_tac (list_µ_elim [¬Â®, ¬Ç®] lt‰o_trich)
	THEN all_fc_tac [lt‰o_trans]
	THEN_TRY var_elim_nth_asm_tac 2
	THEN fc_tac[lt‰o_irrefl]);
val ¼‰o_lt‰o = save_pop_thm "¼‰o_lt‰o";

set_goal([], ¬µÂ Ç· (³ Â <‰o Ç ¤ Ç ¼‰o Â)
	±  (³ Ç ¼‰o Â ¤ Â <‰o Ç)®);
a (rewrite_tac[¼‰o_def] THEN contr_tac
	THEN_TRY all_var_elim_asm_tac
	THEN_TRY all_fc_tac [lt‰o_trich_fc, lt‰o_trans]
	THEN asm_prove_tac [lt‰o_irrefl]);
val ³‰o_clauses = save_pop_thm "³‰o_clauses";

add_rw_thms [lt‰o_irrefl, ¼‰o_refl] "'ordcard";
add_sc_thms [lt‰o_irrefl, ¼‰o_refl] "'ordcard";
add_st_thms [lt‰o_irrefl] "'ordcard";
set_merge_pcs ["basic_hol", "'ordcard0", "'ordcard"];
=TEX
}%ignore

A useful principle for reasoning about the ordinals is the following analogue of set theoretic extensionality:

=GFT
Ûord_ext_thmÝ =
	ô µ Â Ç· Â = Ç ¤ (µ Ä· Ä <‰o Â ¤ Ä <‰o Ç)
=TEX

We we later make use of quasi extensional characterisations of operations over ordinals, in which an ordinal expression is characterised by a statement of the conditions under which ordinals are less than the value of the expression.
This facilitates proofs about ordinals in which the complexity is on the right of an inequality, or in which such can be obtained by the extesionality principle above.

This leaves an awkwardness where our goal has an expression on the left of an inequality which the following rule is intended to ameliorate.

=GFT
Û¼‰o_ext_thmÝ =
	ô µ Â Ç· Â ¼‰o Ç ¤ (µ Ä· Ä <‰o Â ´ Ä <‰o Ç)
=TEX

\ignore{
=SML
set_goal([], ¬µÂ Ç· Â = Ç ¤ µÄ· Ä <‰o Â ¤ Ä <‰o Ç®);
a (REPEAT_N 5 strip_tac THEN_TRY asm_rewrite_tac[] THEN contr_tac);
a (spec_nth_asm_tac 2 ¬Â®
	THEN spec_nth_asm_tac 4 ¬Ç®
	THEN all_fc_tac [lt‰o_trich_fc2]);
val ord_ext_thm = save_pop_thm "ord_ext_thm";

(* skip to end of next section for ¼‰o_ext_thm *)
=TEX
}%ignore

=GFT
Ûlt‰o_¼‰oÝ =
	ô µ Â Ç È· Â <‰o Ç ´ Â ¼‰o Ç
Û¼‰o_transÝ =
	ô µ Â Ç È· Â ¼‰o Ç ± Ç ¼‰o È ´ Â ¼‰o È
Û¼‰o_lt‰o_transÝ =
	ô µ Â Ç È· Â ¼‰o Ç ± Ç <‰o È ´ Â <‰o È
Ûlt‰o_¼‰o_transÝ =
	ô µ Â Ç È· Â <‰o Ç ± Ç ¼‰o È ´ Â <‰o È
Û¼‰o_casesÝ =
	ô µ Â Ç· Â ¼‰o Ç ² Ç ¼‰o Â
=TEX

\ignore{
=SML
set_goal([], ¬µ Â Ç È· Â <‰o Ç ´ Â ¼‰o Ç®);
a (rewrite_tac[¼‰o_def] THEN REPEAT strip_tac);
val lt‰o_¼‰o = save_pop_thm "lt‰o_¼‰o";

set_goal([], ¬µÂ Ç È· Â ¼‰o Ç ± Ç ¼‰o È ´ Â ¼‰o È®);
a (rewrite_tac[¼‰o_def] THEN REPEAT strip_tac
	THEN_TRY all_var_elim_asm_tac
	THEN all_fc_tac [lt‰o_trans]
	THEN rewrite_tac[]);
val ¼‰o_trans = save_pop_thm "¼‰o_trans";

set_goal([], ¬µÂ Ç È· Â ¼‰o Ç ± Ç <‰o È ´ Â <‰o È®);
a (rewrite_tac[¼‰o_def] THEN REPEAT strip_tac
	THEN_TRY all_var_elim_asm_tac
	THEN all_fc_tac [lt‰o_trans]
	THEN rewrite_tac[]);
val ¼‰o_lt‰o_trans = save_pop_thm "¼‰o_lt‰o_trans";

set_goal([], ¬µÂ Ç È· Â <‰o Ç ± Ç ¼‰o È ´ Â <‰o È®);
a (rewrite_tac[¼‰o_def] THEN REPEAT strip_tac
	THEN_TRY all_var_elim_asm_tac
	THEN all_fc_tac [lt‰o_trans]
	THEN rewrite_tac[]);
val lt‰o_¼‰o_trans = save_pop_thm "lt‰o_¼‰o_trans";

set_goal([], ¬µÂ Ç· Â ¼‰o Ç ² Ç ¼‰o Â®);
a (rewrite_tac[¼‰o_def] THEN contr_tac);
a (strip_asm_tac (all_µ_elim lt‰o_trich));
val ¼‰o_cases = save_pop_thm "¼‰o_cases";

set_goal([], ¬µÂ Ç· Â ¼‰o Ç ¤ µÄ· Ä <‰o Â ´ Ä <‰o Ç®);
a (REPEAT_N 5 strip_tac THEN_TRY asm_rewrite_tac[] THEN contr_tac);
(* *** Goal "1" *** *)
a (all_fc_tac [lt‰o_¼‰o_trans]);
(* *** Goal "2" *** *)
a (spec_nth_asm_tac 2 ¬Ç®);
a (REPEAT_N 2 (POP_ASM_T ante_tac)
	THEN rewrite_tac[³‰o_clauses]
	THEN REPEAT strip_tac);
val ¼‰o_ext_thm = save_pop_thm "¼‰o_ext_thm";
=TEX
}%ignore

It will be useful to have a name for the least element of a collection of ordinals...

\ignore{
=SML
set_goal([], ¬¶Least‰o· µso· 
	µÈ· È  so ´ Least‰o so  so ± Least‰o so ¼‰o È®);
a (¶_tac ¬Ìso· ÅÇ· Ç  so ± µÂ· Â  so ´ Ç ¼‰o Â®
	THEN rewrite_tac[]
	THEN REPEAT_N 3 strip_tac);
a (Å_tac ¬Å Ç· Ç  so ± (µ Â· Â  so ´ Ç ¼‰o Â)®);
(* *** Goal "1" *** *)
a (strip_asm_tac (µ_elim ¬so® lt‰o_min_cond));
(* *** Goal "1.1" *** *)
a (PC_T1 "hol1" asm_prove_tac[]);
(* *** Goal "1.2" *** *)
a (¶_tac ¬x®
	THEN asm_rewrite_tac []
	THEN µ_tac
	THEN asm_rewrite_tac[get_spec ¬$¼‰o®]
	THEN contr_tac
	THEN asm_fc_tac[]);
a (strip_asm_tac (list_µ_elim [¬x®, ¬Â®] lt‰o_trich));
(* *** Goal "2" *** *)
a (ASM_FC_T asm_rewrite_tac[]);
save_cs_¶_thm (pop_thm());
=TEX
}%ignore

¹HOLCONST
Ü ÛLeast‰oÝ: ordinal ð ­ ordinal
÷üüüüüüüüüüü
Ü µso È· È  so ´ Least‰o so  so ± Least‰o so ¼‰o È
°

... and for the supremum of a set of ordinals.

¹HOLCONST
Ü ÛUb‰oÝ: ordinal ð ­ ordinal ð
÷üüüüüüüüüüü
Ü µso· Ub‰o so = {Â | µÈ· È  so ´ È ¼‰o Â}
°

¹HOLCONST
Ü ÛSUb‰oÝ: ordinal ð ­ ordinal ð
÷üüüüüüüüüüü
Ü µso· SUb‰o so = {Â | µÈ· È  so ´ È <‰o Â}
°

¹HOLCONST
Ü ÛSup‰oÝ: ordinal ð ­ ordinal
÷üüüüüüüüüüü
Ü µso· Sup‰o so = Least‰o (Ub‰o so)
°

¹HOLCONST
Ü ÛSSup‰oÝ: ordinal ð ­ ordinal
÷üüüüüüüüüüü
Ü µso· SSup‰o so = Least‰o (SUb‰o so)
°

=GFT
ÛLeast‰o_thmÝ =
	ô µ so Â· Â  so ´
		(µ Ç· Ç <‰o Least‰o so ¤ (µ È· È  so ´ Ç <‰o È))
ÛUb‰o_thmÝ =
	ô µ so Ç· Ç  Ub‰o so ¤ (µ È· È  so ´ È ¼‰o Ç)
ÛUb‰o_X‰o_thmÝ =
	ô µ Á· Á  Ub‰o (X‰o Á)
ÛUb‰o_X‰o_thm2Ý =
	ô µ Á· Á  Ub‰o {Â|Â <‰o Á}
ÛSUb‰o_thmÝ =
	ô µ so Ç· Ç  SUb‰o so ¤ (µ È· È  so ´ È <‰o Ç)
ÛSUb‰o_X‰o_thmÝ =
	ô µ Á· Á  SUb‰o (X‰o Á)
ÛSUb‰o_X‰o_thm2Ý =
	ô µ Á· Á  SUb‰o {Â|Â <‰o Á}
Ûlt‰o_Sup‰oÝ =
	ô µ so Á· Á  Ub‰o so ´
		(µÇ· Ç <‰o Sup‰o so ¤ (¶È· È  so ± Ç <‰o È))
Ûlt‰o_Sup‰o2Ý =
	ô µ Á Ç· Ç <‰o Sup‰o {Â|Â <‰o Á} ¤ (¶ È· È <‰o Á ± Ç <‰o È)
Ûlt‰o_SSup‰oÝ =
	ô µ so Á· Á  SUb‰o so ´
		(µ Ç· Ç <‰o SSup‰o so ¤ (¶ È· È  so ± Ç ¼‰o È))
ÛSSup‰o_lt‰oÝ =
	ô µ Á· SSup‰o {Â|Â <‰o Á} = Á
ÛSSup‰o_lt‰o2Ý =
	ô µ so Á Â· Â  so ± Â  SUb‰o so ´
		(SSup‰o so <‰o Á ¤ (¶ Â· Â  SUb‰o so ± Â <‰o Á))
ÛSSup‰o_X‰oÝ =
	ô µ Á· SSup‰o (X‰o Á) = Á
=TEX

\ignore{
=SML
val Least‰o_def = get_spec ¬Least‰o®;
val Ub‰o_def = get_spec ¬Ub‰o®;
val SUb‰o_def = get_spec ¬SUb‰o®;
val Sup‰o_def = get_spec ¬Sup‰o®;
val SSup‰o_def = get_spec ¬SSup‰o®;

push_pc "hol1";

set_goal([], ¬µso Â· Â  so ´
	(µÇ· Ç <‰o Least‰o so ¤ µÈ· È  so ´ Ç <‰o È)®);
a (REPEAT strip_tac THEN all_ufc_tac [Least‰o_def]);
(* *** Goal "1" *** *)
a (all_fc_tac[lt‰o_¼‰o_trans]);
(* *** Goal "2" *** *)
a (asm_fc_tac[]);
val Least‰o_thm = save_pop_thm "Least‰o_thm";

set_goal([], ¬µso Ç· Ç  Ub‰o so ¤ µÈ· È  so ´ È ¼‰o Ç®);
a (rewrite_tac[Ub‰o_def]);
val Ub‰o_thm = save_pop_thm "Ub‰o_thm";

set_goal([], ¬µÁ· Á  Ub‰o (X‰o Á)®);
a (strip_tac THEN rewrite_tac[Ub‰o_thm, X‰o_def, ¼‰o_def]
	THEN REPEAT strip_tac);
val Ub‰o_X‰o_thm = save_pop_thm "Ub‰o_X‰o_thm";

set_goal([], ¬µÁ· Á  Ub‰o {Â | Â <‰o Á}®);
a (strip_tac THEN rewrite_tac[Ub‰o_thm, ¼‰o_def]
	THEN REPEAT strip_tac);
val Ub‰o_X‰o_thm2 = save_pop_thm "Ub‰o_X‰o_thm2";

set_goal([], ¬µso Ç· Ç  SUb‰o so ¤ µÈ· È  so ´ È <‰o Ç®);
a (rewrite_tac[SUb‰o_def]);
val SUb‰o_thm = save_pop_thm "SUb‰o_thm";

set_goal([], ¬µÁ· Á  SUb‰o (X‰o Á)®);
a (strip_tac THEN rewrite_tac[SUb‰o_thm, X‰o_def, ¼‰o_def]
	THEN REPEAT strip_tac);
val SUb‰o_X‰o_thm = save_pop_thm "SUb‰o_X‰o_thm";

set_goal([], ¬µÁ· Á  SUb‰o {Â | Â <‰o Á}®);
a (strip_tac THEN rewrite_tac[SUb‰o_thm, ¼‰o_def]
	THEN REPEAT strip_tac);
val SUb‰o_X‰o_thm2 = save_pop_thm "SUb‰o_X‰o_thm2";

set_goal([], ¬µso Á· Á  Ub‰o so ´
	(µÇ· Ç <‰o Sup‰o so ¤ ¶È· È  so ± Ç <‰o È)®);
a (rewrite_tac[Sup‰o_def]
	THEN REPEAT_N 5 strip_tac
	THEN_TRY all_ufc_¤_rewrite_tac [Least‰o_thm]
	THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a (contr_tac);
a (lemma_tac ¬Ç  Ub‰o so®);
(* *** Goal "1.1" *** *)
a (asm_rewrite_tac [Ub‰o_thm]
	THEN REPEAT strip_tac);
a (spec_nth_asm_tac 2 ¬È®);
a (asm_rewrite_tac[¼‰o_lt‰o]);
(* *** Goal "1.2" *** *)
a (asm_fc_tac[]);
a (fc_tac[lt‰o_irrefl]);
(* *** Goal "2" *** *)
a (all_fc_tac[Ub‰o_thm]);
a (all_fc_tac[lt‰o_¼‰o_trans]);
val lt‰o_Sup‰o = save_pop_thm "lt‰o_Sup‰o";

=IGN
set_goal([], ¬µso1 so2 Á· Á  Ub‰o so2 ± so1 € so2
	´ Sup‰o so1 ¼‰o Sup‰o so2®);
a (REPEAT strip_tac THEN rewrite_tac[]);
=SML

set_goal([], ¬µÁ Ç· Ç <‰o Sup‰o {Â | Â <‰o Á} ¤ ¶È· È <‰o Á ± Ç <‰o È®);
a (REPEAT µ_tac);
a (lemma_tac ¬¶ È· È  Ub‰o {Â|Â <‰o Á}®
	THEN1 (¶_tac ¬Á:ordinal® THEN rewrite_tac[Ub‰o_X‰o_thm2]));
a (all_ufc_¤_tac[lt‰o_Sup‰o]);
a (asm_rewrite_tac[]);
val lt‰o_Sup‰o2 = save_pop_thm "lt‰o_Sup‰o2";

=IGN
set_goal([], ¬µso· (¶Á· Á  Ub‰o so) ´
	µÇ· Sup‰o so <‰o Ç ¤ ¶È· È  Ub‰o so ´ È <‰o Ç®);
a (rewrite_tac[Sup‰o_def]
	THEN REPEAT_N 5 strip_tac);
	THEN_TRY all_ufc_¤_rewrite_tac [Least‰o_thm]
	THEN REPEAT strip_tac);
=SML

pop_pc();
set_merge_pcs ["ordcard01", "'ordcard"];

set_goal([], ¬µso Á· Á  SUb‰o so ´
	(µÇ· Ç <‰o SSup‰o so ¤ ¶È· È  so ± Ç ¼‰o È)®);
a (rewrite_tac[SSup‰o_def]
	THEN REPEAT_N 5 strip_tac
	THEN_TRY all_ufc_¤_rewrite_tac [Least‰o_thm]
	THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a (contr_tac);
a (lemma_tac ¬Ç  SUb‰o so®);
(* *** Goal "1.1" *** *)
a (asm_rewrite_tac [SUb‰o_thm]
	THEN REPEAT strip_tac);
a (spec_nth_asm_tac 2 ¬È®);
a (swap_nth_asm_concl_tac 1);
a (asm_rewrite_tac[¼‰o_lt‰o]);
(* *** Goal "1.2" *** *)
a (asm_fc_tac[]);
(* *** Goal "2" *** *)
a (all_fc_tac[SUb‰o_thm]);
a (all_fc_tac[¼‰o_lt‰o_trans]);
val lt‰o_SSup‰o = save_pop_thm "lt‰o_SSup‰o";

set_goal([], ¬µÁ· SSup‰o {Â | Â <‰o Á} = Á®);
a (REPEAT µ_tac THEN rewrite_tac[ord_ext_thm]);
a (lemma_tac ¬¶ È· È  SUb‰o {Â|Â <‰o Á}®
	THEN1 (¶_tac ¬Á:ordinal® THEN rewrite_tac[SUb‰o_X‰o_thm2]));
a (all_ufc_¤_tac[lt‰o_SSup‰o]);
a (asm_rewrite_tac[]);
a (REPEAT strip_tac);
(* *** Goal "1" *** *)
a (all_fc_tac [¼‰o_lt‰o_trans]);
(* *** Goal "2" *** *)
a (¶_tac ¬Ä® THEN asm_rewrite_tac[]);
val SSup‰o_lt‰o = save_pop_thm "SSup‰o_lt‰o";

set_goal([], ¬µÁ· SSup‰o (X‰o Á) = Á®);
a (strip_tac THEN rewrite_tac[X‰o_def, SSup‰o_lt‰o]);
val SSup‰o_X‰o = save_pop_thm "SSup‰o_X‰o";

set_goal([], ¬µso Â Ç· Â  so ± Ç  SUb‰o so ´
	(µÁ· SSup‰o so <‰o Á ¤ ¶È· È  SUb‰o so ± È <‰o Á)®);
a (REPEAT µ_tac THEN rewrite_tac[SSup‰o_def]
	THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a (all_ufc_¤_tac [Least‰o_def]);
a (¶_tac ¬Least‰o (SUb‰o so)® THEN asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a (all_ufc_¤_tac [Least‰o_def]);
a (all_ufc_tac [¼‰o_lt‰o_trans]);
val SSup‰o_lt‰o2 = save_pop_thm "SSup‰o_lt‰o2";

=IGN
set_goal([], ¬µÇ P· (¶È· È  SUb‰o {Â | P Â Ç}) ± (µÂ· Â <‰o Ç ¤ P Â Ç)
	´ Ç = SSup‰o{Â | P Â Ç}®);
a (rewrite_tac[ord_ext_thm] THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a (all_ufc_¤_rewrite_tac [lt‰o_SSup‰o]);
a (¶_tac ¬Ä® THEN all_asm_fc_tac[] THEN REPEAT strip_tac);
(* *** Goal "2" *** *)
a (POP_ASM_T ante_tac
	THEN all_ufc_¤_rewrite_tac [lt‰o_SSup‰o]
	THEN strip_tac);
a (DROP_NTH_ASM_T 2 ante_tac
	THEN SYM_ASMS_T rewrite_tac
	THEN strip_tac);
a (all_fc_tac [¼‰o_lt‰o_trans]);
val 

=SML
add_rw_thms [Ub‰o_thm, SUb‰o_thm, Ub‰o_X‰o_thm, SUb‰o_X‰o_thm,
	Ub‰o_X‰o_thm2, SUb‰o_X‰o_thm2, lt‰o_Sup‰o2, SSup‰o_lt‰o, SSup‰o_X‰o] "'ordcard";
add_sc_thms [Ub‰o_thm, SUb‰o_thm, Ub‰o_X‰o_thm, SUb‰o_X‰o_thm,
	Ub‰o_X‰o_thm2, SUb‰o_X‰o_thm2, lt‰o_Sup‰o2, SSup‰o_lt‰o, SSup‰o_X‰o] "'ordcard";
add_st_thms [lt‰o_Sup‰o2] "'ordcard";
set_merge_pcs ["ordcard01", "'ordcard"];
=TEX
}%ignore

Now a name to the least ordinal:

¹HOLCONST
Ü Û0‰oÝ: ordinal
÷üüüüüüüüüüü
Ü 0‰o = Least‰o {Ä | T}
°

=GFT
Ûzero‰o_thmÝ =
	ô µ Â· 0‰o ¼‰o Â
Ûlt‰o_zero‰o_thmÝ =
	ô µ Â· ³ Â <‰o 0‰o
=TEX

\ignore{
=SML
val zero‰o_def = get_spec ¬0‰o®;

set_goal([], ¬µÂ· 0‰o ¼‰o Â®);
a (rewrite_tac[zero‰o_def, pc_rule1 "hol1" rewrite_rule []
	(µ_elim ¬{Ä:ordinal|T}® Least‰o_def)]
	THEN strip_tac);
val zero‰o_thm = save_pop_thm "zero‰o_thm";

val lt‰o_zero‰o_thm = save_thm ("lt‰o_zero‰o_thm",
	rewrite_rule [¼‰o_lt‰o] zero‰o_thm);
=TEX
}%ignore

In order to define operators over the ordinals (without undesirable complications) the ordinals must be closed under the operations.
If we want to use such operations in formulating our strong axiom of infinity, then we would need to assert sufficiently strong closure conditions in advance of our axiom of infinity.

The basis for the closure principle one which definitions of functions like ordinal addition is based is a related to the axiom of replacement in set theory.
In talking of ordinals the corresponding notion is that or regularity, which we can define without any kind of axiom of infinity as follows.

First the notion of cofinality.
This definition is perhaps a little eccentric, in that it is defined over all ordinals not just limit ordinals, and in that it is couched in terms of arbitrary functions rather than increasing sequences, and consequently takes the supremum of the image rather than the limit of a sequence.

The supremum of an image will prove more generally useful so we give it a name.

By the image of an ordinal through a map, I mean the image of the set of ordinals less than that ordinal (which will be a set of ordinals of course):

¹HOLCONST
Ü ÛImage‰oÝ: ((ordinal ­ ordinal) ¸ ordinal) ­ ordinal ð
÷üüüüüüüüüüü
Ü µf Â· Image‰o(f, Â) = {Ä | ¶È· È <‰o Â ± f È = Ä}
°

=GFT
ÛImage‰o_thmÝ =
	ô µ f Â Ç· Ç  Image‰o (f, Â) ¤ (¶ È· È <‰o Â ± Ç = f È)
ÛImage‰o_zero‰o_thmÝ =
	ô µ f· Image‰o (f, 0‰o) = {}
ÛImage‰o_mono_thmÝ =
	ô µ f Á Â· Á ¼‰o Â ´ Image‰o (f, Á) € Image‰o (f, Â)
ÛUb‰o_Image‰o_thmÝ =
	ô µ f Â· ¶ Ç· Ç  Ub‰o (Image‰o (f, Â))
ÛUb‰o_Image‰o_zero‰oÝ =
	ô µ f Â Ç· Ç  Ub‰o (Image‰o (f, 0‰o))
ÛSUb‰o_Image‰o_thmÝ =
	ô µ f Â· ¶ Ç· Ç  SUb‰o (Image‰o (f, Â))
ÛSUb‰o_Image‰o_zero‰oÝ =
	ô µ f Â Ç· Ç  SUb‰o (Image‰o (f, 0‰o))
=TEX

\ignore{
=SML
val Image‰o_def = get_spec ¬Image‰o®;

set_goal([], ¬µf Â Ç· Ç  Image‰o (f, Â) ¤ ¶È· È <‰o Â ± Ç = f È®);
a (rewrite_tac[Image‰o_def] THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a (¶_tac ¬È® THEN asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a (¶_tac ¬È® THEN asm_rewrite_tac[]);
val Image‰o_thm = save_pop_thm "Image‰o_thm";

set_goal([], ¬µf· Image‰o(f, 0‰o) = {}®);
a (rewrite_tac[Image‰o_thm, lt‰o_zero‰o_thm]);
val Image‰o_zero‰o_thm = save_pop_thm "Image‰o_zero‰o_thm";

set_goal([], ¬µf Á Â· Á ¼‰o Â ´ Image‰o(f, Á) € Image‰o(f, Â)®);
a (rewrite_tac[Image‰o_thm, lt‰o_zero‰o_thm]
	THEN REPEAT strip_tac);
a (¶_tac ¬È® THEN asm_rewrite_tac[]);
a (all_fc_tac[lt‰o_¼‰o_trans]);
val Image‰o_mono_thm = save_pop_thm "Image‰o_mono_thm";

set_goal([], ¬µf Â· ¶Ç· Ç  Ub‰o(Image‰o (f, Â))®);
a (REPEAT µ_tac);
a (strip_asm_tac (strong_infinity));
a (spec_nth_asm_tac 1 ¬Â®);
a (spec_nth_asm_tac 1 ¬Â®);
a (SPEC_NTH_ASM_T 1 ¬f® (STRIP_THM_THEN (STRIP_THM_THEN asm_tac)));
a (POP_ASM_T discard_tac);
a (rewrite_tac[Ub‰o_def]);
a (¶_tac ¬Ò®
	THEN rewrite_tac[Image‰o_thm]
	THEN REPEAT strip_tac
	THEN asm_rewrite_tac[¼‰o_def]
	THEN asm_fc_tac[]
	THEN contr_tac);
val Ub‰o_Image‰o_thm = save_pop_thm "Ub‰o_Image‰o_thm";

set_goal([], ¬µf Â Ç· Ç  Ub‰o(Image‰o (f, 0‰o))®);
a (rewrite_tac[Ub‰o_thm, Ub‰o_Image‰o_thm, Image‰o_zero‰o_thm]);
val Ub‰o_Image‰o_zero‰o = save_pop_thm "Ub‰o_Image‰o_zero‰o";

set_goal([], ¬µf Â· ¶Ç· Ç  SUb‰o(Image‰o (f, Â))®);
a (REPEAT µ_tac);
a (strip_asm_tac (strong_infinity));
a (spec_nth_asm_tac 1 ¬Â®);
a (spec_nth_asm_tac 1 ¬Â®);
a (SPEC_NTH_ASM_T 1 ¬f® (STRIP_THM_THEN (STRIP_THM_THEN asm_tac)));
a (POP_ASM_T discard_tac);
a (rewrite_tac[SUb‰o_def]);
a (¶_tac ¬Ò®
	THEN rewrite_tac[Image‰o_thm]
	THEN REPEAT strip_tac
	THEN asm_rewrite_tac[¼‰o_def]
	THEN asm_fc_tac[]
	THEN contr_tac);
val SUb‰o_Image‰o_thm = save_pop_thm "SUb‰o_Image‰o_thm";

set_goal([], ¬µf Â Ç· Ç  SUb‰o(Image‰o (f, 0‰o))®);
a (rewrite_tac[SUb‰o_Image‰o_thm, Image‰o_zero‰o_thm]);
val SUb‰o_Image‰o_zero‰o = save_pop_thm "SUb‰o_Image‰o_zero‰o";

add_rw_thms [Image‰o_thm, zero‰o_thm, lt‰o_zero‰o_thm, Ub‰o_Image‰o_zero‰o,
	SUb‰o_Image‰o_zero‰o] "'ordcard";
add_sc_thms [Image‰o_thm, zero‰o_thm, lt‰o_zero‰o_thm, Ub‰o_Image‰o_zero‰o,
	SUb‰o_Image‰o_zero‰o] "'ordcard";
add_st_thms [Image‰o_thm, lt‰o_zero‰o_thm] "'ordcard";
set_merge_pcs ["ordcard01", "'ordcard"];
=TEX
}

$SupIm‰o$ is then the supremum of the image of an ordinal.
In the case that the function is increasing then this is the limit of a $Â$ sequence.
Sometimes where such a limit is used in the literature there is no apparent benefit from the restriction to increasing sequences and I use $SupIm‰o$ of an arbitary map, as in, for example, the definition of ordinal addition.

¹HOLCONST
Ü ÛSupIm‰oÝ: ((ordinal ­ ordinal) ¸ ordinal) ­ ordinal
÷üüüüüüüüüüü
Ü µx· SupIm‰o x = Sup‰o (Image‰o x)
°

$SSupIm‰o$ is the strict supremum of the image of an ordinal.

¹HOLCONST
Ü ÛSSupIm‰oÝ: ((ordinal ­ ordinal) ¸ ordinal) ­ ordinal
÷üüüüüüüüüüü
Ü µx· SSupIm‰o x = SSup‰o (Image‰o x)
°

In general the supremum of an image only exists if the image is bounded above.
However, one of the principle purposes of our axiom of strong infinity is to ensure that such bounds exist.
By analogy with replacement in set theory, which tells us that the image of a set is a set, we know that the image of a bounded collection of ordinals is itself bounded.
This enables us to prove the following results about $SupIm‰o$ and $SSupIm‰o$.

=GFT
Ûlt‰o_SupIm‰oÝ =
	ô µ f Â Ç· Ç <‰o SupIm‰o (f, Â) ¤ (¶ È· È <‰o Â ± Ç <‰o f È)
ÛSupIm‰o_zero‰oÝ =
	ô µ f Â Ç· ³ Ç <‰o SupIm‰o (f, 0‰o)
Ûlt‰o_SSupIm‰oÝ =
	ô µ f Â Ç· Ç <‰o SSupIm‰o (f, Â) ¤ (¶ È· È <‰o Â ± Ç ¼‰o f È)
ÛSSupIm‰o_zero‰oÝ =
	ô µ f Â Ç· ³ Ç <‰o SSupIm‰o (f, 0‰o)
=TEX

\ignore{
=SML
val SupIm‰o_def = get_spec ¬SupIm‰o®;
val SSupIm‰o_def = get_spec ¬SSupIm‰o®;

set_goal([], ¬µf Â Ç· Ç <‰o SupIm‰o (f, Â) ¤ ¶È· È <‰o Â ± Ç <‰o f È®);
a (REPEAT µ_tac
	THEN rewrite_tac [SupIm‰o_def]);
a (strip_asm_tac (list_µ_elim [¬f®, ¬Â®] Ub‰o_Image‰o_thm));
a (all_ufc_¤_rewrite_tac [µ_elim ¬Image‰o (f, Â)® lt‰o_Sup‰o]
	THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a (¶_tac ¬$"È'"® THEN asm_rewrite_tac[]);
a (SYM_ASMS_T rewrite_tac);
(* *** Goal "2" *** *)
a (¶_tac ¬f È® THEN asm_rewrite_tac[Image‰o_thm]);
a (¶_tac ¬È® THEN asm_rewrite_tac[]);
val lt‰o_SupIm‰o = save_pop_thm "lt‰o_SupIm‰o";

set_goal([], ¬µf Â Ç· ³ Ç <‰o SupIm‰o (f, 0‰o)®);
a (rewrite_tac[lt‰o_SupIm‰o]);
val SupIm‰o_zero‰o = save_pop_thm "SupIm‰o_zero‰o";

=IGN
set_goal([], ¬µf Á Â· Á ¼‰o Â ´ SupIm‰o (f, Á) ¼‰o SupIm‰o (f, Â)®);
a (REPEAT µ_tac THEN rewrite_tac[SupIm‰o_def] THEN REPEAT strip_tac);
=SML

set_goal([], ¬µf Â Ç· Ç <‰o SSupIm‰o (f, Â) ¤ ¶È· È <‰o Â ± Ç ¼‰o f È®);
a (REPEAT µ_tac
	THEN rewrite_tac [SSupIm‰o_def]);
a (strip_asm_tac (list_µ_elim [¬f®, ¬Â®] SUb‰o_Image‰o_thm));
a (all_ufc_¤_rewrite_tac [µ_elim ¬Image‰o (f, Â)® lt‰o_SSup‰o]
	THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a (¶_tac ¬$"È'"® THEN asm_rewrite_tac[]);
a (SYM_ASMS_T rewrite_tac);
(* *** Goal "2" *** *)
a (¶_tac ¬f È® THEN asm_rewrite_tac[Image‰o_thm]);
a (¶_tac ¬È® THEN asm_rewrite_tac[]);
val lt‰o_SSupIm‰o = save_pop_thm "lt‰o_SSupIm‰o";

set_goal([], ¬µf· SSupIm‰o (f, 0‰o) = 0‰o®);
a (rewrite_tac[ord_ext_thm, lt‰o_SSupIm‰o]);
val SSupIm‰o_zero‰o = save_pop_thm "SSupIm‰o_zero‰o";

add_rw_thms [lt‰o_SupIm‰o, lt‰o_SSupIm‰o, SupIm‰o_zero‰o, SSupIm‰o_zero‰o] "'ordcard";
add_sc_thms [lt‰o_SupIm‰o, lt‰o_SSupIm‰o, SupIm‰o_zero‰o, SSupIm‰o_zero‰o] "'ordcard";
add_st_thms [lt‰o_SupIm‰o, lt‰o_SSupIm‰o, SupIm‰o_zero‰o, SSupIm‰o_zero‰o] "'ordcard";
set_merge_pcs ["ordcard01", "'ordcard"];
=TEX
}%ignore

\subsection{Defining Functions over the Ordinals}

Often functions over ordinals are defined by cases in a manner analogous to primitive recursive definitions over the natural numbers (in which the cases are zero and successors) by adding a further case for limit ordinals.
Its not clear whether such an approach would work for us, because there is some difficulty in dealing with the limit case.

The approach I adopt addresses directly the limit case and subsumes the whole.

It may help to think of this as definition by inequality.
Just as sets can be uniquely determined by identifying their members, so can ordinals when they are represented by sets.
Though we do not represent an ordinal by a set, it is nevertheless uniquely determined by its predecessors, which would have been its members if we had been working in set theory.

Thus an ordinal $Â$ might be defined by a sentence of the following form:

=GFT
	µÇ· Ç <‰o Â ¤ formula
=TEX	

I did look for a way of automatically proving the consistency of definitions in that form, but found this to be less straightforward than I had expected.
The reason is that not all formulae of the given form are consistent.
The formula on the right has to have the property that if true for a given value $Ç$ it is true also for any smaller value.

I have therefore to fall back on forms of definition more similar to those used in t042 \cite{rbjt042}.

Thus instead of the above we would have something like:

=GFT
	Â = SSup‰o {Ç | formula}
=TEX	

Which is not subject to the same constraint.

A further problem is the necessary recursion in defining operations over ordinals.
A more definite example is desirable so we will look at addition.

Addition could be defined as follows:

=GFT
	µÂ Ç È· È <‰o Â +‰o Ç ¤ È <‰o Â ² ¶Ò· Ò <‰o Ç ± È = Â +‰o Ò
=TEX

The recursion here is well-founded because the addition on the right operates on smaller arguments than the one on the left.
To make this conspicuous we can rewrite the definition, first:

=GFT
	µÂ Ç· Â +‰o Ç = SSup‰o {È | È <‰o Â ² ¶Ò· Ò <‰o Ç ± È = Â +‰o Ò}
=TEX


This first step overcomes the first problem (the dependence on establishing that the formula `downward closed', the set in the second formulation does not need to be downward closed).
The smaller values become irrelevant, and this could be simplified to:

=GFT
	µÂ Ç· Â +‰o Ç = SSup‰o {È | ¶Ò· Ò <‰o Ç ± È = Â +‰o Ò}
=TEX

A further step allows the well-foundedness of the recursion to be made more obvious.

=GFT
	µÂ Ç· ($+‰o Â) Ç = SSup‰o (Image‰o ($+‰o Â) Ç)
=TEX

It is a feature of $SSupIm‰o (\$+‰o Â) Ç$ that it accessed values of $\$+‰o Â$ only for ordinals less than $Ç$.
A suitable recursion theorem is necessary to permit definitions in this form to be accepted.

There is a question in formulating such a recursion theorem as to what access to the function is required.
A maximally general theorem will allow access to a restricted version of the function, an intermediate version to the image of the values below some ordinal through the map, and a minimal version to the supremum of strict supremum of the values.
At this point it is not clear to me what is likely to be most useful.

On considering this I came to the conclusion that a general principle should be provided elsewhere, and have put one ($tf\_rec\_thm2$) in t009 \cite{rbjt009}.
This provides a recursion theorem for use with any well-founded relation.

When we specialise that to the ordering over the ordinals we get:

=GFT
Ûord_rec_thmÝ =
	ô µ af· ¶ f· µ x· f x = af ((x, $<‰o) §ò f) x
=TEX

In which the operator $§ò$ restricts the domain of function $f$ hiding information about values for arguments not lower in the ordering than $x$.
This can be made a little slicker for use in this document by defining a more specific restriction operator:

=SML
declare_infix(400, "ò‰o");
=TEX

¹HOLCONST
Ü $Ûò‰oÝ: ordinal ­ (ordinal ­ ordinal) ­ (ordinal ­ ordinal)
÷üüüüüüüüüüü
Ü µx f· x ò‰o f = (x, $<‰o) §ò f
°

=GFT
Ûò‰o_fcÝ =
	ô µÇ f Â· Â <‰o Ç ´ (Ç ò‰o f) Â = f Â
ÛImage‰o_ò‰o_thmÝ =
	ô µ Ç f· Image‰o (Ç ò‰o f, Ç) = Image‰o (f, Ç)
ÛSupIm‰o_ò‰o_thmÝ =
	ô µ Ç f· SupIm‰o (Ç ò‰o f, Ç) = SupIm‰o (f, Ç)
ÛSSupIm‰o_ò‰o_thmÝ =
	ô µÇ f· SSupIm‰o (Ç ò‰o f, Ç) = SSupIm‰o (f, Ç)
=TEX

Hence:

=GFT
Ûord_rec_thm2Ý =
	ô µ af· ¶ f· µ x· f x = af (x ò‰o f) x
=TEX

Unfortunately this will not work with the ProofPower consistency prover, which requires a constructor (as if we were defining a function by pattern matching over a recursive data type).
To get automatic consistency proofs we need to add a dummy constructor, so:

=GFT
Ûord_rec_thm3Ý =
	ô µ af· ¶ f· µ x· f (CombI x) = af (x ò‰o f) x
=TEX

=GFT
ÛImage‰o_recursion_thmÝ =
	ô µ af· ¶ f· µ x· f (CombI x) = af (Image‰o (f, x)) x
=TEX


\ignore{
=SML
val ò‰o_def = get_spec ¬$ò‰o®;

set_goal([], ¬µÇ f Â· Â <‰o Ç ´ (Ç ò‰o f) Â = f Â®);
a (REPEAT µ_tac THEN rewrite_tac [ò‰o_def] THEN REPEAT strip_tac
	THEN FC_T rewrite_tac [§ò_fc_thm]); 
val ò‰o_fc = save_pop_thm "ò‰o_fc";

set_goal([], ¬µÇ f· Image‰o (Ç ò‰o f, Ç) = Image‰o (f, Ç)®);
a (REPEAT µ_tac THEN rewrite_tac [ord_ext_thm]
	THEN REPEAT strip_tac
	THEN POP_ASM_T ante_tac
	THEN_TRY UFC_T rewrite_tac [ò‰o_fc]
	THEN strip_tac
	THEN ¶_tac ¬È:ordinal®
	THEN REPEAT strip_tac
	THEN asm_fc_tac[]
	);
(* *** Goal "1" *** *)
a (SYM_ASMS_T (fc_tac));
(* *** Goal "2" *** *)
a (FC_T asm_rewrite_tac [ò‰o_fc]);
(* *** Goal "3" *** *)
a (POP_ASM_T ante_tac);
a (FC_T asm_rewrite_tac [ò‰o_fc]);
val Image‰o_ò‰o_thm = save_pop_thm "Image‰o_ò‰o_thm";

set_goal([], ¬µÇ f· SupIm‰o (Ç ò‰o f, Ç) = SupIm‰o (f, Ç)®);
a (REPEAT strip_tac THEN rewrite_tac [ord_ext_thm]
	THEN REPEAT strip_tac
	THEN POP_ASM_T ante_tac
	THEN_TRY FC_T rewrite_tac [ò‰o_fc]
	THEN strip_tac
	THEN ¶_tac ¬È:ordinal®
	THEN REPEAT strip_tac
	);
a (FC_T asm_rewrite_tac [ò‰o_fc]);
val SupIm‰o_ò‰o_thm = save_pop_thm "SupIm‰o_ò‰o_thm";

set_goal([], ¬µÇ f· SSupIm‰o (Ç ò‰o f, Ç) = SSupIm‰o (f, Ç)®);
a (REPEAT strip_tac THEN rewrite_tac [ord_ext_thm]
	THEN REPEAT strip_tac
	THEN POP_ASM_T ante_tac
	THEN_TRY FC_T rewrite_tac [ò‰o_fc]
	THEN strip_tac
	THEN ¶_tac ¬È:ordinal®
	THEN REPEAT strip_tac
	);
a (FC_T asm_rewrite_tac [ò‰o_fc]);
val SSupIm‰o_ò‰o_thm = save_pop_thm "SSupIm‰o_ò‰o_thm";

val ord_rec_thm = save_thm("ord_rec_thm",
	rewrite_rule [lt‰o_def] (µ_elim ¬$<‰o® tf_rec_thm2));

set_goal([], ¬µ af· ¶ f· µ x· f x = af (x ò‰o f) x®);
a (rewrite_tac[ò‰o_def, ord_rec_thm]);
val ord_rec_thm2 = save_pop_thm "ord_rec_thm2";

set_goal ([], ¬µ af· ¶ f· µ x· f (CombI x) = af (x ò‰o f) x®);
a (strip_tac);
a (strip_asm_tac (µ_elim ¬af® ord_rec_thm2));
a (¶_tac ¬f® THEN asm_rewrite_tac [get_spec ¬CombI®]);
val ord_rec_thm3 = save_pop_thm "ord_rec_thm3";

set_goal([], ¬µaf· (Ìf x· af (Image‰o (f, x)) x) respects $<‰o®);
a (rewrite_tac [get_spec ¬$respects®] THEN REPEAT strip_tac);
a (LEMMA_T ¬Image‰o (g, x) = Image‰o (h, x)® rewrite_thm_tac);
a (rewrite_tac[ord_ext_thm] THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a (¶_tac ¬È® THEN asm_rewrite_tac[] THEN REPEAT strip_tac);
(* *** Goal "1.1" *** *)
a (POP_ASM_T ante_tac);
a (lemma_tac ¬tc $<‰o È x® THEN1 fc_tac [tc_incr_thm]);
a (ASM_FC_T rewrite_tac []);
(* *** Goal "1.2" *** *)
a (POP_ASM_T ante_tac);
a (lemma_tac ¬tc $<‰o È x® THEN1 fc_tac [tc_incr_thm]);
a (ASM_FC_T rewrite_tac []);
(* *** Goal "2" *** *)
a (¶_tac ¬È® THEN asm_rewrite_tac[] THEN REPEAT strip_tac);
(* *** Goal "2.1" *** *)
a (POP_ASM_T ante_tac);
a (lemma_tac ¬tc $<‰o È x® THEN1 fc_tac [tc_incr_thm]);
a (ASM_FC_T rewrite_tac []);
(* *** Goal "2.2" *** *)
a (POP_ASM_T ante_tac);
a (lemma_tac ¬tc $<‰o È x® THEN1 fc_tac [tc_incr_thm]);
a (ASM_FC_T rewrite_tac []);
val Image‰o_respects_lt‰o = pop_thm ();

set_goal([], ¬µ af· ¶ f· µx· f (CombI x) = af (Image‰o (f, x)) x®);
a (REPEAT strip_tac THEN_TRY rewrite_tac[get_spec ¬CombI®]);
a (¶_tac ¬fix (Ìf x· af (Image‰o (f, x)) x)®);
a (asm_tac Image‰o_respects_lt‰o);
a (asm_tac lt‰o_wf);
a (spec_nth_asm_tac 2 ¬af®);
a (all_fc_tac [get_spec ¬fix®]);
a (swap_nth_asm_concl_tac 1);
a (rewrite_tac[ext_thm]);
a (swap_nth_asm_concl_tac 1);
a (asm_rewrite_tac []);
val Image‰o_recursion_thm = save_pop_thm "Image‰o_recursion_thm";
=TEX
}%ignore

Rather than having specific recursion theorems for definitions involving SupIm or SSupIm, we apply the required domain restriction to the function being defined wherever it is used on the right of the definition.

=SML
force_new_pc "'ordcard-rec1";
add_¶_cd_thms [ord_rec_thm3] "'ordcard-rec1";
=TEX

\subsection{Ordinal Arithmetic}

=SML
declare_infix(400, "+‰o");
=TEX

\ignore{
=SML
push_merge_pcs ["ordcard0", "'ordcard", "'ordcard-rec1"];

set_goal([], ¬¶$+‰o:ordinal ­ ordinal ­ ordinal·
		µÂ Ç· Â +‰o Ç = if Ç = 0‰o then Â else SupIm‰o ($+‰o Â, Ç)®);
a (LEMMA_T ¬¶$+‰o:ordinal ­ ordinal ­ ordinal·
		µÂ Ç· Â +‰o (CombI Ç) = if Ç = 0‰o then Â else SupIm‰o (Ç ò‰o ($+‰o Â), Ç)®
	(accept_tac o (pure_rewrite_rule [get_spec ¬CombI®, SupIm‰o_ò‰o_thm]))
	THEN1 basic_prove_¶_tac);
val plus‰o_consistent = save_cs_¶_thm (pop_thm());

pop_pc();
=TEX
}%ignore

The sum of two ordinals is the strict supremum of the set of ordinals less than the second operand under the function which adds each ordinal to the first operand.

¹HOLCONST
Ü $Û+‰oÝ: ordinal ­ ordinal ­ ordinal
÷üüüüüüüüüüü
Ü µÂ Ç· Â +‰o Ç = if Ç = 0‰o then Â else SupIm‰o ($+‰o Â, Ç)
°

=GFT
Ûplus‰o_0‰oÝ =
	ô µ Â· Â +‰o 0‰o = Â
=TEX

\ignore{
=SML

=IGN
val plus‰o_def = get_spec ¬$+‰o®;

set_goal([], ¬µÂ· Â +‰o 0‰o = Â®);
a (REPEAT µ_tac);
a (once_rewrite_tac [plus‰o_def]);
a (pure_rewrite_tac[ord_ext_thm]);
a (rewrite_tac[]);
val plus‰o_0‰o = save_pop_thm "plus‰o_0‰o";
=SML

val plus‰o_def = get_spec ¬$+‰o®;

set_goal([], ¬µÂ· Â +‰o 0‰o = Â®);
a (REPEAT µ_tac);
a (once_rewrite_tac [plus‰o_def] THEN rewrite_tac[]);
val plus‰o_0‰o = save_pop_thm "plus‰o_0‰o";

=IGN

push_merge_pcs ["ordcard0", "'ordcard", "'ordcard-rec1"];

set_goal([], ¬µÂ Ç· Â +‰o Ç = if Ç = 0‰o then Â else SupIm‰o ($+‰o Â, Ç)®);
a (REPEAT µ_tac);
a (cond_cases_tac ¬Ç = 0‰o® THEN_TRY rewrite_tac[plus‰o_0‰o]);
a (once_rewrite_tac [plus‰o_def]);
a (lemma_tac ¬¶set· set = {È|È <‰o Â ² È <‰o SupIm‰o ($+‰o Â, Ç)}®
	THEN1 prove_¶_tac);
a (lemma_tac ¬¶x· x  SUb‰o set®);
(* *** Goal "1" *** *)
a (¶_tac ¬SupIm‰o ($+‰o Â, Ç)®
		THEN asm_rewrite_tac[]
		THEN REPEAT strip_tac);
(* *** Goal "1.1" *** *)
a (¶_tac ¬0‰o®
		THEN asm_rewrite_tac[plus‰o_0‰o]
		THEN strip_asm_tac (µ_elim ¬Ç:ordinal®
			(pure_rewrite_rule [¼‰o_def] zero‰o_thm))
		THEN asm_rewrite_tac[]
		THEN_TRY all_var_elim_asm_tac);
(* *** Goal "1.2" *** *)
a (¶_tac ¬$"È'"® THEN asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a (rewrite_tac[ord_ext_thm]);
a (all_ufc_¤_tac [lt‰o_SSup‰o]);
a (POP_ASM_T ante_tac THEN asm_rewrite_tac[]);
	THEN strip_tac THEN asm_rewrite_tac[]);

(asm_tac o rewrite_rule[]));
stop;

=IGN

set_goal([], ¬µÁ Â Ç· Á ¼‰o Â ¤ Ç +‰o Á ¼‰o Ç +‰o Â®);
a (REPEAT µ_tac
	THEN ord_induction_tac ¬Ç:ordinal®
	THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a (rewrite_tac[¼‰o_ext_thm, plus‰o_def] THEN REPEAT µ_tac);
a (cond_cases_tac ¬Â = 0‰o®);
a (lemma_tac ¬Á = 0‰o® 

a (once_rewrite_tac[plus‰o_def]);

set_goal([], ¬µÂ Ç È· È <‰o Â +‰o Ç ¤ È <‰o Â ² ¶Ò· Ò <‰o Ç ± È = Â +‰o Ò®);
a (REPEAT µ_tac
	THEN ord_induction_tac ¬È:ordinal®
	THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a (LEMMA_T ¬¶set· set = {Õ | ¶ Ò· Ò <‰o t ± Ò = Â +‰o Õ}®
	(STRIP_THM_THEN asm_tac) THEN1 prove_¶_tac);
a (lemma_tac ¬µv· v  SUb‰o set ¤ t ¼‰o Â +‰o v® 
	THEN1 (asm_rewrite_tac[] THEN REPEAT strip_tac));
(* *** Goal "1.1" *** *)
a (spec_nth_asm_tac 1 ¬v®);
a (spec_nth_asm_tac 1 ¬Â +‰o v®);
a (asm_rewrite_tac[¼‰o_def]);
a (contr_tac THEN strip_asm_tac (list_µ_elim [¬t®, ¬Â +‰o v®] lt‰o_trich));
(* *** Goal "1.2" *** *)
a (var_elim_asm_tac ¬Ò = Â +‰o È®);
a (LEMMA_T ¬Â +‰o È <‰o Â +‰o v® ante_tac
	THEN1 (all_ufc_tac [lt‰o_¼‰o_trans]));
a (rewrite_tac[plus‰o_def]);



a (lemma_tac ¬µv· v  SUb‰o set ´ t ¼‰o Â +‰o v® 
	THEN1 (asm_rewrite_tac[] THEN REPEAT strip_tac));
(* *** Goal "1.1" *** *)
a (spec_nth_asm_tac 1 ¬v®);
a (spec_nth_asm_tac 1 ¬Â +‰o v®);
a (asm_rewrite_tac[¼‰o_def]);
a (contr_tac THEN strip_asm_tac (list_µ_elim [¬t®, ¬Â +‰o v®] lt‰o_trich));
(* *** Goal "1.2" *** *)
a (lemma_tac ¬¶Á· Á  set®
	THEN1 (¶_tac ¬0‰o® THEN asm_rewrite_tac[]));

SSup‰o_lt‰o2;
a (¶_tac ¬SSup‰o set® THEN strip_tac);
(* *** Goal "1.2.1" *** *)



	THEN rewrite_tac[SSup‰o_def]);

a (lemma_tac ¬¶f:ordinal ­ ordinal· µx:ordinal·
	if x <‰o Â ² ³ x <‰o t
	then f x = 0‰o
	else x = Â +‰o (f x)® THEN1 (prove_¶_tac THEN strip_tac));
(* *** Goal "1.1" *** *)
a (cond_cases_tac ¬x' <‰o Â ² ³ x' <‰o t®
	THEN_TRY prove_¶_tac);
a (asm_fc_tac[] THEN_TRY all_fc_tac [lt‰o_trans]);
a (¶_tac ¬Ò® THEN strip_tac);
(* *** Goal "1.2" *** *)
a (¶_tac ¬SSupIm‰o(f, t)®);


a (¶_tac ¬if x <‰o Â ² ³ x <‰o t then 0‰o else Åy:ordinal· x = Â +‰o y®);

a (¶_tac ¬SSupIm‰o((ÌÎ· ÅÕ· Õ <‰o Ç ± Î = Â +‰o Î ² v = 0), t)®
	THEN_TRY asm_rewrite_tac[]);

¶ Ò· Ò <‰o Ç ± u = Â +‰o Ò)
=TEX
}%ignore




\subsection{Defining Inaccessibility}

The significance of this section to the purposes of this work is moot, since the strong axiom of infinity, which implicitly asserts the existence of inaccessible ordinals, does not depend upon an explicit definition.

The purpose of this section is therefore as a kind of check on the formulation of that axiom.
This check could go as far as defining inaccessible and proving the equivalence of the give axiom with a formulation based on the defined concept.
However, to serve that pupose this material would have to come before the axiom, since in the context of that axiom we cannot distinguish between equivalence and entailment of the new formulation by the old.

Co-finality is usually a relation between increasing $Â$ sequences (Â a limit ordinal) and some limit ordinal $Á$.
I don't yet have sequences, so its convenient to give a slightly broader definition.
Instead of increasing sequences I allow the image of any ordinal under a function (which need not be increasing).
At this point I don't actually understand why an increasing sequence is 

Such an image is ``cofinal'' in an ordinal if:

\begin{itemize}
\item the image falls entirely below the ordinal
\item the supremum of the image is that ordinal
\end{itemize}

=SML
declare_infix(400, "CofinalIn‰o");
=TEX

¹HOLCONST
Ü $ÛCofinalIn‰oÝ: ((ordinal ­ ordinal) ¸ ordinal) ­ ordinal ­ BOOL
÷üüüüüüüüüüü
Ü µx Ç· x CofinalIn‰o Ç ¤ Image‰o x € X‰o Ç ± SupIm‰o x = Ç 
°

¹HOLCONST
Ü ÛCf‰oÝ: ordinal ­ ordinal
÷üüüüüüüüüüü
Ü µÂ· Cf‰o Â = Least‰o {Ç | ¶f· (f, Ç) CofinalIn‰o Â}
°

We can now define the notion of regularity, one of the defining properties of inaccessible cardinals.

¹HOLCONST
Ü ÛRegular‰oÝ: ordinal ­ BOOL
÷üüüüüüüüüüü
Ü µÂ· Regular‰o Â ¤ Cf‰o Â = Â
°

¹HOLCONST
Ü ÛSingular‰oÝ: ordinal ­ BOOL
÷üüüüüüüüüüü
Ü µÂ· Singular‰o Â ¤ ³ Regular‰o Â
°

As well as using this in the definition of inaccessibility we want to be able to state that the universe is regular (to get sufficiently generous recursion principles, analogous to global replacement).
The vocabulary above doesn't really help in stating this global principle, but it is simple enough to state directly.
We will come to that later.

To get inaccessibilty we need also to express the notion of a strong limit.

¹HOLCONST
Ü ÛSucc‰oÝ: ordinal ­ ordinal
÷üüüüüüüüüüü
Ü µÂ· Succ‰o Â = Least‰o {Ç | Â <‰o Ç}
°

¹HOLCONST
Ü ÛSuccessor‰oÝ: ordinal ­ BOOL
÷üüüüüüüüüüü
Ü µÂ· Successor‰o Â ¤ ¶Ç· Â = Succ‰o Ç
°

¹HOLCONST
Ü ÛLimit‰oÝ: ordinal ­ BOOL
÷üüüüüüüüüüü
Ü µÂ· Limit‰o Â ¤ 0‰o <‰o Â ± ³ Successor‰o Â
°

¹HOLCONST
Ü Û×‰oÝ: ordinal
÷üüüüüüüüüüü
Ü ×‰o = Least‰o {Â | Limit‰o Â}
°

=GFT
=TEX

\ignore{
=SML
val Succ‰o_def = get_spec ¬Succ‰o®;
val Successor‰o_def = get_spec ¬Successor‰o®;
val Limit‰o_def = get_spec ¬Limit‰o®;
val ×‰o_def = get_spec ¬×‰o®;

=IGN
set_goal([], ¬Limit‰o ×‰o ± µÂ· Limit‰o Â ´ ×‰o ¼‰o Â®);
a (rewrite_tac[×‰o_def]);

=TEX
}%ignore

¹HOLCONST
Ü ÛStrongLimit‰oÝ: ordinal ­ BOOL
÷üüüüüüüüüüü
Ü µÂ· StrongLimit‰o Â ¤ µÇ· Ç <‰o Â ´ ð (X‰o Ç) <‰s X‰o Â
°

=SML
val strong_infinity2 = ¬
µÂ· 	(¶Ç· Â <‰o Ç ±
		Regular‰o Ç ±
		StrongLimit‰o Ç)
    ±
	(µf· (¶Ò· (µÎ· Î <‰o Â ´ f Î <‰o Ò)))
®;
=TEX

\ignore{
=SML
val CofinalIn‰o_def = get_spec ¬$CofinalIn‰o®;
val Cf‰o_def = get_spec ¬Cf‰o®;
val Regular‰o_def = get_spec ¬Regular‰o®;
val StrongLimit‰o_def = get_spec ¬StrongLimit‰o®;

=IGN

set_goal([], strong_infinity2);
a (µ_tac);
a (strip_asm_tac (µ_elim ¬Â® strong_infinity)
	THEN REPEAT strip_tac
	THEN asm_fc_tac[]);
(* *** Goal "1" *** *)
a (strip_asm_tac (µ_elim ¬Â® strong_infinity));
a (¶_tac ¬Ç® THEN asm_rewrite_tac
	[Limit‰o_def, CofinalIn‰o_def, Cf‰o_def,
	Regular‰o_def, StrongLimit‰o_def]);
a (REPEAT strip_tac THEN asm_fc_tac[]);

set_labelled_goal "2";
a (spec_nth_asm_tac 2 ¬f®);
(* *** Goal "2.1" *** *)
a (¶_tac ¬Ò® THEN asm_rewrite_tac[]);
(* *** Goal "2.2" *** *)
a (¶_tac ¬Ò® THEN asm_rewrite_tac[]);

=TEX
}%ignore


The basic idea is to state that every ordinal is less than some (strongly) inaccessible ordinal (also a cardinal), with a little tweak to give, in effect, global replacement  (or its analogue for a theory of ordinals rather than sets).
Here local replacement is the requirement that each ordinal is less than some regular cardinal, global replacement tells us that the universe is regular.
The other requirement is that this regular cardinal is a strong limit, i.e. closed under powerset.
 
To validate this principle I could first prove the principal in the set theory in t023, or alternatively in t041 since the ordinals are further developed there.
That would gives greater confidence in its consistency.
That it is adequate can be testing in use, or by constructing a set theory from this type of ordinals which satisifies the first principle.

However, without further validation I now proceed to establish that it can be used to justify a convenient recursion principle.

The first step in this is to define a couple of functions using our axiom of infinity.

The first is a function which give an infinite ordinal will deliver the least inaccessible ordinal greater than that ordinal, given a finite ordinal it returns $×$.
I will call this $Lio$.

\ignore{
=IGN
set_goal(¶Lio:ordinal ­ ordinal·
µÂ· let Ç = Lio Â in 
    Â < Ç
    ± µÔ· Ô <‰o Ç ´ 
	   ð (X‰o Ô) <‰s X‰o Ç
	± (µf· (µÎ· Î <‰o Ô ´ f Î <‰o Ô)
		´ (¶Ò· Ò <‰o Ç ± (µÎ· Î <‰o Ô ´ f Î <‰o Ò)))
=TEX
}%ignore


¹HOLCONST
Ü ÛG‰oÝ: ordinal ­ ordinal
÷üüüüüüüüüü
Ü µÂ· G‰o Â = Least‰o {Ç | Â <‰o Ç ± ×‰o <‰o Ç
    ± µÔ· Ô <‰o Ç ´ 
	   ð (X‰o Ô) <‰s X‰o Ç
	± (µf· (µÎ· Î <‰o Ô ´ f Î <‰o Ô)
		´ (¶Ò· Ò <‰o Ç ± (µÎ· Î <‰o Ô ´ f Î <‰o Ò)))}
°

=GFT
=TEX

\ignore{
=SML
val G‰o_def = get_spec ¬G‰o®;

list_µ_elim [¬{Ç | Â <‰o Ç ± ×‰o <‰o Ç
    ± µÔ· Ô <‰o Ç ´ 
	   ð (X‰o Ô) <‰s X‰o Ç
	± (µf· (µÎ· Î <‰o Ô ´ f Î <‰o Ô)
		´ (¶Ò· Ò <‰o Ç ± (µÎ· Î <‰o Ô ´ f Î <‰o Ò)))}®] Least‰o_def;

=IGN
set_goal([], ¬µÂ· 

®);


=TEX
}%ignore

\section{CARDINALS}

Its by no means clear that a type of cardinals is necessary for my purposes, so in the first instance the development of this type will be quite limited.
I have put it in just to see whether it proves useful rather than in a firm expectation that it will.
In fact I put in the type of cardinals before I came up with the strong infinity axiom above which does not make use of the cardinals, and my first thought about how the type might be useful was to think it might make possibly a neat strong axiom.
The one I have now is pretty neat, but possibly it might look less of a Kluge if I talked about cardinality using the cardinals rather that by using cardinality comparisons over ProofPower sets.

\subsection{The Type of Cardinals}

One could introduce cardinals in a manner similar to the introduction of ordinals, but we would then have no coupling between the two types.
We want the cardinals to be the initial ordinals, so that a strong axiom of infinity for the ordinals populates the cardinals as well.

With that in mind we need the vocabulary to talk about initial ordinals before we can set up a type of cardinals.

=GFT
Ûlt‰o_€Ý =
	ô µ Â Ç· Ç <‰o Â ´ X‰o Ç € X‰o Â
Ûlt‰o_ Ý =
	ô µ Â Ç· Ç <‰o Â ´ X‰o Ç   X‰o Â
Û¼‰o_€Ý =
	ô µÂ Ç· Ç ¼‰o Â ´ X‰o Ç € X‰o Â
=TEX

\ignore{
=SML
set_goal([], ¬µÂ Ç· Ç <‰o Â ´ X‰o Ç € X‰o Â®);
a (PC_T1 "hol1" rewrite_tac[X‰o_def] THEN REPEAT strip_tac);
a (all_fc_tac[lt‰o_trans]);
val lt‰o_€ = save_pop_thm "lt‰o_€";

set_goal([], ¬µÂ Ç· Ç <‰o Â ´ X‰o Ç   X‰o Â®);
a (PC_T1 "hol1" rewrite_tac[X‰o_def] THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a (all_fc_tac[lt‰o_trans]);
(* *** Goal "2" *** *)
a (¶_tac ¬Ç® THEN asm_rewrite_tac[lt‰o_irrefl]);
val lt‰o_  = save_pop_thm "lt‰o_ ";

set_goal([], ¬µÂ Ç· Ç ¼‰o Â ´ X‰o Ç € X‰o Â®);
a (PC_T1 "hol1" rewrite_tac[X‰o_def, ¼‰o_def] THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a (all_fc_tac[lt‰o_trans]);
(* *** Goal "2" *** *)
a (all_var_elim_asm_tac);
val ¼‰o_€ = save_pop_thm "¼‰o_€";
=TEX
}%ignore

The ordering of ordinals by cardinality is then:

=SML
declare_infix(300, "¼‰o‰c");
=TEX

¹HOLCONST
Ü $Û¼‰o‰cÝ: ordinal ­ ordinal ­ BOOL
÷üüüüüüüüüü
Ü µÂ Ç· Â ¼‰o‰c Ç ¤ X‰o Â ¼‰s X‰o Ç
°

=GFT
Û¼‰o‰c_reflÝ =
	ô µ Â· Â ¼‰o‰c Â
Ûlt‰o_¼‰o‰cÝ =
	ô µ Â Ç· Ç <‰o Â ´ Ç ¼‰o‰c Â
Û¼‰o‰c_transÝ =
	ô µ Â Ç È· Â ¼‰o‰c Ç ± Ç ¼‰o‰c È ´ Â ¼‰o‰c È
Û¼‰o‰c_casesÝ =
	ô µ Â Ç· Â ¼‰o‰c Ç ² Ç ¼‰o‰c Â
=TEX

\ignore{
=SML
val ¼‰o‰c_def = get_spec ¬$¼‰o‰c®;

set_goal([], ¬µÂ· Â ¼‰o‰c Â®);
a (strip_tac THEN rewrite_tac[¼‰o‰c_def, X‰o_def, ¼‰s_refl]);
val ¼‰o‰c_refl = save_pop_thm "¼‰o‰c_refl";

=IGN
set_goal([], ¬µÂ Ç· Â ¼‰o‰c Ç ² Ç ¼‰o‰c Â®);
=SML

set_goal([], ¬µÂ Ç· Ç <‰o Â ´ Ç ¼‰o‰c Â®);
a (rewrite_tac[¼‰o‰c_def] THEN REPEAT strip_tac
	THEN fc_tac [lt‰o_¼‰o]
	THEN fc_tac [¼‰o_€]);
a (POP_ASM_T ante_tac THEN PC_T1 "hol1" rewrite_tac[¼‰s_def]
	THEN REPEAT strip_tac);
a (¶_tac ¬Ìx:'a·x® THEN asm_rewrite_tac[]
	THEN REPEAT strip_tac
	THEN asm_fc_tac[]);
val lt‰o_¼‰o‰c = save_pop_thm "lt‰o_¼‰o‰c";

set_goal([], ¬µÂ Ç È· Â ¼‰o‰c Ç ± Ç ¼‰o‰c È ´ Â ¼‰o‰c È®);
a (rewrite_tac[¼‰o‰c_def] THEN REPEAT strip_tac);
a (all_asm_fc_tac [¼‰s_trans]);
val ¼‰o‰c_trans = save_pop_thm "¼‰o‰c_trans";

set_goal([], ¬µÂ Ç· Â ¼‰o‰c Ç ² Ç ¼‰o‰c Â®);
a (rewrite_tac[¼‰o‰c_def] THEN REPEAT µ_tac);
a (lemma_tac ¬X‰o Ç € X‰o Â ² X‰o Â € X‰o Ç®
	THEN_TRY (FC_T rewrite_tac [€_¼‰s_thm]));
a (PC_T1 "hol1" rewrite_tac[X‰o_def] THEN contr_tac);
a (strip_asm_tac (list_µ_elim [¬x®, ¬Â®] lt‰o_trich));
(* *** Goal "1" *** *)
a (strip_asm_tac (list_µ_elim [¬x'®, ¬Ç®] lt‰o_trich));
a (REPEAT (all_ufc_tac [lt‰o_trans]));
(* *** Goal "1.2" *** *)
a (all_var_elim_asm_tac THEN all_ufc_tac [lt‰o_trans]);
(* *** Goal "2" *** *)
a (all_var_elim_asm_tac THEN all_ufc_tac [lt‰o_trans]);
val ¼‰o‰c_cases = save_pop_thm "¼‰o‰c_cases";
=TEX
}%ignore

=SML
declare_infix(300, "<‰o‰c");
=TEX

¹HOLCONST
Ü $Û<‰o‰cÝ: ordinal ­ ordinal ­ BOOL
÷üüüüüüüüüü
Ü µÂ Ç· Â <‰o‰c Ç ¤ ³ Ç ¼‰o‰c Â
°

=GFT
Û<‰o‰c_irreflÝ =
	ô µ Â· ³ Â <‰o‰c Â
Û¼‰o‰c_³_lt‰o‰cÝ =
	ô µ Â Ç· Â ¼‰o‰c Ç ´ ³ Ç <‰o‰c Â
=TEX

\ignore{
=SML
val ¼‰o_def = get_spec ¬$¼‰o®;
val lt‰o‰c_def = get_spec ¬$<‰o‰c®;

set_goal([], ¬µÂ· ³ Â <‰o‰c Â®);
a (strip_tac THEN rewrite_tac[lt‰o‰c_def, ¼‰o‰c_refl]);
val lt‰o‰c_irrefl = save_pop_thm "lt‰o‰c_irrefl";

set_goal([], ¬µÂ Ç· Â ¼‰o‰c Ç ´ ³ Ç <‰o‰c Â®);
a (rewrite_tac[lt‰o‰c_def] THEN contr_tac);
val ¼‰o‰c_³_lt‰o‰c = save_pop_thm "¼‰o‰c_³_lt‰o‰c";
=TEX
}%ignore

=SML
declare_infix(300, "~‰o‰c");
=TEX

¹HOLCONST
Ü $Û~‰o‰cÝ: ordinal ­ ordinal ­ BOOL
÷üüüüüüüüüü
Ü µÂ Ç· Â ~‰o‰c Ç ¤ Â ¼‰o‰c Ç ± Ç ¼‰o‰c Â
°

=GFT
Û¼‰o‰c_cases2Ý =
	ô µ Â Ç· Â ¼‰o‰c Ç ¤ Â <‰o‰c Ç ² Â ~‰o‰c Ç
Û~‰o‰c_reflÝ =
	ô µ Â· Â ~‰o‰c Â
Ûeq‰o‰c_symÝ =
	ô µ Â Ç· Â ~‰o‰c Ç ´ Ç ~‰o‰c Â
Ûeq‰o‰c_transÝ =
	ô µ Â Ç È· Â ~‰o‰c Ç ± Ç ~‰o‰c È ´ Â ~‰o‰c È
Ûlt‰o‰c_trichÝ =
	ô µ Â Ç· Â <‰o‰c Ç ² Ç <‰o‰c Â ² Â ~‰o‰c Ç
=TEX

\ignore{
=SML
val eq‰o‰c_def = get_spec ¬$~‰o‰c®;

set_goal([], ¬µÂ Ç· Â ¼‰o‰c Ç  ¤ Â <‰o‰c Ç ² Â ~‰o‰c Ç®);
a (strip_tac
	THEN rewrite_tac[eq‰o‰c_def, lt‰o‰c_def]
	THEN contr_tac);
a (strip_asm_tac (all_µ_elim ¼‰o‰c_cases));
val ¼‰o‰c_cases2 = save_pop_thm "¼‰o‰c_cases2";

set_goal([], ¬µÂ· Â ~‰o‰c Â®);
a (strip_tac THEN rewrite_tac[eq‰o‰c_def, ¼‰o‰c_def, X‰o_def, ¼‰s_refl]);
val eq‰o‰c_refl = save_pop_thm "eq‰o‰c_refl";

set_goal([], ¬µÂ Ç· Â ~‰o‰c Ç ´ Ç ~‰o‰c Â®);
a (REPEAT µ_tac
	THEN rewrite_tac[eq‰o‰c_def]
	THEN contr_tac);
val eq‰o‰c_sym = save_pop_thm "eq‰o‰c_sym";

set_goal([], ¬µÂ Ç È· Â ~‰o‰c Ç ± Ç ~‰o‰c È ´ Â ~‰o‰c È®);
a (rewrite_tac[eq‰o‰c_def]
	THEN REPEAT strip_tac
	THEN REPEAT_N 3 (TRY (all_asm_fc_tac[¼‰o‰c_trans])));
val eq‰o‰c_trans  = save_pop_thm "eq‰o‰c_trans";

set_goal([], ¬µÂ Ç· Â <‰o‰c Ç ² Ç <‰o‰c Â ² Â ~‰o‰c Ç®);
a (rewrite_tac[lt‰o‰c_def] THEN contr_tac);
a (all_fc_tac [map_eq_sym_rule eq‰o‰c_def]);
val lt‰o‰c_trich = save_pop_thm "lt‰o‰c_trich";
=TEX
}%ignore

We have to define the notion of initiality.
A initial ordinal is one which is not smaller than or equal in cardinality with any smaller ordinal.

¹HOLCONST
Ü ÛInitialOrdinalÝ: ordinal ­ BOOL
÷üüüüüüüüüüü
Ü µÂ· InitialOrdinal Â ¤ µÇ· Ç <‰o Â ´ Ç <‰o‰c Â
°

Before introducing a type using this predicate we must prove that there exists an initial ordinal, for which the witness is the least ordinal, obtainable using the minimal condition.

=GFT
ÛInitialOrdinal_existsÝ =
	ô ¶ Â· InitialOrdinal Â

ÛInitialOrdinals_existÝ =
	ô µ Â· ¶ Ä· InitialOrdinal Ä ± Ä ~‰o‰c Â

ÛInitialOrdinal_eqÝ =
	ô µ Â Ç· InitialOrdinal Â ± InitialOrdinal Ç ± Â ~‰o‰c Ç ´ Â = Ç
=TEX

\ignore{
=SML
val InitialOrdinal_def = get_spec ¬InitialOrdinal®;

set_goal ([], ¬¶Â· InitialOrdinal Â®);
a (strip_asm_tac (pc_rule1 "hol1" rewrite_rule [] (µ_elim ¬Universe:ordinal ð® lt‰o_min_cond)));
a (¶_tac ¬x® THEN asm_rewrite_tac[InitialOrdinal_def]
	THEN REPEAT strip_tac);
val InitialOrdinal_exists = save_pop_thm "InitialOrdinal_exists";

push_pc "hol1";

set_goal([], ¬µÂ· ¶ Ä· InitialOrdinal Ä ± Ä ~‰o‰c Â®);
a (rewrite_tac[InitialOrdinal_def] THEN strip_tac);
a (strip_asm_tac (µ_elim ¬{È | È ~‰o‰c Â}® lt‰o_min_cond));
(* *** Goal "1" *** *)
a (swap_nth_asm_concl_tac 1 THEN PC_T "hol1" (REPEAT strip_tac));
a (¶_tac ¬Â® THEN PC_T1 "hol1" rewrite_tac[eq‰o‰c_refl]);
(* *** Goal "2" *** *)
a (¶_tac ¬x® THEN REPEAT strip_tac);
a (spec_nth_asm_tac 2 ¬Ç®);
a (swap_nth_asm_concl_tac 1);
a (fc_tac[lt‰o_¼‰o‰c]);
a (fc_tac[¼‰o‰c_def]);
a (fc_tac[¼‰o‰c_cases2]);
a (all_fc_tac [eq‰o‰c_trans]);
val InitialOrdinals_exist = save_pop_thm "InitialOrdinals_exist";

set_goal([], ¬µÂ Ç· InitialOrdinal Â ± InitialOrdinal Ç ± Â ~‰o‰c Ç
	´ Â = Ç®);
a (rewrite_tac[InitialOrdinal_def, eq‰o‰c_def]
	THEN REPEAT strip_tac);
a (fc_tac[¼‰o‰c_³_lt‰o‰c]);
a (spec_nth_asm_tac 6 ¬Ç®);
a (spec_nth_asm_tac 6 ¬Â®);
a (strip_asm_tac (all_µ_elim lt‰o_trich));
val InitialOrdinal_eq = save_pop_thm "InitialOrdinal_eq";

pop_pc ();

=TEX
}%ignore

Now we can introduce a new type represented by the initial ordinals.

=SML
val cardinal_def = new_type_defn(["cardinal"], "cardinal", [], InitialOrdinal_exists);
=TEX

There are various functions between the ordinals and cardinals which may be used in formulating a strong axiom of infinity.
The type definition defines the new type as having the same cardinality as the initial ordinals, and we use this bijection to determine the correspondence between cardinals and their alephs.
The abstraction function would normally be determined only over the alephs, but it will be more useful to have an abstraction function which yields the cardinality of any ordinal.

These two maps can be defined thus:

\ignore{
=SML
val [cardinal_lemma] = fc_rule [type_defn_lemma4] [cardinal_def];

set_merge_pcs ["ordcard0", "'ordcard"];

set_goal([], ¬¶Ord‰c:cardinal ­ ordinal· ¶Card‰o· (µÂ:cardinal· Card‰o(Ord‰c Â) = Â)
	± (µÂ:ordinal· InitialOrdinal Â ¤ Ord‰c (Card‰o Â) = Â)
	± OneOne Ord‰c
	± (µ Â· InitialOrdinal (Ord‰c Â))
	± (µÂ Ç· Â ~‰o‰c Ç ´ Card‰o Â = Card‰o Ç)
®);
a (strip_asm_tac cardinal_lemma);
a (lemma_tac ¬¶g· g = ÌÇ:ordinal· ÅÂ:ordinal· InitialOrdinal Â ± Â ~‰o‰c Ç®
	THEN1 prove_¶_tac);
a (lemma_tac ¬µx· InitialOrdinal (g x)®
	THEN1 rewrite_tac[asm_rule
		¬g = Ì Ç· ÅÂ:ordinal· InitialOrdinal Â ± Â ~‰o‰c Ç®]);
(* *** Goal "1" *** *)
a (strip_tac);
a (Å_tac ¬Å Â· InitialOrdinal Â ± Â ~‰o‰c x®);
a (strip_asm_tac InitialOrdinals_exist);
a (spec_nth_asm_tac 1 ¬x®);
a (¶_tac ¬Ä® THEN asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a (¶_tac ¬rep® THEN ¶_tac ¬Ìx· abs(g x)®
	THEN rewrite_tac[]
	THEN REPEAT strip_tac);
(* *** Goal "2.1" *** *)
a (lemma_tac
	¬g (rep Â) = rep Â®
	THEN_LIST [TRY (rewrite_tac[]), asm_rewrite_tac[]]);
a (rewrite_tac[asm_rule ¬g = (Ì Ç· Å Â· InitialOrdinal Â ± Â ~‰o‰c Ç)®]);
a (Å_tac ¬Å $"Â'"· InitialOrdinal $"Â'" ± $"Â'" ~‰o‰c rep Â®);
(* *** Goal "2.1.1" *** *)
a (¶_tac ¬rep Â® THEN asm_rewrite_tac[eq‰o‰c_refl]);
(* *** Goal "2.1.2" *** *)
a (all_ufc_tac [InitialOrdinal_eq]);
(* *** Goal "2.2" *** *)
a (ALL_ASM_UFC_T rewrite_tac []);
a (rewrite_tac[asm_rule ¬g = (Ì Ç· Å Â· InitialOrdinal Â ± Â ~‰o‰c Ç)®]);
a (Å_tac ¬Å $"Â'"· InitialOrdinal $"Â'" ± $"Â'" ~‰o‰c Â®);
(* *** Goal "2.2.1" *** *)
a (¶_tac ¬Â® THEN asm_rewrite_tac[eq‰o‰c_refl]);
(* *** Goal "2.2.2" *** *)
a (all_ufc_tac [InitialOrdinal_eq]);
(* *** Goal "2.3" *** *)
a (SYM_ASMS_T once_rewrite_tac);
a (asm_rewrite_tac[]);
(* *** Goal "2.4" *** *)
a (asm_rewrite_tac[]);
(* *** Goal "2.5" *** *)
a (LEMMA_T ¬g Â = g Ç® rewrite_thm_tac);
a (lemma_tac ¬µx· g x ~‰o‰c x®
	THEN1 (strip_tac THEN asm_rewrite_tac[]));
(* *** Goal "2.5.1" *** *)
a (Å_tac ¬Å Â· rep (abs Â) = Â ± Â ~‰o‰c x®);
a (strip_asm_tac (µ_elim ¬x® InitialOrdinals_exist));
a (¶_tac ¬Ä® THEN ALL_ASM_UFC_T asm_rewrite_tac []);
(* *** Goal "2.5.2" *** *)
a (lemma_tac ¬g Â ~‰o‰c Â ± g Ç ~‰o‰c Ç® THEN1 rewrite_tac[asm_rule ¬µ x· g x ~‰o‰c x®]);
a (lemma_tac ¬g Ç ~‰o‰c g Â®
	THEN1 (all_ufc_tac[eq‰o‰c_sym]
		THEN REPEAT (all_ufc_tac[eq‰o‰c_trans])));
a (lemma_tac ¬InitialOrdinal (g Â) ± InitialOrdinal (g Ç)®
	THEN1 rewrite_tac[asm_rule ¬µ x· InitialOrdinal (g x)®]);
a (all_ufc_tac [list_µ_elim [¬g Ç®, ¬g Â®] InitialOrdinal_eq]);
a (asm_rewrite_tac[]);
save_cs_¶_thm (pop_thm());
=TEX
}%ignore

¹HOLCONST
Ü ÛOrd‰cÝ: cardinal ­ ordinal;
Ü ÛCard‰oÝ: ordinal ­ cardinal
÷üüüüüüüüüüü
Ü	  (µÂ:cardinal· Card‰o(Ord‰c Â) = Â)
Ü	± (µÂ:ordinal· InitialOrdinal Â ¤ Ord‰c (Card‰o Â) = Â)
Ü	± OneOne Ord‰c
Ü	± (µ Â· InitialOrdinal (Ord‰c Â))
Ü	± (µÂ Ç· Â ~‰o‰c Ç ´ Card‰o Â = Card‰o Ç)
°

\section{INFINITARY SEQUENCES}

Infinitary sequences are functions whose domain is an ordinal.
To make a type of them we will need to use HOL total functions over the type of ordinals, and the domain would then be fixed.
We therefore use an ordered pair consisting of an ordinal (which is the domain) together with a total function over the ordinals.
The values of this function outside the domain are immaterial, but the fact that the function has such values confuses the identity conditions and we must take steps to ensure that the identity conditions come out right.
We could either ensure that in the new type all functions take the same value everywhere outside the domain, or else we could use an equivalence class of functions which take the same values over the domain.

I don't know which of these two would be simplest; I shall plump for the first since it is more familiar to me.

The following predicate determines the representatives of infinitary sequences.

¹HOLCONST
Ü ÛISeqRepÝ: ordinal ¸ (ordinal ­ 'a) ­ BOOL
÷üüüüüüüüüüü
Ü µp· ISeqRep p ¤ µor· ³ or <‰o Fst p ´ Snd p or = Åx·T
°

\ignore{
=SML
val ISeqRep_def = get_spec ¬ISeqRep®;

set_goal([], ¬¶isr:ordinal ¸ (ordinal ­ 'a)· ISeqRep isr®);
a (¶_tac ¬((Åx:ordinal·T), Ìor· Åx:'a·T)® THEN rewrite_tac[ISeqRep_def]);
val ISeqRep_nonempty_thm = pop_thm();

val iseq_def = new_type_defn(["iseq"], "iseq", ["'a"], ISeqRep_nonempty_thm);

val [iseq_lemma] = fc_rule [type_defn_lemma4] [iseq_def];

set_goal([], ¬¶ MkISeq: ordinal ¸ (ordinal ­ 'a) ­ 'a iseq;
	DestISeq: 'a iseq ­ ordinal ¸ (ordinal ­ 'a)·
	(µÂ Ç· DestISeq Â = DestISeq Ç ´ Â = Ç) 
 ±	(µÂ· ISeqRep (DestISeq Â))
 ±	(µÂ· MkISeq (DestISeq Â) = Â)
 ±      (µp· ISeqRep p ´ DestISeq(MkISeq p) = p)®);
a (strip_asm_tac iseq_lemma);
a (DROP_ASM_T ¬OneOne rep® (asm_tac o (rewrite_rule [get_spec ¬OneOne®])));
a (¶_tac ¬abs® THEN ¶_tac ¬rep® THEN asm_rewrite_tac[]);
save_cs_¶_thm (pop_thm());
=TEX
}%ignore

We now define destructor/constructor operations over these sequences.

¹HOLCONST
Ü ÛMkISeqÝ: ordinal ¸ (ordinal ­ 'a) ­ 'a iseq;
Ü ÛDestISeqÝ: 'a iseq ­ ordinal ¸ (ordinal ­ 'a)
÷üüüüüüüüüüü
Ü	(µÂ Ç· DestISeq Â = DestISeq Ç ´ Â = Ç) 
 ±	(µÂ· ISeqRep (DestISeq Â))
 ±	(µÂ· MkISeq (DestISeq Â) = Â)
 ±      (µp· ISeqRep p ´ DestISeq(MkISeq p) = p)
°

¹HOLCONST
Ü ÛLength‰i‰sÝ: 'a iseq ­ ordinal
÷üüüüüüüüüüü
Ü	µis· Length‰i‰s is = Fst (DestISeq is) 
°

¹HOLCONST
Ü ÛElems‰i‰sÝ: 'a iseq ­ 'a ð
÷üüüüüüüüüüü
Ü	µis· Elems‰i‰s is = {e | ¶Â· Â <‰o Fst (DestISeq is) ± e = Snd (DestISeq is) Â}
°

\section{INFINITARY TREES}

An infinitary tree is to be represented by a partial function from sequences of ordinals to some type of labels.
The sequences are the coordinates of nodes in the tree, and the labels label each node.
There is a well-formedness condition which ensures that the set of coordinates of branches from any node is an initial segment of the ordinals.

¹HOLCONST
Ü ÛITreeRepÝ: (ordinal LIST ­ 'a + ONE) ­ BOOL
÷üüüüüüüüüüü
Ü µf· ITreeRep f ¤
Ü	µl:ordinal LIST· ¶Â· {Ç | IsL (f (l @ [Ç]))} = X‰o Â
°

=GFT
ÛiTree_defÝ = ô ¶ f· TypeDefn ITreeRep f
=TEX

\ignore{
=SML
val ITreeRep_def = get_spec ¬ITreeRep®;

set_goal([], ¬¶itr: ordinal LIST ­ 'a + ONE· ITreeRep itr®);
a (¶_tac ¬(Ìx· InR One): ordinal LIST ­ 'a + ONE®);
a (rewrite_tac[ITreeRep_def]);
a (strip_asm_tac (µ_elim ¬{x:ordinal|T}® lt‰o_min_cond));
(* *** Goal "1" *** *)
a (POP_ASM_T ante_tac THEN PC_T1 "hol1" rewrite_tac[]);
(* *** Goal "2" *** *)
a (¶_tac ¬x® THEN POP_ASM_T ante_tac
	THEN PC_T1 "hol1" rewrite_tac[] THEN strip_tac);
a (PC_T1 "hol1" asm_rewrite_tac[X‰o_def]);
val iTree_exists = pop_thm();

val iTree_def = new_type_defn(["iTree"], "iTree", ["'a"], iTree_exists);
=TEX
}%ignore

We now define a constructor/destructor pair for this new type of object.

=GFT

=TEX

\ignore{
=IGN
val [iTree_lemma] = fc_rule [type_defn_lemma4] [iTree_def];

set_goal([], ¬¶	(MkiTree:'a ¸ ('a iTree)iseq ­ 'a iTree)
		(DestiTree:'a iTree ­ 'a ¸ ('a iTree)iseq)· 
	(µt· MkiTree (DestiTree t) = t)
	± T®);
a (strip_asm_tac (iTree_lemma));
a (¶_tac ¬abs® THEN ¶_tac ¬rep® THEN asm_rewrite_tac[]);



=TEX
}%ignore




\ignore{

\section{Graphs}

[I played with this idea a little but it goes beyond my present needs and involves some extra difficulty so I have shelved it pending stronger motivation.]

There may be no point in developing the Trees because it looks like Graphs would be more general an no less easily applicable to the kinds of problem for which one would have used Trees.

Not sure about that, so a bit of exploration is called for.

Graphs could be done in a manner closely similar to the Trees, using ordinals and infinitary sequences, and requiring that the children of a node are indexed by an initial segment of the ordinals.
Its not obvious that this is better than allowing the children to be any indexed set, in which case the construction becomes independent of the ordinals and ordinals need only be introduced where the specific application demands it.

So lets consider the notion of graph independently of the ordinals, but in such a way that the graphs are not assumed to be finitary.

A graph will be a collection of nodes (not necessarily a type) and a function which takes each node to a label (of some type) and an indexed collection of children.
That sounds like three type variables, do we really want that many?

Its not really my present aim to do something independent of the ordinals.
I am really interested here in whether the kind of thing which is done above for trees using ordinals would be as well generalised to graphs.
So here is a type of graphs in which the nodes are represented by ordinals and the children of a node must be a (possibly infinite) sequence.

The essential information in a graph is the mapping from nodes to label and sequences (which is very similar to the signature for the trees).
So we have to define when two such mappings are isomorphic.

Lets use a type abbreviation here:

 =SML
declare_type_abbrev("IG", ["'a"], ”ordinal LIST ­ ONE + 'a + ordinal LIST®);
 =TEX

The first ordinal is the "top" of the graph, and the extent of the graph is disovered by chasing through the graph.
The function must take a default value everywhere not in this reachable extent and the choice of ordinals for nodes must comply with a natural ordering of the paths throught the graph (it must be the least of the ordinals corresponding to paths which reach that node).
This means that when graphs are distroyed or created they must be renumbered, so it might be better to use functions over coordinate lists, which gets us closer to the tree representation.

There is a well-formedness condition on these (this one is not yet complete):

 ¹HOLCONST
Ü ÛIGraphRepÝ: 'a IG ­ BOOL
÷üüüüüüüüüüü
Ü µf· IGraphRep f ¤
Ü	µl:ordinal LIST· ¶Â· {Ç | IsR (f (l @ [Ç]))} = X‰o Â
 °

}%ignore

\subsubsection{Proof Context}

=SML
add_pc_thms "'ordcard" ([]);
add_rw_thms [] "'ordcard";
add_sc_thms [] "'ordcard";

set_merge_pcs ["basic_hol", "'ordcard"];
commit_pc "'ordcard";
=TEX

\subsection{Closing}

=IGN
val rewrite_thms = ref ([]:THM list);

merge_pcs ["rbjmisc", "'ordcard"] "ordcard";
commit_pc "ordcard";
=TEX

\appendix

{\raggedright
\bibliographystyle{fmu}
\bibliography{rbj,fmu}
} %\raggedright

{\let\Section\section
\newcounter{ThyNum}
\def\section#1{\Section{#1}
\addtocounter{ThyNum}{1}\label{Theory\arabic{ThyNum}}}
\include{ordcard0.th}
\def\section#1{\Section{#1}
\addtocounter{ThyNum}{1}\label{Theory\arabic{ThyNum}}}
\include{ordcard.th}
}%\let

\twocolumn[\section{INDEX}\label{index}]
{\small\printindex}

\end{document}
