=IGN
val _ =
	let open ReaderWriterSupport.PrettyNames;
	in add_new_symbols [ (["identeq"], Value "\233", Simple) ]
end;
=TEX

\def\rbjidtADHdoc{$$Id: t037.doc,v 1.6 2010/07/20 18:57:23 rbj Exp $$}

I will endeavour to follow the structure of Grice's paper \emph{Vacuous names}\cite{griceVN, quineWO}.
However, the method employed for the formal analysis, which is called ``shallow embedding'', is essentially semantic, and involves addressing semantic fundamentals before finding manageable syntactic presentations, and we therefore find it necessary to address key aspects of the semantics before considering the details of syntactic derivation.

\subsection{Background}

Grice's deliberations about Vacuous Names may be understood primarily against those who have supposed or desired a significant difference between formal logics and the logic of ordinary discourse, by one who felt that the differences are, or need be, modest.
In some of his writings. for example in the ``Retrospective Epilogue'' in \emph{Sudies in the Way of Words}\cite{grice89}, Grice describes two camps, ``Modernists'' and ``Neo-traditionalists'', the former making more and the latter less of the distinctions between formal and ordinary logic.

Elsewhere in Grice's philosophy issues such as the relationship between the logical connectives and their ordinary language counterparts is discussed.
Here we are concerned with the problem of referring expressions lacking a referent.

The modern discussion of this problem begins with Russell \cite{russell1956,russellOD}, who sought formal languages for mathematics which were more precise and more transparent in their logical structure than is ordinary language.

There are two aspects of the problems here at stake which are separable.
One concerns logic and language, how we talk and reason using words or phrases which do not or might not refer to any existent entity.
The second is the metaphysical question of what exists.
Russell's most important work in this area arose from his making a transition away from a lavish Meinongian ontology in which there are different kinds or grades of existence, to the adoption of Occam's razor wherever possible, leading to a spartan ontology.
Key to this is the acceptance that some referring phrases fail to refer, and Russell's principle contribution here is in his theory of descriptions \cite{russell1956,russellOD}.

Russell's theory treats definite and indefinite descriptions as ``incomplete symbols'', which contribute to the meaning of the sentence as a whole even if they fail to refer.
Proper names are then eliminated in favour of descriptions.

Grice's principle aim is to resurrect the conception of names as references, rather than as surrogates for descriptions.
He wants to do this without being forced to regard names of non-existent entities such as Pegasus as yielding sentences which are neither true nor false.
This he achieves by allowing that names which do no designate nevertheless refer to some kind of entity which he calls its correlate, and by the rule that predications to non-designating names are to yield falsehoods.

Grice's Vacuous names may be seen in the first instance as a reaction against Russell's theory of descriptions, the principle aim b

\subsection{Preliminary Formalities}

Just in case I need multiple incompatible accounts I have a ``top level'' theory under which all other gricean theories will be placed and in which common aspects can be placed.

=SML
open_theory "rbjmisc";
force_new_theory "grice";
=TEX

\ignore{
=SML
force_new_pc Û"'grice"Ý;
merge_pcs ["'savedthm_cs_¶_proof"] "'grice";
set_merge_pcs ["rbjmisc", "'grice"];
=TEX
}%ignore

\section{The Problem}\label{G1}

Grice uses several lists in his presentation.
To simplify unambiguous reference I have prefixed some of the numbering schemes with capital letters.

Our starting point is a list of eight \emph{inclinations} supplied by Grice and summarised here:

\begin{itemize}\label{inclinations}\index{inclinations}
\item[I1] That individual constants be admitted.
\item[I2] Note that names are sometimes ``vacuous''
\item[I3] Thence that a constant might lack a designatum.
\item[I4] That excluded middle and bivalence nevertheless remain unqualified.
\item[I5] That a claim about (predication to) a non-designating constant be false and its negation true.
\item[I6] That no unusual constraints on ``U.I.'' \footnote{Universal Instantiation} and ``E.G.'' \footnote{Existential Generalisation} be introduced.
\item[I7] That the law of identity (in the form $µx· x=x$) be a theorem\footnote{Which seems to suggest that identity is not a predicate.}.
\item[I8] That derivability implies entailment.\footnote{i.e. that the system be sound!}
\end{itemize}

In relation to these Grice points out two \emph{difficulties} as follows:

\begin{itemize}\label{difficulties}\index{difficulties}
\item[(a)] I2, I3 and I7 between them seem prima facie to enable proofs of the existence of non-existent entities (e.g. ``Pegasus exists'').

\item[(b)] I5 and I6 would if gratified permit us to infer that there exists something which does not fly from the premise that Pegasus does not exist.

\end{itemize}

He then lists five possible \emph{resolutions} the difficulties:

\begin{itemize}\label{resolutions}\index{resolutions}
\item[R1] To resist I3 and insists that constants have a designatum.
\item[R2] Resisting I4 and I5, insist that a predication to a non designating term and their negations lack a truth value. 
\item[R3] Resist I1 and do without individual constants.
\item[R4] Resist I2 by insisting that all constants have a desgnatum, which might perhaps ``be'' without existing.
\item[R5] Resist I6 by adding requirements on existential generalisation that the relevant constant be shown to designate.
\item[R6] Resist I8, allowing that the deductive system be not strictly sound, but only so subject to the constants used as in 6 designating.
\end{itemize}

Grice does not discuss any of these alternatives, but instead proposes to attempt to square the circle by devising a system which satisfies all these (apparently) incompatible inclinations.

\section{System Q: Objectives}

Grice now proposes a first order predicate calculus meeting two particular objectives, spelt out in five points of further detail.

\begin{itemize}\label{objectives}\index{objectives}
\item[(i)] That a sentence such as ``Pegasus does not fly'' be capable of rendition in two distinct ways one of which will be true and the other false in the case that Peagasus does not exist. 
These correpond to disambiguations of the logical structure of the sentence either as predicating non-flying or denying a predication as flying.
\item[(ii)] That in either case the inference from ``Pegasus does not fly'' to ``there is something which does not fly'' is to be admitted.
\end{itemize}

\begin{itemize}\label{objectivesdetailed}\index{objectives!detailed}
\item[O1] U.I. and E.G. are acceptable without special side conditions.
\item[O2] Some sentences involving non-denoting constants will be true and provable.
\item[O3] It will be formally decidable whether a sentence depends for its truth on whether some constant designates.
\item[O4] It will be possible to find in Q representation of sentences such as ``Pegasus exists''.
\item[O5] There will be an extension of Q in which identity is represented.\footnote{No discussion here of whether identity is a predicate.}
\end{itemize}

\section{Scope}

A part of the novelty and difficulty in system Q lies in its special provisions for controlling the ``scope'' of names.

The use of the word scope in this context is distinct from its more common usage (at least in mathematical logic and computer science) in which the (or a) scope of a name (variable or constant) is a syntactic region within which it may be used with the same sense (as opposed to uses of the same name for entirely distinct purposes as may appear in different scopes of the name).

In this case the relevant ambiguity of scope is not a region of significance of the name, but the extent of some predicate applied to the name.
Thus in the example used by Grice, there is an ambiguity in the sentence ``Pegasus does not fly'' about the logical structure of the sentence which leaves doubt about what predicate is being applied to Pegasus.
We may regard the sentences as predicating ``x does not fly'' of Pegasus, or we may be denying that the predicate ``flies'' applies to Pegasus.
The question is whether the negation is part of the predicate or is applied to the result of the predication.

In System Q Grice provides a predicate logic in which numerical subscripts may be used to disambiguate the predications which are taking place.
Unfortunately, this notation, like the dot notation in Principia Mathematica is not as readable as the more usual use of brackets for disambiguating scope.
Furthermore, this aspect of the syntax would be hard to replicate by the methods we propose to adopt, which are intended to permit a lightweight analysis of semantic issues and their connection with the validity of sentences and the soundness of derivations.

In our analysis we will therefore provide for the desired control over predication by the use of Church's lambda notation.
We expect that our syntax will be readily related to that of System Q, but since the system we formalise is at least syntactically distinct we will call it system C\footnote{This in homage to Rudolf Carnap, Q having been chosen by Grice in homage to Quine, and G having been chosen by Myro\cite{grice86a,myroIT} in homage to Grice.}.

System C is obtained by conservative extension to HOL, which is a version of higher order logic derived directly from Church's Simple Theory of Types \cite{church40}. distinctive for its very slender logical core, achieved by building the logical system from the simply typed lambda calculus.
In this logical system boolean valued functions serve for predication, and the ideas of Grice on vacuous names are realised principally by defining a different kind of predication.
To minimise confusion, the word predicate will only be used when Grice's notion of predication is intended, otherwise propositional or boolean valued function will be used.


The use of lambda notation for making explicit the predicate to be applied may be illustrated simply using Grice's Pegasus example.
We adopt a special notation for Grice's new kind of predication which will be an infix subscript g ``$g$'', so the application of the predicate ``$Flies$'' to the term ``$Pegasus$'' will be written ``%
=INLINEFT
Flies g Pegasus
=TEX
''.

The subscript g is used just for the special kind of predication in which the object may possibly not exist, we still have the old fashioned kind which will be used in the lambda calculus possibly in defining complex predicates for application in the new manner.

The two variants of ``Pegasus does not fly'' are then expressed as:

\begin{centering}
``%
=INLINEFT
³ (Flies g Pegasus)
=TEX
\end{centering}
''

and

\begin{centering}
``%
=INLINEFT
(Ìx· ³ Flies x) g Pegasus
=TEX
''.
\end{centering}

In the first case the predicate applied to Pegasus is $¬Flies®$, in the second case it is $¬Ìx· ³ Flies\ x®$ (which is a negation of Flies).

This technique makes it possible to examine the semantic aspects of System Q using formal machine assisted deductive reasoning, while avoiding the special intricacies of formalising Grice's special syntax.
Whether this pays off in terms of perspicuity and penetration in the analysis remains to be seen.

We will therefore offer no further discussion of Grices notational devices for scoping at this point, but may consider later how much may have been lost by this approach.

At this stage I am looking at two alternatives for the underpining semantics, and the following two section work through these two alternatives.
In each case, we are devising a ``shallow embedding'' of something close to Grice's System Q in {\Product} HOL.
These embedded aproximations to System Q are called System C (in homage to Rudolf Carnap) and System S (a nod to Speranza).

\subsection{Semantic Domains}

Grice goes on from his discussions of scope to the presentation of the remaining aspects of the syntax, notably of the various aspects of the deductive system.

We will track this discussion of inference in a semantic way, demonstrating the semantic principles which ensure the soundness of the deductive system presented in a manner which makes reasonably clear the relationship between the two.
This amounts to a semantic embedding into HOL of a system which is intended to be semantically parallel to system Q, though not syntactically quite the same.

To do this we must first provide some basic definitions on which the semantics is based, and before doing that I must explain part of the method of semantic embedding which might seem to, but does not in fact, prejudice one of the principle issues at stake.
That is that the embedding consists in a development of a semantics which is purely denotational, i.e. in which every expression has a denotatum.
These denotation need not be what one would naturally suppose the reference of an expression to be, they may be purely abstract surrogates which suffice to describe the truth conditions of the language.
So the way we model a language in which term expressions may not denote, is by taking the range of things which they might possibly denote, and adding one or more extra items which are values which they are give to indicate that they have no denotation.

\subsubsection{Interpretations}

Grice's definition of an interpretation of Q (VIII A of \cite{griceVN}) is ambiguous in what it says about the domain of an interpretation.
The domain is a set of correlates, some of which may be unit sets the element of which is a designatum.
Grice tells us that there need not be any such unit sets, but does not say explicitly that there may be no other correlates.
He does tell us that he has in mind that there will be exactly one non-designating correlate, the empty set, but he does not place this as a requirement, so the significance of his having this in mind is unclear.

There are three possibilities concerning the number of non-designating correlates in an interpretation, that there are none, exactly one, or more than one.
In relation to these there are a number of possible positions in relation to the definition of an interpretation, the most obvious are:

\begin{enumerate}
\item no constraint
\item there must be at least one
\item there must be exactly one
\end{enumerate}

Of course there may be more, but I propose to discuss just these three.

From a literal reading of Grice in this section I would take the first.
However, from the fact that he explicitly allows there to be no designata but does not explicitly say this for non-designating correlates, we might infer that he intends  but does not state that there will be at least one non-designating correlate.
Alternatively we might take the case he had in mind more presciptively and work with item 3.

These are significant semantically, of course.

Allowing interpretations with no designata will create problems with descriptions if these were to be introduced into Q, for one would then have no correlate available for a non-designating descriptions.
It also affects a matter which Grice later discusses, which is whether certain existential claims are valid, notably the claim that there is something which does not exist.
This (or something similar
=INLINEFT
``¶x4· ³3 F1 x2''
=TEX
, VIII B p137) Grice later claims to be valid, and this is evidence against interpretation 1 in favour of 2 or 3.

Item 2, though the one perhaps preferred by Grice, has the disadvantage that all non-designating terms have the same correlate, and will therefore be equal in a sense of equality which satisfies the universal law of reflexivity of identity.
Do we want Pegasus and Sherlock Holmes to be identical?

Nevertheless, in our shallow embedding of Q we will adopt 2, for in addition to its being preferred by Grice in some sense, and its confirming Grice's belief in the validity of the cited existentials, it allows a simpler and more transparent shallow embedding than either of the others.
\emph{[fuller explanation to be supplied]}

First let us give a name for the domain of discourse of an interpretation of the language $Q$.
We will suppose this to be a ``type'' in HOL, but will leave open the type by using a type variable.
To serve as denotions for terms in system $G_{HP}$ we use a disjoint union of two types, the first of which is the type of those things which do exist and the second is atype of surrogates for those things which do not exist.
We use \emph{V} for Value.

\section{System C}

A new theory is needed which I will call ``sysc'' which is created here:

=SML
open_theory "grice";
force_new_theory "sysc";
set_pc "rbjmisc";
=TEX

Grice introduces a special notion of interpretation in terms of which to give the semantics of Q.
An interpretation has a domain which is a set of correlates, some of which are unit sets, in which case the member of that unit set is called a designatum.
For uniformity type we assume that all correlates are sets of sets.

We allow the domain of an interpretation to be any type and for some element of that type to be identified as THE non-designating element.

¹HOLCONST
Ü ÛâÝ: 'a 
÷üüüüüü
Ü T
°

We can then use inequality with $â$ as the property of being a designatum.
The structure of these interpretations is isomorphic to that of Grice's preferred notion of interpretation, even though we do not use unit sets for correlates of designating constants.

We may use HOL constants of appropriate type for Q constants and predicates, and HOL variables for Q variables, and the consequence should be that the theorems provable in HOL should be just those which are valid in Q.

This is done by using T and F instead of Corr(1) and Corr(0) respectively.

Now we define our special kind of predication.
This is done by introducing a subscript g as a copula.
The subscript is by itself to be used as an infix copula, it doesn't actually subscript anything, except the operation of applying a propositional function (which would otherwise be implicit in juxtaposition of the function and its subject.

=SML
declare_infix (400, "g");
=TEX

¹HOLCONST
Ü $g: ('a ­ BOOL) ­ 'a ­ BOOL
÷üüüüüü
Ü µ p t· p g t ¤ if t = â then F else p t
°

The definition says, if the term denotes then apply the predicate to the value denoted, otherwise the result of the predication is F (false).

Note that this will not work for relations, we would have to define a separate similar predicator for each arity of relation in use.

Here is the copula for applying a 2-ary relation.

=SML
declare_infix (400, "g2");
=TEX

¹HOLCONST
Ü $g2: ('a ¸ 'b ­ BOOL) ­ ('a ¸ 'b) ­ BOOL
÷üüüüüü
Ü µ p t· p g2 t ¤ if Fst t = â ² Snd t = â then F else p t
°

\ignore{
=SML
val g_def = get_spec ¬$g®;
val g2_def = get_spec ¬$g2®;
=TEX
}%ignore

Now let's introduce Pegasus.
The ``definition'' just says that Pegasus is the non-denoting value.

¹HOLCONST
Ü ÛPegasusÝ : 'a
÷üüüüüü
Ü Pegasus = â
°

And the predicate \emph{Flies}.
Note that the predicates apply only to real desigata under the normal HOL application, its only under our special predication that they become applicatble to possibly non denoting values.

¹HOLCONST
Ü ÛFliesÝ : 'a ­ BOOL
÷üüüüüü
Ü T
°

We can now prove in HOL the elementary facts we know about Pegasus flying, yielding the following theorems:

=GFT
ÛPegasus_lemma_1Ý =
	ô Flies g Pegasus ¤ F

ÛPegasus_lemma_2Ý =
	ô (Ì x· ³ Flies x) g Pegasus = F

ÛPegasus_lemma_3Ý =
	ô ³ Flies g Pegasus

ÛPegasus_lemma_4Ý =
	ô ³ (Ì x· ³ Flies x) g Pegasus
=TEX

\ignore{
=SML
val g_def = get_spec ¬$g®;
val Pegasus_def = get_spec ¬Pegasus®;
val Flies_def = get_spec ¬Flies®;

set_goal([], ¬Flies g Pegasus ¤ F®);
a (rewrite_tac [g_def, Pegasus_def]);
val Pegasus_lemma_1 = save_pop_thm "Pegasus_lemma_1";

set_goal([], ¬(Ìx· ³ Flies x) g Pegasus ¤ F®);
a (rewrite_tac [g_def, Pegasus_def]);
val Pegasus_lemma_2 = save_pop_thm "Pegasus_lemma_2";

set_goal([], ¬³ Flies g Pegasus®);
a (rewrite_tac [g_def, Pegasus_def]);
val Pegasus_lemma_3 = save_pop_thm "Pegasus_lemma_3";

set_goal([], ¬³ (Ìx· ³ Flies x) g Pegasus®);
a (rewrite_tac [g_def, Pegasus_def]);
val Pegasus_lemma_4 = save_pop_thm "Pegasus_lemma_4";
=TEX
}%ignore

In case you may doubt the neutrality of our use of lambda expressions, we show here that they are inessential to this approach, and can be dispensed with in favour of explict definitions of the predicates required.
Thus we may instead define a predicate which is the denial of \emph{Flies}:

¹HOLCONST
Ü ÛDoesnt_FlyÝ : 'a ­ BOOL
÷üüüüüü
Ü µx· Doesnt_Fly x ¤ ³ Flies x
°

We can then prove the slightly reworded:

=GFT
ÛPegasus_lemma_5Ý = ô Doesnt_Fly g Pegasus ¤ F
=TEX

the proof of which need not mention the predicate, since it suffices to know that the subject does not exist.

\ignore{
=SML
set_goal([], ¬Doesnt_Fly g Pegasus ¤ F®);
a (rewrite_tac [g_def, Pegasus_def]);
val Pegasus_lemma_5 = save_pop_thm "Pegasus_lemma_5";
=TEX
}%ignore

This general claim can be expressed in HOL and proven.
To make it read sensibly however, it is best for us to define the relevant notion of existence.

¹HOLCONST
Ü ÛExistsÝ : 'a ­ BOOL
÷üüüüüü
Ü µx· Exists x ¤ T
°

The definition looks a bit bizarre and works for just the same reason that we do not need to know the predicate to know that predication to a non-existent will be false.
This predicate will always be true, unless it is applied to a term which fails to denote.
So we satisfy another of Grice's desiderata, that the non-existence of Pegasus can be stated.

But first a more general result:

=GFT
ÛExists_lemma_1Ý =
	ô µ P x· ³ Exists g x ´ ³ P g x
=TEX

\ignore{
=SML
val Exists_def = get_spec ¬Exists®;

set_goal([], ¬µP x· ³ (Exists g x) ´ ³ (P g x)®);
a (REPEAT µ_tac THEN rewrite_tac [g_def, Exists_def]
	THEN REPEAT strip_tac);
val Exists_lemma_1 = save_pop_thm "Exists_lemma_1";
=TEX
}%ignore

Desideratum A8 is satisfied by the standard quantifiers in HOL.

=GFT
Û¶_lemma_1Ý = 
	ô µ P· P g Pegasus ´ (¶ x· P g x)

Ûµ_lemma_1Ý =
	ô µ P· (µ x· P g x) ´ P g Pegasus
=TEX

\ignore{
=SML
set_goal([], ¬µP:'a ­ BOOL· P g (Pegasus:'a) ´ ¶x:'a· P g x®);
a (REPEAT strip_tac);
a (¶_tac ¬Pegasus®);
a (asm_rewrite_tac []);
val ¶_lemma_1 = save_pop_thm "¶_lemma_1";

set_goal([], ¬µP· (µx· P g x) ´ P g Pegasus®);
a (REPEAT strip_tac);
a (asm_rewrite_tac []);
val µ_lemma_1 = save_pop_thm "µ_lemma_1";
=TEX
}%ignore


\ignore{
=SML
force_new_pc "'ghp1";
merge_pcs ["'savedthm_cs_¶_proof"] "'ghp1";
set_merge_pcs ["rbjmisc", "'ghp1"];
=TEX
}%ignore

\subsection{IVB-3 Inference-Rules}

Since we are working with a semantic embedding rather than a syntactic meta-theory we cannot prove results about derivations and instead present proofs about the semantics which show that the required inference rules would be sound.

To do this we adopt a notation for expressing entailment in C in a manner parallel to the presentation of the natural deduction system of Q

=SML
declare_infix(4, "");
=TEX

¹HOLCONST
Ü $ : BOOL LIST ­ BOOL ­ BOOL
÷üüüüüü
Ü µal c· (al  c) ¤ (µL al) ´ c
°

In the following theorems which capture the content of Grices rules for Q as theorems of C, the variables Æ, Ù, Ú... range over formulae (boolean terms) and , , ... over lists (finite sequences) of formulae.
$P$ ranges over propositional functions, values whose types are instances of 'a ­ BOOL® (in which $'a$ is a type variable). 
The notation ``[Æ; Ù; ...]'' is an explicit list formation (``[Æ]'' being a single element list) and the symbol ``$ë$'' is the concatenation operator over lists.

In general the rules of Q can be formulated as theorems of C because C is a higher order logic, and can quantify over predicates.
This means that where substitution is involved in a rule, this is captured as a theorem by the use of a variable as a predicate applied to a variable as an argument.
When such a theorem is instantiated using a lambda expression as the predicate, the substitution into the expression will be achieved by beta-reduction.

=GFT
ÛASSÝ =	ô µ Æ· [Æ]  Æ
ÛRAAÝ =	ô µÆ Ù Ú · ([Æ] ë   Ù ± ³Ù) ´ (  ³Æ)
ÛDNÝ =	ô µ Æ· [³ ³ Æ]  Æ
Û±IÝ =		ô µ Æ Ù· [Æ; Ù]  Æ ± Ù
Û±EÝ =	ô µ Æ Ù· ([Æ ± Ù]  Æ) ± ([Æ ± Ù]  Ù)
Û²IÝ =		ô µ Æ Ù· ([Æ]  Æ ² Ù) ± ([Æ]  Ù ² Æ)
Û²EÝ =	ô µ Æ Ù Ú   · ([Æ] ë   Ú) ± ([Ù] ë   Ú) ± (  Æ ² Ù)
			´ ( ë  ë   Ú)
ÛCPÝ =	ô µ Æ Ù · ([Æ] ë   Ù) ´ (  Æ ´ Ù)
ÛMPPÝ =	ô µ Æ Ù· [Æ ´ Ù; Æ]  Ù
ÛµIÝ =		ô µ  P· (µ x·   P x) ´ (  (µ x· P x))
ÛµEÝ =	ô µ  P c· (  (µ x· P x)) ´ (  P c)
Û¶IÝ =		ô µ  P x· (  P x) ´ (  (¶ x· P x))
Û¶EÝ =	ô µ  P c x· (P x  ) ´ (¶ x· P x  )
=TEX

\ignore{
=SML
val _def = get_spec ¬$®;

set_goal([], ¬µÆ· [Æ]  Æ®);
a (rewrite_tac [_def] THEN REPEAT strip_tac);
val ASS = save_pop_thm "ASS";

set_goal([], ¬µÆ Ù Ú · ([Æ]ë   Ù ± ³Ù) ´ (  ³Æ)®);
a (rewrite_tac [_def, append_def, µL_def, fold_def] THEN REPEAT strip_tac);
val RAA = save_pop_thm "RAA";

set_goal([], ¬µÆ· [³³Æ]  Æ®);
a (rewrite_tac [_def] THEN REPEAT strip_tac);
val DN = save_pop_thm "DN";

set_goal([], ¬µÆ Ù· [Æ; Ù]  Æ ± Ù®);
a (rewrite_tac [_def, µL_def, fold_def] THEN REPEAT strip_tac);
val ±I = save_pop_thm "±I";

set_goal([], ¬µÆ Ù· ([Æ ± Ù]  Æ) ± ([Æ ± Ù]  Ù)®);
a (rewrite_tac [_def, µL_def, fold_def] THEN REPEAT strip_tac);
val ±E = save_pop_thm "±E";

set_goal([], ¬µÆ Ù· ([Æ]  Æ ² Ù) ± ([Æ]  Ù ² Æ)®);
a (rewrite_tac [_def, µL_def, fold_def] THEN REPEAT strip_tac);
val ²I = save_pop_thm "²I";

set_goal([], ¬µÆ Ù (Ú:BOOL) (:BOOL LIST) (:BOOL LIST) (:BOOL LIST)· ([Æ]ë   Ú) ± ([Ù]ë   Ú) ± (  Æ ² Ù) ´ ( ë  ë   Ú)®);
a (rewrite_tac [_def] THEN REPEAT strip_tac);
val ²E = save_pop_thm "²E";

set_goal([], ¬µÆ Ù · ([Æ]ë   Ù) ´ (  Æ ´ Ù)®);
a (rewrite_tac [_def, append_def, µL_def, fold_def] THEN REPEAT strip_tac);
val CP = save_pop_thm "CP";

set_goal([], ¬µÆ Ù· ([Æ ´ Ù; Æ]  Ù)®);
a (rewrite_tac [_def, append_def, µL_def, fold_def] THEN REPEAT strip_tac);
val MPP = save_pop_thm "MPP";

set_goal([], ¬µ  P· (µx· (  P x)) ´ (  µx· P x)®);
a (rewrite_tac [_def] THEN REPEAT strip_tac THEN asm_fc_tac[] THEN asm_rewrite_tac[]);
val µI = save_pop_thm "µI";

set_goal([], ¬µ  P c· (  µx· P x) ´ (  P c)®);
a (rewrite_tac [_def] THEN REPEAT strip_tac THEN asm_fc_tac[] THEN asm_rewrite_tac[]);
val µE = save_pop_thm "µE";

set_goal([], ¬µ  P x· (  P x) ´ (  ¶x· P x)®);
a (rewrite_tac [_def] THEN REPEAT strip_tac);
a (¶_tac ¬x® THEN asm_rewrite_tac[]);
val ¶I = save_pop_thm "¶I";

set_goal([], ¬µ  P c x· (P x  ) ´ (¶x· P x  )®);
a (rewrite_tac [_def] THEN REPEAT strip_tac);
a (¶_tac ¬x® THEN asm_rewrite_tac[]);
a (asm_rewrite_tac[]);
val ¶E = save_pop_thm "¶E";
=TEX
}%ignore

An example of the effect of substitutions obtained by use of these theorems in C intended to mimic the rules of Q is as follows.

Take ths simple case of $µE$, with the predicate
=INLINEFT
Ìx· ³ Flies g x
=TEX
 which we seek to instantiate to Pegasus.

We can specialise $µE$ to this case like this:
=SML
val sve = list_µ_elim [¬[]:BOOL LIST®, ¬Ìx· ³ Flies g x®, ¬Pegasus®] µE;
=TEX

This gives the theorem:

=GFT
val sve =
   ô ([]  (µ x· (Ì x· ³ Flies g x) x)) ´ ([]  (Ì x· ³ Flies g x) Pegasus) : THM
=TEX

in which there are two occurrences of the lambda expression in the places previously occupied by the variable $P$.

The substitutions can the be effected by beta reduction which can be achieved by rewriting the theorem as follows:

=SML
rewrite_rule [] sve;
=TEX

Which yields a theorem justifying the required inference.

=GFT
val it = ô ([]  (µ x· ³ Flies g x)) ´ ([]  ³ Flies g Pegasus) : THM
=TEX

All the above rules simply explicate the standard aspects of the logic of Q and C and do not reflect the specific additional features which Grice requires in connection with vacuous names.
They simply illustrate that the logical context for C includes as much standard logic as is provided in Q, and provide some tenuous indication that Grice's rules conform to standard logic as defined in Church's simple theory of types.
The main risk for Grice is in the detail of his presentation, bearing in mind the additional complexities arising from his suffix notation, and the above exercise offers no assurance in that matter.

\subsection{Existence}

\subsubsection{A}

We have already defined the propositional function ``Exists'' which tells us whether a name designates.

The following theorem indicates that the propositional function captures the intent of Grice's ``+exists'' notation.

=GFT
ÛE1Ý =	ô µ Æ Á· Æ g Á ´ Exists Á
=TEX

\ignore{
=SML
set_goal([], ¬µÆ Á· Æ g Á ´ Exists Á®);
a (REPEAT µ_tac THEN rewrite_tac [Exists_def, get_spec ¬$g®]);
val E1 = save_pop_thm "E1";
=TEX
}%ignore

In system C Grice's notion of \emph{E\_committal} seems to be definable.
The formal criteria for \emph{E\_committal} then becomes provability in HOL (which is not decidable).

In Grice \emph{E\_committal} is a relationship, here it is a property of propositional functions.

¹HOLCONST
Ü ÛE_committalÝ : ('a ­ BOOL) ­ BOOL
÷üüüüüü
Ü µÆ· E_committal Æ ¤ µÁ· Æ Á ´ Exists Á
°

The following theorems correspond to clauses in Grice's definition of \emph{E\_committal}:

=GFT
ÛE_2Ý =	ô µ Æ· E_committal Æ
			´ E_committal (ÌÁ· ³ ³ Æ Á)
ÛE_3Ý =	ô µ Æ Ù· E_committal Æ ² E_committal Ù
			´ E_committal (Ì Á· Æ Á ± Ù Á)
ÛE_4Ý =	ô µ Æ Ù· E_committal Æ ± E_committal Ù
			´ E_committal (Ì Á· Æ Á ² Ù Á)
ÛE_5Ý =	ô µ Æ Ù· E_committal (Ì Á· ³ Æ Á) ± E_committal Ù
			´ E_committal (Ì Á· Æ Á ´ Ù Á)
ÛE_6µÝ =	ô µ Æ· (¶ Â· E_committal (Æ Â))
			´ E_committal (Ì Á· µ Â· Æ Â Á)
=TEX

I have a problem proving the existential element of (6), so this clause is in doubt.
I think Grice should be asking for ``%
=INLINEFT
µÂ· Ù(Â/×)
=TEX
'' to be \emph{E\_committal} for Á (in system Q), which corresponds in system C to the theorem:

=GFT
ÛE_6¶bÝ =	ô µ Æ· (µ Â· E_committal (Æ Â))
			´ E_committal (Ì Á· ¶ Â· Æ Â Á)
=TEX

\ignore{
=SML
val E_committal_def = get_spec ¬E_committal®;

set_goal([], ¬µÆ· E_committal Æ ´ E_committal (ÌÁ· ³ ³ (Æ Á))®);
a (REPEAT strip_tac THEN asm_rewrite_tac[È_axiom]);
val E_2 = save_pop_thm "E_2";

set_goal([], ¬µÆ Ù· E_committal Æ ² E_committal Ù ´ E_committal (ÌÁ· Æ Á ± Ù Á)®);
a (REPEAT µ_tac THEN rewrite_tac[E_committal_def] THEN REPEAT strip_tac THEN asm_fc_tac[]);
val E_3 = save_pop_thm "E_3";

set_goal([], ¬µÆ Ù· E_committal Æ ± E_committal Ù ´ E_committal (ÌÁ· Æ Á ² Ù Á)®);
a (REPEAT µ_tac THEN rewrite_tac[E_committal_def] THEN REPEAT strip_tac THEN asm_fc_tac[]);
val E_4 = save_pop_thm "E_4";

set_goal([], ¬µÆ Ù· E_committal (ÌÁ· ³ (Æ Á)) ± E_committal Ù ´ E_committal (ÌÁ· Æ Á ´ Ù Á)®);
a (REPEAT µ_tac THEN rewrite_tac[E_committal_def] THEN REPEAT strip_tac THEN asm_fc_tac[]);
val E_5 = save_pop_thm "E_5";

set_goal([], ¬µÆ· (¶Â· E_committal (Æ Â)) ´ E_committal (ÌÁ· µÂ· (Æ Â) Á)®);
a (REPEAT µ_tac THEN rewrite_tac[E_committal_def] THEN REPEAT strip_tac);
a (spec_nth_asm_tac 1 ¬Â® THEN asm_fc_tac[]);
val E_6µ = save_pop_thm "E_6µ";

set_goal([], ¬µÆ· (µÂ· E_committal (Æ Â)) ´ E_committal (ÌÁ· ¶Â· (Æ Â) Á)®);
a (REPEAT µ_tac THEN rewrite_tac[E_committal_def] THEN REPEAT strip_tac);
a (asm_fc_tac[]);
val E_6¶b = save_pop_thm "E_6¶b";
=TEX
}%ignore


The definition we have already given for \emph{Exists} is similar in character and identical in effect to Grices suggestions for \emph{+exists}.

\subsubsection{B. ¶ Quantified Formulae}

This has already been covered.

Grice wishes to distinguish himself from Meinong, but his system allows quantification over non-existents, and he can therefore only distinguish himself from Meinong by distancing himself also from Quine's criteria of ontological committment.
This he could easily do by adopting Carnap's distinction between internal and external questions, and denying that any metaphysical significance attaches to something being counted in the range of quantification.

\section{Objections Considered}

I will offer some discussion of Grice's problem here and then offer some of my own.

\section{Identity}

HOL already has identity and this identity is good for System C.
It HOL it is a curried propositional function of polymorphic type 'a ­ 'a ­ BOOL®.
If applied using function application the universal law of reflexivity holds.

To get a ``strict'' version of equality (i.e. one which is false when either argument does not exist) it is necessary to uncurry equality so that its type becomes ('a ¸ 'a) ­ BOOL® and apply it using the system C copula for binary relations.

These two seem to correspond to Grice's intended two kinds of equality insofar as the difference between the two is primarily that one does and the other does not allow that there may be true identities between non-denoting names.
However this is achieved in system C by having two quite distinct identity relations only one of which is properly a predicate, and applied through our copula $g$.
The other is a propositional function which must be applied without use of the copula (because the copula forces strictness, i.e. forces predication to undefined values to yield falsehoods).

Grice seems to think that the required distinction between equalities can be achieved by the use of his scoping subscripts, but I have not yet been convinced that his is correct in this.
Whatever the scope of the predicate, predication to non-denoting names must yield falsehood, so I can't see how any use of subscripts will make ``Pegasus = Pegasus'' true.

To illustrate the effect of the built in equality the following theorems suffice:

=GFT
ÛPegasus_eq_lemma1Ý =
	ô Pegasus = Pegasus
=TEX

Note the lack of copula.
This is of course an instance of the theorem:

=GFT
Ûeq_refl_thmÝ =
	ô µ x· x = x
=TEX

\ignore{
=SML
set_goal([], ¬Pegasus = Pegasus®);
a (rewrite_tac[]);
val Pegasus_eq_lemma1 = save_pop_thm "Pegasus_eq_lemma1";

set_goal([], ¬µx· x=x®);
a (rewrite_tac[]);
val eq_refl_thm = save_pop_thm "eq_refl_thm";
=TEX
}%ignore

To get a nice notation for ``strong'' equality we need to define it as an infix symbol, which requires that the copula be built into the definition.
We could use the $é$ symbol, but this usually represents an equivalence relation which is weaker than identity, so we will subscript the $=$ sign with g, suggesting that it is just the same thing applied through our copula.

=SML
declare_infix (200, "=g");
=TEX

¹HOLCONST
Ü $Û=gÝ : 'a ­ 'a ­ BOOL
÷üüüüüü
Ü µx y:'a· (x =g y) = (Uncurry $=) g2 (x,y)
°

We can now prove:

=GFT
Pegasus_eq_lemma2 =
	ô ³ Pegasus =g Pegasus
=TEX

And must rest content with the qualified rule:

=GFT
Ûeqg_refl_thmÝ =
	ô µ x· Exists g x ¤ x =g x
=TEX

The ``strictness'' of this equality is expressed by the theorem (which would have made a better definition):

=GFT
eqg_strict_thm =
	ô µ x y· x =g y ¤ Exists g x ± Exists g y ± x = y
=TEX

\ignore{
=SML
val eqg_def = get_spec ¬$=g®;

set_goal([], ¬³ Pegasus =g Pegasus®);
a (rewrite_tac[eqg_def, g2_def, Pegasus_def]);
val Pegasus_eq_lemma2 = save_pop_thm "Pegasus_eq_lemma2";

set_goal([], ¬µx· Exists g x ¤ x =g x®);
a (rewrite_tac[eqg_def, g_def, g2_def, Exists_def]);
val eqg_refl_thm = save_pop_thm "eqg_refl_thm";

set_goal([], ¬µx y· x =g y ¤ Exists g x ± Exists g y ± x = y®);
a (rewrite_tac[eqg_def, g_def, g2_def, Exists_def]);
a (REPEAT strip_tac);
val eqg_strict_thm = save_pop_thm "eqg_strict_thm";
=TEX
}%ignore

On reflection Grice's treatment by scoping is presented in the context of a second order definition of equality, and therefore for the weak equality does not define equality as a predicate, but as a second order formula.
Its equivalence to the primitive equality in HOL can be illustrated by the following theorem:

=GFT
Ûsnd_order_eq_thmÝ =
	ô µ x y· x = y ¤ (µ P· P g x ¤ P g y)
=TEX

\ignore{
=SML
set_goal([], ¬µx y· x = y ¤ (µP· P g x ¤ P g y)®);
a (rewrite_tac[g_def] THEN REPEAT strip_tac THEN_TRY all_var_elim_asm_tac);
a (spec_nth_asm_tac 1 ¬Ìz· z = x® THEN all_asm_ante_tac
	THEN_TRY rewrite_tac[] THEN REPEAT strip_tac
	THEN all_var_elim_asm_tac THEN_TRY asm_rewrite_tac[]
	THEN DROP_NTH_ASM_T 2 ante_tac THEN rewrite_tac [] THEN REPEAT strip_tac
	THEN SPEC_NTH_ASM_T 1 ¬Ìx· x = y® (strip_asm_tac o (rewrite_rule[])));
val snd_order_eq_thm = save_pop_thm "snd_order_eq_thm";
=TEX
}%ignore

This equivalence only holds because we adopted Grice's preferred (but not stipulated) domain of interpretation, in which there is exactly one non-designating correlate.
If there was more than one non-designating correlate then Grice's second order definition would give a notion of identity under which all non-designating correlates are considered equal, which would not be the case for the primitive equality in HOL.

Even in that case a similar device would work as illuatrated by the following theorem:
=GFT
Ûsnd_order_eq_thm2Ý =
	ô µ x y· x = y ¤ (µ P· P x ¤ P y)
=TEX

In which the gricean copula has been dropped so that the predication is no longer strict.

\ignore{
=SML
set_goal([], ¬µx y· x = y ¤ (µP· P x ¤ P y)®);
a (REPEAT strip_tac THEN_TRY all_var_elim_asm_tac);
a (SPEC_NTH_ASM_T 1 ¬Ìx· x = y® (strip_asm_tac o (rewrite_rule[])));
val snd_order_eq_thm2 = save_pop_thm "snd_order_eq_thm2";
=TEX
}%ignore

\subsection{Names and Descriptions}

To provide for descriptions as distinct from names System S is to be considered and the discussion of this topic is therefore deferred until System S has been presented.

\section{System S}



\subsection{Names and Descriptions}

I note here pro-tem just that the method adopted in System C for controlling the scope of predications, viz. the use either of lambda expressions or of naming complex predicates by definitions, enables scope to be controlled in predication to descriptions which are formed as terms.
We can therefore follow Grice's system Q in introducing such descriptions.

=SML
declare_binder "É";
=TEX

¹HOLCONST
Ü $ÛÉÝ : ('a ­ BOOL) ­ 'a
÷üüüüüü
Ü µÆ· ($É Æ) = ÅÁ· (Æ g Á ± µÂ· Æ g Â ´ Â = Á) 
		² (³¶Ç· Æ g Ç ± µÂ· Æ g Â ´ Â = Ç) ± Á = â
°

=GFT
ÛÉ_thm1Ý = ô µ Ç· Æ g Ç ± (µ Â· Æ g Â ´ Â = Ç) ´ $É Æ = Ç
ÛÉ_thm2Ý = ô ³ (¶ Ç· Æ g Ç ± (µ Â· Æ g Â ´ Â = Ç)) ´ $É Æ = â
=TEX

\ignore{
=SML
val É_def = get_spec ¬$É®;

set_goal([], ¬µÇ:'a· Æ g Ç ± (µÂ· Æ g Â ´ Â = Ç) ´ ($É Æ) = Ç ®);
a (REPEAT strip_tac THEN rewrite_tac [É_def]);
a (Å_tac ¬ÅÁ· Æ g Á ± (µ Â· Æ g Â ´ Â = Á) ² ³ (¶ Ç· Æ g Ç ± (µ Â· Æ g Â ´ Â = Ç)) ± Á = â®);
(* *** Goal "1" *** *)
a (¶_tac ¬Ç® THEN asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a (asm_fc_tac[]);
(* *** Goal "3" *** *)
a (asm_rewrite_tac[]);
a (asm_fc_tac[]);
val É_thm1 = save_pop_thm "É_thm1";

set_goal([], ¬(³¶Ç:'a· Æ g Ç ± (µÂ· Æ g Â ´ Â = Ç)) ´ ($É Æ) = â®);
a (strip_tac);
a (REPEAT strip_tac THEN rewrite_tac [É_def]);
a (Å_tac ¬ÅÁ· Æ g Á ± (µ Â· Æ g Â ´ Â = Á) ² ³ (¶ Ç· Æ g Ç ± (µ Â· Æ g Â ´ Â = Ç)) ± Á = â®);
(* *** Goal "1" *** *)
a (¶_tac ¬â® THEN asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a (spec_nth_asm_tac 3 ¬(Å Á
             · Æ g Á ± (µ Â· Æ g Â ´ Â = Á)
                 ² ³ (¶ Ç· Æ g Ç ± (µ Â· Æ g Â ´ Â = Ç)) ± Á = â)®);
a (spec_nth_asm_tac 3 ¬Â®);
val É_thm2 = save_pop_thm "É_thm2";
=TEX
}%ignore

There is a difficulty in adopting Grice's reticence to allow existential generalisation on the basis of such a predication.
This cannot be supported in system C without changing the underlying semantics.

Grice has effectively split the non-denoting expressions into two, those which correlate with something in the domain of quantification and those which do not.
Since our embedding requires all expressions to have a value, we would have to add another kind of entity into the domain of interpretation and define quantifiers which operate over expressions which have a correlate but not over the values of non-denoting descriptions.

This would effect most of the embedding, the whole would have to be reworked (in a routine way).


A new theory is needed which I will call ``sysc'' which is created here:

=SML
open_theory "grice";
force_new_theory "syss";
set_pc "rbjmisc";
=TEX

We liberalise the notion of interpretation from system C in the following two ways.
Firstly we allow that there may me more than one non-denoting correllate. and hence then there may be semantic distinctions between non-denoting names, overcoming one obstacle to substantial discussions about fictional entities.
Secondly we introduce values to stand for non-referring descriptions.
These are not intended to be values and will be excluded from the range of quantification, with the effect that EG and UI will not work with failing descriptions.

This will be done using a ``disjoint union'' the right disjunct of which will be surrogates for failing descriptions, and the left will be correlates for names of which there will be at least one which is not a denotatum.
The ``normal'' quantifiers for system S will quantify only over the correlates.

\ignore{
=SML
set_goal([], ¬¶denotatum:'a ­ BOOL· ¶x· ³ denotatum x®);
a (¶_tac ¬Ìy·F® THEN ¶_tac ¬Åz·T® THEN rewrite_tac[]);
save_cs_¶_thm (pop_thm());
=TEX
}%ignore

To effect this we introduce the property of being a denotatum which is left open except to the extent that there must be at least one correlate which is not a denotatum.

¹HOLCONST
Ü ÛdenotatumÝ: 'a ­ BOOL
÷üüüüüü
Ü ¶x· ³ denotatum x
°

\ignore{
=SML
val denotatum_def = get_spec ¬denotatum®;

set_goal([], ¬¶â_corr:'a· ³ denotatum â_corr®);
a (strip_asm_tac denotatum_def);
a (¶_tac ¬x® THEN asm_rewrite_tac[]);
save_cs_¶_thm (pop_thm());
=TEX
}%ignore


¹HOLCONST
Ü Ûâ_corrÝ: 'a
÷üüüüüü
Ü ³ denotatum â_corr
°

The type of exressions in System S is given by the following type abbreviation:

=SML
declare_type_abbrev("SC", ["'a"], 'a + 'b®);
=TEX

¹HOLCONST
Ü ÛâÝ: 'a SC
÷üüüüüü
Ü â = InL â_corr
°

It will be useful to have tests and projections for values of type 'a SC®.

This propositional function tests whether an SC is a correlate:

¹HOLCONST
Ü ÛIsCorrÝ: 'a SC ­ BOOL
÷üüüüüü
Ü µv:'a SC· IsCorr v ¤ IsL v
°

This function extracts the correlate (of type 'a®) from a value of type 'a SC®.

¹HOLCONST
Ü ÛCorrÝ: 'a SC ­ 'a
÷üüüüüü
Ü µv:'a SC· Corr v = OutL v
°

This propositional function tells us whether a value of type 'a SC® is a denotatum.

¹HOLCONST
Ü ÛIsDenÝ: 'a SC ­ BOOL
÷üüüüüü
Ü µv:'a SC· IsDen v ¤ IsCorr v ± denotatum (Corr v)
°

There are now difficulties in the treatment of constants and variables, since a HOL constant or variable constrained only by the type of the elements of an interpretation will not be known to denote (which is OK), but will not even be known to correlate, and hence may not even be in the range of quantification.
SAuch results as can be obtained using unconstrained variables will nevertheless be valid, and will be generalisable.


Now we define our special kind of predication (the copula for System S).
To visually distinguish this from the copula of System C by using the subscript h.

=SML
declare_infix (400, "h");
=TEX

¹HOLCONST
Ü $h: ('a ­ BOOL) ­ 'a SC ­ BOOL
÷üüüüüü
Ü µ p t· p h t ¤ if IsDen t then p (Corr t) else F
°

The definition says, if the term denotes then apply the predicate to the value denoted, otherwise the result of the predication is F (false).

Note that this will not work for relations, we would have to define a separate similar predicator for each arity of relation in use.

Here is the copula for applying a 2-ary relation.

=SML
declare_infix (400, "h2");
=TEX

¹HOLCONST
Ü $h2: ('a ¸ 'c ­ BOOL) ­ ('a SC ¸ 'c SC) ­ BOOL
÷üüüüüü
Ü µ p t· p h2 t ¤ if IsDen (Fst t) ± IsDen (Snd t) then p (Corr (Fst t), Corr (Snd t)) else F
°

\ignore{
=SML
val h_def = get_spec ¬$h®;
val h2_def = get_spec ¬$h2®;
=TEX
}%ignore

Now let's introduce Pegasus.
The ``definition'' just says that Pegasus is a non-denoting correlate.
We know that there must be such a thing (though we don't know that there are any denoting correlates).

\ignore{
=SML
val â_corr_def = get_spec ¬â_corr®;
val â_def = get_spec ¬â®;
val IsCorr_def = get_spec ¬IsCorr®;
val Corr_def = get_spec ¬Corr®;
val IsDen_def = get_spec ¬IsDen®;

set_goal([], ¬¶Pegasus:'a SC· IsCorr Pegasus ± ³ IsDen Pegasus®);
a (¶_tac ¬InL â_corr®);
a (rewrite_tac [IsCorr_def, IsDen_def, Corr_def, â_corr_def]);
val _ = save_cs_¶_thm (pop_thm());
=TEX
}%ignore

¹HOLCONST
Ü ÛPegasusÝ : 'a SC
÷üüüüüü
Ü IsCorr Pegasus ± ³ IsDen Pegasus
°

And the predicate \emph{Flies}.
Note that the predicates apply only to real desigata under the normal HOL application, its only under our special predication that they become applicatble to possibly non denoting values.

¹HOLCONST
Ü ÛFliesÝ : 'a ­ BOOL
÷üüüüüü
Ü T
°

We can now prove in HOL the elementary facts we know about Pegasus flying, yielding the following theorems:

=GFT
ÛPegasus_lemma_1Ý =
	ô Flies h Pegasus ¤ F

ÛPegasus_lemma_2Ý =
	ô (Ì x· ³ Flies x) h Pegasus = F

ÛPegasus_lemma_3Ý =
	ô ³ Flies h Pegasus

ÛPegasus_lemma_4Ý =
	ô ³ (Ì x· ³ Flies x) h Pegasus
=TEX

\ignore{
=SML
val g_def = get_spec ¬$h®;
val Pegasus_def = get_spec ¬Pegasus®;
val Flies_def = get_spec ¬Flies®;

set_goal([], ¬Flies h Pegasus ¤ F®);
a (rewrite_tac [g_def, Pegasus_def]);
val Pegasus_lemma_1 = save_pop_thm "Pegasus_lemma_1";

set_goal([], ¬(Ìx· ³ Flies x) h Pegasus ¤ F®);
a (rewrite_tac [g_def, Pegasus_def]);
val Pegasus_lemma_2 = save_pop_thm "Pegasus_lemma_2";

set_goal([], ¬³ Flies h Pegasus®);
a (rewrite_tac [g_def, Pegasus_def]);
val Pegasus_lemma_3 = save_pop_thm "Pegasus_lemma_3";

set_goal([], ¬³ (Ìx· ³ Flies x) h Pegasus®);
a (rewrite_tac [g_def, Pegasus_def]);
val Pegasus_lemma_4 = save_pop_thm "Pegasus_lemma_4";
=TEX
}%ignore

In case you may doubt the neutrality of our use of lambda expressions, we show here that they are inessential to this approach, and can be dispensed with in favour of explict definitions of the predicates required.
Thus we may instead define a predicate which is the denial of \emph{Flies}:

¹HOLCONST
Ü ÛDoesnt_FlyÝ : 'a ­ BOOL
÷üüüüüü
Ü µx· Doesnt_Fly x ¤ ³ Flies x
°

We can then prove the slightly reworded:

=GFT
ÛPegasus_lemma_5Ý = ô Doesnt_Fly h Pegasus ¤ F
=TEX

the proof of which need not mention the predicate, since it suffices to know that the subject does not exist.

\ignore{
=SML
set_goal([], ¬Doesnt_Fly h Pegasus ¤ F®);
a (rewrite_tac [g_def, Pegasus_def]);
val Pegasus_lemma_5 = save_pop_thm "Pegasus_lemma_5";
=TEX
}%ignore

This general claim can be expressed in HOL and proven.
To make it read sensibly however, it is best for us to define the relevant notion of existence.

¹HOLCONST
Ü ÛExistsÝ : 'a ­ BOOL
÷üüüüüü
Ü µx· Exists x ¤ T
°

The definition looks a bit bizarre and works for just the same reason that we do not need to know the predicate to know that predication to a non-existent will be false.
This predicate will always be true, unless it is applied to a term which fails to denote.
So we satisfy another of Grice's desiderata, that the non-existence of Pegasus can be stated.

But first a more general result:

=GFT
ÛExists_lemma_1Ý =
	ô µ P x· ³ Exists h x ´ ³ P h x
=TEX

\ignore{
=SML
val Exists_def = get_spec ¬Exists®;

set_goal([], ¬µP x· ³ (Exists h x) ´ ³ (P h x)®);
a (REPEAT µ_tac THEN rewrite_tac [g_def, Exists_def]
	THEN REPEAT strip_tac);
val Exists_lemma_1 = save_pop_thm "Exists_lemma_1";
=TEX
}%ignore

Desideratum A8 is satisfied by the standard quantifiers in HOL.

=GFT
Û¶_lemma_1Ý = 
	ô µ P· P h Pegasus ´ (¶ x· P h x)

Ûµ_lemma_1Ý =
	ô µ P· (µ x· P h x) ´ P h Pegasus
=TEX

\ignore{
=SML
set_goal([], ¬µP:'a ­ BOOL· P h (Pegasus:'a SC) ´ ¶x:'a SC· P h x®);
a (REPEAT strip_tac);
a (¶_tac ¬Pegasus®);
a (asm_rewrite_tac []);
val ¶_lemma_1 = save_pop_thm "¶_lemma_1";

set_goal([], ¬µP· (µx:'a SC· P h x) ´ P h (Pegasus:'a SC)®);
a (REPEAT strip_tac);
a (asm_rewrite_tac []);
val µ_lemma_1 = save_pop_thm "µ_lemma_1";
=TEX
}%ignore

However, the HOL native quantifiers are unsatisfactory since they quantify over the values introduced into the domain of the interpretation as correlates for failing descriptions.

This is shown by the following lemma:

=GFT
=TEX

\ignore{
=SML
set_goal([], ¬¶x· IsCorr x ± ³ IsDen x®);
=TEX
}%ignore


\ignore{
=SML
force_new_pc "'syss";
merge_pcs ["'savedthm_cs_¶_proof"] "'syss";
set_merge_pcs ["rbjmisc", "'syss"];
=TEX
}%ignore

\subsection{IVB-3 Inference-Rules}

Since we are working with a semantic embedding rather than a syntactic meta-theory we cannot prove results about derivations and instead present proofs about the semantics which show that the required inference rules would be sound.

To do this we adopt a notation for expressing entailment in C in a manner parallel to the presentation of the natural deduction system of Q

=SML
declare_infix(4, "");
=TEX

¹HOLCONST
Ü $ : BOOL LIST ­ BOOL ­ BOOL
÷üüüüüü
Ü µal c· (al  c) ¤ (µL al) ´ c
°

In the following theorems which capture the content of Grices rules for Q as theorems of C, the variables Æ, Ù, Ú... range over formulae (boolean terms) and , , ... over lists (finite sequences) of formulae.
$P$ ranges over propositional functions, values whose types are instances of 'a ­ BOOL® (in which $'a$ is a type variable). 
The notation ``[Æ; Ù; ...]'' is an explicit list formation (``[Æ]'' being a single element list) and the symbol ``$ë$'' is the concatenation operator over lists.

In general the rules of Q can be formulated as theorems of C because C is a higher order logic, and can quantify over predicates.
This means that where substitution is involved in a rule, this is captured as a theorem by the use of a variable as a predicate applied to a variable as an argument.
When such a theorem is instantiated using a lambda expression as the predicate, the substitution into the expression will be achieved by beta-reduction.

=GFT
ÛASSÝ =	ô µ Æ· [Æ]  Æ
ÛRAAÝ =	ô µÆ Ù Ú · ([Æ] ë   Ù ± ³Ù) ´ (  ³Æ)
ÛDNÝ =	ô µ Æ· [³ ³ Æ]  Æ
Û±IÝ =		ô µ Æ Ù· [Æ; Ù]  Æ ± Ù
Û±EÝ =	ô µ Æ Ù· ([Æ ± Ù]  Æ) ± ([Æ ± Ù]  Ù)
Û²IÝ =		ô µ Æ Ù· ([Æ]  Æ ² Ù) ± ([Æ]  Ù ² Æ)
Û²EÝ =	ô µ Æ Ù Ú   · ([Æ] ë   Ú) ± ([Ù] ë   Ú) ± (  Æ ² Ù)
			´ ( ë  ë   Ú)
ÛCPÝ =	ô µ Æ Ù · ([Æ] ë   Ù) ´ (  Æ ´ Ù)
ÛMPPÝ =	ô µ Æ Ù· [Æ ´ Ù; Æ]  Ù
ÛµIÝ =		ô µ  P· (µ x·   P x) ´ (  (µ x· P x))
ÛµEÝ =	ô µ  P c· (  (µ x· P x)) ´ (  P c)
Û¶IÝ =		ô µ  P x· (  P x) ´ (  (¶ x· P x))
Û¶EÝ =	ô µ  P c x· (P x  ) ´ (¶ x· P x  )
=TEX

\ignore{
=SML
val _def = get_spec ¬$®;

set_goal([], ¬µÆ· [Æ]  Æ®);
a (rewrite_tac [_def] THEN REPEAT strip_tac);
val ASS = save_pop_thm "ASS";

set_goal([], ¬µÆ Ù Ú · ([Æ]ë   Ù ± ³Ù) ´ (  ³Æ)®);
a (rewrite_tac [_def, append_def, µL_def, fold_def] THEN REPEAT strip_tac);
val RAA = save_pop_thm "RAA";

set_goal([], ¬µÆ· [³³Æ]  Æ®);
a (rewrite_tac [_def] THEN REPEAT strip_tac);
val DN = save_pop_thm "DN";

set_goal([], ¬µÆ Ù· [Æ; Ù]  Æ ± Ù®);
a (rewrite_tac [_def, µL_def, fold_def] THEN REPEAT strip_tac);
val ±I = save_pop_thm "±I";

set_goal([], ¬µÆ Ù· ([Æ ± Ù]  Æ) ± ([Æ ± Ù]  Ù)®);
a (rewrite_tac [_def, µL_def, fold_def] THEN REPEAT strip_tac);
val ±E = save_pop_thm "±E";

set_goal([], ¬µÆ Ù· ([Æ]  Æ ² Ù) ± ([Æ]  Ù ² Æ)®);
a (rewrite_tac [_def, µL_def, fold_def] THEN REPEAT strip_tac);
val ²I = save_pop_thm "²I";

set_goal([], ¬µÆ Ù (Ú:BOOL) (:BOOL LIST) (:BOOL LIST) (:BOOL LIST)· ([Æ]ë   Ú) ± ([Ù]ë   Ú) ± (  Æ ² Ù) ´ ( ë  ë   Ú)®);
a (rewrite_tac [_def] THEN REPEAT strip_tac);
val ²E = save_pop_thm "²E";

set_goal([], ¬µÆ Ù · ([Æ]ë   Ù) ´ (  Æ ´ Ù)®);
a (rewrite_tac [_def, append_def, µL_def, fold_def] THEN REPEAT strip_tac);
val CP = save_pop_thm "CP";

set_goal([], ¬µÆ Ù· ([Æ ´ Ù; Æ]  Ù)®);
a (rewrite_tac [_def, append_def, µL_def, fold_def] THEN REPEAT strip_tac);
val MPP = save_pop_thm "MPP";

set_goal([], ¬µ  P· (µx· (  P x)) ´ (  µx· P x)®);
a (rewrite_tac [_def] THEN REPEAT strip_tac THEN asm_fc_tac[] THEN asm_rewrite_tac[]);
val µI = save_pop_thm "µI";

set_goal([], ¬µ  P c· (  µx· P x) ´ (  P c)®);
a (rewrite_tac [_def] THEN REPEAT strip_tac THEN asm_fc_tac[] THEN asm_rewrite_tac[]);
val µE = save_pop_thm "µE";

set_goal([], ¬µ  P x· (  P x) ´ (  ¶x· P x)®);
a (rewrite_tac [_def] THEN REPEAT strip_tac);
a (¶_tac ¬x® THEN asm_rewrite_tac[]);
val ¶I = save_pop_thm "¶I";

set_goal([], ¬µ  P c x· (P x  ) ´ (¶x· P x  )®);
a (rewrite_tac [_def] THEN REPEAT strip_tac);
a (¶_tac ¬x® THEN asm_rewrite_tac[]);
a (asm_rewrite_tac[]);
val ¶E = save_pop_thm "¶E";
=TEX
}%ignore

An example of the effect of substitutions obtained by use of these theorems in C intended to mimic the rules of Q is as follows.

Take ths simple case of $µE$, with the predicate
=INLINEFT
Ìx· ³ Flies h x
=TEX
 which we seek to instantiate to Pegasus.

We can specialise $µE$ to this case like this:
=SML
val sve = list_µ_elim [¬[]:BOOL LIST®, ¬Ìx· ³ Flies h x®, ¬Pegasus®] µE;
=TEX

This gives the theorem:

=GFT
val sve =
   ô ([]  (µ x· (Ì x· ³ Flies h x) x)) ´ ([]  (Ì x· ³ Flies h x) Pegasus) : THM
=TEX

in which there are two occurrences of the lambda expression in the places previously occupied by the variable $P$.

The substitutions can the be effected by beta reduction which can be achieved by rewriting the theorem as follows:

=SML
rewrite_rule [] sve;
=TEX

Which yields a theorem justifying the required inference.

=GFT
val it = ô ([]  (µ x· ³ Flies h x)) ´ ([]  ³ Flies h Pegasus) : THM
=TEX

All the above rules simply explicate the standard aspects of the logic of Q and C and do not reflect the specific additional features which Grice requires in connection with vacuous names.
They simply illustrate that the logical context for C includes as much standard logic as is provided in Q, and provide some tenuous indication that Grice's rules conform to standard logic as defined in Church's simple theory of types.
The main risk for Grice is in the detail of his presentation, bearing in mind the additional complexities arising from his suffix notation, and the above exercise offers no assurance in that matter.

\subsection{Existence}

\subsubsection{A}

We have already defined the propositional function ``Exists'' which tells us whether a name designates.

The following theorem indicates that the propositional function captures the intent of Grice's ``+exists'' notation.

=GFT
ÛE1Ý =	ô µ Æ Á· Æ h Á ´ Exists Á
=TEX

\ignore{
=SML
set_goal([], ¬µÆ Á· Æ h Á ´ Exists Á®);
a (REPEAT µ_tac THEN rewrite_tac [Exists_def, get_spec ¬$h®]);
val E1 = save_pop_thm "E1";
=TEX
}%ignore

In system C Grice's notion of \emph{E\_committal} seems to be definable.
The formal criteria for \emph{E\_committal} then becomes provability in HOL (which is not decidable).

In Grice \emph{E\_committal} is a relationship, here it is a property of propositional functions.

¹HOLCONST
Ü ÛE_committalÝ : ('a ­ BOOL) ­ BOOL
÷üüüüüü
Ü µÆ· E_committal Æ ¤ µÁ· Æ Á ´ Exists Á
°

The following theorems correspond to clauses in Grice's definition of \emph{E\_committal}:

=GFT
ÛE_2Ý =	ô µ Æ· E_committal Æ
			´ E_committal (ÌÁ· ³ ³ Æ Á)
ÛE_3Ý =	ô µ Æ Ù· E_committal Æ ² E_committal Ù
			´ E_committal (Ì Á· Æ Á ± Ù Á)
ÛE_4Ý =	ô µ Æ Ù· E_committal Æ ± E_committal Ù
			´ E_committal (Ì Á· Æ Á ² Ù Á)
ÛE_5Ý =	ô µ Æ Ù· E_committal (Ì Á· ³ Æ Á) ± E_committal Ù
			´ E_committal (Ì Á· Æ Á ´ Ù Á)
ÛE_6µÝ =	ô µ Æ· (¶ Â· E_committal (Æ Â))
			´ E_committal (Ì Á· µ Â· Æ Â Á)
=TEX

I have a problem proving the existential element of (6), so this clause is in doubt.
I think Grice should be asking for ``%
=INLINEFT
µÂ· Ù(Â/×)
=TEX
'' to be \emph{E\_committal} for Á (in system Q), which corresponds in system C to the theorem:

=GFT
ÛE_6¶bÝ =	ô µ Æ· (µ Â· E_committal (Æ Â))
			´ E_committal (Ì Á· ¶ Â· Æ Â Á)
=TEX

\ignore{
=SML
val E_committal_def = get_spec ¬E_committal®;

set_goal([], ¬µÆ· E_committal Æ ´ E_committal (ÌÁ· ³ ³ (Æ Á))®);
a (REPEAT strip_tac THEN asm_rewrite_tac[È_axiom]);
val E_2 = save_pop_thm "E_2";

set_goal([], ¬µÆ Ù· E_committal Æ ² E_committal Ù ´ E_committal (ÌÁ· Æ Á ± Ù Á)®);
a (REPEAT µ_tac THEN rewrite_tac[E_committal_def] THEN REPEAT strip_tac THEN asm_fc_tac[]);
val E_3 = save_pop_thm "E_3";

set_goal([], ¬µÆ Ù· E_committal Æ ± E_committal Ù ´ E_committal (ÌÁ· Æ Á ² Ù Á)®);
a (REPEAT µ_tac THEN rewrite_tac[E_committal_def] THEN REPEAT strip_tac THEN asm_fc_tac[]);
val E_4 = save_pop_thm "E_4";

set_goal([], ¬µÆ Ù· E_committal (ÌÁ· ³ (Æ Á)) ± E_committal Ù ´ E_committal (ÌÁ· Æ Á ´ Ù Á)®);
a (REPEAT µ_tac THEN rewrite_tac[E_committal_def] THEN REPEAT strip_tac THEN asm_fc_tac[]);
val E_5 = save_pop_thm "E_5";

set_goal([], ¬µÆ· (¶Â· E_committal (Æ Â)) ´ E_committal (ÌÁ· µÂ· (Æ Â) Á)®);
a (REPEAT µ_tac THEN rewrite_tac[E_committal_def] THEN REPEAT strip_tac);
a (spec_nth_asm_tac 1 ¬Â® THEN asm_fc_tac[]);
val E_6µ = save_pop_thm "E_6µ";

set_goal([], ¬µÆ· (µÂ· E_committal (Æ Â)) ´ E_committal (ÌÁ· ¶Â· (Æ Â) Á)®);
a (REPEAT µ_tac THEN rewrite_tac[E_committal_def] THEN REPEAT strip_tac);
a (asm_fc_tac[]);
val E_6¶b = save_pop_thm "E_6¶b";
=TEX
}%ignore


The definition we have already given for \emph{Exists} is similar in character and identical in effect to Grices suggestions for \emph{+exists}.

\subsubsection{B. ¶ Quantified Formulae}

This has already been covered.

Grice wishes to distinguish himself from Meinong, but his system allows quantification over non-existents, and he can therefore only distinguish himself from Meinong by distancing himself also from Quine's criteria of ontological committment.
This he could easily do by adopting Carnap's distinction between internal and external questions, and denying that any metaphysical significance attaches to something being counted in the range of quantification.

\section{Objections Considered}

I will offer some discussion of Grice's problem here and then offer some of my own.

\section{Identity}

HOL already has identity and this identity is good for System C.
It HOL it is a curried propositional function of polymorphic type 'a ­ 'a ­ BOOL®.
If applied using function application the universal law of reflexivity holds.

To get a ``strict'' version of equality (i.e. one which is false when either argument does not exist) it is necessary to uncurry equality so that its type becomes ('a ¸ 'a) ­ BOOL® and apply it using the system C copula for binary relations.

These two seem to correspond to Grice's intended two kinds of equality insofar as the difference between the two is primarily that one does and the other does not allow that there may be true identities between non-denoting names.
However this is achieved in system C by having two quite distinct identity relations only one of which is properly a predicate, and applied through our copula $h$.
The other is a propositional function which must be applied without use of the copula (because the copula forces strictness, i.e. forces predication to undefined values to yield falsehoods).

Grice seems to think that the required distinction between equalities can be achieved by the use of his scoping subscripts, but I have not yet been convinced that his is correct in this.
Whatever the scope of the predicate, predication to non-denoting names must yield falsehood, so I can't see how any use of subscripts will make ``Pegasus = Pegasus'' true.

To illustrate the effect of the built in equality the following theorems suffice:

=GFT
ÛPegasus_eq_lemma1Ý =
	ô Pegasus = Pegasus
=TEX

Note the lack of copula.
This is of course an instance of the theorem:

=GFT
Ûeq_refl_thmÝ =
	ô µ x· x = x
=TEX

\ignore{
=SML
set_goal([], ¬Pegasus = Pegasus®);
a (rewrite_tac[]);
val Pegasus_eq_lemma1 = save_pop_thm "Pegasus_eq_lemma1";

set_goal([], ¬µx· x=x®);
a (rewrite_tac[]);
val eq_refl_thm = save_pop_thm "eq_refl_thm";
=TEX
}%ignore

To get a nice notation for ``strong'' equality we need to define it as an infix symbol, which requires that the copula be built into the definition.
We could use the $é$ symbol, but this usually represents an equivalence relation which is weaker than identity, so we will subscript the $=$ sign with g, suggesting that it is just the same thing applied through our copula.

=SML
declare_infix (200, "=h");
=TEX

¹HOLCONST
Ü $Û=hÝ : 'a SC ­ 'a SC ­ BOOL
÷üüüüüü
Ü µx y:'a SC· (x =h y) = (Uncurry $=) h2 (x,y)
°

We can now prove:

=GFT
Pegasus_eq_lemma2 =
	ô ³ Pegasus =h Pegasus
=TEX

And must rest content with the qualified rule:

=GFT
Ûeqh_refl_thmÝ =
	ô µ x· Exists h x ¤ x =h x
=TEX

The ``strictness'' of this equality is expressed by the theorem (which would have made a better definition):

=GFT
eqh_strict_thm =
	ô µ x y· x =h y ¤ Exists h x ± Exists h y ± x = y
=TEX

\ignore{
=SML
val eqh_def = get_spec ¬$=h®;

set_goal([], ¬³ Pegasus =h Pegasus®);
a (rewrite_tac[eqh_def, h2_def, Pegasus_def]);
val Pegasus_eq_lemma2 = save_pop_thm "Pegasus_eq_lemma2";

set_goal([], ¬µx· Exists h x ¤ x =h x®);
a (rewrite_tac[eqh_def, h_def, h2_def, Exists_def]);
val eqh_refl_thm = save_pop_thm "eqh_refl_thm";

set_goal([], ¬µx y· x =h y ¤ Exists h x ± Exists h y ± x = y®);
a (rewrite_tac[eqh_def, h_def, h2_def, Exists_def, IsDen_def, IsCorr_def, Corr_def]);
a (REPEAT strip_tac THEN_TRY asm_rewrite_tac[]);
a (fc_tac [sum_clauses]);
a (DROP_ASM_T ¬InL (OutL x) = x® ante_tac THEN asm_rewrite_tac[]);
a (STRIP_T rewrite_thm_tac);
val eqh_strict_thm = save_pop_thm "eqh_strict_thm";
=TEX
}%ignore

The primitive equality in HOL no longer corresponds to Grice's second order definition and the proof of $snd\_order\_eq\_thm$ fails.

=GFT
Ûneg_snd_order_eq_thmÝ =
	ô ³ (µ x y· x = y ¤ (µ P· P h x ¤ P h y))
=TEX

There are two reasons for this.
The first is that there is now more than one possible non-denoting correlate, and Leibniz's formula, applied through the System S copula does not distinguish between them.
The second is the presence of values for failing descriptions.

The values for failing descriptions should not be in the range of quantification, so we do need to have special quantifiers in System S, it will then also be necessary to qualify the quantification to get a version of the second order definition which takes account of possibly distinct non-designating names.



\ignore{
=SML
set_goal([], ¬³ µx y:'a SC· x = y ¤ (µP:'a ­ BOOL· P h x ¤ P h y)®);
a (strip_tac);
a (¶_tac ¬â® THEN strip_tac);
a (¶_tac ¬InR (Åx·T)® THEN strip_tac);
a (lemma_tac ¬³ â = InR (Å x· T)® THEN asm_rewrite_tac [â_def, h_def, IsDen_def, IsCorr_def, Corr_def, â_corr_def]);
val neg_snd_order_eq_thm = save_pop_thm "neg_snd_order_eq_thm";
=TEX
}%ignore

This equivalence fails because we now allow (in fact, require) more than one non-designating value in the domain of an interpretation.

However, if the copula is dropped we still get a working definition of a `weak' equality.

=GFT
Ûsnd_order_eq_thm2Ý =
	ô µ x y· x = y ¤ (µ P· P x ¤ P y)
=TEX

\ignore{
=SML
set_goal([], ¬µx y· x = y ¤ (µP· P x ¤ P y)®);
a (REPEAT strip_tac THEN_TRY all_var_elim_asm_tac);
a (SPEC_NTH_ASM_T 1 ¬Ìx· x = y® (strip_asm_tac o (rewrite_rule[])));
val snd_order_eq_thm2 = save_pop_thm "snd_order_eq_thm2";
=TEX
}%ignore


\section{System S}



\section{Conclusions}
