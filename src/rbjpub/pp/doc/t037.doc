=IGN
val _ =
	let open ReaderWriterSupport.PrettyNames;
	in add_new_symbols [ (["identeq"], Value "\233", Simple) ]
end;
=TEX

\def\rbjidtACNdoc{$$Id: t037.doc,v 1.4 2010/07/13 21:27:46 rbj Exp $$}

I will endeavour to follow the structure of Grice's paper \emph{Vacuous names}\cite{griceVN, quineWO}.
However, the method employed for the formal analysis, which is called ``shallow embedding'', is essentially semantic, and involves addressing semantic fundamentals before finding manageable syntactic presentations, and we therefore find it necessary to address key aspects of the semantics before considering the details of syntactic derivation.

\subsection{Background}

Grice's deliberations about Vacuous Names may be understood primarily against those who have supposed or desired a significant difference between formal logics and the logic of ordinary discourse, by one who felt that the differences are, or need be, modest.
In some of his writings. for example in the ``Retrospective Epilogue'' in \emph{Sudies in the Way of Words}\cite{grice89}, Grice describes two camps, ``Modernists'' and ``Neo-traditionalists'', the former making more and the latter less of the distinctions between formal and ordinary logic.

Elsewhere in Grice's philosophy issues such as the relationship between the logical connectives and their ordinary language counterparts is discussed.
Here we are concerned with the problem of referring expressions lacking a referent.

The modern discussion of this problem begins with Russell \cite{russell1956,russellOD}, who sought formal languages for mathematics which were more precise and more transparent in their logical structure than is ordinary language.

There are two aspects of the problems here at stake which are separable.
One concerns logic and language, how we talk and reason using words or phrases which do not or might not refer to any existent entity.
The second is the metaphysical question of what exists.
Russell's most important work in this area arose from his making a transition away from a lavish Meinongian ontology in which there are different kinds or grades of existence, to the adoption of Occam's razor wherever possible, leading to a spartan ontology.
Key to this is the acceptance that some referring phrases fail to refer, and Russell's principle contribution here is in his theory of descriptions \cite{russell1956,russellOD}.

Russell's theory treats definite and indefinite descriptions as ``incomplete symbols'', which contribute to the meaning of the sentence as a whole even if they fail to refer.
Proper names are then eliminated in favour of descriptions.

Grice's principle aim is to resurrect the conception of names as references, rather than as surrogates for descriptions.
He wants to do this without being forced to regard names of non-existent entities such as Pegasus as yielding sentences which are neither true nor false.
This he achieves by allowing that names which do no designate nevertheless refer to some kind of entity which he calls its correlate, and by the rule that predications to non-designating names are to yield falsehoods.

Grice's Vacuous names may be seen in the first instance as a reaction against Russell's theory of descriptions, the principle aim b

\subsection{Preliminary Formalities}

Just in case I need multiple incompatible accounts I have a ``top level'' theory under which all other gricean theories will be placed and in which common aspects can be placed.

=SML
open_theory "rbjmisc";
force_new_theory "grice";
=TEX

\ignore{
=SML
force_new_pc Û"'grice"Ý;
merge_pcs ["'savedthm_cs_¶_proof"] "'grice";
set_merge_pcs ["rbjmisc", "'grice"];
=TEX
}%ignore

\section{The Problem}\label{G1}

Grice uses several lists in his presentation.
To simplify unambiguous reference I have prefixed some of the numbering schemes with capital letters.

Our starting point is a list of eight \emph{inclinations} supplied by Grice and summarised here:

\begin{itemize}\label{inclinations}\index{inclinations}
\item[I1] That individual constants be admitted.
\item[I2] Note that names are sometimes ``vacuous''
\item[I3] Thence that a constant might lack a designatum.
\item[I4] That excluded middle and bivalence nevertheless remain unqualified.
\item[I5] That a claim about (predication to) a non-designating constant be false and its negation true.
\item[I6] That no unusual constraints on ``U.I.'' \footnote{Universal Instantiation} and ``E.G.'' \footnote{Existential Generalisation} be introduced.
\item[I7] That the law of identity (in the form $µx· x=x$) be a theorem\footnote{Which seems to suggest that identity is not a predicate.}.
\item[I8] That derivability implies entailment.\footnote{i.e. that the system be sound!}
\end{itemize}

In relation to these Grice points out two \emph{difficulties} as follows:

\begin{itemize}\label{difficulties}\index{difficulties}
\item[(a)] I2, I3 and I7 between them seem prima facie to enable proofs of the existence of non-existent entities (e.g. ``Pegasus exists'').

\item[(b)] I5 and I6 would if gratified permit us to infer that there exists something which does not fly from the premise that Pegasus does not exist.

\end{itemize}

He then lists five possible \emph{resolutions} the difficulties:

\begin{itemize}\label{resolutions}\index{resolutions}
\item[R1] To resist I3 and insists that constants have a designatum.
\item[R2] Resisting I4 and I5, insist that a predication to a non designating term and their negations lack a truth value. 
\item[R3] Resist I1 and do without individual constants.
\item[R4] Resist I2 by insisting that all constants have a desgnatum, which might perhaps ``be'' without existing.
\item[R5] Resist I6 by adding requirements on existential generalisation that the relevant constant be shown to designate.
\item[R6] Resist I8, allowing that the deductive system be not strictly sound, but only so subject to the constants used as in 6 designating.
\end{itemize}

Grice does not discuss any of these alternatives, but instead proposes to attempt to square the circle by devising a system which satisfies all these (apparently) incompatible inclinations.

\section{System Q: Objectives}

Grice now proposes a first order predicate calculus meeting two particular objectives, spelt out in five points of further detail.

\begin{itemize}\label{objectives}\index{objectives}
\item[(i)] That a sentence such as ``Pegasus does not fly'' be capable of rendition in two distinct ways one of which will be true and the other false in the case that Peagasus does not exist. 
These correpond to disambiguations of the logical structure of the sentence either as predicating non-flying or denying a predication as flying.
\item[(ii)] That in either case the inference from ``Pegasus does not fly'' to ``there is something which does not fly'' is to be admitted.
\end{itemize}

\begin{itemize}\label{objectivesdetailed}\index{objectives!detailed}
\item[O1] U.I. and E.G. are acceptable without special side conditions.
\item[O2] Some sentences involving non-denoting constants will be true and provable.
\item[O3] It will be formally decidable whether a sentence depends for its truth on whether some constant designates.
\item[O4] It will be possible to find in Q representation of sentences such as ``Pegasus exists''.
\item[O5] There will be an extension of Q in which identity is represented.\footnote{No discussion here of whether identity is a predicate.}
\end{itemize}

\section{Scope}

A part of the novelty and difficulty in system Q lies in its special provisions for controlling the ``scope'' of names.

The use of the word scope in this context is distinct from its more common usage (at least in mathematical logic and computer science) in which the (or a) scope of a name (variable or constant) is a syntactic region within which it may be used with the same sense (as opposed to uses of the same name for entirely distinct purposes as may appear in different scopes of the name).

In this case the relevant ambiguity of scope is not a region of significance of the name, but the extent of some predicate applied to the name.
Thus in the example used by Grice, there is an ambiguity in the sentence ``Pegasus does not fly'' about the logical structure of the sentence which leaves doubt about what predicate is being applied to Pegasus.
We may regard the sentences as predicating ``x does not fly'' of Pegasus, or we may be denying that the predicate ``flies'' applies to Pegasus.
The question is whether the negation is part of the predicate or is applied to the result of the predication.

In System Q Grice provides a predicate logic in which numerical subscripts may be used to disambiguate the predications which are taking place.
Unfortunately, this notation, like the dot notation in Principia Mathematica is not as readable as the more usual use of brackets for disambiguating scope.
Furthermore, this aspect of the syntax would be hard to replicate by the methods we propose to adopt, which are intended to permit a lightweight analysis of semantic issues and their connection with the validity of sentences and the soundness of derivations.

In our analysis we will therefore provide for the desired control over predication by the use of Church's lambda notation.
We expect that our syntax will be readily related to that of System Q, but since the system we formalise is at least syntactically distinct we will call it system C\footnote{This in homage to Rudolf Carnap, Q having been chosen by Grice in homage to Quine, and G (of which more anon) having been chosen by Myro in homage to Grice.}.

System C is obtained by conservative extension to HOL, which is a version of higher order logic derived directly from Church's Simple Theory of Types \cite{church40}. distinctive for its very slender logical core, achieved by building the logical system from the simply typed lambda calculus.
In this logical system boolean valued functions serve for predication, and the ideas of Grice on vacuous names are realised principally by defining a different kind of predication.
To minimise confusion, the word predicate will only be used when Grice's notion of predication is intended, otherwise propositional or boolean valued function will be used.


The use of lambda notation for making explicit the predicate to be applied may be illustrated simply using Grice's Pegasus example.
We adopt a special notation for Grice's new kind of predication which will be an infix subscript g ``$‰g$'', so the application of the predicate ``$Flies$'' to the term ``$Pegasus$'' will be written%
=INLINEFT
``Flies ‰g Pegasus''
=TEX
.

The subscript g is used just for the special kind of predication in which the object may possibly not exist, we still have the old fashioned kind which will be used in the lambda calculus possibly in defining complex predicates for application in the new manner.

The two variants of ``Pegasus does not fly'' are then expressed as
=INLINEFT
``³ (Flies ‰g Pegasus)''
=TEX
 and
=INLINEFT
``(Ìx· ³ Flies x) ‰g Pegasus''
=TEX
.
In the first case the predicate applied to Pegasus is $¬Flies®$, in the second case it is $¬Ìx· ³ Flies x®$ (which is a negation of Flies).

This technique makes it possible to examine the semantic aspects of System Q using formal machine assisted deductive reasoning, while avoiding the special intricacies of formalising Grice's special syntax.
Whether this pays off in terms of perspicuity and penetration in the analysis remains to be seen.

We will therefore offer no further discussion of Grices notational devices for scoping at this point, but may consider later how much may have been lost by this approach.

\section{Deductive Systems}

\subsection{Glossary}

\subsection{Symbols}

\subsection{Formulae}

\subsection{Inference-Rules}

\section{Semantics for Q and C}

Grice goes on from his discussions of scope to the presentation of the remaining aspects of the syntax, notably of the various aspects of the deductive system.

We will track this discussion of inference in a semantic way, demonstrating the semantic principles which ensure the soundness of the deductive system presented in a manner which makes reasonably clear the relationship between the two.
This amounts to a semantic embedding into HOL of a system which is intended to be semantically parallel to system Q, though not syntactically quite the same.

To do this we must first provide some basic definitions on which the semantics is based, and before doing that I must explain part of the method of semantic embedding which might seem to, but does not in fact, prejudice one of the principle issues at stake.
That is that the embedding consists in a development of a semantics which is purely denotational, i.e. in which every expression has a denotatum.
These denotation need not be what one would naturally suppose the reference of an expression to be, they may be purely abstract surrogates which suffice to describe the truth conditions of the language.
So the way we model a language in which term expressions may not denote, is by taking the range of things which they might possibly denote, and adding one or more extra items which are values which they are give to indicate that they have no denotation.

\subsection{Interpretations in Q and C}

Grice's definition of an interpretation of Q (VIII A of \cite{griceVN}) is ambiguous in what it says about the domain of an interpretation.
The domain is a set of correlates, some of which may be unit sets the element of which is a designatum.
Grice tells us that there need not be any such unit sets, but does not say explicitly that there may be no other correlates.
He does tell us that he has in mind that there will be exactly one non-designating correlate, the empty set, but he does not place this as a requirement, so the significance of his having this in mind is unclear.

There are three possibilities concerning the number of non-designating correlates in an interpretation, that there are none, exactly one, or more than one.
In relation to these there are a number of possible positions in relation to the definition of an interpretation, the most obvious are:

\begin{enumerate}
\item no constraint
\item there must be at least one
\item there must be exactly one
\end{enumerate}

Of course there may be more, but I propose to discuss just these three.

From a literal reading of Grice in this section I would take the first.
However, from the fact that he explicitly allows there to be no designata but does not explicitly say this for non-designating correlates, we might infer that he intends  but does not state that there will be at least one non-designating correlate.
Alternatively we might take the case he had in mind more presciptively and work with item 3.

These are significant semantically, of course.

Allowing interpretations with no designata will create problems with descriptions if these were to be introduced into Q, for one would then have no correlate available for a non-designating descriptions.
It also affects a matter which Grice later discusses, which is whether certain existential claims are valid, notably the claim that there is something which does not exist.
This (or something similar
=INLINEFT
``¶x‰4· ³‰3 F‰1 x‰2''
=TEX
, VIII B p137) Grice later claims to be valid, and this is evidence against interpretation 1 in favour of 2 or 3.

Item 2, though the one perhaps preferred by Grice, has the disadvantage that all non-designating terms have the same correlate, and will therefore be equal in a sense of equality which satisfies the universal law of reflexivity of identity.
Do we want Pegasus and Sherlock Holmes to be identical?

Nevertheless, in our shallow embedding of Q we will adopt 2, for in addition to its being preferred by Grice in some sense, and its confirming Grice's belief in the validity of the cited existentials, it allows a simpler and more transparent shallow embedding than either of the others.
\emph{[fuller explanation to be supplied]}

First let us give a name for the domain of discourse of an interpretation of the language $Q$.
We will suppose this to be a ``type'' in HOL, but will leave open the type by using a type variable.
To serve as denotions for terms in system $G_{HP}$ we use a disjoint union of two types, the first of which is the type of those things which do exist and the second is atype of surrogates for those things which do not exist.
We use \emph{V} for Value.

A new theory is needed which I will call ``sysc'' which is created here:

=SML
open_theory "grice";
force_new_theory "sysc";
set_pc "rbjmisc";
=TEX

Grice introduces a special notion of interpretation in terms of which to give the semantics of Q.
An interpretation has a domain which is a set of correlates, some of which are unit sets, in which case the member of that unit set is called a designatum.
For uniformity type we assume that all correlates are sets of sets.

We allow the domain of an interpretation to be any type and for any element of that type to be identified as THE non-designating element.

¹HOLCONST
Ü ÛâÝ: 'a 
÷üüüüüü
Ü T
°

We can then use inequality with $â$ as the property of being a designatum.
The structure of these interpretations is isomorphic to that of Grice's preferred notion of interpretation, even though we do not use unit sets for correlates of designating constants.

We may use HOL constants of appropriate type for Q constants and predicates, and HOL variables for Q variables, and the consequence should be that the theorems provable in HOL should be just those which are valid in Q.

This is done by using T and F instead of Corr(1) and Corr(0) respectively.

Now we define our special kind of predication.

=SML
declare_infix (400, "‰g");
=TEX

¹HOLCONST
Ü $‰g: ('a ­ BOOL) ­ 'a ­ BOOL
÷üüüüüü
Ü µ p t· p ‰g t ¤ if t = â then F else p t
°

The definition says, if the term denotes then apply the predicate to the value denoted, otherwise the result of the predication is F (false).

Note that this will not work for relations, we would have to define a separate similar predicator for each arity of relation in use.

Now let's introduce Pegasus.
The ``definition'' just says that Pegasus is the non-denoting value.

¹HOLCONST
Ü ÛPegasusÝ : 'a
÷üüüüüü
Ü Pegasus = â
°

And the predicate \emph{Flies}.
Note that the predicates apply only to real desigata under the normal HOL application, its only under our special predication that they become applicatble to possibly non denoting values.

¹HOLCONST
Ü ÛFliesÝ : 'a ­ BOOL
÷üüüüüü
Ü T
°

We can now prove in HOL the elementary facts we know about Pegasus flying, yielding the following theorems:

=GFT
ÛPegasus_lemma_1Ý =
	ô Flies ‰g Pegasus ¤ F

ÛPegasus_lemma_2Ý =
	ô (Ì x· ³ Flies x) ‰g Pegasus = F

ÛPegasus_lemma_3Ý =
	ô ³ Flies ‰g Pegasus

ÛPegasus_lemma_4Ý =
	ô ³ (Ì x· ³ Flies x) ‰g Pegasus
=TEX

\ignore{
=SML
val g_def = get_spec ¬$‰g®;
val Pegasus_def = get_spec ¬Pegasus®;
val Flies_def = get_spec ¬Flies®;

set_goal([], ¬Flies ‰g Pegasus ¤ F®);
a (rewrite_tac [g_def, Pegasus_def]);
val Pegasus_lemma_1 = save_pop_thm "Pegasus_lemma_1";

set_goal([], ¬(Ìx· ³ Flies x) ‰g Pegasus ¤ F®);
a (rewrite_tac [g_def, Pegasus_def]);
val Pegasus_lemma_2 = save_pop_thm "Pegasus_lemma_2";

set_goal([], ¬³ Flies ‰g Pegasus®);
a (rewrite_tac [g_def, Pegasus_def]);
val Pegasus_lemma_3 = save_pop_thm "Pegasus_lemma_3";

set_goal([], ¬³ (Ìx· ³ Flies x) ‰g Pegasus®);
a (rewrite_tac [g_def, Pegasus_def]);
val Pegasus_lemma_4 = save_pop_thm "Pegasus_lemma_4";
=TEX
}%ignore

In case you may doubt the neutrality of our use of lambda expressions, we show here that they are inessential to this approach, and can be dispensed with in favour of explict definitions of the predicates required.
Thus we may instead define a predicate which is the denial of \emph{Flies}:

¹HOLCONST
Ü ÛDoesnt_FlyÝ : 'a ­ BOOL
÷üüüüüü
Ü µx· Doesnt_Fly x ¤ ³ Flies x
°

We can then prove the slightly reworded:

=GFT
ÛPegasus_lemma_5Ý = ô Doesnt_Fly ‰g Pegasus ¤ F
=TEX

the proof of which need not mention the predicate, since it suffices to know that the subject does not exist.

\ignore{
=SML
set_goal([], ¬Doesnt_Fly ‰g Pegasus ¤ F®);
a (rewrite_tac [g_def, Pegasus_def]);
val Pegasus_lemma_5 = save_pop_thm "Pegasus_lemma_5";
=TEX
}%ignore

This general claim can be expressed in HOL and proven.
To make it read sensibly however, it is best for us to define the relevant notion of existence.

¹HOLCONST
Ü ÛExistsÝ : 'a ­ BOOL
÷üüüüüü
Ü µx· Exists x ¤ T
°

The definition looks a bit bizarre and works for just the same reason that we do not need to know the predicate to know that predication to a non-existent will be false.
This predicate will always be true, unless it is applied to a term which fails to denote.
So we satisfy another of Grice's desiderata, that the non-existence of Pegasus can be stated.

But first a more general result:

=GFT
ÛExists_lemma_1Ý =
	ô µ P x· ³ Exists ‰g x ´ ³ P ‰g x
=TEX

\ignore{
=SML
val Exists_def = get_spec ¬Exists®;

set_goal([], ¬µP x· ³ (Exists ‰g x) ´ ³ (P ‰g x)®);
a (REPEAT µ_tac THEN rewrite_tac [g_def, Exists_def]
	THEN REPEAT strip_tac);
val Exists_lemma_1 = save_pop_thm "Exists_lemma_1";
=TEX
}%ignore

Desideratum A8 is satisfied by the standard quantifiers in HOL.

=GFT
Û¶_lemma_1Ý = 
	ô µ P· P ‰g Pegasus ´ (¶ x· P ‰g x)

Ûµ_lemma_1Ý =
	ô µ P· (µ x· P ‰g x) ´ P ‰g Pegasus
=TEX

\ignore{
=SML
set_goal([], ¬µP:'a ­ BOOL· P ‰g (Pegasus:'a) ´ ¶x:'a· P ‰g x®);
a (REPEAT strip_tac);
a (¶_tac ¬Pegasus®);
a (asm_rewrite_tac []);
val ¶_lemma_1 = save_pop_thm "¶_lemma_1";

set_goal([], ¬µP· (µx· P ‰g x) ´ P ‰g Pegasus®);
a (REPEAT strip_tac);
a (asm_rewrite_tac []);
val µ_lemma_1 = save_pop_thm "µ_lemma_1";
=TEX
}%ignore


\ignore{
=SML
force_new_pc "'ghp1";
merge_pcs ["'savedthm_cs_¶_proof"] "'ghp1";
set_merge_pcs ["rbjmisc", "'ghp1"];
=TEX
}%ignore

\subsection{IVB-3 Inference-Rules}

Since we are working with a semantic embedding rather than a syntactic meta-theory we cannot prove results about derivations and instead present proofs about the semantics which show that the required inference rules would be sound.

To do this we adopt a notation for expressing entailment in C in a manner parallel to the presentation of the natural deduction system of Q

=SML
declare_infix(4, "˜");
=TEX

¹HOLCONST
Ü $˜ : BOOL LIST ­ BOOL ­ BOOL
÷üüüüüü
Ü µal c· (al ˜ c) ¤ (µ‰L al) ´ c
°

In the following theorems which capture the content of Grices rules for Q as theorems of C, the variables Æ, Ù, Ú... range over formulae (booleans) and ‡, „, Š... over lists of formulae.
The notation ``[a; b; ...]'' is an explicit list formation (``[Æ]'' being a single element list) and the symbol ``$ë$'' is the concatenation operator over lists.

In general the rules of Q can be formulated as theorems of C because C is a higher order logic, and can quantify over predicates.
This means that where substition is involved in a rule, this is captured as a theorem by the use of a variable as a predicate applied to a variable as an argument.
When such a theorem is instantiated using a lambda expression as the predicate, the substitution into the expression will be achieved by beta-reduction.

=GFT
ÛASSÝ =	ô µ Æ· [Æ] ˜ Æ
ÛRAAÝ =	ô µÆ Ù Ú ‡· ([Æ] ë ‡ ˜ Ù ± ³Ù) ´ (‡ ˜ ³Æ)
ÛDNÝ =	ô µ Æ· [³ ³ Æ] ˜ Æ
Û±IÝ =		ô µ Æ Ù· [Æ; Ù] ˜ Æ ± Ù
Û±EÝ =	ô µ Æ Ù· ([Æ ± Ù] ˜ Æ) ± ([Æ ± Ù] ˜ Ù)
Û²IÝ =		ô µ Æ Ù Ú ‡ „ Š· ([Æ] ë ‡ ˜ Ú) ± ([Ù] ë „ ˜ Ú) ± (Š ˜ Æ ² Ù)
			´ (‡ ë „ ë Š ˜ Ú)
Û²EÝ =	ô µ Æ Ù· ([Æ] ˜ Æ ² Ù) ± ([Æ] ˜ Ù ² Æ)
ÛCPÝ =	ô µ Æ Ù ‡· ([Æ] ë ‡ ˜ Ù) ´ (‡ ˜ Æ ´ Ù)
ÛMPPÝ =	ô µ Æ Ù· [Æ ´ Ù; Æ] ˜ Ù
ÛµIÝ =		ô µ ‡ P· (µ x· ‡ ˜ P x) ´ (‡ ˜ (µ x· P x))
ÛµEÝ =	ô µ ‡ P c· (‡ ˜ (µ x· P x)) ´ (‡ ˜ P c)
Û¶IÝ =		ô µ ‡ P x· (‡ ˜ P x) ´ (‡ ˜ (¶ x· P x))
Û¶EÝ =	ô µ ‡ P c x· (P x ˜ ‡) ´ (¶ x· P x ˜ ‡)
=TEX

\ignore{
=SML
val ˜_def = get_spec ¬$˜®;

set_goal([], ¬µÆ· [Æ] ˜ Æ®);
a (rewrite_tac [˜_def] THEN REPEAT strip_tac);
val ASS = save_pop_thm "ASS";

set_goal([], ¬µÆ Ù Ú ‡· ([Æ]ë ‡ ˜ Ù ± ³Ù) ´ (‡ ˜ ³Æ)®);
a (rewrite_tac [˜_def, append_def, µ‰L_def, fold_def] THEN REPEAT strip_tac);
val RAA = save_pop_thm "RAA";

set_goal([], ¬µÆ· [³³Æ] ˜ Æ®);
a (rewrite_tac [˜_def] THEN REPEAT strip_tac);
val DN = save_pop_thm "DN";

set_goal([], ¬µÆ Ù· [Æ; Ù] ˜ Æ ± Ù®);
a (rewrite_tac [˜_def, µ‰L_def, fold_def] THEN REPEAT strip_tac);
val ±I = save_pop_thm "±I";

set_goal([], ¬µÆ Ù· ([Æ ± Ù] ˜ Æ) ± ([Æ ± Ù] ˜ Ù)®);
a (rewrite_tac [˜_def, µ‰L_def, fold_def] THEN REPEAT strip_tac);
val ±E = save_pop_thm "±E";

set_goal([], ¬µÆ Ù· ([Æ] ˜ Æ ² Ù) ± ([Æ] ˜ Ù ² Æ)®);
a (rewrite_tac [˜_def, µ‰L_def, fold_def] THEN REPEAT strip_tac);
val ²E = save_pop_thm "²E";

set_goal([], ¬µÆ Ù (Ú:BOOL) (‡:BOOL LIST) („:BOOL LIST) (Š:BOOL LIST)· ([Æ]ë ‡ ˜ Ú) ± ([Ù]ë „ ˜ Ú) ± (Š ˜ Æ ² Ù) ´ (‡ ë „ ë Š ˜ Ú)®);
a (rewrite_tac [˜_def] THEN REPEAT strip_tac);
val ²I = save_pop_thm "²I";

set_goal([], ¬µÆ Ù ‡· ([Æ]ë ‡ ˜ Ù) ´ (‡ ˜ Æ ´ Ù)®);
a (rewrite_tac [˜_def, append_def, µ‰L_def, fold_def] THEN REPEAT strip_tac);
val CP = save_pop_thm "CP";

set_goal([], ¬µÆ Ù· ([Æ ´ Ù; Æ] ˜ Ù)®);
a (rewrite_tac [˜_def, append_def, µ‰L_def, fold_def] THEN REPEAT strip_tac);
val MPP = save_pop_thm "MPP";

set_goal([], ¬µ ‡ P· (µx· (‡ ˜ P x)) ´ (‡ ˜ µx· P x)®);
a (rewrite_tac [˜_def] THEN REPEAT strip_tac THEN asm_fc_tac[] THEN asm_rewrite_tac[]);
val µI = save_pop_thm "µI";

set_goal([], ¬µ ‡ P c· (‡ ˜ µx· P x) ´ (‡ ˜ P c)®);
a (rewrite_tac [˜_def] THEN REPEAT strip_tac THEN asm_fc_tac[] THEN asm_rewrite_tac[]);
val µE = save_pop_thm "µE";

set_goal([], ¬µ ‡ P x· (‡ ˜ P x) ´ (‡ ˜ ¶x· P x)®);
a (rewrite_tac [˜_def] THEN REPEAT strip_tac);
a (¶_tac ¬x® THEN asm_rewrite_tac[]);
val ¶I = save_pop_thm "¶I";

set_goal([], ¬µ ‡ P c x· (P x ˜ ‡) ´ (¶x· P x ˜ ‡)®);
a (rewrite_tac [˜_def] THEN REPEAT strip_tac);
a (¶_tac ¬x® THEN asm_rewrite_tac[]);
a (asm_rewrite_tac[]);
val ¶E = save_pop_thm "¶E";
=TEX
}%ignore

An example of the effect of substitutions obtained by use of these theorems in C intended to mimic the rules of Q is as follows.

Take ths simple case of $µE$, with the predicate
=INLINEFT
``Ìx· ³ Flies ‰g x''
=TEX
 which we seek to instantiate to Pegasus.

We can specialise $µE$ to this case like this:
=SML
val sve = list_µ_elim [¬[]:BOOL LIST®, ¬Ìx· ³ Flies ‰g x®, ¬Pegasus®] µE;
=TEX

This gives the theorem:

=GFT
val sve =
   ô ([] ˜ (µ x· (Ì x· ³ Flies ‰g x) x)) ´ ([] ˜ (Ì x· ³ Flies ‰g x) Pegasus) : THM
=TEX

in which there are two occurrences of the lambda expression in the places previously occupied by the variable $P$.

The substitutions can the be effected by beta reduction which can be achieved by rewriting the theorem as follows:

=SML
rewrite_rule [] sve;
=TEX

Which yields a theorem justifying the required inference.

=GFT
val it = ô ([] ˜ (µ x· ³ Flies ‰g x)) ´ ([] ˜ ³ Flies ‰g Pegasus) : THM
=TEX

All the above rules simply explicate the standard aspects of the logic of Q and C and do not reflect the specific additional features which Grice requires in connection with vacuous names.
They simply illustrate that the logical context for C includes as much standard logic as is provided in Q, and provide some tenuous indication that Grice's rules conform to standard logic as defined in Church's simple theory of types.
The main risk for Grice is in the detail of his presentation, bearing in mind the additional complexities arising from his suffix notation, and the above exercise offers no assurance in that matter.

\section{V. Existence}

\subsection{A}

We have already defined the propositional function ``Exists'' which tells us whether a name designates.

The following theorem indicates that the propositional function captures the intent of Grice's ``+exists'' notation.

=GFT
ÛE1Ý =	ô µ Æ Á· Æ ‰g Á ´ Exists Á
=TEX

\ignore{
=SML
set_goal([], ¬µÆ Á· Æ ‰g Á ´ Exists Á®);
a (REPEAT µ_tac THEN rewrite_tac [Exists_def, get_spec ¬$‰g®]);
val E1 = save_pop_thm "E1";
=TEX
}%ignore

In system C Grice's notion of \emph{E\_committal} seems to be definable.
The formal criteria for \emph{E\_committal} then becomes provability in HOL (which is not decidable).

In Grice \emph{E\_committal} is a relationship, here it is a property of propositional functions.

¹HOLCONST
Ü ÛE_committalÝ : ('a ­ BOOL) ­ BOOL
÷üüüüüü
Ü µÆ· E_committal Æ ¤ µÁ· Æ Á ´ Exists Á
°

The following theorems correspond to clauses in Grice's definition of \emph{E\_committal}:

=GFT
ÛE_2Ý =	ô µ Æ· E_committal Æ
			´ E_committal (ÌÁ· ³ ³ Æ Á)
ÛE_3Ý =	ô µ Æ Ù· E_committal Æ ² E_committal Ù
			´ E_committal (Ì Á· Æ Á ± Ù Á)
ÛE_4Ý =	ô µ Æ Ù· E_committal Æ ± E_committal Ù
			´ E_committal (Ì Á· Æ Á ² Ù Á)
ÛE_5Ý =	ô µ Æ Ù· E_committal (Ì Á· ³ Æ Á) ± E_committal Ù
			´ E_committal (Ì Á· Æ Á ´ Ù Á)
ÛE_6µÝ =	ô µ Æ· (¶ Â· E_committal (Æ Â))
			´ E_committal (Ì Á· µ Â· Æ Â Á)
=TEX

I have a problem proving the existential element of (6), so this clause is in doubt.
I think Grice should be asking for ``%
=INLINEFT
µÂ· Ù(Â/×)
=TEX
'' to be \emph{E\_committal} for Á (in system Q), which corresponds in system C to the theorem:

=GFT
ÛE_6¶bÝ =	ô µ Æ· (µ Â· E_committal (Æ Â))
			´ E_committal (Ì Á· ¶ Â· Æ Â Á)
=TEX

\ignore{
=SML
val E_committal_def = get_spec ¬E_committal®;

set_goal([], ¬µÆ· E_committal Æ ´ E_committal (ÌÁ· ³ ³ (Æ Á))®);
a (REPEAT strip_tac THEN asm_rewrite_tac[È_axiom]);
val E_2 = save_pop_thm "E_2";

set_goal([], ¬µÆ Ù· E_committal Æ ² E_committal Ù ´ E_committal (ÌÁ· Æ Á ± Ù Á)®);
a (REPEAT µ_tac THEN rewrite_tac[E_committal_def] THEN REPEAT strip_tac THEN asm_fc_tac[]);
val E_3 = save_pop_thm "E_3";

set_goal([], ¬µÆ Ù· E_committal Æ ± E_committal Ù ´ E_committal (ÌÁ· Æ Á ² Ù Á)®);
a (REPEAT µ_tac THEN rewrite_tac[E_committal_def] THEN REPEAT strip_tac THEN asm_fc_tac[]);
val E_4 = save_pop_thm "E_4";

set_goal([], ¬µÆ Ù· E_committal (ÌÁ· ³ (Æ Á)) ± E_committal Ù ´ E_committal (ÌÁ· Æ Á ´ Ù Á)®);
a (REPEAT µ_tac THEN rewrite_tac[E_committal_def] THEN REPEAT strip_tac THEN asm_fc_tac[]);
val E_5 = save_pop_thm "E_5";

set_goal([], ¬µÆ· (¶Â· E_committal (Æ Â)) ´ E_committal (ÌÁ· µÂ· (Æ Â) Á)®);
a (REPEAT µ_tac THEN rewrite_tac[E_committal_def] THEN REPEAT strip_tac);
a (spec_nth_asm_tac 1 ¬Â® THEN asm_fc_tac[]);
val E_6µ = save_pop_thm "E_6µ";

set_goal([], ¬µÆ· (µÂ· E_committal (Æ Â)) ´ E_committal (ÌÁ· ¶Â· (Æ Â) Á)®);
a (REPEAT µ_tac THEN rewrite_tac[E_committal_def] THEN REPEAT strip_tac);
a (asm_fc_tac[]);
val E_6¶b = save_pop_thm "E_6¶b";
=TEX
}%ignore


The definition we have already given for \emph{Exists} is similar in character and identical in effect to Grices suggestions for \emph{+exists}.

\subsection{B. ¶ Quantified Formulae}

This has already been covered.

Grice wishes to distinguish himself from Meinong, but his system allows quantification over non-existents, and he can therefore only distinguish himself from Meinong by distancing himself also from Quine's criteria of ontological committment.
This he could easily do by adopting Carnap's distinction between internal and external questions, and denying that any metaphysical significance attaches to something being counted in the range of quantification.

\section{Objections Considered}

I will offer some discussion of Grice's problem here and then offer some of my own.

\section{Identity}

HOL already has identity and this identity is good for System C.
It HOL it is a curried propositional function of polymorphic type ”'a ­ 'a ­ BOOL®.
If applied using function application the universal law of reflexivity holds.

To get a ``strict'' version of equality (i.e. one which is false when either argument does not exist) it is necessary to uncurry equality so that its type becomes ”('a ¸ 'a) ­ BOOL® and apply it using a special system C predicator for binary relations.

This will not yield the same two notions of identity discussed by Grice, which will have to be further discussed here.

\section{Semantics}

\section{Names and Descriptions}

\section{Conclusions}
