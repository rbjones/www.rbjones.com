=IGN
$Id: t007.doc,v 1.19 2008/07/27 19:56:06 rbj Exp $
open_theory "fixp";
set_merge_pcs["basic_hol1", "'sets_alg", "'Ø", "'savedthm_cs_∂_proof"];
=TEX
\documentclass[11pt,a4paper]{article}
\usepackage{latexsym}
\usepackage{ProofPower}
\ftlinepenalty=9999
\tabstop=0.25in
\usepackage{A4}
\def\Hide#1{\relax}
\newcommand{\ignore}[1]{}

\title{Inductive, Co-inductive and Pseudo-(Co-)Inductive Definitions in ProofPower}
\makeindex
\author{Roger Bishop Jones\\rbj01@rbjones.com}
\date{\ }
\usepackage[unicode,pdftex]{hyperref}
\hypersetup{pdfauthor={Roger Bishop Jones}}
\hypersetup{colorlinks=true, urlcolor=black, citecolor=black, filecolor=black, linkcolor=black}

\begin{document}
\vfill
\maketitle
\begin{abstract}
Systematic facilities for a range of different kinds of inductive and co-inductive definitions of sets and types in ProofPower HOL.
\end{abstract}

\vfill

\begin{centering}

{\footnotesize

Created 2004/07/15

Last Change $ $Date: 2008/07/27 19:56:06 $ $

\href{http://www.rbjones.com/rbjpub/pp/doc/t007.pdf}
{http://www.rbjones.com/rbjpub/pp/doc/t007.pdf}

$ $Id: t007.doc,v 1.19 2008/07/27 19:56:06 rbj Exp $ $

\copyright\ Roger Bishop Jones; Licenced under Gnu LGPL

}%footnotesize

\end{centering}

\newpage
{\parskip=0pt\tableofcontents}

%%%%

{\raggedright
\bibliographystyle{fmu}
\bibliography{rbj,fmu}
} %\raggedright

\newpage
\section{INTRODUCTION}

Inductive definitions are so pervasive and diverse in logic, mathematics and computer science that it is doubtful that a comprehensive account could be given.
In this document I attempt to provide support for some kinds of inductive type definition commonly used in computing at the same time as facilitating various other kinds of inductive definition of sets which are relevant to my interests in set theory and foundational studies.
Some interest for me and perhaps some novelty for the reader may arise from the ecclectic mix of applications through which I have attempted to find common threads.

I began with a proof of the ``Knaster-Tarski'' theorem asserting that monotone functions over some power set have greatest and least fixed points, and this does provide at least one point common to all the material.

\subsection{Pre-Topologies, Closures and Interiors}

I'm groping here for the best language for describing what's going on.

It is natural to consider inductive definitions as arising from closures, and closure as a topological concept, though in fact the notion of closure is strictly broader than its use in topology.
I have adopted apparently topological terminology where that seems appropriate, primarily by taking ``open'' as a dual for ``closed'' even in our present non-topological context.
The kind of closure of interest here is strictly pre-topological, in the sense that these structures belong to a kind which is broader than the notion of topology (let's for the while call this a ``pre-topology''), and all the interesting cases from our present perspective are pre-topologies which are not actually topologies.

To make this explanation more informative let us chose a definition of pre-topology.
It won't do to generalise the idea of a topology as a set of open sets, because a pre-topology is not determined by its set of open sets.
What we do instead is generalise the notion of a limit to that of an operator, or the notion of a limit point to that of a point of closure.

Think of a topology as being determined by a (monotonic) function which maps each subset of some universe into its closure, i.e. the smallest enclosing set which contains all its limit points.
Such a map tells you what the open sets are (they are the complements of fixed points of the function), but not every such map determines a topology.
It will fail to do so if, as in all the cases of present interest, the empty set is not one of its fixed points.

This gives a generalised notion of open and closed, which is perhaps best spoken of by using ``closure point'' as a generalisation of ``limit point''.
A set is open if all its members are a among its closure points, and closed if it contains all its closure points.

In the pre-topologies of interest to us the empty set is never closed nor the universal set open.
There are really only two sets in a pre-topology which are of interest from our present point of view, the closure of the empty set, which is the set defined inductively by the pre-topology, and the interior of the universal set, which is the set defined co-inductively by the pre-topology.

Having thus explained our talk of closures and interiors, we will have no further use for the notion of a pre-topology, and will work only with sets of operators, which may be thought of as defining pre-topologies in relation to which talk of closures and interiors may be understood.

\subsection{Related Work}

For a general introduction to inductive definitions see Aczel \cite{aczel77}.

This work is conducted in a proof tool for higher order logic after the manner of LCF, and the literature concerning inductive definitions in similar contexts is therefore relevant.
Several papers by Larry Paulson fall into this category, for example \cite{paulson00}, in which may be found a more comprehensive guide to related work.
I am aware of having taken from Paulson the idea of using the Knaster-Tarski fixedpoint theorem, but it is probable that his contribution, direct or indirect, is pervasive.

The particular system I have used is {\Product}, in relation to which the problem of ``Free Types'' in the Z specification language is relevant, and is discussed by Rob Arthan in \cite{Arthan91c}.
So far however, the present work does not support any facilities specific to Z.

\subsection{Intended Applications}

Three kinds of application are approached:

\begin{enumerate}
\item support for defining (mutual) recursive datatypes where the character of the constructors is known but no particular types are known over which the constructions operate.
\item similar features for use in a context like set theory (in higher order logic) where it is essential to code up the constructors in that context (for example as required to prove Tarski's result about the definability of arithmetic or set theoretic truth in the languages of arithmetic or set theory).
\item support for a generalisation of what set theorists call ``Hereditarily P'' sets, i.e. sets which have property P all of whose members have property ``Hereditarily P''.
The generalisation is to allow the constituents which must have the property to be defined other than by plain membership, as for example, in the ``hereditarily pure functions'', even though the members of such a function are not themselves functions (because of the way functions are usually coded up in set theory).
In this case the relevant constutuents are the members of the domain and range of the function.
\end{enumerate}

\subsection{Formalities}

Create new theory ``fixp''.

=SML
open_theory "rbjmisc";
force_new_theory "fixp";
new_parent "U_orders";
new_parent "wf_relp";
set_merge_pcs["hol", "'savedthm_cs_∂_proof"];
=IGN
set_pc "hol";
set_merge_pcs["basic_hol1", "'sets_alg", "'Ø", "'savedthm_cs_∂_proof"];
set_flag ("pp_use_alias", false);
=TEX

\section{ORDERS AND BOUNDS}

We need to talk about greatest lower bounds etc.
This would have gone in ``ordered\_sets'' but it doesn't follow the general treatment their, so for the time being its here.

First lets say what a lower bound is:

πHOLCONST
‹ €IsLb› : ('a ≠ 'a ≠ BOOL) ≠ 'a SET ≠ 'a ≠ BOOL
˜¸¸¸¸¸¸¸¸¸¸¸
‹ µ r s e∑ IsLb r s e = µx∑ x ç s ¥ r e x
∞

πHOLCONST
‹ €IsUb› : ('a ≠ 'a ≠ BOOL) ≠ 'a SET ≠ 'a ≠ BOOL
˜¸¸¸¸¸¸¸¸¸¸¸
‹ µ r s e∑ IsUb r s e = µx∑ x ç s ¥ r x e
∞

Often the domain of our relations does not have a unique maximal element, and so there may be no greatest lower bound for the empty set.
However, this affects the applications rather than the concept:

πHOLCONST
‹ €IsGlb› : ('a ≠ 'a ≠ BOOL) ≠ 'a SET ≠ 'a ≠ BOOL
˜¸¸¸¸¸¸¸¸¸¸¸
‹ µ r s e∑ IsGlb r s e § IsLb r s e ± µx∑ IsLb r s x ¥ r x e
∞

πHOLCONST
‹ €IsLub› : ('a ≠ 'a ≠ BOOL) ≠ 'a SET ≠ 'a ≠ BOOL
˜¸¸¸¸¸¸¸¸¸¸¸
‹ µ r s e∑ IsLub r s e § IsUb r s e ± µx∑ IsUb r s x ¥ r e x
∞

πHOLCONST
‹ €Lub› : ('a ≠ 'a ≠ BOOL) ≠ 'a SET ≠ 'a
˜¸¸¸¸¸¸¸¸¸¸¸
‹ µ r s∑ Lub r s = ≈x∑ IsLub r s x
∞

πHOLCONST
‹ €Glb› : ('a ≠ 'a ≠ BOOL) ≠ 'a SET ≠ 'a
˜¸¸¸¸¸¸¸¸¸¸¸
‹ µ r s∑ Glb r s = ≈x∑ IsGlb r s x
∞

=GFT
€lub_unique_lemma› =
   Ù µ X r x y∑ Antisym (Universe, r) ¥ IsLub r Y x ± IsLub r Y y ¥ x = y

€lub_unique_lemma2› =
   Ù µ X r x y
     ∑ Antisym (X, r) ± x ç X ± y ç X ¥ IsLub r X x ± IsLub r X y ¥ x = y

€glb_unique_lemma› =
   Ù µ X r x y∑ Antisym (Universe, r) ¥ IsGlb r X x ± IsGlb r X y ¥ x = y

€glb_unique_lemma2› =
   Ù µ X r x y
     ∑ Antisym (X, r) ± x ç X ± y ç X ¥ IsGlb r X x ± IsGlb r X y ¥ x = y
=TEX

\ignore{
=SML
set_goal([], ¨µX r x y∑ Antisym (Universe, r) ¥ IsLub r X x ± IsLub r X y ¥ x = yÆ);
a (rewrite_tac [get_spec ¨IsLubÆ, get_spec ¨AntisymÆ] THEN contr_tac);
a (REPEAT (asm_fc_tac[]));
val lub_unique_lemma = save_pop_thm "lub_unique_lemma";

set_goal([], ¨µX r x y∑ Antisym (X, r) ± x ç X ± y ç X ¥ IsLub r X x ± IsLub r X y ¥ x = yÆ);
a (rewrite_tac [get_spec ¨IsLubÆ, get_spec ¨AntisymÆ] THEN contr_tac);
a (REPEAT (asm_fc_tac[]));
val lub_unique_lemma2 = save_pop_thm "lub_unique_lemma2";

set_goal([], ¨µX r x y∑ Antisym (Universe, r) ¥ IsGlb r X x ± IsGlb r X y ¥ x = yÆ);
a (rewrite_tac [get_spec ¨IsGlbÆ, get_spec ¨AntisymÆ] THEN contr_tac);
a (REPEAT (asm_fc_tac[]));
val glb_unique_lemma = save_pop_thm "glb_unique_lemma";

set_goal([], ¨µX r x y∑ Antisym (X, r) ± x ç X ± y ç X ¥ IsGlb r X x ± IsGlb r X y ¥ x = yÆ);
a (rewrite_tac [get_spec ¨IsGlbÆ, get_spec ¨AntisymÆ] THEN contr_tac);
a (REPEAT (asm_fc_tac[]));
val glb_unique_lemma2 = save_pop_thm "glb_unique_lemma2";

set_goal([], ¨µX r∑ (∂z∑ IsLub r X z) ¥ IsLub r X (Lub r X)Æ);
a (rewrite_tac[get_spec ¨LubÆ] THEN REPEAT strip_tac);
a (≈_tac ¨≈ x∑ IsLub r X xÆ);
a (∂_tac ¨zÆ THEN asm_rewrite_tac[]);
val lub_lub_lemma = save_pop_thm "lub_lub_lemma";

set_goal([], ¨µX r∑ (∂z∑ IsGlb r X z) ¥ IsGlb r X (Glb r X)Æ);
a (rewrite_tac[get_spec ¨GlbÆ] THEN REPEAT strip_tac);
a (≈_tac ¨≈ x∑ IsGlb r X xÆ);
a (∂_tac ¨zÆ THEN asm_rewrite_tac[]);
val glb_glb_lemma = save_pop_thm "glb_glb_lemma";
=TEX
}%ignore

=GFT
€lub_ub_lemma1› =
	Ù µ r X y∑ IsLub r X y ¥ (µ x∑ x ç X ¥ r x y)
€glb_lb_lemma1› =
	Ù µ r X y∑ IsGlb r X y ¥ (µ x∑ x ç X ¥ r y x)
=TEX

\ignore{
=SML
set_goal([], ¨µr X y∑ IsLub r X y ¥ µx∑ x ç X ¥ r x yÆ);
a (REPEAT strip_tac THEN fc_tac [get_spec ¨IsLubÆ]);
a (all_asm_fc_tac[get_spec ¨IsUbÆ]);
val lub_ub_lemma1 = save_pop_thm "lub_ub_lemma1";

set_goal([], ¨µr X y∑ IsGlb r X y ¥ µx∑ x ç X ¥ r y xÆ);
a (REPEAT strip_tac THEN fc_tac [get_spec ¨IsGlbÆ]);
a (all_asm_fc_tac[get_spec ¨IsLbÆ]);
val glb_lb_lemma1 = save_pop_thm "glb_lb_lemma1";
=TEX
}%ignore


πHOLCONST
‹ €NeGlbsExist› : ('a ≠ 'a ≠ BOOL) ≠ BOOL
˜¸¸¸¸¸¸¸¸¸¸¸
‹ µ r∑ NeGlbsExist r § µs∑ (∂d∑ d ç s) ¥ ∂e∑ IsGlb r s e
∞

πHOLCONST
‹ €GlbsExist› : ('a ≠ 'a ≠ BOOL) ≠ BOOL
˜¸¸¸¸¸¸¸¸¸¸¸
‹ µ r∑ GlbsExist r § µs∑ ∂e∑ IsGlb r s e
∞

πHOLCONST
‹ €LubsExist› : ('a ≠ 'a ≠ BOOL) ≠ BOOL
˜¸¸¸¸¸¸¸¸¸¸¸
‹ µ r∑ LubsExist r § µs∑ ∂e∑ IsLub r s e
∞

=GFT
€lub_lub_lemma2› =
   Ù µ r X∑ LubsExist r ¥ IsLub r X (Lub r X)

€glb_glb_lemma2› =
   Ù µ r X∑ GlbsExist r ¥ IsGlb r X (Glb r X)
=TEX

\ignore{
=SML
set_goal([], ¨µr X∑ LubsExist r ¥ IsLub r X (Lub r X)Æ);
a (rewrite_tac[get_spec ¨LubsExistÆ]
	THEN REPEAT strip_tac);
a (spec_nth_asm_tac 1 ¨XÆ);
a (strip_asm_tac (list_µ_elim [¨XÆ, ¨rÆ] lub_lub_lemma));
a (asm_fc_tac[]);
val lub_lub_lemma2 = save_pop_thm "lub_lub_lemma2";

set_goal([], ¨µr X∑ GlbsExist r ¥ IsGlb r X (Glb r X)Æ);
a (rewrite_tac[get_spec ¨GlbsExistÆ]
	THEN REPEAT strip_tac);
a (spec_nth_asm_tac 1 ¨XÆ);
a (strip_asm_tac (list_µ_elim [¨XÆ, ¨rÆ] glb_glb_lemma));
a (asm_fc_tac[]);
val glb_glb_lemma2 = save_pop_thm "glb_glb_lemma2";
=TEX
}%ignore

=GFT
€less_lub_lemma› =
	Ù µ r∑ LubsExist r ¥ (µ x X∑ x ç X ¥ r x (Lub r X))
€gt_glb_lemma› =
	Ù µ r∑ GlbsExist r ¥ (µ x X∑ x ç X ¥ r (Glb r X) x)
=TEX

\ignore{
=SML
set_goal([], ¨µr∑ LubsExist r ¥ µx X∑ x ç X ¥ r x (Lub r X)Æ);
a (REPEAT strip_tac THEN fc_tac [lub_lub_lemma2]);
a (ufc_tac [lub_ub_lemma1]);
a (asm_fc_tac[]);
val less_lub_lemma = save_pop_thm "less_lub_lemma";

set_goal([], ¨µr∑ GlbsExist r ¥ µx X∑ x ç X ¥ r (Glb r X) xÆ);
a (REPEAT strip_tac THEN fc_tac [glb_glb_lemma2]);
a (ufc_tac [glb_lb_lemma1]);
a (asm_fc_tac[]);
val gt_glb_lemma = save_pop_thm "gt_glb_lemma";
=TEX
}%ignore

=GFT
€lub_sub_lemma› =
   Ù µ r∑ LubsExist r ¥ (µ X Y∑ X Ä Y ¥ r (Lub r X) (Lub r Y))
=TEX

\ignore{
=SML
set_goal([], ¨µr∑ LubsExist r ¥ µX Y∑ X Ä Y ¥ r (Lub r X) (Lub r Y)Æ);
a (REPEAT strip_tac THEN fc_tac [lub_lub_lemma2]);
a (ufc_tac [get_spec ¨IsLubÆ]);
a (lemma_tac ¨IsUb r X (Lub r Y)Æ
	THEN1 (rewrite_tac [get_spec ¨IsUbÆ]
		THEN REPEAT strip_tac));
(* *** Goal "1" *** *)
a (GET_NTH_ASM_T 5 (PC_T1 "hol1" strip_asm_tac));
a (asm_fc_tac[]);
a (fc_tac [less_lub_lemma]);
a (list_spec_nth_asm_tac 1 [¨xÆ, ¨YÆ]);
(* *** Goal "2" *** *)
a (asm_fc_tac[]);
val lub_sub_lemma = save_pop_thm "lub_sub_lemma";
=TEX
}%ignore

\section{FIXED POINTS}

The general scheme involves finding closures of sets under varieties of operators.
The operators take members or sets of members of elements of the set in question, and construct new values from them.
Taking the closure of such a set under certain operations involves adding the things which can be constructed from elements in the set to the set untill there are no longer any new values which can be constructed.

In seeking to provide general support for such closure operations in a typed framework the diversity of the possible operations is an issue.
For this reason, in addressing the fundamental problem for finding the required closure it is supposed that the operations over elements in the sets which are of interest have been compounded into a monotonic operator operating on a set and yeilding that same set augmented by the elements which can be constructed from them.

In the present type-theoretic context such an operator is always monotonic and unbounded, and therefore by the Knaster-Tarski fixedpoint theorem will have at least one fixed point.

In this section we prove the fixedpoint theorem and spin out some elementary consequences.

For reasons connected with the motivation of this work, the emphasis is on taking closures, and the concept of closure is made prominent.
There is a dual system of terminology, at least insofar the dual of induction is called ``co-induction'' and though I am not strongly motivated by the aplications of the dual system, there is so little extra work in providing both that I have systematically done so, in the hope that applications may become apparent.
In doing so I have used a "co" prefix whenever I know of no other terminology for the dual of a concept.

\subsection{Monotonicity, Closure and Interior}

Definition of the notion of a function over a powerset monotonic with respect to set inclusion.
The Knaster-Tarski fixed point theorem applies to bounded monotonic functions, when considering only HOL ``SET''s, as we do here, the boundedness condition is automatically satisfied.

πHOLCONST
‹ €Monotonic› : ('a SET ≠ 'b SET) ≠ BOOL
˜
‹ µf∑ Monotonic f § µx y∑ x Ä y ¥ f(x) Ä f(y)
∞

=SML
declare_infix (300, "ClosedUnder");
declare_infix (300, "OpenUnder");
=TEX

πHOLCONST
‹ $€ClosedUnder› : 'a SET ≠ ('a SET ≠ 'a SET) ≠ BOOL
˜
‹ µf X∑ X ClosedUnder f § f(X) Ä X
∞

πHOLCONST
‹ $€OpenUnder› : 'a SET ≠ ('a SET ≠ 'a SET) ≠ BOOL
˜
‹ µf X∑ X OpenUnder f § X Ä f(X)
∞

\subsection{Least and Greatest Fixed Points}

Now we define the conditions for being a least fixed point.

πHOLCONST
‹ €IsLfp› : ('a ≠ 'a ≠ BOOL) ≠ ('a ≠ 'a) ≠ 'a ≠ BOOL
˜¸¸¸¸¸¸¸¸¸¸¸
‹ µ r f e∑ IsLfp r f e §
‹	let fp = {x | f x = x}
‹	in e ç fp ± IsGlb r fp e
∞

πHOLCONST
‹ €IsGfp› : ('a ≠ 'a ≠ BOOL) ≠ ('a ≠ 'a) ≠ 'a ≠ BOOL
˜¸¸¸¸¸¸¸¸¸¸¸
‹ µ r f e∑ IsGfp r f e §
‹	let fp = {x | f x = x}
‹	in e ç fp ± IsLub r fp e
∞

=GFT
€islfp_lemma1› =
	Ù µ r f e∑ IsLfp r f e ¥ e = f e ± (µ x∑ x = f x ¥ r e x)

€isgfp_lemma1› =
	Ù µ r f e∑ IsGfp r f e ¥ e = f e ± (µ x∑ x = f x ¥ r x e)

€islfp_lemma2› =
	Ù µ r f e∑ IsLfp r f e ¥ f e = e ± (µ x∑ f x = x ¥ r e x)

€isgfp_lemma2› =
	Ù µ r f e∑ IsGfp r f e ¥ f e = e ± (µ x∑ f x = x ¥ r x e)

€islfp_unique_lemma› =
	Ù µ r f e d∑ Antisym (Universe, r) ± IsLfp r f e ± IsLfp r f d ¥ e = d

€isgfp_unique_lemma› =
   Ù µ r f e d∑ Antisym (Universe, r) ± IsGfp r f e ± IsGfp r f d ¥ e = d
=TEX

\ignore{
=SML
set_goal([], ¨µr f e∑ IsLfp r f e ¥ e = f e
	± (µx∑ x = f x ¥ r e x)Æ);
a (rewrite_tac [get_spec ¨IsLfpÆ, let_def]
	THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a (asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a (fc_tac [get_spec ¨IsGlbÆ]);
a (fc_tac [get_spec ¨IsLbÆ]);
a (DROP_NTH_ASM_T 4 (asm_tac o (conv_rule eq_sym_conv)));
a (asm_fc_tac[]);
val islfp_lemma1 = save_pop_thm "islfp_lemma1";

set_goal([], ¨µr f e∑ IsGfp r f e ¥ e = f e
	± (µx∑ x = f x ¥ r x e)Æ);
a (rewrite_tac [get_spec ¨IsGfpÆ, let_def]
	THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a (asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a (fc_tac [get_spec ¨IsLubÆ]);
a (fc_tac [get_spec ¨IsUbÆ]);
a (DROP_NTH_ASM_T 4 (asm_tac o (conv_rule eq_sym_conv)));
a (asm_fc_tac[]);
val isgfp_lemma1 = save_pop_thm "isgfp_lemma1";

set_goal([], ¨µr f e∑ IsLfp r f e ¥ f e = e
	± (µx∑ f x = x¥ r e x)Æ);
a (rewrite_tac [get_spec ¨IsLfpÆ, let_def]
	THEN REPEAT strip_tac);
a (fc_tac [get_spec ¨IsGlbÆ]);
a (fc_tac [get_spec ¨IsLbÆ]);
a (all_asm_ante_tac THEN rewrite_tac[] THEN REPEAT strip_tac
	THEN asm_fc_tac[]);
val islfp_lemma2 = save_pop_thm "islfp_lemma2";

set_goal([], ¨µr f e∑ IsGfp r f e ¥ f e = e
	± (µx∑ f x = x ¥ r x e)Æ);
a (rewrite_tac [get_spec ¨IsGfpÆ, let_def]
	THEN REPEAT strip_tac);
a (fc_tac [get_spec ¨IsLubÆ]);
a (fc_tac [get_spec ¨IsUbÆ]);
a (all_asm_ante_tac THEN rewrite_tac[] THEN REPEAT strip_tac
	THEN asm_fc_tac[]);
val isgfp_lemma2 = save_pop_thm "isgfp_lemma2";

set_goal([], ¨µr f e d∑ Antisym (Universe, r) ± IsLfp r f e ± IsLfp r f d ¥ e = dÆ);
a (REPEAT strip_tac THEN fc_tac [islfp_lemma1, get_spec ¨AntisymÆ]);
a (DROP_NTH_ASM_T 5 ante_tac THEN rewrite_tac [] THEN contr_tac);
a (all_asm_fc_tac[]);
a (all_asm_fc_tac[]);
val islfp_unique_lemma = pop_thm();

set_goal([], ¨µr f e d∑ Antisym (Universe, r) ± IsGfp r f e ± IsGfp r f d ¥ e = dÆ);
a (REPEAT strip_tac THEN fc_tac [isgfp_lemma1, get_spec ¨AntisymÆ]);
a (DROP_NTH_ASM_T 5 ante_tac THEN rewrite_tac [] THEN contr_tac);
a (all_asm_fc_tac[]);
a (all_asm_fc_tac[]);
val isgfp_unique_lemma = pop_thm();
=TEX
}%ignore


πHOLCONST
‹ €Lfp› : ('a SET ≠ 'a SET) ≠ 'a SET
˜
‹ µf∑ Lfp f = •{X | X ClosedUnder f}
∞

{\it Lfp} gives a fixed point:
=GFT
lfp_fixedpoint_thm =
	Ù µh∑ Monotonic h ¥ h (Lfp h) = Lfp h
=TEX

\ignore{
=SML
val Monotonic_def = get_spec ¨MonotonicÆ;
val ClosedUnder_def = get_spec ¨$ClosedUnderÆ;
val OpenUnder_def = get_spec ¨$OpenUnderÆ;
val Lfp_def = get_spec ¨LfpÆ;

set_goal([],¨µh∑ Monotonic h ¥ h (Lfp h) = Lfp hÆ);
a (rewrite_tac [ClosedUnder_def, Lfp_def] THEN REPEAT strip_tac);
a (lemma_tac ¨h(•{X|h X Ä X}) Ä •{X|h X Ä X}Æ);
(* *** Goal "1" *** *)
a (once_rewrite_tac[sets_ext_clauses] THEN REPEAT strip_tac);
a (lemma_tac ¨(•{X|h X Ä X}) Ä sÆ);
(* *** Goal "1.1" *** *)
a (once_rewrite_tac[sets_ext_clauses] THEN REPEAT strip_tac);
a (spec_nth_asm_tac 1 ¨sÆ);
(* *** Goal "1.2" *** *)
a (all_asm_fc_tac [Monotonic_def]);
a (all_fc_tac[get_spec ¨$ÄÆ]);
a (all_fc_tac[get_spec ¨$ÄÆ]);
(* *** Goal "2" *** *)
a (lemma_tac ¨•{X|h X Ä X} Ä h(•{X|h X Ä X})Æ);
(* *** Goal "2.1" *** *)
a (once_rewrite_tac[sets_ext_clauses]);
a (REPEAT strip_tac);
a (spec_asm_tac ¨µ s∑ s ç {X|h X Ä X} ¥ x ç sÆ ¨h (• {X|h X Ä X})Æ);
a (fc_tac [Monotonic_def]);
a (list_spec_asm_tac ¨µ x y∑ x Ä y ¥ h x Ä h yÆ [¨h(• {X|h X Ä X})Æ, ¨• {X|h X Ä X}Æ]);
(* *** Goal "2.2" *** *)
a (all_asm_fc_tac [pc_rule "sets_ext" (prove_rule []) ¨µA B∑ A Ä B ± B Ä A ¥ A = BÆ]);
val lfp_fixedpoint_thm = save_pop_thm "lfp_fixedpoint_thm";
=TEX
}%ignore

{\it Lfp} gives the least fixed point:
=GFT
‹ Lfp_lfp_thm =
	Ù µh∑ Monotonic h ¥ µg∑ h g = g ¥ (Lfp h) Ä g
=TEX

\ignore{
=SML
set_goal([],¨µh∑ Monotonic h ¥ µg∑ h g = g ¥ (Lfp h) Ä gÆ);
a (rewrite_tac [Lfp_def, ClosedUnder_def] THEN REPEAT strip_tac);
a (once_rewrite_tac [sets_ext_clauses]
	THEN REPEAT strip_tac);
a (spec_asm_tac ¨µ s∑ s ç {X|h X Ä X} ¥ x ç sÆ ¨gÆ);
a (DROP_ASM_T ¨≥ h g Ä gÆ ante_tac THEN asm_rewrite_tac []);
val Lfp_lfp_thm = save_pop_thm "Lfp_lfp_thm";
=TEX
}%ignore

πHOLCONST
‹ €Gfp› : ('a SET ≠ 'a SET) ≠ 'a SET
˜
‹ µf∑ Gfp f = ﬁ{X | X OpenUnder f}
∞

{\it Gfp} gives a fixed point:
=GFT
gfp_fixedpoint_thm
	Ù µh∑ Monotonic h ¥ h (Gfp h) = Gfp h
=TEX

\ignore{
=SML
val gfp_def = get_spec ¨GfpÆ;
set_goal([],¨µh∑ Monotonic h ¥ h (Gfp h) = Gfp hÆ);
a (rewrite_tac [gfp_def, OpenUnder_def] THEN REPEAT strip_tac);
a (lemma_tac ¨ﬁ {X|X Ä h X} Ä h (ﬁ {X|X Ä h X})Æ);
(* *** Goal "1" *** *)
a (once_rewrite_tac[sets_ext_clauses] THEN REPEAT strip_tac);
a (lemma_tac ¨s Ä ﬁ {X|X Ä h X}Æ);
(* *** Goal "1.1" *** *)
a (once_rewrite_tac[sets_ext_clauses] THEN REPEAT strip_tac);
a (∂_tac ¨sÆ THEN REPEAT strip_tac);
(* *** Goal "1.2" *** *)
a (lemma_tac ¨s ç {X|X Ä h X}Æ);
(* *** Goal "1.1" *** *)
a (once_rewrite_tac[sets_ext_clauses] THEN REPEAT strip_tac);
a (all_asm_fc_tac [Monotonic_def]);
a (all_asm_fc_tac [get_spec ¨$ÄÆ]);
a (all_asm_fc_tac [get_spec ¨$ÄÆ]);
(* *** Goal "2" *** *)
a (lemma_tac ¨h (ﬁ {X|X Ä h X}) ç {X|X Ä h X}Æ);
(* *** Goal "2.1" *** *)
a (all_asm_fc_tac [Monotonic_def]);
a (asm_rewrite_tac [ç_in_clauses]);
(* *** Goal "2.2" *** *)
a (lemma_tac ¨h (ﬁ {X|X Ä h X}) Ä ﬁ {X|X Ä h X}Æ);
(* *** Goal "2.2.1" *** *)
a (once_rewrite_tac [sets_ext_clauses]);
a (REPEAT strip_tac);
a (∂_tac ¨h (ﬁ {X|X Ä h X})Æ);
a (REPEAT strip_tac);
(* *** Goal "2.2.2" *** *)
a (rewrite_tac [pc_rule "sets_ext" (prove_rule []) ¨µA B∑ A = B § B Ä A ± A Ä BÆ]
	THEN asm_rewrite_tac[]);
val gfp_fixedpoint_thm = save_pop_thm "gfp_fixedpoint_thm";
=TEX
}%ignore

Gfp gives the greatest fixed point:

=GFT
gfp_gfp_thm =
	Ù µh∑ Monotonic h ¥ µg∑ h g = g ¥ g Ä (Gfp h)
=TEX

\ignore{
=SML
set_goal([],¨µh∑ Monotonic h ¥ µg∑ h g = g ¥ g Ä (Gfp h)Æ);
a (rewrite_tac [gfp_def, OpenUnder_def] THEN REPEAT strip_tac);
a (once_rewrite_tac [sets_ext_clauses]
	THEN REPEAT strip_tac);
a (∂_tac ¨gÆ THEN asm_rewrite_tac[]);
val gfp_gfp_thm = save_pop_thm "gfp_gfp_thm";
=TEX
}%ignore

\subsection{Closure and Interior}

=GFT
lfp_closed_thm =
	Ù µh∑ Monotonic h ¥ (Lfp h) ClosedUnder h

lfp_closed_thm1 =
	Ù µ h∑ Monotonic h ¥ (µ x∑ x ç h (Lfp h) ¥ x ç Lfp h)

lfp_open_thm =
	Ù µh∑ Monotonic h ¥ (Lfp h) OpenUnder h

lfp_open_thm1 =
	Ù µ h∑ Monotonic h ¥ (µ x∑ x ç Lfp h ¥ x ç h (Lfp h))
=TEX

\ignore{
=SML
set_goal([],¨µh∑ Monotonic h ¥ (Lfp h) ClosedUnder hÆ);
a (rewrite_tac [ClosedUnder_def] THEN REPEAT strip_tac);
a (fc_tac [lfp_fixedpoint_thm]
	THEN asm_rewrite_tac[]);
val lfp_closed_thm = save_pop_thm "lfp_closed_thm";
val lfp_closed_thm1 = save_thm ("lfp_closed_thm1",
	rewrite_rule [ClosedUnder_def, sets_ext_clauses] lfp_closed_thm);
=TEX
=SML
set_goal([],¨µh∑ Monotonic h ¥ (Lfp h) OpenUnder hÆ);
a (rewrite_tac [OpenUnder_def] THEN REPEAT strip_tac);
a (fc_tac [lfp_fixedpoint_thm]
	THEN asm_rewrite_tac[]);
val lfp_open_thm = save_pop_thm "lfp_open_thm";
val lfp_open_thm1 = save_thm ("lfp_open_thm1",
	rewrite_rule [OpenUnder_def, sets_ext_clauses] lfp_open_thm);
=TEX
}%ignore

=GFT
gfp_closed_thm =
	Ù µh∑ Monotonic h ¥ (Gfp h) ClosedUnder h
gfp_closed_thm1 =
	Ù µ h∑ Monotonic h ¥ (µ x∑ x ç h (Gfp h) ¥ x ç Gfp h)
gfp_open_thm =
	Ù µh∑ Monotonic h ¥ (Gfp h) OpenUnder h
gfp_open_thm1 =
	Ù µ h∑ Monotonic h ¥ (µ x∑ x ç Gfp h ¥ x ç h (Gfp h))
=TEX

\ignore{
=SML
set_goal([],¨µh∑ Monotonic h ¥ (Gfp h) ClosedUnder hÆ);
a (rewrite_tac [ClosedUnder_def] THEN REPEAT strip_tac);
a (fc_tac [gfp_fixedpoint_thm]
	THEN asm_rewrite_tac[]);
val gfp_closed_thm = save_pop_thm "gfp_closed_thm";
val gfp_closed_thm1 = save_thm ("gfp_closed_thm1",
	rewrite_rule [ClosedUnder_def, sets_ext_clauses] gfp_closed_thm);
=TEX
=SML
set_goal([],¨µh∑ Monotonic h ¥ (Gfp h) OpenUnder hÆ);
a (rewrite_tac [OpenUnder_def] THEN REPEAT strip_tac);
a (fc_tac [gfp_fixedpoint_thm]
	THEN asm_rewrite_tac[]);
val gfp_open_thm = save_pop_thm "gfp_open_thm";
val gfp_open_thm1 = save_thm ("gfp_open_thm1",
	rewrite_rule [OpenUnder_def, sets_ext_clauses] gfp_open_thm);
=TEX
}%ignore

\subsection{Induction and Co-induction}

To prove something about the members of an inductively defined set you prove that all the operations which were used to define the set preserve the required property.
In our case, where the operator is defined over sets of elements and we think of ourselves as starting out with the empty set, there is no ``base case'' for the induction
(alternatively think of the base case as the application of the operator to the empty set).

For some property represented as a set {\it s} and a set of constructors represented as a function {\it h} the induction principle states that if the property is closed under the function then all the elements of the set inductively defined by the function (e.g. its least fixed point) have the property.

The least fixed point induction principle may therefore be expressed:


\ignore{
=SML
set_goal([],¨µh∑ Monotonic h ¥ µs∑ s ClosedUnder h ¥ (Lfp h) Ä sÆ);
a (rewrite_tac [Lfp_def, ClosedUnder_def] THEN REPEAT strip_tac);
a (once_rewrite_tac [sets_ext_clauses] THEN REPEAT strip_tac);
a (asm_fc_tac[]);
val Lfp_induction_thm = save_pop_thm "Lfp_induction_thm";

val Lfp_induction_thm1 = save_thm ("Lfp_induction_thm1",
	pc_rule1 "hol" rewrite_rule [get_spec ¨$ClosedUnderÆ] Lfp_induction_thm);
=TEX
}%ignore

=GFT
Lfp_induction_thm =
	Ù µh∑ Monotonic h ¥ µs∑ s ClosedUnder h ¥ (Lfp h) Ä s
Lfp_induction_thm1 =
	Ù µh∑ Monotonic h ¥ µs∑ h s Ä s ¥ (Lfp h) Ä s
=TEX

This is the corresponding theorem for greatest fixed point to the ``induction'' principle for least fixed points.

\ignore{
=SML
set_goal([],¨µh∑ Monotonic h ¥ µs∑ s OpenUnder h ¥ s Ä (Gfp h)Æ);
a (rewrite_tac [gfp_def, OpenUnder_def] THEN REPEAT strip_tac);
a (once_rewrite_tac [sets_ext_clauses] THEN contr_tac);
a (asm_fc_tac[]);
val gfp_coinduction_thm = save_pop_thm "gfp_coinduction_thm";

val gfp_coinduction_thm1 = save_thm ("gfp_coinduction_thm1",
	pc_rule1 "hol" rewrite_rule [get_spec ¨$OpenUnderÆ] gfp_coinduction_thm);
=TEX
}%ignore

=GFT
gfp_coinduction_thm =
	Ù µh∑ Monotonic h ¥ µs∑ s OpenUnder h ¥ s Ä (Gfp h)
gfp_coinduction_thm1 =
	Ù µ h∑ Monotonic h ¥ (µ s∑ s Ä h s ¥ s Ä Gfp h)
=TEX

\subsection{Monotonicity Against Other Relations}

The above considers only functions on sets which are monotonic relative to the subset relationship.

In order to get fixed points the relations relative to which our functions are monotone must have appropriate kinds of completeness.
Ideally they will be simply ``complete'' i.e. having supremum and infimum of arbitrary sets of elements.
This makes the domain into a complete lattice, but since we focus on the relation and do not have operators for supremum and infimum in the structure we are considering, what we are doing doesn't look like lattice theory.

However, we sometimes want to obtain fixed points relative to orderings which are not complete.
We begin with chain-complete partial orders.
I should for consistency have done chain co-complete partial orders as well but that didn't occur to me at the time.

\subsection{Reflexive Partial Orders}

It is simpler to do this specifically for reflexive partial orders, whereas the theory of orders already available is not specific to reflexive orders.
The notion of of reflexive partial order is therefore defined first, and various relevant concepts (upper and lower bounds etc.) are introduced in this context.

Since the orders considered here are reflexive we will use the symbol $ºâv$ as a variable ranging over these relations.
Note however that the theory {\it ordered\_sets}, on which we draw, uses $<<$.
Note also that we do not follow generally here the practice of reasoning about relations over sets.
Usually we reason about relations over whole types.

In the theory {\it ordered\_sets} ordering relations are treated in many areas with indifference as to whether they are reflexive or strict or inbetween.
Here we work primarily with reflexive partial orders.
The distinction is marked (perhaps not consistently) by the choice of symbol for relation variable.
Where a reflexive relation is intended the symbol $ºâv$ is used, where the relation need not be reflexive we follow {\it ordered\_sets} in using $<<$.
Where I have used $r$ this is prior to my introducing this scheme and the relation is probably reflexive.

=SML
declare_infix (300, "€ºâv›");
=TEX

πHOLCONST
‹ €Rpo› : ('a SET) ∏ ('a ≠ 'a ≠ BOOL) ≠ BOOL
˜¸¸¸¸¸¸¸¸¸¸¸
‹ µr∑ Rpo r § PartialOrder r ± Refl r
∞

=GFT
€rpo_fc_clauses› =
   Ù µ (X, $ºâv)
     ∑ Rpo (X, $ºâv)
         ¥ (µ x y∑ x ç X ± y ç X ± x ºâv y ± y ºâv x ¥ x = y)
           ± (µ x y z∑ x ç X ± y ç X ± z ç X ± x ºâv y ± y ºâv z ¥ x ºâv z)
           ± (µ x∑ x ç X ¥ x ºâv x)
=TEX

πHOLCONST
‹ €RpoU›: ('a ≠ 'a ≠ BOOL) ≠ BOOL
˜¸¸¸¸¸¸
‹ µ r∑ RpoU r § Rpo (Universe, r)
∞

=GFT
€rpou_fc_clauses› =
   Ù µ $ºâv
     ∑ Rpo (Universe, $ºâv)
         ¥ (µ x y∑ x ºâv y ± y ºâv x ¥ x = y)
           ± (µ x y z∑ x ºâv y ± y ºâv z ¥ x ºâv z)
           ± (µ x∑ x ºâv x)

€rpou_fc_clauses2› =
   Ù µ $ºâv
     ∑ RpoU $ºâv
         ¥ (µ x y∑ x ºâv y ± y ºâv x ¥ x = y)
           ± (µ x y z∑ x ºâv y ± y ºâv z ¥ x ºâv z)
           ± (µ x∑ x ºâv x)

€rpo_antisym_lemma› =
   Ù µ X r f∑ Rpo (X, r) ¥ Antisym (X, r)

€rpo_°_lemma› =
   Ù µ X Y r∑ Rpo (X, r) ± Rpo (Y, r) ¥ Rpo (X ° Y, r)
=TEX

\ignore{
=SML
push_merge_pcs ["hol1", "'savedthm_cs_∂_proof"];

set_goal([], ¨µ(X, $ºâv)∑ Rpo (X, $ºâv)
	¥ (µ x y∑ x ç X ± y ç X ± x ºâv y ± y ºâv x ¥ x = y)
	± (µ x y z∑ x ç X ± y ç X ± z ç X ± x ºâv y ± y ºâv z ¥ x ºâv z)
	± (µ x∑ x ç X ¥ x ºâv x)
Æ);
a (rewrite_tac (map get_spec [¨RpoÆ, ¨PartialOrderÆ, ¨AntisymÆ, ¨TransÆ, ¨ReflÆ])
	THEN REPEAT_N 6 strip_tac
	THEN REPEAT µ_tac
	THEN_TRY asm_rewrite_tac[]
	THEN contr_tac);
a (all_asm_fc_tac[]);
val rpo_fc_clauses = save_pop_thm "rpo_fc_clauses";

set_goal([], ¨µ$ºâv∑ Rpo (Universe, $ºâv)
	¥ (µ x y∑ x ºâv y ± y ºâv x ¥ x = y)
	± (µ x y z∑ x ºâv y ± y ºâv z ¥ x ºâv z)
	± (µ x∑ x ºâv x)
Æ);
a (strip_tac THEN strip_tac
	THEN (ASM_FC_T (MAP_EVERY ante_tac) [rpo_fc_clauses])
	THEN PC_T1 "hol1" rewrite_tac[]
	THEN contr_tac
	THEN REPEAT (asm_fc_tac[]));
val rpou_fc_clauses = save_pop_thm "rpou_fc_clauses";

set_goal([], ¨µ$ºâv∑ RpoU $ºâv
	¥ (µ x y∑ x ºâv y ± y ºâv x ¥ x = y)
	± (µ x y z∑ x ºâv y ± y ºâv z ¥ x ºâv z)
	± (µ x∑ x ºâv x)
Æ);
a (rewrite_tac [get_spec ¨RpoUÆ] THEN REPEAT strip_tac
	THEN fc_tac [rpou_fc_clauses]
	THEN asm_fc_tac[]
	THEN asm_fc_tac[]
	THEN asm_rewrite_tac[]);
val rpou_fc_clauses2 = save_pop_thm "rpou_fc_clauses2";

set_goal([], ¨µX r f∑ Rpo (X,r) ¥ Antisym (X, r)Æ);
a (rewrite_tac [get_spec ¨AntisymÆ]
	THEN REPEAT strip_tac);
a (fc_tac [rpo_fc_clauses]);
a (list_spec_nth_asm_tac 1 [¨xÆ, ¨yÆ]);
val rpo_antisym_lemma = pop_thm ();

set_goal([], ¨µX Y r∑ Rpo (X,r) ± Rpo (Y,r) ¥ Rpo (X ° Y,r)Æ);
a (REPEAT µ_tac
	THEN rewrite_tac [get_spec ¨RpoÆ]
	THEN strip_tac);
a (asm_tac (pc_rule1 "hol1" prove_rule [] ¨X ° Y Ä XÆ));
a (strip_asm_tac (list_µ_elim [¨YÆ, ¨X ° YÆ, ¨rÆ] subrel_partial_order_thm));
a (strip_asm_tac (list_µ_elim [¨YÆ, ¨X ° YÆ, ¨rÆ] subrel_refl_thm));
a contr_tac;
val rpo_°_lemma = pop_thm();

set_goal([], ¨∂Lfpâc∑ µ r f∑ (∂ e∑ IsLfp r f e) ¥ IsLfp r f (Lfpâc r f)Æ);
a (REPEAT strip_tac
	THEN ∂_tac ¨Ãr f∑ ≈e∑ IsLfp r f eÆ
	THEN rewrite_tac[]
	THEN REPEAT strip_tac);
a (≈_tac ¨≈e∑ IsLfp r f eÆ);
a (∂_tac ¨eÆ THEN asm_rewrite_tac[]);
save_cs_∂_thm (pop_thm());
=TEX
}%ignore

πHOLCONST
‹ €Lfpâc›: ('a ≠ 'a ≠ BOOL) ≠ ('a ≠ 'a) ≠ 'a
˜¸¸¸¸¸¸¸¸¸
‹ µ r f∑ (∂ e∑ IsLfp r f e) ¥ IsLfp r f (Lfpâc r f)
∞

\ignore{
=SML
set_goal([], ¨∂Gfpâc∑ µ r f∑ (∂ e∑ IsGfp r f e) ¥ IsGfp r f (Gfpâc r f)Æ);
a (REPEAT strip_tac
	THEN ∂_tac ¨Ãr f∑ ≈e∑ IsGfp r f eÆ
	THEN rewrite_tac[]
	THEN REPEAT strip_tac);
a (≈_tac ¨≈e∑ IsGfp r f eÆ);
a (∂_tac ¨eÆ THEN asm_rewrite_tac[]);
save_cs_∂_thm (pop_thm());
=TEX
}%ignore

πHOLCONST
‹ €Gfpâc›: ('a ≠ 'a ≠ BOOL) ≠ ('a ≠ 'a) ≠ 'a
˜¸¸¸¸¸¸¸¸¸
‹ µ r f∑ (∂ e∑ IsGfp r f e) ¥ IsGfp r f (Gfpâc r f)
∞

=GFT
€islfp_unique_lemma2› =
   Ù µ r f e∑ Antisym (Universe, r) ± IsLfp r f e ¥ Lfpâc r f = e

€isgfp_unique_lemma2› =
   Ù µ r f e∑ Antisym (Universe, r) ± IsGfp r f e ¥ Gfpâc r f = e
=TEX

\ignore{
=SML
set_goal([], ¨µ r f e∑ Antisym(Universe, r) ± IsLfp r f e ¥ (Lfpâc r f) = eÆ);
a (REPEAT strip_tac THEN fc_tac [get_spec ¨LfpâcÆ]);
a (all_fc_tac [islfp_unique_lemma]);
val islfp_unique_lemma2 = pop_thm ();

set_goal([], ¨µ r f e∑ Antisym(Universe, r) ± IsGfp r f e ¥ (Gfpâc r f) = eÆ);
a (REPEAT strip_tac THEN fc_tac [get_spec ¨GfpâcÆ]);
a (all_fc_tac [isgfp_unique_lemma]);
val isgfp_unique_lemma2 = pop_thm ();
=TEX
}%ignore

\subsubsection{Directed Sets}

These definitions are not actually used.

We need the concept of a directed set.

πHOLCONST
‹ €Directed› : ('a ≠ 'a ≠ BOOL) ≠ 'a SET ≠ BOOL
˜¸¸¸¸¸¸¸¸¸¸¸
‹ µ r s∑ Directed r s § µx y∑ x ç s ± y ç s ¥ ∂z∑ z ç s ± IsUb r {x; y} z
∞

Which we use to define the property of having directed upper bounds:

πHOLCONST
‹ €DirectedUb› : ('a ≠ 'a ≠ BOOL) ≠ BOOL
˜¸¸¸¸¸¸¸¸¸¸¸
‹ µ r∑ DirectedUb r § µs∑ Directed r s ¥ ∂x∑ IsUb r s x
∞

\subsection{Monotonicity}

We need to establish the existence of least fixed points of monotone functions and so we want a result to the effect that the greatest lower bound of closed elements is a fixed point.
A closed element is one which maps to a point below itself in the ordering.

πHOLCONST
‹ €Increasing› : ('a ≠ 'a ≠ BOOL) ≠ ('b ≠ 'b ≠ BOOL) ≠ ('a ≠ 'b) ≠ BOOL
˜¸¸¸¸¸¸¸¸¸¸¸
‹ µ r s f∑ Increasing r s f § µx y∑ r x y ¥ s (f x) (f y)
∞

=GFT
€increasing_funcomp_thm› =
   Ù µ r1 r2 r3 f g
     ∑ Increasing r1 r2 f ± Increasing r2 r3 g ¥ Increasing r1 r3 (g o f)

€increasing_funcomp_thm2› =
   Ù µ r1 r2 r3 f g
     ∑ Increasing r1 r2 f ± Increasing r2 r3 g ¥ Increasing r1 r3 (Ãx∑ g(f(x)))
=TEX

\ignore{
=SML
set_goal([], ¨µr1 r2 r3 f g∑ Increasing r1 r2 f ± Increasing r2 r3 g ¥ Increasing r1 r3 (g o f)Æ);
a (rewrite_tac [get_spec ¨IncreasingÆ]
	THEN REPEAT strip_tac
	THEN REPEAT (all_asm_ufc_tac[]));
val increasing_funcomp_thm = save_pop_thm "increasing_funcomp_thm";

set_goal([], ¨µr1 r2 r3 f g∑ Increasing r1 r2 f ± Increasing r2 r3 g ¥ Increasing r1 r3 (Ãx∑ g(f(x)))Æ);
a (rewrite_tac [get_spec ¨IncreasingÆ]
	THEN REPEAT strip_tac
	THEN REPEAT (all_asm_ufc_tac[]));
val increasing_funcomp_thm2 = save_pop_thm "increasing_funcomp_thm2";
=TEX
}%ignore

Since the least fixed point will be a greatest lower bound, we need to know that greatest lower bounds exist to prove that there is a fixed point.
Since we don't have a top element we assert only the existence of a greatest lower bound for non-empty sets.

=GFT
€mono_fixp_thm› =
   Ù µ f r
     ∑ Refl (Universe, r)
           ± (µ x y∑ r x y ± r y x ¥ x = y)
           ± trans r
           ± Increasing r r f
           ± NeGlbsExist r
           ± (∂ x∑ r (f x) x)
         ¥ (∂ e∑ IsGlb r {x|r (f x) x} e ± IsLfp r f e)

€mono_fixp_thm2› =
   Ù µ f r
     ∑ Refl (Universe, r)
           ± (µ x y∑ r x y ± r y x ¥ x = y)
           ± trans r
           ± Increasing r r f
           ± GlbsExist r
         ¥ (∂ e∑ IsGlb r {x|r (f x) x} e ± IsLfp r f e)

€mono_fixp_thm3› =
   Ù µ f r
     ∑ Refl (Universe, r)
           ± (µ x y∑ r x y ± r y x ¥ x = y)
           ± trans r
           ± Increasing r r f
           ± LubsExist r
         ¥ (∂ e∑ IsLub r {x|r x (f x)} e ± IsGfp r f e)
=TEX

\ignore{
=SML
set_goal([], ¨µf r∑ Refl (Universe, r)
	± (µx y∑ r x y ± r y x ¥ x = y)
	± trans r
	± Increasing r r f
	± NeGlbsExist r
	± (∂x∑ r (f x) x)
	¥ ∂e∑ IsGlb r {x | r (f x) x} e ± IsLfp r f eÆ);
a (REPEAT strip_tac);
a (fc_tac [get_spec ¨NeGlbsExistÆ]);
a (list_spec_nth_asm_tac 1 [¨xÆ, ¨{x|r (f x) x}Æ]);
a (∂_tac ¨eÆ THEN asm_rewrite_tac[]);
a (rewrite_tac [get_spec ¨IsLfpÆ, let_def]);
a (lemma_tac ¨f e = eÆ THEN_TRY asm_rewrite_tac[]);
(* *** Goal "1" *** *)
a (fc_tac [get_spec ¨IsGlbÆ]);
a (all_asm_fc_tac[]);
a (fc_tac [get_spec ¨IncreasingÆ]);
a (lemma_tac ¨r (f e) eÆ);
(* *** Goal "1.1" *** *)
a (spec_nth_asm_tac 4 ¨f eÆ);
a (swap_nth_asm_concl_tac 1
	THEN rewrite_tac [get_spec ¨IsLbÆ]
	THEN REPEAT strip_tac);
a (fc_tac [get_spec ¨IsLbÆ]);
a (spec_nth_asm_tac 1 ¨f xÆ);
(* *** Goal "1.1.1" *** *)
a (list_spec_nth_asm_tac 5 [¨f xÆ, ¨xÆ]);
(* *** Goal "1.1.2" *** *)
a (fc_tac [get_spec ¨transÆ]);
a (REPEAT (all_asm_fc_tac[]));
(* *** Goal "1.2" *** *)
a (lemma_tac ¨r e (f e)Æ);
(* *** Goal "1.2.1" *** *)
a (lemma_tac ¨r (f (f e)) (f e)Æ THEN1 asm_fc_tac[]);
a (fc_tac [get_spec ¨IsLbÆ]);
a (spec_nth_asm_tac 1 ¨f eÆ);
a (all_asm_fc_tac[]);
(* *** Goal "2" *** *)
a (fc_tac [get_spec ¨IsGlbÆ]);
a (fc_tac [get_spec ¨IsLbÆ]);
a (rewrite_tac [get_spec ¨IsGlbÆ, get_spec ¨IsLbÆ] THEN REPEAT strip_tac);
(* *** Goal "2.1" *** *)
a (spec_nth_asm_tac 2 ¨x'Æ);
a (LEMMA_T ¨x ç UniverseÆ asm_tac THEN1 prove_tac[]);
a (fc_tac [get_spec ¨ReflÆ]);
a (spec_nth_asm_tac 1 ¨x'Æ);
a (swap_nth_asm_concl_tac 4 THEN asm_rewrite_tac[]);
(* *** Goal "2.2" *** *)
a (all_asm_fc_tac[]);
val mono_fixp_thm = save_pop_thm "mono_fixp_thm";

set_goal([], ¨µf r∑ Refl (Universe, r)
	± (µx y∑ r x y ± r y x ¥ x = y)
	± trans r
	± Increasing r r f
	± GlbsExist r
	¥ ∂e∑ IsGlb r {x | r (f x) x} e ± IsLfp r f eÆ);
a (REPEAT strip_tac);
a (fc_tac [get_spec ¨GlbsExistÆ]);
a (spec_nth_asm_tac 1 ¨{x|r (f x) x}Æ);
a (∂_tac ¨eÆ THEN asm_rewrite_tac[]);
a (rewrite_tac [get_spec ¨IsLfpÆ, let_def]);
a (lemma_tac ¨f e = eÆ THEN_TRY asm_rewrite_tac[]);
(* *** Goal "1" *** *)
a (fc_tac [get_spec ¨IsGlbÆ]);
a (all_asm_fc_tac[]);
a (fc_tac [get_spec ¨IncreasingÆ]);
a (lemma_tac ¨r (f e) eÆ);
(* *** Goal "1.1" *** *)
a (spec_nth_asm_tac 4 ¨f eÆ);
a (swap_nth_asm_concl_tac 1
	THEN rewrite_tac [get_spec ¨IsLbÆ]
	THEN REPEAT strip_tac);
a (fc_tac [get_spec ¨IsLbÆ]);
a (spec_nth_asm_tac 1 ¨f xÆ);
(* *** Goal "1.1.1" *** *)
a (list_spec_nth_asm_tac 5 [¨f xÆ, ¨xÆ]);
(* *** Goal "1.1.2" *** *)
a (fc_tac [get_spec ¨transÆ]);
a (REPEAT (all_asm_fc_tac[]));
(* *** Goal "1.2" *** *)
a (lemma_tac ¨r e (f e)Æ);
(* *** Goal "1.2.1" *** *)
a (lemma_tac ¨r (f (f e)) (f e)Æ THEN1 asm_fc_tac[]);
a (fc_tac [get_spec ¨IsLbÆ]);
a (spec_nth_asm_tac 1 ¨f eÆ);
a (all_asm_fc_tac[]);
(* *** Goal "2" *** *)
a (fc_tac [get_spec ¨IsGlbÆ]);
a (fc_tac [get_spec ¨IsLbÆ]);
a (rewrite_tac [get_spec ¨IsGlbÆ, get_spec ¨IsLbÆ] THEN REPEAT strip_tac);
(* *** Goal "2.1" *** *)
a (spec_nth_asm_tac 2 ¨xÆ);
a (LEMMA_T ¨x ç UniverseÆ asm_tac THEN1 prove_tac[]);
a (fc_tac [get_spec ¨ReflÆ]);
a (spec_nth_asm_tac 1 ¨xÆ);
a (swap_nth_asm_concl_tac 4 THEN asm_rewrite_tac[]);
(* *** Goal "2.2" *** *)
a (all_asm_fc_tac[]);
val mono_fixp_thm2 = save_pop_thm "mono_fixp_thm2";

set_goal([], ¨µf r∑ Refl (Universe, r)
	± (µx y∑ r x y ± r y x ¥ x = y)
	± trans r
	± Increasing r r f
	± LubsExist r
	¥ ∂e∑ IsLub r {x | r x (f x)} e ± IsGfp r f eÆ);
a (REPEAT strip_tac);
a (fc_tac [get_spec ¨LubsExistÆ]);
a (spec_nth_asm_tac 1 ¨{x|r x (f x)}Æ);
a (∂_tac ¨eÆ THEN asm_rewrite_tac[]);
a (rewrite_tac [get_spec ¨IsGfpÆ, let_def]);
a (lemma_tac ¨f e = eÆ THEN_TRY asm_rewrite_tac[]);
(* *** Goal "1" *** *)
a (fc_tac [get_spec ¨IsLubÆ]);
a (all_asm_fc_tac[]);
a (fc_tac [get_spec ¨IncreasingÆ]);
a (lemma_tac ¨r e (f e)Æ);
(* *** Goal "1.1" *** *)
a (spec_nth_asm_tac 4 ¨f eÆ);
a (swap_nth_asm_concl_tac 1
	THEN rewrite_tac [get_spec ¨IsUbÆ]
	THEN REPEAT strip_tac);
a (fc_tac [get_spec ¨IsUbÆ]);
a (spec_nth_asm_tac 1 ¨f xÆ);
(* *** Goal "1.1.1" *** *)
a (list_spec_nth_asm_tac 5 [¨xÆ, ¨f xÆ]);
(* *** Goal "1.1.2" *** *)
a (fc_tac [get_spec ¨transÆ]);
a (REPEAT (all_asm_fc_tac[]));
(* *** Goal "1.2" *** *)
a (lemma_tac ¨r (f e) eÆ);
(* *** Goal "1.2.1" *** *)
a (lemma_tac ¨r (f e) (f (f e))Æ THEN1 asm_fc_tac[]);
a (fc_tac [get_spec ¨IsUbÆ]);
a (spec_nth_asm_tac 1 ¨f eÆ);
a (all_asm_fc_tac[]);
(* *** Goal "2" *** *)
a (fc_tac [get_spec ¨IsLubÆ]);
a (fc_tac [get_spec ¨IsUbÆ]);
a (rewrite_tac [get_spec ¨IsLubÆ, get_spec ¨IsUbÆ] THEN REPEAT strip_tac);
(* *** Goal "2.1" *** *)
a (spec_nth_asm_tac 2 ¨xÆ);
a (LEMMA_T ¨x ç UniverseÆ asm_tac THEN1 prove_tac[]);
a (fc_tac [get_spec ¨ReflÆ]);
a (spec_nth_asm_tac 1 ¨xÆ);
a (swap_nth_asm_concl_tac 4 THEN asm_rewrite_tac[]);
(* *** Goal "2.2" *** *)
a (all_asm_fc_tac[]);
val mono_fixp_thm3 = save_pop_thm "mono_fixp_thm3";
=TEX
}%ignore

\subsection{Chain Complete Partial Orders}

A ccpo is a chain-complete partial order.
The proof of the fixed point result in this context is more difficult than in the case of a complete lattice, and the following version of it is a kludge, but will have to do for now.

The main point of this section is to obtain a least fixed point theorem for monotone functions over chain complete partial orders (CCPOs).


πHOLCONST
‹ €ChainComplete› : ('a SET ∏ ('a ≠ 'a ≠ BOOL)) ≠ BOOL
˜¸¸¸¸¸¸¸¸¸¸¸
‹ µ X r∑ ChainComplete (X, r) § µY∑ Y Ä X ± LinearOrder (Y, r) ¥
‹	∂x∑ x ç X ± IsLub r Y x
∞

πHOLCONST
‹ €CcRpo› : ('a SET ∏ ('a ≠ 'a ≠ BOOL)) ≠ BOOL
˜¸¸¸¸¸¸¸¸¸¸¸
‹ µ r∑ CcRpo r § Rpo r ± ChainComplete r
∞

πHOLCONST
‹ €CcRpoU› : ('a ≠ 'a ≠ BOOL) ≠ BOOL
˜¸¸¸¸¸¸¸¸¸¸¸
‹ µ r∑ CcRpoU r § CcRpo (Universe, r)
∞

πHOLCONST
‹ €CRpo› : ('a ≠ 'a ≠ BOOL) ≠ BOOL
˜¸¸¸¸¸¸¸¸¸¸¸
‹ µ r∑ CRpo r § Rpo (Universe, r) ± GlbsExist r
∞

πHOLCONST
‹ €FClosed› : ('a ≠ 'a) ≠ 'a SET ≠ BOOL
˜¸¸¸¸¸¸¸¸¸¸¸
‹ µ f X∑ FClosed f X § (µx∑ x ç X ¥ f x ç X)
∞

=GFT
fclosed_°_lemma =
   Ù µ X Y f∑ FClosed f X ± FClosed f Y ¥ FClosed f (X ° Y)
=TEX

\ignore{
=SML
set_goal ([], ¨µX Y f∑ FClosed f X ± FClosed f Y ¥ FClosed f (X ° Y)Æ);
a (REPEAT µ_tac
	THEN rewrite_tac [get_spec ¨FClosedÆ]
	THEN REPEAT strip_tac
	THEN all_asm_fc_tac[]);
val fclosed_°_lemma = pop_thm();
=TEX
}%ignore

πHOLCONST
‹ €FChainClosed› : ('a ≠ 'a) ≠ ('a SET ∏ ('a ≠ 'a ≠ BOOL)) ≠ BOOL
˜¸¸¸¸¸¸¸¸¸¸¸
‹ µ f X r∑ FChainClosed f (X, r) § 
‹	FClosed f X ± ChainComplete (X, r)
∞

πHOLCONST
‹ €FChain› : ('a ≠ 'a) ≠ ('a SET ∏ ('a ≠ 'a ≠ BOOL)) ≠ 'a SET
˜¸¸¸¸¸¸¸¸¸¸¸
‹ µ f X r∑ FChain f (X, r) = • {Y | Y Ä X ± FChainClosed f (Y, r)}
∞

=GFT
€fcc_fchain_lemma1› =
	Ù (∂ V∑ V ç W) ± (µ V∑ V ç W ¥ V Ä X) ± Y Ä • W ¥ Y Ä X

€fchain_lemma1› =
	Ù µ X r f∑ FChainClosed f (X, r) ¥ FChain f (X, r) Ä X

€fchain_fchainclosed_lemma› =
   Ù µ X r f
     ∑ Antisym (Universe, r) ± FChainClosed f (X, r)
         ¥ FChainClosed f (FChain f (X, r), r)

€fchain_fchainclosed_lemma2› =
   Ù µ X r f
     ∑ Rpo (Universe, r) ± FChainClosed f (X, r)
         ¥ FChainClosed f (FChain f (X, r), r)

€fchain_lemma2› =
	Ù µ X Y r f
     ∑ Rpo (Universe, r)
           ± FChainClosed f (X, r)
           ± Y Ä FChain f (X, r)
           ± FChainClosed f (Y, r)
         ¥ Y = FChain f (X, r)

€ccrpo_fixp_lemma1› =
   Ù µ X r f
     ∑ Increasing r r f
         ¥ FClosed f {x|x ç FChain f (X, r) ± (r x (f x) ≤ x = f x)}

€ccrpo_fixp_lemma2› =
   Ù µ X r f
     ∑ Increasing r r f ± Rpo (Universe, r) ± FChainClosed f (X, r)
         ¥ ChainComplete ({z|z ç FChain f (X, r) ± (r z (f z) ≤ z = f z)}, r)

€ccrpo_fixp_lemma3› =
   Ù µ X r f
     ∑ Increasing r r f ± Rpo (Universe, r) ± FChainClosed f (X, r)
         ¥ FChainClosed
           f
           ({z|z ç FChain f (X, r) ± (r z (f z) ≤ z = f z)}, r)

€ccrpo_fixp_lemma4› =
   Ù µ X r f
     ∑ Increasing r r f ± Rpo (Universe, r) ± FChainClosed f (X, r)
         ¥ (µ z∑ z ç FChain f (X, r) ¥ r z (f z) ≤ z = f z)
=TEX

\ignore{
=SML
set_goal([], ¨(∂V∑ V ç W) ± (µV∑ V ç W ¥ V Ä X) ± Y Ä •W ¥ Y Ä XÆ);
a (REPEAT strip_tac THEN REPEAT (asm_fc_tac[]));
val fcc_fchain_lemma1 = pop_thm();

set_goal([], ¨µX r f∑ FChainClosed f (X, r) ¥ FChain f (X,r) Ä XÆ);
a (rewrite_tac [get_spec ¨FChainÆ]
	THEN REPEAT strip_tac);
a (spec_nth_asm_tac 1 ¨XÆ);
val fchain_lemma1 = save_pop_thm "fchain_lemma1";

push_merge_pcs ["hol", "'savedthm_cs_∂_proof"];

set_goal([], ¨µX r f∑ Antisym (Universe, r) ± FChainClosed f (X, r)
	¥ FChainClosed f (FChain f (X,r), r)Æ);
a (REPEAT strip_tac);
a (fc_tac [get_spec ¨FChainClosedÆ]);
a (fc_tac [get_spec ¨FClosedÆ]);
a (rewrite_tac [get_spec ¨FChainClosedÆ, get_spec ¨FClosedÆ]
	THEN REPEAT µ_tac
	THEN strip_tac);
(* *** Goal "1" *** *)
a (rewrite_tac [get_spec ¨FChainClosedÆ,
		get_spec ¨FClosedÆ,
		get_spec ¨FChainÆ,
		get_spec ¨ChainCompleteÆ]
	THEN REPEAT strip_tac
	THEN REPEAT (asm_fc_tac[]));
(* *** Goal "2" *** *)
a (fc_tac [get_spec ¨ChainCompleteÆ]);
a (rewrite_tac [get_spec ¨ChainCompleteÆ]
	THEN REPEAT strip_tac);
a (fc_tac [fchain_lemma1]);
a (all_fc_tac [pc_rule1 "hol1" prove_rule [] ¨µA B C∑ A Ä B ± B Ä C ¥ A Ä CÆ]);
a (all_asm_fc_tac []);
a (∂_tac ¨xÆ THEN REPEAT strip_tac);
a (REPEAT_N 3 (PC_T1 "hol1" once_rewrite_tac [get_spec ¨FChainÆ])
	THEN REPEAT strip_tac);
a (fc_tac [get_spec ¨FChainClosedÆ]);
a (fc_tac [get_spec ¨FClosedÆ]);
a (fc_tac [get_spec ¨ChainCompleteÆ]);
a (lemma_tac ¨FChain f (X, r) Ä sÆ
	THEN1 (rewrite_tac [get_spec ¨FChainÆ] THEN REPEAT strip_tac
		THEN (PC_T1 "hol1" asm_rewrite_tac [])
		THEN REPEAT strip_tac THEN all_asm_fc_tac[]));
a (all_fc_tac [pc_rule1 "hol1" prove_rule [] ¨µA B C∑ A Ä B ± B Ä C ¥ A Ä CÆ]);
a (all_asm_fc_tac[]);
a (fc_tac [lub_unique_lemma]);
a (all_asm_fc_tac[]);
a (var_elim_nth_asm_tac 8);
val fchain_fchainclosed_lemma = save_pop_thm "fchain_fchainclosed_lemma";

set_goal([], ¨µX r f∑ Rpo (Universe, r) ± FChainClosed f (X, r)
	¥ FChainClosed f (FChain f (X,r), r)Æ);
a (REPEAT strip_tac
	THEN fc_tac [rpo_antisym_lemma]
	THEN all_fc_tac [fchain_fchainclosed_lemma]);
val fchain_fchainclosed_lemma2 = save_pop_thm "fchain_fchainclosed_lemma2";

set_goal([], ¨µX r f∑ Rpo (Universe, r) ± FChainClosed f (X, r)
	¥ µx∑ x ç FChain f (X,r) ¥ f x ç FChain f (X,r)Æ);
a (REPEAT strip_tac);
a (fc_tac [rpo_antisym_lemma]);
a (all_fc_tac [fchain_fchainclosed_lemma]);
a (all_fc_tac [get_spec ¨FChainClosedÆ]);
a (all_fc_tac [get_spec ¨FClosedÆ]);
val fc_fcclosed_fc_lemma = save_pop_thm "fc_fcclosed_fc_lemma";

set_goal([], ¨µX Y r f∑ Rpo (Universe, r) ± FChainClosed f (X, r)
	± Y Ä FChain f (X, r) ± FChainClosed f (Y, r)
	¥ Y = FChain f (X, r)Æ);
a (REPEAT strip_tac
	THEN PC_T1 "hol1" rewrite_tac [get_spec ¨FChainÆ]
	THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a (GET_NTH_ASM_T 5 ante_tac
	THEN PC_T1 "hol1" rewrite_tac [get_spec ¨FChainÆ]
	THEN REPEAT strip_tac);
a (all_asm_fc_tac[]);
(* *** Goal "2" *** *)
a (spec_nth_asm_tac 1 ¨YÆ);
a (fc_tac [fchain_lemma1]);
a (ALL_ASM_FC_T (fc_tac o (map (pc_rule1 "hol1" rewrite_rule []))) [Ä_trans_thm]);
val fchain_lemma2 = save_pop_thm "fchain_lemma2";

set_goal([], ¨µX r f∑ Increasing r r f
	¥ FClosed f {x | x ç FChain f (X,r) ± (r x (f x) ≤ x = (f x))}Æ);
a (REPEAT strip_tac);
a (rewrite_tac [get_spec ¨FClosedÆ, get_spec ¨FChainÆ]
	THEN REPEAT strip_tac THEN_TRY SYM_ASMS_T rewrite_tac);
(* *** Goal "1" *** *)
a (GET_NTH_ASM_T 4 (fn x => all_fc_tac [rewrite_rule [] x]));
a (fc_tac [get_spec ¨FChainClosedÆ]);
a (fc_tac [get_spec ¨FClosedÆ]);
a (asm_fc_tac[]);
(* *** Goal "2" *** *)
a (fc_tac [get_spec ¨IncreasingÆ]);
a (asm_fc_tac[]);
(* *** Goal "3" *** *)
a (fc_tac [get_spec ¨IncreasingÆ]);
a (asm_fc_tac[]);
val ccrpo_fixp_lemma1 = pop_thm ();

set_goal([], ¨µX r f∑ Increasing r r f ± Rpo (Universe, r) ± FChainClosed f (X, r)
	¥ ChainComplete ({x | x ç FChain f (X,r) ± (r x (f x) ≤ x = (f x))}, r)Æ);
a (rewrite_tac [get_spec ¨ChainCompleteÆ]
	THEN REPEAT strip_tac);
a (fc_tac [ccrpo_fixp_lemma1]);
a (lemma_tac ¨FChain f (X, r) Ä XÆ
	THEN1 (PC_T1 "hol1" rewrite_tac [get_spec ¨FChainÆ]
		THEN REPEAT strip_tac
		THEN (spec_nth_asm_tac 1 ¨XÆ)));
a (lemma_tac ¨Y Ä FChain f (X, r)Æ
	THEN1 (PC_T1 "hol1" rewrite_tac []
		THEN REPEAT strip_tac
		THEN GET_NTH_ASM_T 5 (fn x => all_fc_tac [pc_rule1 "hol1" rewrite_rule [] x])));
a (lemma_tac ¨Y Ä XÆ
	THEN1 (all_fc_tac [pc_rule1 "hol1" prove_rule []
	 ¨µA B C∑ A Ä B ± B Ä C ¥ A Ä CÆ]));
a (fc_tac [get_spec ¨FChainClosedÆ]);
a (all_fc_tac [get_spec ¨ChainCompleteÆ]);
a (∂_tac ¨xÆ THEN asm_rewrite_tac[]);
a (strip_tac);
(* *** Goal "1" *** *)
a (PC_T1 "hol1" rewrite_tac [get_spec ¨FChainÆ]
	THEN REPEAT strip_tac);
a (fc_tac [get_spec ¨FChainClosedÆ]);
a (lemma_tac ¨Y Ä sÆ);
(* *** Goal "1.1" *** *)
a (lemma_tac ¨FChain f (X, r) Ä sÆ
	THEN1 rewrite_tac [get_spec ¨FChainÆ]);
(* *** Goal "1.1.1" *** *)
a (LEMMA_T ¨s ç {Y|Y Ä X ± FChainClosed f (Y, r)}Æ asm_tac
	THEN1 (PC_T1 "hol1" asm_rewrite_tac []));
a (bc_tac [pc_rule1 "hol1" prove_rule [] ¨s ç A ¥ •A Ä sÆ]
	THEN CONTR_T check_asm_tac);
(* *** Goal "1.1.2" *** *)
a (all_fc_tac [pc_rule1 "hol1" prove_rule [] ¨µA B C∑ A Ä B ± B Ä C ¥ A Ä CÆ]);
(* *** Goal "1.2" *** *)
a (GET_NTH_ASM_T 3 (fn x => (all_fc_tac [rewrite_rule [get_spec ¨ChainCompleteÆ] x])));
a (fc_tac [rpo_antisym_lemma]);
a (all_fc_tac [lub_unique_lemma]);
a (var_elim_nth_asm_tac 1);
(* *** Goal "2" *** *)
a (contr_tac);
a (lemma_tac ¨IsUb r Y (f x)Æ
	THEN1 (rewrite_tac [get_spec ¨IsUbÆ]
		THEN REPEAT strip_tac));
(* *** Goal "2.1" *** *)
a (lemma_tac ¨r x' (f x') ≤ x' = f x'Æ
	THEN1 GET_NTH_ASM_T 13 (fn x => asm_tac (pc_rule1 "hol1" rewrite_rule[] x)));
(* *** Goal "2.1.1" *** *)
a (spec_nth_asm_tac 1 ¨x'Æ THEN REPEAT strip_tac);
(* *** Goal "2.1.2" *** *)
a (lemma_tac ¨r x' xÆ);
(* *** Goal "2.1.2.1" *** *)
a (fc_tac [get_spec ¨IsLubÆ]);
a (GET_NTH_ASM_T 1 ante_tac THEN rewrite_tac [get_spec ¨IsUbÆ]
	THEN strip_tac
	THEN asm_fc_tac[]);
(* *** Goal "2.1.2.2" *** *)
a (fc_tac [get_spec ¨IncreasingÆ]
	THEN all_asm_fc_tac[]);
a (FC_T (MAP_EVERY (strip_asm_tac o (rewrite_rule[]))) [rpo_fc_clauses]);
a (all_asm_fc_tac[]);
(* *** Goal "2.1.3" *** *)
a (fc_tac [get_spec ¨IsLubÆ]);
a (GET_NTH_ASM_T 1 ante_tac THEN rewrite_tac [get_spec ¨IsUbÆ]
	THEN strip_tac
	THEN asm_fc_tac[]);
a (fc_tac [get_spec ¨IncreasingÆ]
	THEN all_asm_fc_tac[]);
a (DROP_NTH_ASM_T 2 ante_tac THEN SYM_ASMS_T rewrite_tac);
(* *** Goal "2.2" *** *)
a (GET_NTH_ASM_T 4 ante_tac THEN rewrite_tac [get_spec ¨IsLubÆ]);
a (REPEAT strip_tac);
a (all_asm_fc_tac[]);
val ccrpo_fixp_lemma2 = pop_thm ();

set_goal([], ¨µX r f∑ Increasing r r f ± Rpo(Universe,r) ± FChainClosed f (X, r)
	¥ FChainClosed f ({z|z ç FChain f (X,r) ± (r z (f z) ≤ z = f z)}, r)Æ);
a (REPEAT strip_tac);
a (rewrite_tac [get_spec ¨FChainClosedÆ]
	THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a (all_fc_tac[ccrpo_fixp_lemma1]);
a (asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a (all_fc_tac[ccrpo_fixp_lemma1]);
a (all_fc_tac[rpo_antisym_lemma]);
a (all_fc_tac[fchain_fchainclosed_lemma]);
a (all_fc_tac[ccrpo_fixp_lemma2]);
val ccrpo_fixp_lemma3 = pop_thm ();

set_goal([], ¨µX r f∑ Increasing r r f ± Rpo(Universe,r) ± FChainClosed f (X, r)
	¥ µz∑ z ç FChain f (X,r) ¥ r z (f z) ≤ z = f zÆ);
a (REPEAT strip_tac);
a (all_fc_tac [ccrpo_fixp_lemma3]);
a (lemma_tac ¨{z|z ç FChain f (X, r) ± (r z (f z) ≤ z = f z)} Ä FChain f (X, r)Æ
	THEN1 (PC_T1 "hol1" rewrite_tac[]
		THEN REPEAT strip_tac));
a (all_fc_tac [fchain_lemma2]);
a (DROP_NTH_ASM_T 5 ante_tac THEN SYM_ASMS_T once_rewrite_tac);
a (rewrite_tac[]);
a (contr_tac);
val ccrpo_fixp_lemma4 = save_pop_thm "ccrpo_fixp_lemma4";
=TEX
}%ignore

πHOLCONST
‹ €Set2› : (('a ≠ 'a) ∏ ('a SET ∏ ('a ≠ 'a ≠ BOOL))) ≠ 'a SET
˜¸¸¸¸¸¸¸¸¸¸¸
‹ µ f X $ºâv∑ Set2 (f, X, $ºâv) =
‹	{x | x ç FChain f (X, $ºâv) ± µy∑ y ç FChain f (X, $ºâv)
		¥ y ºâv x ± ≥ y = x ¥ f y ºâv x}
∞

πHOLCONST
‹ €Extreme› : (('a ≠ 'a) ∏ ('a SET ∏ ('a ≠ 'a ≠ BOOL))) ≠ 'a SET
˜¸¸¸¸¸¸¸¸¸¸¸
‹ µ f X $ºâv∑ Extreme (f, X, $ºâv) =
‹	{x | x ç FChain f (X, $ºâv) ± µy∑ y ç FChain f (X, $ºâv)
‹		¥ y ºâv x ± ≥ y = x ¥ f y ºâv x}
∞

πHOLCONST
‹ €S› : (('a ≠ 'a) ∏ ('a SET ∏ ('a ≠ 'a ≠ BOOL))) ≠ 'a ≠ 'a SET
˜¸¸¸¸¸¸¸¸¸¸¸
‹ µ f X $ºâv x∑ S (f, X, $ºâv) x =
‹	{y | y ç FChain f (X, $ºâv) ± (y ºâv x ≤ f x ºâv y)}
∞

=GFT
€ccrpo_fixp_lemma5› =
   Ù µ X $ºâv f x
     ∑ Increasing $ºâv $ºâv f
           ± Rpo (Universe, $ºâv)
           ± FChainClosed f (X, $ºâv)
           ± x ç Extreme (f, X, $ºâv)
         ¥ FClosed f (S (f, X, $ºâv) x)

€ccrpo_fixp_lemma6› =
   Ù µ X $ºâv f x
     ∑ Increasing $ºâv $ºâv f
           ± Rpo (Universe, $ºâv)
           ± FChainClosed f (X, $ºâv)
           ± x ç Extreme (f, X, $ºâv)
         ¥ ChainComplete (S (f, X, $ºâv) x, $ºâv)

€ccrpo_fixp_lemma7› =
   Ù µ X $ºâv f x
     ∑ Increasing $ºâv $ºâv f
           ± Rpo (Universe, $ºâv)
           ± FChainClosed f (X, $ºâv)
           ± x ç Extreme (f, X, $ºâv)
         ¥ FChainClosed f (S (f, X, $ºâv) x, $ºâv)

€ccrpo_fixp_lemma8› =
   Ù µ X $ºâv f
     ∑ Increasing $ºâv $ºâv f
           ± Rpo (Universe, $ºâv)
           ± FChainClosed f (X, $ºâv)
           ± x ç Extreme (f, X, $ºâv)
         ¥ FChain f (X, $ºâv) = S (f, X, $ºâv) x

€ccrpo_fixp_lemma9› =
   Ù µ X $ºâv f
     ∑ Increasing $ºâv $ºâv f
           ± Rpo (Universe, $ºâv)
           ± FChainClosed f (X, $ºâv)
         ¥ FClosed f (Extreme (f, X, $ºâv))

€ccrpo_fixp_lemma10› =
   Ù µ X $ºâv f
     ∑ Increasing $ºâv $ºâv f
           ± Rpo (Universe, $ºâv)
           ± FChainClosed f (X, $ºâv)
         ¥ ChainComplete (Extreme (f, X, $ºâv), $ºâv)

€ccrpo_fixp_lemma11› =
   Ù µ X $ºâv f x
     ∑ Increasing $ºâv $ºâv f
           ± Rpo (Universe, $ºâv)
           ± FChainClosed f (X, $ºâv)
         ¥ FChainClosed f (Extreme (f, X, $ºâv), $ºâv)

€ccrpo_fixp_lemma12› =
   Ù µ X $ºâv f
     ∑ Increasing $ºâv $ºâv f
           ± Rpo (Universe, $ºâv)
           ± FChainClosed f (X, $ºâv)
         ¥ FChain f (X, $ºâv) = Extreme (f, X, $ºâv)

€ccrpo_fixp_lemma13› =
   Ù µ X $ºâv f
     ∑ Increasing $ºâv $ºâv f
           ± Rpo (Universe, $ºâv)
           ± FChainClosed f (X, $ºâv)
         ¥ FChain f (X, $ºâv)
           = {x
           |x ç Extreme (f, X, $ºâv) ± FChain f (X, $ºâv) Ä S (f, X, $ºâv) x}

€ccrpo_fixp_lemma14› =
   Ù µ X $ºâv f
     ∑ Increasing $ºâv $ºâv f
           ± Rpo (Universe, $ºâv)
           ± FChainClosed f (X, $ºâv)
         ¥ (µ x y
         ∑ {x; y} Ä FChain f (X, $ºâv)
             ¥ (x ºâv f x ≤ x = f x)
               ± (y ºâv x ± ≥ y = x ¥ f y ºâv x)
               ± (y ºâv x ≤ f x ºâv y))
=TEX

\ignore{
=SML
set_goal([], ¨µX $ºâv f x∑ Increasing $ºâv $ºâv f ± Rpo(Universe,$ºâv)
	± FChainClosed f (X, $ºâv) ± x ç Extreme (f, X, $ºâv)
	¥ FClosed f (S (f, X, $ºâv) x)Æ);
a (rewrite_tac (map get_spec [¨FClosedÆ, ¨SÆ, ¨ExtremeÆ])
	THEN REPEAT_N 7 strip_tac);
(* *** Goal "1" *** *)
a (ALL_FC_T rewrite_tac [fc_fcclosed_fc_lemma]);
a (cases_tac ¨x' = xÆ THEN1 var_elim_asm_tac ¨x' = xÆ);
(* *** Goal "1.1" *** *)
a (fc_tac [get_spec ¨IncreasingÆ]
	THEN all_asm_fc_tac []
	THEN asm_rewrite_tac[]);
(* *** Goal "1.2" *** *)
a (all_asm_fc_tac[] THEN asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a (ALL_FC_T rewrite_tac [fc_fcclosed_fc_lemma]);
a (lemma_tac ¨x ºâv (f x) ≤ x = f xÆ
	THEN1 (FC_T (MAP_EVERY (strip_asm_tac o (list_µ_elim [¨XÆ, ¨xÆ]))) [ccrpo_fixp_lemma4]
		THEN REPEAT strip_tac));
(* *** Goal "2.1" *** *)
a (lemma_tac ¨x' ºâv (f x') ≤ x' = f x'Æ
	THEN1 (FC_T (MAP_EVERY (strip_asm_tac o (list_µ_elim [¨XÆ, ¨x'Æ]))) [ccrpo_fixp_lemma4]
		THEN REPEAT strip_tac));
(* *** Goal "2.1.1" *** *)
a (FC_T (MAP_EVERY(strip_asm_tac o (rewrite_rule[]))) [rpo_fc_clauses]);
a (all_asm_fc_tac[] THEN contr_tac);
(* *** Goal "2.1.2" *** *)
a (SYM_ASMS_T rewrite_tac);
(* *** Goal "2.2" *** *)
a (lemma_tac ¨x ºâv x'Æ
	THEN1 (GET_NTH_ASM_T 2 ante_tac
		THEN (POP_ASM_T (rewrite_thm_tac o map_eq_sym_rule))
		THEN strip_tac));
a (all_fc_tac [get_spec ¨IncreasingÆ]);
a (contr_tac);
val ccrpo_fixp_lemma5 = pop_thm ();

set_goal([], ¨µX $ºâv f x∑ Increasing $ºâv $ºâv f ± Rpo(Universe,$ºâv)
	± FChainClosed f (X, $ºâv) ± x ç Extreme (f, X, $ºâv)
	¥ ChainComplete (S (f, X, $ºâv) x, $ºâv)Æ);
a (rewrite_tac (map get_spec [¨ChainCompleteÆ, ¨SÆ, ¨ExtremeÆ])
	THEN REPEAT_N 7 strip_tac);
a (lemma_tac ¨Y Ä FChain f (X, $ºâv)Æ);
(* *** Goal "1" *** *)
a (GET_NTH_ASM_T 2 (asm_tac o (pc_rule1 "hol1" rewrite_rule[]))); 
a (PC_T "hol1" (REPEAT strip_tac));
a (asm_fc_tac[]);
(* *** Goal "2" *** *)
a (all_fc_tac [fchain_fchainclosed_lemma2]);
a (all_fc_tac [get_spec ¨FChainClosedÆ]);
a (all_fc_tac [get_spec ¨ChainCompleteÆ]);
a (∂_tac ¨x'Æ
	THEN asm_rewrite_tac[]);
a (cases_tac ¨µc∑ c ç Y ¥ c ºâv xÆ);
(* *** Goal "2.1" *** *)
a (lemma_tac ¨x' ºâv xÆ);
(* *** Goal "2.1.1" *** *)
a (lemma_tac ¨IsUb $ºâv Y xÆ
	THEN1 (rewrite_tac [get_spec ¨IsUbÆ]
		THEN REPEAT strip_tac THEN asm_fc_tac[]));
a (all_fc_tac [get_spec ¨IsLubÆ]);
(* *** Goal "2.1.2" *** *)
a (contr_tac);
(* *** Goal "2.2" *** *)
a (DROP_NTH_ASM_T 12 (asm_tac o (pc_rule1 "hol1" rewrite_rule[])));
a (all_asm_fc_tac[]);
a (all_fc_tac[get_spec ¨IsLubÆ]);
a (all_fc_tac[get_spec ¨IsUbÆ]);
a (all_fc_tac[rpou_fc_clauses]);
a contr_tac;
val ccrpo_fixp_lemma6 = pop_thm ();

set_goal([], ¨µX $ºâv f x∑ Increasing $ºâv $ºâv f ± Rpo(Universe,$ºâv)
	± FChainClosed f (X, $ºâv) ± x ç Extreme (f, X, $ºâv)
	¥ FChainClosed f (S (f, X, $ºâv) x, $ºâv)Æ);
a (REPEAT strip_tac
	THEN rewrite_tac [get_spec ¨FChainClosedÆ]
	THEN all_fc_tac [ccrpo_fixp_lemma5]
	THEN all_fc_tac [ccrpo_fixp_lemma6]
	THEN contr_tac);
val ccrpo_fixp_lemma7 = pop_thm ();

set_goal([], ¨µX $ºâv f∑ Increasing $ºâv $ºâv f ± Rpo(Universe,$ºâv)
	± FChainClosed f (X, $ºâv) ± x ç Extreme (f, X, $ºâv)
	¥ FChain f (X, $ºâv) = S (f, X, $ºâv)  xÆ);
a (REPEAT strip_tac
	THEN all_fc_tac [ccrpo_fixp_lemma7]);
a (all_fc_tac[get_spec ¨FChainClosedÆ]);
a (PC_T1 "hol1" rewrite_tac [] THEN REPEAT strip_tac
	THEN all_fc_tac [get_spec ¨FClosedÆ]);
a (lemma_tac ¨S (f, X, $ºâv) x Ä FChain f (X, $ºâv)Æ
	THEN1 (rewrite_tac [get_spec ¨SÆ]
		THEN PC_T "hol1" (REPEAT strip_tac)));
a (all_fc_tac [fchain_lemma2]
	THEN asm_rewrite_tac[]);
a (POP_ASM_T ante_tac
	THEN rewrite_tac [get_spec ¨SÆ]
		THEN PC_T "hol1" (REPEAT strip_tac));
val ccrpo_fixp_lemma8 = pop_thm();

set_goal([], ¨µX $ºâv f∑ Increasing $ºâv $ºâv f ± Rpo(Universe,$ºâv)
	± FChainClosed f (X, $ºâv)
	¥ FClosed f (Extreme (f, X, $ºâv))Æ);
a (REPEAT strip_tac THEN rewrite_tac [get_spec ¨FClosedÆ]
	THEN REPEAT strip_tac);
a (GET_NTH_ASM_T 1 ante_tac THEN rewrite_tac [get_spec ¨ExtremeÆ]
	THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a (all_fc_tac [fchain_fchainclosed_lemma2]);
a (all_fc_tac [get_spec ¨FChainClosedÆ]);
a (all_fc_tac [get_spec ¨FClosedÆ]);
(* *** Goal "2" *** *)
a (all_fc_tac [ccrpo_fixp_lemma8]);
a (GET_NTH_ASM_T 4 ante_tac
	THEN GET_NTH_ASM_T 1 rewrite_thm_tac
	THEN rewrite_tac [get_spec ¨SÆ]
	THEN strip_tac); 
(* *** Goal "2.1" *** *)
a (all_fc_tac [get_spec ¨IncreasingÆ]);
(* *** Goal "2.2" *** *)
a (all_fc_tac [rpou_fc_clauses]);
val ccrpo_fixp_lemma9 = pop_thm ();

set_goal([], ¨µX $ºâv f∑ Increasing $ºâv $ºâv f ± Rpo(Universe,$ºâv)
	± FChainClosed f (X, $ºâv)
	¥ ChainComplete (Extreme (f, X, $ºâv), $ºâv)Æ);
a (REPEAT strip_tac THEN rewrite_tac [get_spec ¨ChainCompleteÆ]
	THEN REPEAT strip_tac);
a (GET_NTH_ASM_T 2 (strip_asm_tac o (pc_rule1 "hol1" rewrite_rule [get_spec ¨ExtremeÆ])));
a (lemma_tac ¨Y Ä FChain f (X, $ºâv)Æ
	THEN1 (PC_T "hol1" (REPEAT strip_tac)
		THEN asm_fc_tac[]));
a (all_fc_tac [fchain_fchainclosed_lemma2]);
a (all_fc_tac [get_spec ¨FChainClosedÆ]);
a (all_fc_tac [get_spec ¨ChainCompleteÆ]);
a (∂_tac ¨xÆ
	THEN asm_rewrite_tac[]);
a (rewrite_tac [get_spec ¨ExtremeÆ]
	THEN REPEAT strip_tac);
a (lemma_tac ¨∂b∑ b ç Y ± ≥ b ºâv yÆ
	THEN1 contr_tac);
(* *** Goal "1" *** *)
a (lemma_tac ¨IsUb $ºâv Y yÆ
	THEN1 rewrite_tac [get_spec ¨IsUbÆ]);
(* *** Goal "1.1" *** *)
a (REPEAT strip_tac);
a (spec_nth_asm_tac 2 ¨x'Æ);
(* *** Goal "1.2" *** *)
a (fc_tac [list_µ_elim [¨$ºâvÆ, ¨YÆ, ¨xÆ] (get_spec ¨IsLubÆ)]);
a (spec_nth_asm_tac 2 ¨yÆ);
a (all_fc_tac [rpou_fc_clauses]);
(* *** Goal "2" *** *)
a (lemma_tac ¨b ç Extreme (f, X, $ºâv)Æ
	THEN1 (GET_NTH_ASM_T 16 ante_tac
	THEN PC_T1 "hol1" rewrite_tac[]
	THEN REPEAT strip_tac
	THEN asm_fc_tac[]));
a (all_fc_tac [ccrpo_fixp_lemma8]);
a (GET_NTH_ASM_T 7 ante_tac
	THEN GET_NTH_ASM_T 1 rewrite_thm_tac
	THEN rewrite_tac [get_spec ¨SÆ]
	THEN strip_tac); 
(* *** Goal "2.1" *** *)
a (lemma_tac ¨≥ y = bÆ
	THEN1 (contr_tac
		THEN all_fc_tac [rpou_fc_clauses]
		THEN var_elim_nth_asm_tac 2
		THEN asm_fc_tac[]));
a (GET_NTH_ASM_T 4 (strip_asm_tac o (rewrite_rule [get_spec ¨ExtremeÆ])));
a (lemma_tac ¨f y ºâv bÆ THEN1 all_asm_fc_tac[]);
a (lemma_tac ¨b ºâv xÆ);
(* *** Goal "2.1.1" *** *)
a (lemma_tac ¨IsUb $ºâv Y xÆ  THEN1 fc_tac [get_spec ¨IsLubÆ]);
a (POP_ASM_T (asm_tac o (rewrite_rule [get_spec ¨IsUbÆ])));
a (asm_fc_tac[]);
(* *** Goal "2.1.2" *** *)
a (all_fc_tac [rpou_fc_clauses]);
(* *** Goal "2.2" *** *)
a (lemma_tac ¨b ç FChain f (X, $ºâv)Æ
	THEN1 (GET_NTH_ASM_T 16 (fn x => fc_tac [pc_rule1 "hol1" rewrite_rule [] x])));
a (strip_asm_tac (list_µ_elim [¨XÆ, ¨$ºâvÆ, ¨fÆ] ccrpo_fixp_lemma4));
a (spec_nth_asm_tac 1 ¨bÆ);
(* *** Goal "2.2.1" *** *)
a (all_fc_tac [rpou_fc_clauses]);
(* *** Goal "2.2.2" *** *)
a (DROP_NTH_ASM_T 4 ante_tac
	THEN SYM_ASMS_T rewrite_tac
	THEN contr_tac);
val ccrpo_fixp_lemma10 = pop_thm ();

set_goal([], ¨µX $ºâv f x∑ Increasing $ºâv $ºâv f ± Rpo(Universe,$ºâv)
	± FChainClosed f (X, $ºâv) 
	¥ FChainClosed f (Extreme (f, X, $ºâv), $ºâv)Æ);
a (REPEAT strip_tac
	THEN rewrite_tac [get_spec ¨FChainClosedÆ]
	THEN all_fc_tac [ccrpo_fixp_lemma9]
	THEN all_fc_tac [ccrpo_fixp_lemma10]
	THEN contr_tac);
val ccrpo_fixp_lemma11 = pop_thm ();

set_goal([], ¨µX $ºâv f∑ Increasing $ºâv $ºâv f ± Rpo(Universe,$ºâv)
	± FChainClosed f (X, $ºâv)
	¥ FChain f (X, $ºâv) = Extreme (f, X, $ºâv)Æ);
a (REPEAT strip_tac
	THEN all_fc_tac [ccrpo_fixp_lemma7]);
a (all_fc_tac[get_spec ¨FChainClosedÆ]);
a (PC_T1 "hol1" rewrite_tac [] THEN REPEAT strip_tac
	THEN all_fc_tac [get_spec ¨FClosedÆ]);
(* *** Goal "1" *** *)
a (lemma_tac ¨Extreme (f, X, $ºâv) Ä FChain f (X, $ºâv)Æ
	THEN1 (rewrite_tac [get_spec ¨ExtremeÆ]
		THEN PC_T "hol1" (REPEAT strip_tac)));
a (all_fc_tac [ccrpo_fixp_lemma11]);
a (all_fc_tac [fchain_lemma2]
	THEN asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a (POP_ASM_T ante_tac
	THEN rewrite_tac [get_spec ¨ExtremeÆ]
		THEN PC_T "hol1" (REPEAT strip_tac));
val ccrpo_fixp_lemma12 = pop_thm();


set_goal([], ¨µX $ºâv f∑ Increasing $ºâv $ºâv f ± Rpo(Universe,$ºâv)
	± FChainClosed f (X, $ºâv)
	¥ FChain f (X, $ºâv) = {x | x ç Extreme (f, X, $ºâv)
		± FChain f (X, $ºâv) Ä S (f,X, $ºâv) x}Æ);
a (PC_T "hol1" (REPEAT_N 9 strip_tac));
(* *** Goal "1" *** *)
a (all_fc_tac [ccrpo_fixp_lemma12]);
a (GET_NTH_ASM_T 2 (asm_tac o (rewrite_rule [asm_rule ¨FChain f (X, $ºâv) = Extreme (f, X, $ºâv)Æ])));
a (REPEAT strip_tac);
a (all_fc_tac [ccrpo_fixp_lemma8]
	THEN asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a (all_fc_tac [ccrpo_fixp_lemma12]
	THEN asm_rewrite_tac[]);
val ccrpo_fixp_lemma13 = pop_thm();
 
set_goal([], ¨µX $ºâv f∑ Increasing $ºâv $ºâv f ± Rpo(Universe,$ºâv)
	± FChainClosed f (X, $ºâv)
	¥ µx y∑ {x; y} Ä FChain f (X, $ºâv)
		¥ (y ºâv x ± ≥ y = x ¥ f y ºâv x)
		± (y ºâv x ≤ f x ºâv y)
		Æ);
a (REPEAT_N 6 strip_tac
	THEN all_fc_tac [ccrpo_fixp_lemma13]);
a (once_asm_rewrite_tac[]);
a (rewrite_tac[get_spec ¨ExtremeÆ, get_spec ¨SÆ]);
a (PC_T "hol1" strip_tac);
a (spec_nth_asm_tac 1 ¨xÆ);
a (spec_nth_asm_tac 4 ¨yÆ);
a (REPEAT strip_tac);
(* *** Goal "1" *** *)
a (spec_nth_asm_tac 7 ¨yÆ);
(* *** Goal "2" *** *)
a (GET_NTH_ASM_T 5 ante_tac THEN PC_T1 "hol1" rewrite_tac[]
	THEN strip_tac);
a (spec_nth_asm_tac 1 ¨yÆ);
val ccrpo_fixp_lemma14 = pop_thm();
 
set_goal([], ¨µX $ºâv f∑ Increasing $ºâv $ºâv f ± Rpo(Universe,$ºâv)
	± FChainClosed f (X, $ºâv)
	¥ µx y∑ {x; y} Ä FChain f (X, $ºâv)
		¥ (x ºâv f x ≤ x = f x)
		± (y ºâv x ± ≥ y = x ¥ f y ºâv x)
		± (y ºâv x ≤ f x ºâv y)
		Æ);
a (REPEAT_N 6 strip_tac
	THEN all_fc_tac [ccrpo_fixp_lemma13]);
a (once_asm_rewrite_tac[]);
a (rewrite_tac[get_spec ¨ExtremeÆ, get_spec ¨SÆ]);
a (PC_T "hol1" strip_tac);
a (spec_nth_asm_tac 1 ¨xÆ);
a (spec_nth_asm_tac 4 ¨yÆ);
a (strip_tac);
(* *** Goal "1" *** *)
a (strip_asm_tac (list_µ_elim [¨XÆ, ¨$ºâvÆ, ¨fÆ] ccrpo_fixp_lemma4));
a (spec_nth_asm_tac 1 ¨xÆ THEN contr_tac);
(* *** Goal "2" *** *)
a (REPEAT strip_tac);
(* *** Goal "2.1" *** *)
a (spec_nth_asm_tac 7 ¨yÆ);
(* *** Goal "2.2" *** *)
a (GET_NTH_ASM_T 5 ante_tac THEN PC_T1 "hol1" rewrite_tac[]
	THEN strip_tac);
a (spec_nth_asm_tac 1 ¨yÆ);
val ccrpo_fixp_lemma14 = pop_thm();
=TEX
}%ignore

=GFT
€ccrpo_fixp_lemma15› =
   Ù µ X $ºâv f
     ∑ Increasing $ºâv $ºâv f
           ± Rpo (Universe, $ºâv)
           ± FChainClosed f (X, $ºâv)
         ¥ Trich (FChain f (X, $ºâv), $ºâv)

€ccrpo_fixp_lemma16› =
   Ù µ X $ºâv f
     ∑ Increasing $ºâv $ºâv f
           ± Rpo (Universe, $ºâv)
           ± FChainClosed f (X, $ºâv)
         ¥ LinearOrder (FChain f (X, $ºâv), $ºâv)

€ccrpo_fixp_lemma17› =
   Ù µ X $ºâv f
     ∑ Increasing $ºâv $ºâv f
           ± Rpo (Universe, $ºâv)
           ± FChainClosed f (X, $ºâv)
         ¥ (∂ e
         ∑ IsLub $ºâv (FChain f (X, $ºâv)) e
             ± e = f e
             ± e ç FChain f (X, $ºâv))
=TEX

\ignore{
=SML
set_goal([], ¨µX $ºâv f∑ Increasing $ºâv $ºâv f ± Rpo(Universe,$ºâv)
	± FChainClosed f (X, $ºâv)
	¥ Trich (FChain f (X, $ºâv), $ºâv)	Æ);
a (REPEAT µ_tac);
a (REPEAT strip_tac
	THEN strip_asm_tac (list_µ_elim [¨XÆ, ¨$ºâvÆ, ¨fÆ] ccrpo_fixp_lemma14)
	THEN rewrite_tac [get_spec ¨TrichÆ]
	THEN REPEAT strip_tac);
a (PC_T "hol1" (list_spec_nth_asm_tac 5 [¨xÆ, ¨yÆ])
	THEN_TRY (var_elim_nth_asm_tac 2));
(* *** Goal "1" *** *)
a (all_fc_tac [rpou_fc_clauses]);
(* *** Goal "2" *** *)
a (all_fc_tac [rpou_fc_clauses]);
(* *** Goal "3" *** *)
a (POP_ASM_T ante_tac
	THEN SYM_ASMS_T rewrite_tac);
(* *** Goal "4" *** *)
a (POP_ASM_T ante_tac
	THEN SYM_ASMS_T rewrite_tac);
val ccrpo_fixp_lemma15 = pop_thm();

set_goal([], ¨µX $ºâv f∑ Increasing $ºâv $ºâv f ± Rpo(Universe,$ºâv)
	± FChainClosed f (X, $ºâv)
	¥ LinearOrder (FChain f (X, $ºâv), $ºâv)Æ);
a (REPEAT strip_tac
	THEN all_asm_fc_tac [ccrpo_fixp_lemma15]
	THEN rewrite_tac [get_spec ¨LinearOrderÆ]
	THEN REPEAT strip_tac);
a (fc_tac [get_spec ¨RpoÆ]);
a (LEMMA_T ¨FChain f (X, $ºâv) Ä UniverseÆ asm_tac THEN1 PC_T1 "hol1" prove_tac[]);
a (all_fc_tac [subrel_partial_order_thm]);
val ccrpo_fixp_lemma16 = pop_thm ();

=IGN
set_goal([], ¨µX $ºâv f∑ Increasing $ºâv $ºâv f ± Rpo(Universe,$ºâv)
	± FChainClosed f (X, $ºâv)
	¥ ∂e∑ IsLub $ºâv (FChain f (X, $ºâv)) e ± e = f eÆ);
a (REPEAT strip_tac);
a (all_fc_tac [fchain_fchainclosed_lemma2]);
a (fc_tac[fchain_lemma1]);
a (all_fc_tac [ccrpo_fixp_lemma16]);
a (all_fc_tac [get_spec ¨FChainClosedÆ]);
a (LEMMA_T ¨FChain f (X, $ºâv) Ä FChain f (X, $ºâv)Æ asm_tac
	THEN1 PC_T1 "hol1" prove_tac[]);
a (all_fc_tac [get_spec ¨ChainCompleteÆ]);
a (∂_tac ¨xÆ THEN asm_rewrite_tac[]);
a (lemma_tac ¨f x ç FChain f (X, $ºâv)Æ
	THEN1 (all_fc_tac [get_spec ¨FClosedÆ]));
a (strip_asm_tac (list_µ_elim [¨XÆ, ¨$ºâvÆ, ¨fÆ] ccrpo_fixp_lemma4));
a (spec_nth_asm_tac 1 ¨xÆ);
a (lemma_tac ¨f x ºâv xÆ);
a (all_fc_tac [get_spec ¨IsLubÆ]);
a (strip_asm_tac (list_µ_elim [¨$ºâvÆ, ¨FChain f (X, $ºâv)Æ, ¨xÆ]
			(get_spec ¨IsUbÆ)));
(* *** Goal "1.1" *** *)
a (all_asm_fc_tac[]);
(* *** Goal "1.2" *** *)
a (all_asm_fc_tac[]);
(* *** Goal "2" *** *)
a (all_fc_tac [rpou_fc_clauses]);
val ccrpo_fixp_lemma17a = pop_thm ();
=SML

set_goal([], ¨µX $ºâv f∑ Increasing $ºâv $ºâv f ± Rpo(Universe,$ºâv)
	± FChainClosed f (X, $ºâv)
	¥ ∂e∑ IsLub $ºâv (FChain f (X, $ºâv)) e ± e = f e ± e ç FChain f (X, $ºâv)Æ);
a (REPEAT strip_tac);
a (all_fc_tac [fchain_fchainclosed_lemma2]);
a (fc_tac[fchain_lemma1]);
a (all_fc_tac [ccrpo_fixp_lemma16]);
a (all_fc_tac [get_spec ¨FChainClosedÆ]);
a (LEMMA_T ¨FChain f (X, $ºâv) Ä FChain f (X, $ºâv)Æ asm_tac
	THEN1 PC_T1 "hol1" prove_tac[]);
a (all_fc_tac [get_spec ¨ChainCompleteÆ]);
a (∂_tac ¨xÆ THEN asm_rewrite_tac[]);
a (lemma_tac ¨f x ç FChain f (X, $ºâv)Æ
	THEN1 (all_fc_tac [get_spec ¨FClosedÆ]));
a (strip_asm_tac (list_µ_elim [¨XÆ, ¨$ºâvÆ, ¨fÆ] ccrpo_fixp_lemma4));
a (spec_nth_asm_tac 1 ¨xÆ);
a (lemma_tac ¨f x ºâv xÆ);
a (all_fc_tac [get_spec ¨IsLubÆ]);
a (strip_asm_tac (list_µ_elim [¨$ºâvÆ, ¨FChain f (X, $ºâv)Æ, ¨xÆ]
			(get_spec ¨IsUbÆ)));
(* *** Goal "1.1" *** *)
a (all_asm_fc_tac[]);
(* *** Goal "1.2" *** *)
a (all_asm_fc_tac[]);
(* *** Goal "2" *** *)
a (all_fc_tac [rpou_fc_clauses]);
val ccrpo_fixp_lemma17 = pop_thm ();
=TEX
}%ignore

=GFT
€ccrpo_fixp_lemma18› =
   Ù µ X $ºâv f
     ∑ Increasing $ºâv $ºâv f
           ± Rpo (Universe, $ºâv)
           ± FChainClosed f (X, $ºâv)
         ¥ (∂ l∑ IsLub $ºâv (FChain f (X, $ºâv)) l ± IsLfp $ºâv f l)

€ccrpo_fixp_lemma19› =
   Ù µ r f∑ CcRpo (Universe, r) ± Increasing r r f ¥ (∂ e∑ IsLfp r f e)

€ccrpou_fixp_induction_thm› =
   Ù µ r f p
     ∑ CcRpoU r
           ± Increasing r r f
           ± (µ x∑ p x ¥ p (f x))
           ± (µ s
           ∑ (µ x∑ x ç s ¥ p x) ± LinearOrder (s, r)
               ¥ (∂ y∑ p y ± IsLub r s y))
         ¥ p (Lfpâc r f)
=TEX


\ignore{
=SML
set_goal([], ¨µX $ºâv f∑ Increasing $ºâv $ºâv f ± Rpo(Universe,$ºâv)
	± FChainClosed f (X, $ºâv)
	¥ ∂l∑ IsLub $ºâv (FChain f (X, $ºâv)) l ± IsLfp $ºâv f lÆ);
a (REPEAT strip_tac
	THEN all_fc_tac [ccrpo_fixp_lemma17]);
a (∂_tac ¨eÆ THEN (SYM_ASMS_T rewrite_tac));
a (rewrite_tac [get_spec ¨IsLfpÆ, let_def]
	THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a (SYM_ASMS_T rewrite_tac);
(* *** Goal "2" *** *)
a (rewrite_tac [get_spec ¨IsGlbÆ, get_spec ¨IsLbÆ]
	THEN REPEAT strip_tac);
(* *** Goal "2.1" *** *)
a (lemma_tac ¨FChainClosed f ({y | y ç FChain f (X, $ºâv) ± y ºâv x}, $ºâv)Æ
	THEN1 (rewrite_tac [get_spec ¨FChainClosedÆ]
		THEN REPEAT strip_tac));
(* *** Goal "2.1.1" *** *)
a (rewrite_tac [get_spec ¨FClosedÆ]
	THEN REPEAT strip_tac);
(* *** Goal "2.1.1.1" *** *)
a (all_fc_tac [fchain_fchainclosed_lemma2]);
a (all_fc_tac [get_spec ¨FChainClosedÆ]);
a (all_fc_tac [get_spec ¨FClosedÆ]);
(* *** Goal "2.1.1.2" *** *)
a (all_fc_tac [get_spec ¨IncreasingÆ]);
a (POP_ASM_T ante_tac
	THEN GET_NTH_ASM_T 3 rewrite_thm_tac);
(* *** Goal "2.1.2" *** *)
a (rewrite_tac [get_spec ¨ChainCompleteÆ]
	THEN REPEAT strip_tac);
a (all_fc_tac [fchain_fchainclosed_lemma2]);
a (all_fc_tac [get_spec ¨FChainClosedÆ]);
a (lemma_tac ¨Y Ä FChain f (X, $ºâv)Æ
	THEN1 (GET_NTH_ASM_T 7 ante_tac
		THEN PC_T1 "hol1" prove_tac[]));
a (all_fc_tac [get_spec ¨ChainCompleteÆ]);
a (∂_tac ¨x'Æ THEN REPEAT strip_tac);
a (lemma_tac ¨IsUb $ºâv Y xÆ
	THEN1 (rewrite_tac [get_spec ¨IsUbÆ]
		THEN GET_NTH_ASM_T 10 ante_tac
		THEN PC_T1 "hol1" prove_tac[]));
a (all_fc_tac [get_spec ¨IsLubÆ]);
(* *** Goal "2.1.3" *** *)
a (lemma_tac ¨{y|y ç FChain f (X, $ºâv) ± y ºâv x} Ä FChain f (X, $ºâv)Æ
	THEN1 (PC_T1 "hol1" prove_tac[]));
a (all_fc_tac [fchain_lemma2]);
a (lemma_tac ¨µ x'∑ x' ç FChain f (X, $ºâv) ¥ x' ºâv xÆ
	THEN1 (POP_ASM_T ante_tac THEN PC_T1 "hol1" prove_tac[]));
a (lemma_tac ¨IsUb $ºâv (FChain f (X, $ºâv)) xÆ
	THEN1 (rewrite_tac [get_spec ¨IsUbÆ]
		THEN REPEAT strip_tac
		THEN asm_fc_tac[]));
a (all_fc_tac [get_spec ¨IsLubÆ]);
(* *** Goal "2.2" *** *)
a (spec_nth_asm_tac 1 ¨eÆ);
a (POP_ASM_T ante_tac THEN SYM_ASMS_T rewrite_tac);
val ccrpo_fixp_lemma18 = pop_thm ();

set_goal([], ¨µr f∑ CcRpoU r
	± Increasing r r f
	¥ (∂ e∑ IsLfp r f e)Æ);
a (REPEAT strip_tac
	THEN all_fc_tac [get_spec ¨CcRpoUÆ]
	THEN all_fc_tac [get_spec ¨CcRpoÆ]);
a (lemma_tac ¨FClosed f UniverseÆ
	THEN1 rewrite_tac [get_spec ¨FClosedÆ]);
a (lemma_tac ¨FChainClosed f (Universe, r)Æ
	THEN1 asm_rewrite_tac[get_spec¨FChainClosedÆ]);
a (all_fc_tac [ccrpo_fixp_lemma18]);
a (∂_tac ¨lÆ THEN contr_tac);
val ccrpo_fixp_lemma19 = pop_thm ();

set_goal([], ¨µr f p∑ CcRpoU r 
	± Increasing r r f
	± (µx∑ p x ¥ p (f x))
	± (µs∑ (µx∑ x ç s ¥ p x) ± LinearOrder (s, r) ¥ ∂y∑ p y ± (IsLub r s y))
	¥ p (Lfpâc r f)
	Æ);
a (REPEAT strip_tac
	THEN all_fc_tac [ccrpo_fixp_lemma19]);
a (lemma_tac ¨FChainClosed f ({x | p x}, r)Æ
	THEN1 (rewrite_tac [get_spec ¨FChainClosedÆ]
		THEN REPEAT strip_tac));
(* *** Goal "1" *** *)
a (rewrite_tac [get_spec ¨FClosedÆ]
	THEN REPEAT strip_tac
	THEN all_asm_fc_tac[]);
(* *** Goal "2" *** *)
a (rewrite_tac [get_spec ¨ChainCompleteÆ]
	THEN (PC_T1 "hol1" rewrite_tac [])
	THEN (PC_T1 "hol1" REPEAT strip_tac)
	THEN all_asm_fc_tac[]);
a (all_fc_tac [get_spec ¨CcRpoUÆ]);
a (all_fc_tac [get_spec ¨CcRpoÆ]);
a (fc_tac [get_spec ¨ChainCompleteÆ]);
a (POP_ASM_T (fn x => fc_tac [rewrite_rule[] x]));
a (∂_tac ¨xÆ
	THEN asm_rewrite_tac[]);
a (all_fc_tac [rpo_antisym_lemma]);
a (all_fc_tac [lub_unique_lemma]);
a (var_elim_nth_asm_tac 1);
(* *** Goal "3" *** *)
a (FC_T (MAP_EVERY(asm_tac o (pc_rule1 "hol1" rewrite_rule[]))) [fchain_lemma1]);
a (fc_tac [get_spec ¨FChainClosedÆ]);
a (fc_tac [get_spec ¨CcRpoUÆ]);
a (all_fc_tac [get_spec ¨CcRpoÆ]);
a (all_fc_tac [ccrpo_fixp_lemma16]);
a (all_asm_fc_tac[]);
a (all_fc_tac [ccrpo_fixp_lemma17]);
a (all_fc_tac [rpo_antisym_lemma]);
a (all_fc_tac [lub_unique_lemma]);
a (var_elim_asm_tac ¨e' = yÆ);
a (all_fc_tac [ccrpo_fixp_lemma19]);
a (all_fc_tac [ccrpo_fixp_lemma18]);
a (all_fc_tac [lub_unique_lemma]);
a (var_elim_asm_tac ¨l = yÆ);
a (lemma_tac ¨Lfpâc r f = yÆ THEN1 all_fc_tac [islfp_unique_lemma2]);
a (rewrite_tac[asm_rule ¨Lfpâc r f = yÆ]);
a (contr_tac);
val ccrpou_fixp_induction_thm = save_pop_thm "ccrpou_fixp_induction_thm"; 

pop_pc();
pop_pc();
=TEX
}%ignore

\subsection{Inverse Relations}

In order to exploit the duality between induction and co-induction it is useful to have some results about the inverses of relations.

First the definition.

πHOLCONST
‹ €RelInv› : ('a ≠ 'a ≠ BOOL) ≠ ('a ≠ 'a ≠ BOOL)
˜¸¸¸¸¸¸¸¸¸¸¸
‹ µ r∑ RelInv r = Ãx y∑ r y x
∞

Then we prove lemmas about various properties of relations and their inverses.

=GFT
€refl_inverse_lemma› =
	Ù µ X r∑ Refl (X, RelInv r) = Refl (X, r)

€antisym_inverse_lemma› =
	Ù µ X r∑ Antisym (X, RelInv r) = Antisym (X, r)

€trans_inverse_lemma› =
	Ù µ X r∑ Trans (X, RelInv r) = Trans (X, r)

€trans_inverse_lemma› =
	Ù µ X r∑ Trans (X, RelInv r) = Trans (X, r)

€trich_inverse_lemma› =
	Ù µ X r∑ Trich (X, RelInv r) = Trich (X, r)

€linearorder_inverse_lemma› =
	Ù µ X r∑ LinearOrder (X, r) = LinearOrder (X, RelInv r)

€rpo_inverse_lemma› =
	Ù µ X r∑ Rpo (X, RelInv r) = Rpo (X, r)
=TEX

\ignore{
=SML
set_goal([], ¨µX r∑ Refl (X, RelInv r) § Refl (X, r)Æ);
a (rewrite_tac [get_spec ¨ReflÆ, get_spec ¨RelInvÆ]);
val refl_inverse_lemma = save_pop_thm "refl_inverse_lemma";

set_goal([], ¨µX r∑ Antisym (X, RelInv r) § Antisym (X, r)Æ);
a (rewrite_tac [get_spec ¨AntisymÆ, get_spec ¨RelInvÆ]);
a (contr_tac THEN all_asm_fc_tac[]);
val antisym_inverse_lemma = save_pop_thm "antisym_inverse_lemma";

set_goal([], ¨µX r∑ Trans (X, RelInv r) § Trans (X, r)Æ);
a (rewrite_tac [get_spec ¨TransÆ, get_spec ¨RelInvÆ] THEN contr_tac);
a (list_spec_nth_asm_tac 7 [¨zÆ, ¨yÆ, ¨xÆ]);
a (list_spec_nth_asm_tac 7 [¨zÆ, ¨yÆ, ¨xÆ]);
val trans_inverse_lemma = save_pop_thm "trans_inverse_lemma";

set_goal([], ¨µX r∑ PartialOrder (X, RelInv r) § PartialOrder (X, r)Æ);
a (rewrite_tac [get_spec ¨PartialOrderÆ, antisym_inverse_lemma, trans_inverse_lemma]);
val partialorder_inverse_lemma = save_pop_thm "partialorder_inverse_lemma";

set_goal([], ¨µX r∑ Trich (X, RelInv r) § Trich (X, r)Æ);
a (rewrite_tac [get_spec ¨TrichÆ, get_spec ¨RelInvÆ] THEN contr_tac
	THEN all_asm_fc_tac[]);
val trich_inverse_lemma = save_pop_thm "trich_inverse_lemma";

set_goal([], ¨µX r∑ LinearOrder (X, RelInv r) § LinearOrder (X, r)Æ);
a (rewrite_tac [get_spec ¨LinearOrderÆ, partialorder_inverse_lemma, trich_inverse_lemma]);
val linearorder_inverse_lemma = save_pop_thm "linearorder_inverse_lemma";

set_goal([], ¨µX r∑ Rpo (X, RelInv r) § Rpo (X, r)Æ);
a (rewrite_tac [get_spec ¨RpoÆ, partialorder_inverse_lemma, refl_inverse_lemma]);
val rpo_inverse_lemma = save_pop_thm "rpo_inverse_lemma";
=TEX
}%ignore

=GFT
€isub_inverse_lemma› =
	Ù µ X r x∑ IsUb (RelInv r) X x = IsLb r X x

€islb_inverse_lemma› =
	Ù µ X r x∑ IsLb (RelInv r) X x = IsUb r X x

€islub_inverse_lemma› =
	Ù µ X r x∑ IsLub (RelInv r) X x = IsGlb r X x

€isglb_inverse_lemma› =
	Ù µ X r x∑ IsGlb (RelInv r) X x = IsLub r X x

€islfp_inverse_lemma› =
	Ù µ r f e∑ IsLfp (RelInv r) f e = IsGfp r f e

€isgfp_inverse_lemma› =
	Ù µ r f e∑ IsGfp (RelInv r) f e = IsLfp r f e

€increasing_inverse_lemma› =
   Ù µ r1 r2∑ Increasing (RelInv r1) (RelInv r2) = Increasing r1 r2
=TEX

\ignore{
=SML
set_goal([], ¨µX r x∑ IsUb (RelInv r) X x = IsLb r X xÆ);
a (rewrite_tac [get_spec ¨IsUbÆ, get_spec ¨IsLbÆ, get_spec ¨RelInvÆ]);
val isub_inverse_lemma = save_pop_thm "isub_inverse_lemma";

set_goal([], ¨µX r x∑ IsLb (RelInv r) X x = IsUb r X xÆ);
a (rewrite_tac [get_spec ¨IsUbÆ, get_spec ¨IsLbÆ, get_spec ¨RelInvÆ]);
val islb_inverse_lemma = save_pop_thm "islb_inverse_lemma";

set_goal([], ¨µX r x∑ IsLub (RelInv r) X x = IsGlb r X xÆ);
a (rewrite_tac [get_spec ¨IsLubÆ, get_spec ¨IsGlbÆ, get_spec ¨RelInvÆ,
	isub_inverse_lemma]);
val islub_inverse_lemma = save_pop_thm "islub_inverse_lemma";

set_goal([], ¨µX r x∑ IsGlb (RelInv r) X x = IsLub r X xÆ);
a (rewrite_tac [get_spec ¨IsGlbÆ, get_spec ¨IsLubÆ, get_spec ¨RelInvÆ,
	islb_inverse_lemma]);
val isglb_inverse_lemma = save_pop_thm "isglb_inverse_lemma";

set_goal([], ¨µr f e∑ IsLfp (RelInv r) f e = IsGfp r f eÆ);
a (rewrite_tac [get_spec ¨IsLfpÆ, get_spec ¨IsGfpÆ,
	isglb_inverse_lemma]);
val islfp_inverse_lemma = save_pop_thm "islfp_inverse_lemma";

set_goal([], ¨µr f e∑ IsGfp (RelInv r) f e = IsLfp r f eÆ);
a (rewrite_tac [get_spec ¨IsLfpÆ, get_spec ¨IsGfpÆ,
	islub_inverse_lemma]);
val isgfp_inverse_lemma = save_pop_thm "isgfp_inverse_lemma";

set_goal([], ¨µr1 r2∑ Increasing (RelInv r1) (RelInv r2) = Increasing r1 r2Æ);
a (REPEAT µ_tac
	THEN rewrite_tac [ext_thm, get_spec ¨IncreasingÆ, get_spec ¨RelInvÆ]
	THEN REPEAT strip_tac
	THEN asm_fc_tac[]);
val increasing_inverse_lemma = save_pop_thm "increasing_inverse_lemma";
=TEX
}%ignore

\subsection{Chain Co-Complete Partial Orders}

The results in this section could be achieved in either of two ways.
The first is by systematic modifications to the proof above to obtain their duals.
The second is by use of the original theorems on inverses of relationship.
I have done some by the first method, which is a bit tedious.
To use the second method here is the definition of the inverse of a relationship.

πHOLCONST
‹ €ChainCoComplete› : ('a SET ∏ ('a ≠ 'a ≠ BOOL)) ≠ BOOL
˜¸¸¸¸¸¸¸¸¸¸¸
‹ µ X r∑ ChainCoComplete (X, r) § µY∑ Y Ä X ± LinearOrder (Y, r) ¥
‹	∂x∑ x ç X ± IsGlb r Y x
∞

=GFT
€chaincocomplete_dual_lemma› =
   Ù µ X r∑ ChainCoComplete (X, r) = ChainComplete (X, RelInv r)
=TEX

\ignore{
=SML
set_goal([], ¨µX r∑ ChainCoComplete (X, r) § ChainComplete (X, RelInv r)Æ);
a (rewrite_tac [get_spec ¨ChainCoCompleteÆ, get_spec ¨ChainCompleteÆ,
	linearorder_inverse_lemma, islub_inverse_lemma]);
val chaincocomplete_dual_lemma = save_pop_thm "chaincocomplete_dual_lemma";
=TEX
}%ignore

πHOLCONST
‹ €CoCcRpo› : ('a SET ∏ ('a ≠ 'a ≠ BOOL)) ≠ BOOL
˜¸¸¸¸¸¸¸¸¸¸¸
‹ µ r∑ CoCcRpo r § Rpo r ± ChainCoComplete r
∞

=GFT
€coccrpo_dual_lemma› =
	Ù µ X r∑ CoCcRpo (X, r) = CcRpo (X, RelInv r)
=TEX

\ignore{
=SML
set_goal([], ¨µX r∑ CoCcRpo (X, r) § CcRpo (X, RelInv r)Æ);
a (rewrite_tac [get_spec ¨CoCcRpoÆ, get_spec ¨CcRpoÆ,
	chaincocomplete_dual_lemma, rpo_inverse_lemma]);
val coccrpo_dual_lemma = save_pop_thm "coccrpo_dual_lemma";
=TEX
}%ignore

πHOLCONST
‹ €CoCcRpoU› : ('a ≠ 'a ≠ BOOL) ≠ BOOL
˜¸¸¸¸¸¸¸¸¸¸¸
‹ µ r∑ CoCcRpoU r § CoCcRpo (Universe, r)
∞

=GFT
€coccrpou_dual_lemma› =
	Ù µ r∑ CoCcRpoU r = CcRpoU (RelInv r)
=TEX

\ignore{
=SML
set_goal([], ¨µr∑ CoCcRpoU r § CcRpoU (RelInv r)Æ);
a (rewrite_tac [get_spec ¨CoCcRpoUÆ, get_spec ¨CcRpoUÆ, coccrpo_dual_lemma]);
val coccrpou_dual_lemma = save_pop_thm "coccrpou_dual_lemma";
=TEX
}%ignore

πHOLCONST
‹ €FCoChainClosed› : ('a ≠ 'a) ≠ ('a SET ∏ ('a ≠ 'a ≠ BOOL)) ≠ BOOL
˜¸¸¸¸¸¸¸¸¸¸¸
‹ µ f X r∑ FCoChainClosed f (X, r) § 
‹	FClosed f X ± ChainCoComplete (X, r)
∞

=GFT
€fcochainclosed_dual_lemma› =
   Ù µ f X r∑ FCoChainClosed f (X, r) = FChainClosed f (X, RelInv r)
=TEX

\ignore{
=SML
set_goal([], ¨µf X r∑ FCoChainClosed f (X, r) § FChainClosed f (X, RelInv r)Æ);
a (rewrite_tac [get_spec ¨FCoChainClosedÆ, get_spec ¨FChainClosedÆ,
	chaincocomplete_dual_lemma]);
val fcochainclosed_dual_lemma = save_pop_thm "fcochainclosed_dual_lemma";
=TEX
}%ignore

πHOLCONST
‹ €FCoChain› : ('a ≠ 'a) ≠ ('a SET ∏ ('a ≠ 'a ≠ BOOL)) ≠ 'a SET
˜¸¸¸¸¸¸¸¸¸¸¸
‹ µ f X r∑ FCoChain f (X, r) = • {Y | Y Ä X ± FCoChainClosed f (Y, r)}
∞

=GFT
€fcochain_dual_lemma› =
	Ù µ X r f∑ FCoChain f (X, r) = FChain f (X, RelInv r)

€fcochain_lemma1› =
	Ù µ X r f∑ FCoChainClosed f (X, r) ¥ FCoChain f (X, r) Ä X

€fcochain_fcochainclosed_lemma› =
   Ù µ X r f
     ∑ Antisym (Universe, r) ± FCoChainClosed f (X, r)
         ¥ FCoChainClosed f (FCoChain f (X, r), r)

€fcochain_fcochainclosed_lemma2› =
   Ù µ X r f
     ∑ Rpo (Universe, r) ± FCoChainClosed f (X, r)
         ¥ FCoChainClosed f (FCoChain f (X, r), r)

€fcoc_fcocclosed_fcoc_lemma› =
   Ù µ X r f
     ∑ Rpo (Universe, r) ± FCoChainClosed f (X, r)
         ¥ (µ x∑ x ç FCoChain f (X, r) ¥ f x ç FCoChain f (X, r))

€fcochain_lemma2› =
   Ù µ X Y r f
     ∑ Rpo (Universe, r)
           ± FCoChainClosed f (X, r)
           ± Y Ä FCoChain f (X, r)
           ± FCoChainClosed f (Y, r)
         ¥ Y = FCoChain f (X, r)

€coccrpo_fixp_lemma1› =
   Ù µ X r f
     ∑ Increasing r r f
         ¥ FClosed f {x|x ç FCoChain f (X, r) ± (r (f x) x ≤ x = f x)}

€coccrpo_fixp_lemma2› =
   Ù µ X r f
     ∑ Increasing r r f ± Rpo (Universe, r) ± FCoChainClosed f (X, r)
         ¥ ChainCoComplete
           ({x|x ç FCoChain f (X, r) ± (r (f x) x ≤ x = f x)}, r)

€coccrpo_fixp_lemma3› =
   Ù µ X r f
     ∑ Increasing r r f ± Rpo (Universe, r) ± FCoChainClosed f (X, r)
         ¥ FCoChainClosed
           f
           ({z|z ç FCoChain f (X, r) ± (r (f z) z ≤ z = f z)}, r)

€coccrpo_fixp_lemma4› =
   Ù µ X r f
     ∑ Increasing r r f ± Rpo (Universe, r) ± FCoChainClosed f (X, r)
         ¥ (µ z∑ z ç FCoChain f (X, r) ¥ r (f z) z ≤ z = f z)
=TEX

\ignore{
=SML
push_merge_pcs ["hol1", "'savedthm_cs_∂_proof"];

set_goal([], ¨µX r f∑ FCoChain f (X, r) = FChain f (X, RelInv r)Æ);
a (rewrite_tac [get_spec ¨FCoChainÆ, get_spec ¨FChainÆ, fcochainclosed_dual_lemma]
	THEN REPEAT strip_tac);
val fcochain_dual_lemma = save_pop_thm "fcochain_dual_lemma";


set_goal([], ¨µX r f∑ FCoChainClosed f (X, r) ¥ FCoChain f (X,r) Ä XÆ);
a (rewrite_tac [get_spec ¨FCoChainClosedÆ, get_spec ¨FCoChainÆ] THEN REPEAT strip_tac);
a (spec_nth_asm_tac 1 ¨XÆ);
val fcochain_lemma1 = save_pop_thm "fcochain_lemma1";

push_merge_pcs ["hol", "'savedthm_cs_∂_proof"];

set_goal([], ¨µX r f∑ Antisym (Universe, r) ± FCoChainClosed f (X, r)
	¥ FCoChainClosed f (FCoChain f (X,r), r)Æ);
a (REPEAT strip_tac);
a (fc_tac [get_spec ¨FCoChainClosedÆ]);
a (fc_tac [get_spec ¨FClosedÆ]);
a (rewrite_tac [get_spec ¨FCoChainClosedÆ, get_spec ¨FClosedÆ]
	THEN REPEAT µ_tac
	THEN strip_tac);
(* *** Goal "1" *** *)
a (rewrite_tac [get_spec ¨FCoChainClosedÆ,
		get_spec ¨FClosedÆ,
		get_spec ¨FCoChainÆ,
		get_spec ¨ChainCoCompleteÆ]
	THEN REPEAT strip_tac
	THEN REPEAT (asm_fc_tac[]));
(* *** Goal "2" *** *)
a (fc_tac [get_spec ¨ChainCoCompleteÆ]);
a (rewrite_tac [get_spec ¨ChainCoCompleteÆ]
	THEN REPEAT strip_tac);
a (fc_tac [fcochain_lemma1]);
a (all_fc_tac [pc_rule1 "hol1" prove_rule [] ¨µA B C∑ A Ä B ± B Ä C ¥ A Ä CÆ]);
a (all_asm_fc_tac []);
a (∂_tac ¨xÆ THEN REPEAT strip_tac);
a (REPEAT_N 3 (PC_T1 "hol1" once_rewrite_tac [get_spec ¨FCoChainÆ])
	THEN REPEAT strip_tac);
a (fc_tac [get_spec ¨FCoChainClosedÆ]);
a (fc_tac [get_spec ¨FClosedÆ]);
a (fc_tac [get_spec ¨ChainCoCompleteÆ]);
a (lemma_tac ¨FCoChain f (X, r) Ä sÆ
	THEN1 (rewrite_tac [get_spec ¨FCoChainÆ] THEN REPEAT strip_tac
		THEN (PC_T1 "hol1" asm_rewrite_tac [])
		THEN REPEAT strip_tac THEN all_asm_fc_tac[]));
a (all_fc_tac [pc_rule1 "hol1" prove_rule [] ¨µA B C∑ A Ä B ± B Ä C ¥ A Ä CÆ]);
a (all_asm_fc_tac[]);
a (fc_tac [glb_unique_lemma]);
a (all_asm_fc_tac[]);
a (var_elim_nth_asm_tac 8);
val fcochain_fcochainclosed_lemma = save_pop_thm "fcochain_fcochainclosed_lemma";

set_goal([], ¨µX r f∑ Rpo (Universe, r) ± FCoChainClosed f (X, r)
	¥ FCoChainClosed f (FCoChain f (X,r), r)Æ);
a (REPEAT strip_tac
	THEN fc_tac [rpo_antisym_lemma]
	THEN all_fc_tac [fcochain_fcochainclosed_lemma]);
val fcochain_fcochainclosed_lemma2 = save_pop_thm "fcochain_fcochainclosed_lemma2";

set_goal([], ¨µX r f∑ Rpo (Universe, r) ± FCoChainClosed f (X, r)
	¥ µx∑ x ç FCoChain f (X,r) ¥ f x ç FCoChain f (X,r)Æ);
a (REPEAT strip_tac);
a (fc_tac [rpo_antisym_lemma]);
a (all_fc_tac [fcochain_fcochainclosed_lemma]);
a (all_fc_tac [get_spec ¨FCoChainClosedÆ]);
a (all_fc_tac [get_spec ¨FClosedÆ]);
val fcoc_fcocclosed_fcoc_lemma = save_pop_thm "fcoc_fcocclosed_fcoc_lemma";

set_goal([], ¨µX Y r f∑ Rpo (Universe, r) ± FCoChainClosed f (X, r)
	± Y Ä FCoChain f (X, r) ± FCoChainClosed f (Y, r)
	¥ Y = FCoChain f (X, r)Æ);
a (REPEAT strip_tac
	THEN PC_T1 "hol1" rewrite_tac [get_spec ¨FCoChainÆ]
	THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a (GET_NTH_ASM_T 5 ante_tac
	THEN PC_T1 "hol1" rewrite_tac [get_spec ¨FCoChainÆ]
	THEN REPEAT strip_tac);
a (all_asm_fc_tac[]);
(* *** Goal "2" *** *)
a (spec_nth_asm_tac 1 ¨YÆ);
a (fc_tac [fcochain_lemma1]);
a (ALL_ASM_FC_T (fc_tac o (map (pc_rule1 "hol1" rewrite_rule []))) [Ä_trans_thm]);
val fcochain_lemma2 = save_pop_thm "fcochain_lemma2";

set_goal([], ¨µX r f∑ Increasing r r f
	¥ FClosed f {x | x ç FCoChain f (X,r) ± (r (f x) x ≤ x = (f x))}Æ);
a (REPEAT strip_tac);
a (rewrite_tac [get_spec ¨FClosedÆ, get_spec ¨FCoChainÆ]
	THEN REPEAT strip_tac THEN_TRY SYM_ASMS_T rewrite_tac);
(* *** Goal "1" *** *)
a (GET_NTH_ASM_T 4 (fn x => all_fc_tac [rewrite_rule [] x]));
a (fc_tac [get_spec ¨FCoChainClosedÆ]);
a (fc_tac [get_spec ¨FClosedÆ]);
a (asm_fc_tac[]);
(* *** Goal "2" *** *)
a (fc_tac [get_spec ¨IncreasingÆ]);
a (asm_fc_tac[]);
(* *** Goal "3" *** *)
a (fc_tac [get_spec ¨IncreasingÆ]);
a (asm_fc_tac[]);
val coccrpo_fixp_lemma1 = pop_thm ();

set_goal([], ¨µX r f∑ Increasing r r f ± Rpo (Universe, r) ± FCoChainClosed f (X, r)
	¥ ChainCoComplete ({x | x ç FCoChain f (X,r) ± (r (f x) x ≤ x = (f x))}, r)Æ);
a (rewrite_tac [get_spec ¨ChainCoCompleteÆ]
	THEN REPEAT strip_tac);
a (fc_tac [coccrpo_fixp_lemma1]);
a (lemma_tac ¨FCoChain f (X, r) Ä XÆ
	THEN1 (PC_T1 "hol1" rewrite_tac [get_spec ¨FCoChainÆ]
		THEN REPEAT strip_tac
		THEN (spec_nth_asm_tac 1 ¨XÆ)));
a (lemma_tac ¨Y Ä FCoChain f (X, r)Æ
	THEN1 (PC_T1 "hol1" rewrite_tac []
		THEN REPEAT strip_tac
		THEN GET_NTH_ASM_T 5 (fn x => all_fc_tac [pc_rule1 "hol1" rewrite_rule [] x])));
a (lemma_tac ¨Y Ä XÆ
	THEN1 (all_fc_tac [pc_rule1 "hol1" prove_rule []
	 ¨µA B C∑ A Ä B ± B Ä C ¥ A Ä CÆ]));
a (fc_tac [get_spec ¨FCoChainClosedÆ]);
a (all_fc_tac [get_spec ¨ChainCoCompleteÆ]);
a (∂_tac ¨xÆ THEN asm_rewrite_tac[]);
a (strip_tac);
(* *** Goal "1" *** *)
a (PC_T1 "hol1" rewrite_tac [get_spec ¨FCoChainÆ]
	THEN REPEAT strip_tac);
a (fc_tac [get_spec ¨FCoChainClosedÆ]);
a (lemma_tac ¨Y Ä sÆ);
(* *** Goal "1.1" *** *)
a (lemma_tac ¨FCoChain f (X, r) Ä sÆ
	THEN1 rewrite_tac [get_spec ¨FCoChainÆ]);
(* *** Goal "1.1.1" *** *)
a (LEMMA_T ¨s ç {Y|Y Ä X ± FCoChainClosed f (Y, r)}Æ asm_tac
	THEN1 (PC_T1 "hol1" asm_rewrite_tac []));
a (bc_tac [pc_rule1 "hol1" prove_rule [] ¨s ç A ¥ •A Ä sÆ]
	THEN CONTR_T check_asm_tac);
(* *** Goal "1.1.2" *** *)
a (all_fc_tac [pc_rule1 "hol1" prove_rule [] ¨µA B C∑ A Ä B ± B Ä C ¥ A Ä CÆ]);
(* *** Goal "1.2" *** *)
a (GET_NTH_ASM_T 3 (fn x => (all_fc_tac [rewrite_rule [get_spec ¨ChainCoCompleteÆ] x])));
a (fc_tac [rpo_antisym_lemma]);
a (all_fc_tac [glb_unique_lemma]);
a (var_elim_nth_asm_tac 1);
(* *** Goal "2" *** *)
a (contr_tac);
a (lemma_tac ¨IsLb r Y (f x)Æ
	THEN1 (rewrite_tac [get_spec ¨IsLbÆ]
		THEN REPEAT strip_tac));
(* *** Goal "2.1" *** *)
a (lemma_tac ¨r (f x') x' ≤ x' = f x'Æ
	THEN1 GET_NTH_ASM_T 13 (fn x => asm_tac (pc_rule1 "hol1" rewrite_rule[] x)));
(* *** Goal "2.1.1" *** *)
a (spec_nth_asm_tac 1 ¨x'Æ THEN REPEAT strip_tac);
(* *** Goal "2.1.2" *** *)
a (lemma_tac ¨r x x'Æ);
(* *** Goal "2.1.2.1" *** *)
a (fc_tac [get_spec ¨IsGlbÆ]);
a (GET_NTH_ASM_T 1 ante_tac THEN rewrite_tac [get_spec ¨IsLbÆ]
	THEN strip_tac
	THEN asm_fc_tac[]);
(* *** Goal "2.1.2.2" *** *)
a (fc_tac [get_spec ¨IncreasingÆ]
	THEN all_asm_fc_tac[]);
a (FC_T (MAP_EVERY (strip_asm_tac o (rewrite_rule[]))) [rpo_fc_clauses]);
a (all_asm_fc_tac[]);
(* *** Goal "2.1.3" *** *)
a (fc_tac [get_spec ¨IsGlbÆ]);
a (GET_NTH_ASM_T 1 ante_tac THEN rewrite_tac [get_spec ¨IsLbÆ]
	THEN strip_tac
	THEN asm_fc_tac[]);
a (fc_tac [get_spec ¨IncreasingÆ]
	THEN all_asm_fc_tac[]);
a (DROP_NTH_ASM_T 2 ante_tac THEN SYM_ASMS_T rewrite_tac);
(* *** Goal "2.2" *** *)
a (GET_NTH_ASM_T 4 ante_tac THEN rewrite_tac [get_spec ¨IsGlbÆ]);
a (REPEAT strip_tac);
a (all_asm_fc_tac[]);
val coccrpo_fixp_lemma2 = pop_thm ();

set_goal([], ¨µX r f∑ Increasing r r f ± Rpo(Universe,r) ± FCoChainClosed f (X, r)
	¥ FCoChainClosed f ({z|z ç FCoChain f (X,r) ± (r (f z) z ≤ z = f z)}, r)Æ);
a (REPEAT strip_tac);
a (rewrite_tac [get_spec ¨FCoChainClosedÆ]
	THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a (all_fc_tac[coccrpo_fixp_lemma1]);
a (asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a (all_fc_tac[coccrpo_fixp_lemma1]);
a (all_fc_tac[rpo_antisym_lemma]);
a (all_fc_tac[fcochain_fcochainclosed_lemma]);
a (all_fc_tac[coccrpo_fixp_lemma2]);
val coccrpo_fixp_lemma3 = pop_thm ();

set_goal([], ¨µX r f∑ Increasing r r f ± Rpo(Universe,r) ± FCoChainClosed f (X, r)
	¥ µz∑ z ç FCoChain f (X,r) ¥ r (f z) z ≤ z = f zÆ);
a (REPEAT strip_tac);
a (all_fc_tac [coccrpo_fixp_lemma3]);
a (lemma_tac ¨{z | z ç FCoChain f (X, r) ± (r (f z) z ≤ z = f z)} Ä FCoChain f (X, r)Æ
	THEN1 (PC_T1 "hol1" rewrite_tac[]
		THEN REPEAT strip_tac));
a (all_fc_tac [fcochain_lemma2]);
a (DROP_NTH_ASM_T 5 ante_tac THEN SYM_ASMS_T once_rewrite_tac);
a (rewrite_tac[]);
a (contr_tac);
val coccrpo_fixp_lemma4 = save_pop_thm "coccrpo_fixp_lemma4";
=TEX
}%ignore

=GFT
€coccrpo_fixp_lemma18› =
   Ù µ X $ºâv f
     ∑ Increasing $ºâv $ºâv f
           ± Rpo (Universe, $ºâv)
           ± FCoChainClosed f (X, $ºâv)
         ¥ (∂ l∑ IsGlb $ºâv (FCoChain f (X, $ºâv)) l ± IsGfp $ºâv f l)

€coccrpo_fixp_lemma19› =
   Ù µ r f∑ CoCcRpoU r ± Increasing r r f ¥ (∂ e∑ IsGfp r f e)
=TEX


\ignore{
=SML
set_goal([], ¨µX $ºâv f∑ Increasing $ºâv $ºâv f ± Rpo(Universe,$ºâv)
	± FCoChainClosed f (X, $ºâv)
	¥ ∂l∑ IsGlb $ºâv (FCoChain f (X, $ºâv)) l ± IsGfp $ºâv f lÆ);
a (rewrite_tac [fcochainclosed_dual_lemma, isglb_inverse_lemma, fcochain_dual_lemma,
	isgfp_inverse_lemma]
	THEN REPEAT strip_tac);
a (lemma_tac ¨Rpo (Universe, RelInv $ºâv)Æ
	THEN1 asm_rewrite_tac [rpo_inverse_lemma]);
a (DROP_ASM_T ¨Rpo (Universe, $ºâv)Æ discard_tac);
a (lemma_tac ¨Increasing (RelInv $ºâv) (RelInv $ºâv) fÆ
	THEN1 asm_rewrite_tac [increasing_inverse_lemma]);
a (DROP_ASM_T ¨Increasing $ºâv $ºâv fÆ discard_tac);
a (ALL_FC_T (MAP_EVERY ante_tac) [ccrpo_fixp_lemma18]
	THEN rewrite_tac [islub_inverse_lemma, islfp_inverse_lemma]
	THEN REPEAT strip_tac);
a (∂_tac ¨lÆ THEN asm_rewrite_tac[]);
val coccrpo_fixp_lemma18 = pop_thm ();

set_goal([], ¨µr f∑ CoCcRpoU r
	± Increasing r r f
	¥ (∂ e∑ IsGfp r f e)Æ);
a (rewrite_tac [coccrpou_dual_lemma]
	THEN REPEAT strip_tac);
a (lemma_tac ¨Increasing (RelInv r) (RelInv r) fÆ
	THEN1 asm_rewrite_tac [increasing_inverse_lemma]);
a (DROP_ASM_T ¨Increasing r r fÆ discard_tac);
a (ALL_FC_T (MAP_EVERY ante_tac) [ccrpo_fixp_lemma19]
	THEN rewrite_tac [islfp_inverse_lemma]
	THEN strip_tac);
a (∂_tac ¨eÆ THEN asm_rewrite_tac[]);
val coccrpo_fixp_lemma19 = pop_thm ();

set_goal([], ¨µr f p∑ CoCcRpoU r 
	± Increasing r r f
	± (µx∑ p x ¥ p (f x))
	± (µs∑ (µx∑ x ç s ¥ p x) ± LinearOrder (s, r) ¥ ∂y∑ p y ± (IsGlb r s y))
	¥ p (Gfpâc r f)
	Æ);
a (rewrite_tac [coccrpou_dual_lemma] THEN REPEAT strip_tac);
a (lemma_tac ¨Increasing (RelInv r) (RelInv r) fÆ
	THEN1 asm_rewrite_tac [increasing_inverse_lemma]);
a (DROP_ASM_T ¨Increasing r r fÆ discard_tac);
a (lemma_tac ¨µs∑ (µx∑ x ç s ¥ p x) ± LinearOrder (s, RelInv r) ¥ ∂y∑ p y ± (IsLub (RelInv r) s y)Æ
	THEN1 asm_rewrite_tac [linearorder_inverse_lemma, islub_inverse_lemma]);
a (DROP_NTH_ASM_T 3 discard_tac);
=IGN
a (ALL_FC_T (MAP_EVERY ante_tac) [ccrpou_fixp_induction_thm]);
	THEN rewrite_tac [lfp_dual_lemma]
	THEN strip_tac);
a (∂_tac ¨eÆ THEN asm_rewrite_tac[]);
val ccrpou_fixp_induction_thm = save_pop_thm "ccrpou_fixp_induction_thm"; 

=SML
pop_pc();
pop_pc();
=TEX
}%ignore

\subsection{Closure}

If you start from bottom and iterate a function over some complete partial order you get a least fixed point of the function.
If you start somewhere else you get a ``closure''.
From a monotone function you obtain by transfinite iteration a closure operator.

The purpose of this subsection is to adapt the above material so that it can be applied to closure operators obtained in this way.

For this to work we need only chain completeness, so we will do the theory first in that context.

πHOLCONST
‹ €Closedâc›: ('a ≠ 'a ≠ BOOL) ∏ ('a ≠ 'a) ≠ 'a ≠ BOOL
˜¸¸¸¸¸¸
‹ µ $ºâv f x∑ Closedâc ($ºâv, f) x § f x ºâv x
∞

πHOLCONST
‹ €Closureâc›: ('a ≠ 'a ≠ BOOL) ∏ ('a ≠ 'a) ≠ 'a ≠ 'a
˜¸¸¸¸¸¸
‹ µ $ºâv f x∑ Closureâc ($ºâv, f) x = Glb $ºâv {y | x ºâv y ± Closedâc ($ºâv, f) y}
∞

πHOLCONST
‹ €Closureâd›: ('a ≠ 'a ≠ BOOL) ∏ ('a ≠ 'a) ≠ 'a ≠ 'a
˜¸¸¸¸¸¸
‹ µ $ºâv f x∑ Closureâd ($ºâv, f) x = Lub $ºâv (FChain f ({y | x ºâv y}, $ºâv))
∞

The first result I am looking for is that the closure of a function {\it f} maps each element {\it x} in its domain to the least fixed point of {\it f} which is greater than {\it x}.

=GFT
=TEX

\ignore{
=IGN
stop;
set_goal([], ¨µX f $ºâv x∑ Increasing $ºâv $ºâv f ± ChainComplete (X, $ºâv)
	¥ FChainClosed f ({y | y ç X ± x ºâv y}, $ºâv)Æ);
a (rewrite_tac [get_spec ¨FChainClosedÆ, get_spec ¨IncreasingÆ,
	get_spec ¨FClosedÆ, get_spec ¨ChainCompleteÆ]
	THEN REPEAT strip_tac
	THEN_TRY asm_rewrite_tac[]);


set_goal([], ¨µ$ºâv f∑ let g = Closureâc ($ºâv, f) in g o g = gÆ);
a (rewrite_tac [ext_thm, let_def, get_spec ¨ClosureâcÆ, get_spec ¨$o:(('a≠'c)≠(('b≠'a)≠('b≠'c)))Æ]);
=TEX
}%ignore


\subsection{Complete Partial Orders}

πHOLCONST
‹ €CRpoU›: ('a ≠ 'a ≠ BOOL) ≠ BOOL
˜¸¸¸¸¸¸
‹ µ r∑ CRpoU r § CRpo r ± LubsExist r ± GlbsExist r
∞

=GFT
€crpou_ccrpou_lemma› =
   Ù µ r∑ CRpoU r ¥ CcRpoU r

€crpou_lub_glb_ö_lemma› =
   Ù µ r∑ CRpoU r ¥ (µ x∑ r (Lub r {}) x ± r x (Glb r {}))

€crpou_fc_clauses› =
   Ù µ r
     ∑ CRpoU r
         ¥ GlbsExist r
           ± LubsExist r
           ± (µ x∑ r x x)
           ± (µ x y z∑ r x y ± r y z ¥ r x z)
           ± (µ x y∑ r x y ± r y x ¥ x = y)

€crpou_glb_lfp_lemma1› =
   Ù µ r f
     ∑ CRpoU r ± Increasing r r f
         ¥ (∂ e∑ IsGlb r {x|r (f x) x} e ± IsLfp r f e)

€crpou_increasing_lfp_lemma1› =
   Ù µ r f∑ CRpoU r ± Increasing r r f ¥ (∂ l∑ IsLfp r f l)

€crpou_increasing_lfp_lemma2› =
   Ù µ r f∑ CRpoU r ± Increasing r r f ¥ IsLfp r f (Lfpâc r f)

€crpou_lub_gfp_lemma1› =
   Ù µ r f
     ∑ CRpoU r ± Increasing r r f
         ¥ (∂ e∑ IsLub r {x|r x (f x)} e ± IsGfp r f e)

€crpou_increasing_gfp_lemma1› =
   Ù µ r f∑ CRpoU r ± Increasing r r f ¥ (∂ g∑ IsGfp r f g)

€crpou_increasing_gfp_lemma2› =
   Ù µ r f∑ CRpoU r ± Increasing r r f ¥ IsGfp r f (Gfpâc r f)
=TEX

\ignore{
=SML
set_goal([], ¨µr∑ CRpoU r ¥ CcRpoU rÆ);
a (rewrite_tac (map get_spec [¨CRpoUÆ, ¨CcRpoUÆ, ¨CcRpoÆ, ¨CRpoÆ, ¨ChainCompleteÆ, ¨LubsExistÆ])
	THEN REPEAT strip_tac
	THEN asm_rewrite_tac[]);
val crpou_ccrpou_lemma = save_pop_thm "crpou_ccrpou_lemma";

set_goal([], ¨µr∑ CRpoU r ¥ µx∑ r (Lub r {}) x ± r x (Glb r {})Æ);
a (rewrite_tac [get_spec ¨RpoUÆ, get_spec ¨CRpoUÆ, get_spec ¨LubsExistÆ, get_spec ¨GlbsExistÆ] THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a (spec_nth_asm_tac 2 ¨{}Æ THEN fc_tac [lub_lub_lemma]);
a (fc_tac [get_spec ¨IsLubÆ]);
a (lemma_tac ¨IsUb r {} xÆ
	THEN1 rewrite_tac [get_spec ¨IsUbÆ]);
a (asm_fc_tac[]);
(* *** Goal "2" *** *)
a (spec_nth_asm_tac 1 ¨{}Æ THEN fc_tac [glb_glb_lemma]);
a (fc_tac [get_spec ¨IsGlbÆ]);
a (lemma_tac ¨IsLb r {} xÆ
	THEN1 rewrite_tac [get_spec ¨IsLbÆ]);
a (asm_fc_tac[]);
val crpou_lub_glb_ö_lemma = save_pop_thm "crpou_lub_glb_ö_lemma";

set_goal([], ¨µr∑ CRpoU r ¥
		GlbsExist r
	±	LubsExist r
	±	(µx∑ r x x)
	±	(µx y z∑ r x y ± r y z ¥ r x z)
	±	(µx y∑ r x y ± r y x ¥ x = y)Æ);
a (REPEAT_N 2 strip_tac
	THEN fc_tac [get_spec ¨CRpoUÆ]
	THEN fc_tac [get_spec ¨CRpoÆ]
	THEN fc_tac [get_spec ¨RpoUÆ]
	THEN fc_tac [rpou_fc_clauses]
	THEN REPEAT strip_tac
	THEN all_asm_fc_tac[]
	THEN_TRY asm_rewrite_tac[]);
val crpou_fc_clauses = save_pop_thm "crpou_fc_clauses";

set_goal([], ¨µr f∑ CRpoU r ± Increasing r r f ¥ ∂ e∑ IsGlb r {x|r (f x) x} e ± IsLfp r f eÆ);
a (rewrite_tac [get_spec ¨CRpoUÆ, get_spec ¨CRpoÆ, get_spec ¨RpoÆ, get_spec ¨PartialOrderÆ,
	get_spec ¨TransÆ, get_spec ¨AntisymÆ]
	THEN REPEAT strip_tac);
a (lemma_tac ¨µx y∑ r x y ± r y x ¥ x = yÆ
	THEN1 (contr_tac
		THEN ASM_FC_T (MAP_EVERY (strip_asm_tac o (try (rewrite_rule []))))
			[get_spec ¨AntisymÆ]
		THEN all_asm_fc_tac[]));
a (lemma_tac ¨trans rÆ
	THEN1 (asm_rewrite_tac [get_spec ¨transÆ]));
a (all_fc_tac [mono_fixp_thm2]);
a (∂_tac ¨eÆ THEN asm_rewrite_tac[]);
val crpou_glb_lfp_lemma1 = save_pop_thm "crpou_glb_lfp_lemma1";

set_goal([], ¨µr f∑ CRpoU r ± Increasing r r f ¥ ∂l∑ IsLfp r f lÆ);
a (rewrite_tac (map get_spec [¨CRpoUÆ, ¨CRpoÆ, ¨RpoÆ, ¨PartialOrderÆ, ¨TransÆ])
	THEN REPEAT strip_tac);
a (lemma_tac ¨µx y∑ r x y ± r y x ¥ x = yÆ
	THEN1 (contr_tac
		THEN ASM_FC_T (MAP_EVERY (strip_asm_tac o (try (rewrite_rule []))))
			[get_spec ¨AntisymÆ]
		THEN all_asm_fc_tac[]));
a (lemma_tac ¨trans rÆ
	THEN1 (asm_rewrite_tac [get_spec ¨transÆ]));
a (all_fc_tac [mono_fixp_thm2]);
a (∂_tac ¨eÆ THEN strip_tac);
val crpou_increasing_lfp_lemma1 = save_pop_thm "crpou_increasing_lfp_lemma1";

set_goal([], ¨µr f∑ CRpoU r ± Increasing r r f ¥ IsLfp r f (Lfpâc r f)Æ);
a (REPEAT strip_tac THEN all_fc_tac [crpou_increasing_lfp_lemma1]);
a (bc_tac [get_spec ¨LfpâcÆ]);
a (∂_tac ¨lÆ THEN strip_tac);
val crpou_increasing_lfp_lemma2 = save_pop_thm "crpou_increasing_lfp_lemma2";

set_goal([], ¨µr f∑ CRpoU r ± Increasing r r f ¥ ∂ e∑ IsLub r {x|r x (f x)} e ± IsGfp r f eÆ);
a (rewrite_tac [get_spec ¨CRpoUÆ, get_spec ¨CRpoÆ, get_spec ¨RpoÆ, get_spec ¨PartialOrderÆ,
	get_spec ¨TransÆ, get_spec ¨AntisymÆ]
	THEN REPEAT strip_tac);
a (lemma_tac ¨µx y∑ r x y ± r y x ¥ x = yÆ
	THEN1 (contr_tac
		THEN ASM_FC_T (MAP_EVERY (strip_asm_tac o (try (rewrite_rule []))))
			[get_spec ¨AntisymÆ]
		THEN all_asm_fc_tac[]));
a (lemma_tac ¨trans rÆ
	THEN1 (asm_rewrite_tac [get_spec ¨transÆ]));
a (all_fc_tac [mono_fixp_thm3]);
a (∂_tac ¨eÆ THEN asm_rewrite_tac[]);
val crpou_lub_gfp_lemma1 = save_pop_thm "crpou_lub_gfp_lemma1";

set_goal([], ¨µr f∑ CRpoU r ± Increasing r r f ¥ ∂g∑ IsGfp r f gÆ);
a (rewrite_tac (map get_spec [¨CRpoUÆ, ¨CRpoÆ, ¨RpoÆ, ¨PartialOrderÆ, ¨TransÆ])
	THEN REPEAT strip_tac);
a (lemma_tac ¨µx y∑ r x y ± r y x ¥ x = yÆ
	THEN1 (contr_tac
		THEN ASM_FC_T (MAP_EVERY (strip_asm_tac o (try (rewrite_rule []))))
			[get_spec ¨AntisymÆ]
		THEN all_asm_fc_tac[]));
a (lemma_tac ¨trans rÆ
	THEN1 (asm_rewrite_tac [get_spec ¨transÆ]));
a (all_fc_tac [mono_fixp_thm3]);
a (∂_tac ¨eÆ THEN strip_tac);
val crpou_increasing_gfp_lemma1 = save_pop_thm "crpou_increasing_gfp_lemma1";

set_goal([], ¨µr f∑ CRpoU r ± Increasing r r f ¥ IsGfp r f (Gfpâc r f)Æ);
a (REPEAT strip_tac THEN all_fc_tac [crpou_increasing_gfp_lemma1]);
a (bc_tac [get_spec ¨GfpâcÆ]);
a (∂_tac ¨gÆ THEN strip_tac);
val crpou_increasing_gfp_lemma2 = save_pop_thm "crpou_increasing_gfp_lemma2";
=TEX
}%ignore

\subsection{Continuity and Induction}

To prove the properties of least fixed points (not the properties of their members) one approach is to prove:

\begin{itemize}
\item that the bottom element has the property
\item that the function preserves the property
\item that the property is ``continuous''
\end{itemize}

The purpose of this section is to formulate suitable notions of continuity.

I did consider using the theory "topology" but that seemed likely to be too difficult to bend to this context.


Here's an induction principle:

=GFT
€crpou_induction_thm› =
   Ù µ r f p
     ∑ CRpoU r
           ± Increasing r r f
           ± (µ x∑ p x ¥ p (f x))
           ± (µ s∑ (µ x∑ x ç s ¥ p x) ¥ p (Lub r s))
         ¥ p (Lfpâc r f)

=TEX

\ignore{
=SML
set_goal([], ¨µr f p∑ CRpoU r 
	± Increasing r r f
	± (µx∑ p x ¥ p (f x))
	± (µs∑ (µx∑ x ç s ¥ p x) ¥ p (Lub r s))
	¥ p (Lfpâc r f)
	Æ);
a (REPEAT strip_tac);
a (fc_tac [crpou_ccrpou_lemma]);
a (lemma_tac ¨µ s∑ (µ x∑ x ç s ¥ p x) ± LinearOrder (s, r) ¥ (∂ y∑ p y ± IsLub r s y)Æ
	THEN1 (REPEAT strip_tac THEN all_asm_fc_tac[]));
(* *** Goal "1" *** *)
a (fc_tac [crpou_fc_clauses]);
a (fc_tac [lub_lub_lemma2]);
a (∂_tac ¨Lub r sÆ THEN asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a (all_fc_tac [ccrpou_fixp_induction_thm]);
val crpou_induction_thm = save_pop_thm "crpou_fixp_induction_thm";
=TEX
}%ignore

I'm going to give a name to the condition required in this induction principle.

πHOLCONST
‹ €ContProp›: ('a ≠ 'a ≠ BOOL) ≠ ('a ≠ BOOL) ≠ BOOL
˜¸¸¸¸¸¸
‹ µ r p∑ ContProp r p § µs∑ (µy∑ y ç s ¥ p y) ¥ p (Lub r s)
∞

And then restate the principle using the name:

=GFT
contprop_induction_thm =
   Ù µ r f p
     ∑ CRpoU r ± Increasing r r f ± (µ x∑ p x ¥ p (f x)) ± ContProp r p
         ¥ p (Lfpâc r f)
=TEX

\ignore{
=SML
set_goal([], ¨µr f p∑ CRpoU r 
	± Increasing r r f
	± (µx∑ p x ¥ p (f x))
	± ContProp r p
	¥ p (Lfpâc r f)
	Æ);
a (rewrite_tac [get_spec ¨ContPropÆ, crpou_induction_thm]);
val contprop_induction_thm = save_pop_thm "contprop_induction_thm";
=TEX
}%ignore

\section{INDUCTIVE DEFINITIONS OF SETS}

We begin with inductive definitions of sets, later addressing the conversion of these sets into types.

The simplest example of interest here is the natural numbers, which can be defined (in HOL) as the smallest set of individuals which includes zero (the individual which is not in the range of the one-one function whose existence is asserted by the usual axiom of infinity) and is closed under the successor function (which is that same one-one function).

We can think of this as forming the natural numbers by starting with some set ({0}) and then adding the additional values following some prescription until no more can be added.
Because we are always adding values, the operation on the set-of-values-so-far is monotonic.
If the closure is supplied in a suitable manner then a completely general proof of monotonicity will suffice.

There is a little difficulty in doing this automatically because the operators under which closure is wanted (counting the starting points as 0-ary operators) will be of diverse types.

We keep the constructor exactly as it is required on the representation type.
This is combined with an "immediate content" function on the domain of the constructor to give a relation which indicates which values are immediate constituents of a constructed value, and then we close up the empty set on the principle of adding a constructed value whenever its immediate constituents are available.

In addition to the constructor function and the content information we want to allow some constraint on values which are acceptable for the construction so that it need not be defined over the entire representation type.
In fact this can be coded into the content function by making it reflexive for values which we wish to exclude from the domain.
Actually its type doesn't allow reflexive, but mapping these to the universe of the representation type will do the trick.

\subsection{Generalised Hereditarily-P Sets}

The notion of a set being ``hereditarily P'' for some property of sets P is to be generalised in the following two ways:

\begin{enumerate}
\item Rather than taking any fixed notion of set, the machinery is to work in as broad a range of ``membership structures'' as possible, the minimal conditions on membership structures for this to work will be worked out as we go.
\item To allow more complex constructions, the generalised ``hereditarily'' will be parameterised by something more complex than a simple property, in particular it is not to be required that all the members of a ``hereditarily X'' set will be ``hereditarily X'', but only the bona-fide ``constituents''.
For example, in the notion of a hereditarily pure function, it is not the members of a hereditarily pure function which must be hereditarily pure functions, rather, the elements of its domain and range.
\end{enumerate}

\subsection{Hereditarily Over a Function}

Parameterising the notion of hereditarily by a relation allows the notion to be relativised to an arbitrary set theory or pseudo-set-theory.
As well as permitting the notion to be used within exotic set theories such as NF, the generalised notion can be applied to domains like the natural numbers, which given a suitable relation will masquerade as hereditarily finite sets, and can be further refined by hereditarily-p notions.

However, the presumption still present is that, albeit with a generalised notion of membership, the kinds construction involved are simply set formation.

It is easy to find natural examples which do not fit into this scheme.
For example the hereditarily pure functions.
If one simply takes the property P of being a pure function, then Hereditarily-P does not give what is desired, because the formation of a pure function over pure functions involves a construction more complex than set formation (or at least, requires multiple set formations, firstly the formation of ordered pairs and then the collection of the ordered pairs into a set).

To allow for this kind of generalisation we must leave behind the idea that the construction is taking place in the domain of a set theory.

We do this by working from a function which models the available constructions or derivations by mapping a set of objects (which need not themselves be sets) to the set of new objects which can be constructed from those objects.
Other things might be used in the construction, but no other ``objects'', so the purpose of this map, which I will call a content function, is not to fully capture the details of the available constructors or derivation rules, but rather to capture the {\it content} of the available constructions or the premises of the rules.

From a content function a fixed point can be obtained.
This is done by converting it into a monotonic function and then using the Tarki-Knaster result.

πHOLCONST
‹ €Fun2MonoFun›: ('a SET ≠ 'a SET) ≠ ('a SET ≠ 'a SET)
˜¸¸¸¸¸¸
‹ µ f s∑ Fun2MonoFun f s = {x | ∂t∑ t Ä s ± x ç f t}
∞

This function does always deliver a monotonic result:

=GFT
F2MF_Monotonic_thm =
	Ù µ r∑ Monotonic (Fun2MonoFun f)
=TEX

\ignore{
=SML
val Fun2MonoFun_def = get_spec ¨Fun2MonoFunÆ;
set_goal([],¨µf∑ Monotonic (Fun2MonoFun f)Æ);
a (rewrite_tac [Monotonic_def, Fun2MonoFun_def, sets_ext_clauses]
	THEN contr_tac
	THEN REPEAT (asm_fc_tac[]));
val F2MF_Monotonic_thm = save_pop_thm "F2MF_Monotonic_thm";
=TEX
}%ignore

We now define the function which maps such a content function to the least fixed point of the monotonic function obtained from it.

πHOLCONST
‹ €HeredFun›: ('a SET ≠ 'a SET) ≠ 'a SET
˜¸¸¸¸¸¸
‹ µ f∑ HeredFun f = Lfp (Fun2MonoFun f)
∞

And its dual:

πHOLCONST
‹ €CoHeredFun›: ('a SET ≠ 'a SET) ≠ 'a SET
˜¸¸¸¸¸¸
‹ µ f∑ CoHeredFun f = Gfp (Fun2MonoFun f)
∞

We define appropriate notions of closure and co-closure for expressing the key properties of these sets.

=SML
declare_infix (300, "ClosedUnderFun");
declare_infix (300, "OpenUnderFun");
=TEX 

πHOLCONST
‹ $€ClosedUnderFun› : 'a SET ≠ ('a SET ≠ 'a SET) ≠ BOOL
˜
‹ µs f∑ s ClosedUnderFun f § s ClosedUnder (Fun2MonoFun f)  
∞

πHOLCONST
‹ $€OpenUnderFun› : 'a SET ≠ ('a SET ≠ 'a SET) ≠ BOOL
˜
‹ µs f∑ s OpenUnderFun f § s OpenUnder (Fun2MonoFun f)
∞

=IGN
rewrite_rule [get_spec ¨$ClosedUnderFunÆ,
	get_spec ¨$ClosedUnderÆ,
	get_spec ¨Fun2MonoFunÆ,
	sets_ext_clauses] HeredFun_induction_thm;
=TEX

\ignore{
=SML
val Fun2MonoFun_def = get_spec ¨Fun2MonoFunÆ;
val HeredFun_def = get_spec ¨HeredFunÆ;
val CoHeredFun_def = get_spec ¨CoHeredFunÆ;
val ClosedUnderFun_def = get_spec ¨$ClosedUnderFunÆ;
val OpenUnderFun_def = get_spec ¨$OpenUnderFunÆ;
=TEX
=SML
set_goal([], ¨µf∑ (HeredFun f) ClosedUnderFun fÆ);
a (rewrite_tac [HeredFun_def, ClosedUnderFun_def]);
a (REPEAT strip_tac);
a (lemma_tac ¨Monotonic (Fun2MonoFun f)Æ
	THEN1 (rewrite_tac [F2MF_Monotonic_thm]));
a (FC_T rewrite_tac [lfp_closed_thm]);
val HeredFun_Closed_thm = save_pop_thm "HeredFun_Closed_thm";

set_goal([], ¨µ f x∑ (∂ t∑ (µ x∑ x ç t ¥ x ç HeredFun f) ± x ç f t)
         ¥ x ç HeredFun fÆ);
a (REPEAT strip_tac
	THEN strip_asm_tac (rewrite_rule
		[ClosedUnderFun_def, ClosedUnder_def, Fun2MonoFun_def, sets_ext_clauses]
		HeredFun_Closed_thm));
a (list_spec_nth_asm_tac 1 [¨fÆ, ¨xÆ]);
a (spec_nth_asm_tac 1 ¨tÆ);
a (asm_fc_tac[]);
val HeredFun_Closed_thm1 = save_pop_thm "HeredFun_Closed_thm1";
=TEX
=SML
set_goal([], ¨µf∑ (HeredFun f) OpenUnderFun fÆ);
a (rewrite_tac [HeredFun_def, OpenUnderFun_def]);
a (REPEAT strip_tac);
a (lemma_tac ¨Monotonic (Fun2MonoFun f)Æ
	THEN1 (rewrite_tac [F2MF_Monotonic_thm]));
a (FC_T rewrite_tac [lfp_open_thm]);
val HeredFun_Open_thm = save_pop_thm "HeredFun_Open_thm";
=TEX
=SML
set_goal([], ¨µf s∑ s ClosedUnderFun f ¥ HeredFun f Ä sÆ);
a (rewrite_tac [HeredFun_def, ClosedUnderFun_def]);
a (REPEAT strip_tac);
a (lemma_tac ¨Monotonic (Fun2MonoFun f)Æ
	THEN1 (rewrite_tac [F2MF_Monotonic_thm]));
a (ALL_FC_T rewrite_tac [Lfp_induction_thm]);
val HeredFun_induction_thm = save_pop_thm "HeredFun_induction_thm";
=TEX
=SML
set_goal([], ¨µf s∑ (µt∑ t Ä s ¥ f t Ä s) ¥ HeredFun f Ä sÆ);
a (rewrite_tac [HeredFun_def]);
a (REPEAT strip_tac);
a (lemma_tac ¨Monotonic (Fun2MonoFun f)Æ
	THEN1 (rewrite_tac [F2MF_Monotonic_thm]));
a (ufc_tac [Lfp_induction_thm]);
a (spec_nth_asm_tac 1 ¨sÆ);
a (swap_nth_asm_concl_tac 1);
a (rewrite_tac [ClosedUnder_def, Fun2MonoFun_def]);
a (DROP_NTH_ASM_T 4 ante_tac
	THEN prove_tac [sets_ext_clauses]);
val HeredFun_induction_thm2 = save_pop_thm "HeredFun_induction_thm2";
=TEX

=IGN
set_goal([], ¨x ç HeredFun fÆ);
a (rewrite_tac [HeredFun_def]);
a (lemma_tac ¨Monotonic (Fun2MonoFun f)Æ
	THEN1 rewrite_tac [F2MF_Monotonic_thm]);
a (all_asm_fc_tac [lfp_fixedpoint_thm]);
a (SYM_ASMS_T once_rewrite_tac);
a (once_rewrite_tac [Fun2MonoFun_def]);

set_goal([], ¨µ f x∑ x ç HeredFun f ¥ (∂ t∑ (µ x∑ x ç t ¥ x ç HeredFun f) ± x ç f t)Æ);
a (REPEAT strip_tac);
a (Ä_induction_tac HeredFun_induction_thm ¨xÆ);

val Ä_induction_canon = 
	REPEAT_CAN (
		simple_µ_rewrite_canon
		ORELSE_CAN (rule_canon undisch_rule)
		ORELSE_CAN ±_rewrite_canon)
	THEN_CAN Ä_ext_canon
	THEN_CAN all_¥_intro_canon;

fun Ä_induction_tac thm term:TACTIC = fn (asms, concl) =>
	let val thm1 = rewrite_rule [] (µ_elim (mk_set_comp (term, concl)) thm)
	in (bc_tac (Ä_induction_canon thm1)) (asms, concl)
	end;

fun Ä_induction_rule thm term = fn (asms, concl) =>
	let val thm1 = µ_elim (mk_set_comp (term, concl)) thm
	in Ä_induction_canon thm1
	end;

Ä_induction_rule HeredFun_induction_thm ¨xÆ (top_goal());
Ä_induction_canon HeredFun_induction_thm;
map (rewrite_rule []) it;
dest_simple_term ¨{x | x=x}Æ;
a (bc_tac (map all_µ_intro it));
set_flag( "pp_show_HOL_types", true);
rewrite_rule [sets_ext_clauses] (undisch_rule (all_µ_elim HeredFun_induction_thm));
a (REPEAT µ_tac THEN rewrite_tac [HeredFun_def] THEN strip_tac);
a (asm_tac (µ_elim ¨fÆ F2MF_Monotonic_thm));
a (ALL_FC_T (MAP_EVERY ante_tac)
	[rewrite_rule [OpenUnder_def, sets_ext_clauses] lfp_open_thm]);
a (rewrite_tac [Fun2MonoFun_def]);

a (list_spec_nth_asm_tac 1 [¨fÆ, ¨xÆ]);
a (spec_nth_asm_tac 1 ¨tÆ);
a (asm_fc_tac[]);
val HeredFun_Closed_thm1 = save_pop_thm "HeredFun_Closed_thm1";
=TEX


=GFT
HeredFun_Closed_thm =
	Ù µf∑ (HeredFun f) ClosedUnderFun f
HeredFun_Open_thm =
	Ù µf∑ (HeredFun f) OpenUnderFun f
HeredFun_induction_thm =
	Ù µf s∑ s ClosedUnderFun f ¥ HeredFun f Ä s
HeredFun_induction_thm2 =
	Ù µf s∑ (µt∑ t Ä s ¥ f t Ä s) ¥ HeredFun f Ä s
=TEX

=IGN	
val HeredFun_Open_thm1 = save_thm ("HeredFun_Open_thm1",
	rewrite_rule [OpenUnderFun_def, OpenUnder_def, Fun2MonoFun_def, sets_ext_clauses]
	HeredFun_Open_thm);
OpenUnder_def;
=TEX
}%ignore

=GFT
CoHeredFun_Closed_thm =
	Ù µf∑ (CoHeredFun f) ClosedUnderFun f
CoHeredFun_Open_thm =
	Ù µf∑ (CoHeredFun f) OpenUnderFun f
CoHeredFun_coinduction_thm =
	Ù µs f∑ s OpenUnderFun f ¥ s Ä CoHeredFun f
=TEX

\ignore{
=SML
set_goal([], ¨µf∑ (CoHeredFun f) ClosedUnderFun fÆ);
a (rewrite_tac [CoHeredFun_def, ClosedUnderFun_def]);
a (REPEAT strip_tac);
a (lemma_tac ¨Monotonic (Fun2MonoFun f)Æ
	THEN1 (rewrite_tac [F2MF_Monotonic_thm]));
a (FC_T rewrite_tac [gfp_closed_thm]);
val CoHeredFun_Closed_thm = save_pop_thm "CoHeredFun_Closed_thm";
=TEX
=SML
set_goal([], ¨µf∑ (CoHeredFun f) OpenUnderFun fÆ);
a (rewrite_tac [CoHeredFun_def, OpenUnderFun_def]);
a (REPEAT strip_tac);
a (lemma_tac ¨Monotonic (Fun2MonoFun f)Æ
	THEN1 (rewrite_tac [F2MF_Monotonic_thm]));
a (FC_T rewrite_tac [gfp_open_thm]);
val CoHeredFun_Open_thm = save_pop_thm "CoHeredFun_Open_thm";

set_goal([], ¨µs f∑ s OpenUnderFun f ¥ s Ä CoHeredFun fÆ);
a (rewrite_tac [CoHeredFun_def, OpenUnderFun_def]);
a (REPEAT strip_tac);
a (lemma_tac ¨Monotonic (Fun2MonoFun f)Æ
	THEN1 (rewrite_tac [F2MF_Monotonic_thm]));
a (ALL_FC_T rewrite_tac [gfp_coinduction_thm]);
val CoHeredFun_coinduction_thm = save_pop_thm "CoHeredFun_coinduction_thm";
=TEX
}%ignore

\subsection{Collections of Rules}

When I came to try out the above (see \cite{rbjt008}) I concluded that the most convenient kind of object to define is a {\it set of rules}, in which each rule is a set of premises and a single conclusion.
This is a relation which need not be functional and need not be one-one (there can be several conclusions from the same set of premises, and several distinct sets of premises which yield the same conclusion).

So I am defining here how to convert one of those things into a content function.

πHOLCONST
‹ €Rules2Fun›: ('a SET ∏ 'a) SET ≠ ('a SET ≠ 'a SET)
˜¸¸¸¸¸¸
‹ µ r∑ Rules2Fun r = Ãs∑ {x | (s, x) ç r}
∞

{\it Rules2Fun} is a bijection and so could be inverted.

\subsection{Hereditarily Over a Relation}

An alternative, but less general approach is to define the constructor from a `content' relation which indicates when a value is an immediate constituent of another value.
This approach is less general because for some inductive definitions of sets, e.g. for the set of theorems of a formal system, there are several ways of constructing the same object and so no obvious content relation which can be used to define the set.

πHOLCONST
‹ €Rel2Fun›: ('a ≠ 'a ≠ BOOL) ≠ ('a SET ≠ 'a SET)
˜¸¸¸¸¸¸
‹ µ r∑ Rel2Fun r = Ãs∑ {x | {y | r y x} = s}
∞

We now define the function which maps a content relation to the least fixed point of the monotonic function obtained from it.

πHOLCONST
‹ €HeredRel›: ('a ≠ 'a ≠ BOOL) ≠ 'a SET
˜¸¸¸¸¸¸
‹ µ r∑ HeredRel r = HeredFun (Rel2Fun r)
∞

And its dual:

πHOLCONST
‹ €CoHeredRel›: ('a ≠ 'a ≠ BOOL) ≠ 'a SET
˜¸¸¸¸¸¸
‹ µ r∑ CoHeredRel r = CoHeredFun (Rel2Fun r)
∞

To accomplist this we need the concepts of closure and co-closure for sets relative to one of our `content relations'

=SML
declare_infix (300, "ClosedUnderRel");
declare_infix (300, "OpenUnderRel");
=TEX 

πHOLCONST
‹ $€ClosedUnderRel› : 'a SET ≠ ('a ≠ 'a ≠ BOOL) ≠ BOOL
˜
‹ µs r∑ s ClosedUnderRel r § s ClosedUnderFun (Rel2Fun r)
∞

πHOLCONST
$€OpenUnderRel› : 'a SET ≠ ('a ≠ 'a ≠ BOOL) ≠ BOOL
˜
µs r∑ s OpenUnderRel r § s OpenUnderFun (Rel2Fun r)
∞

=GFT
HeredRel_Closed_thm =
	Ù µf∑ (HeredRel f) ClosedUnderRel f
HeredRel_Open_thm =
	Ù µf∑ (HeredRel f) OpenUnderRel f
HeredRel_induction_thm =
	Ù µs f∑ s ClosedUnderRel f ¥ HeredRel f Ä s
=TEX

\ignore{
=SML
val Rel2Fun_def = get_spec ¨Rel2FunÆ;
val HeredRel_def = get_spec ¨HeredRelÆ;
val CoHeredRel_def = get_spec ¨CoHeredRelÆ;
val ClosedUnderRel_def = get_spec ¨$ClosedUnderRelÆ;
val OpenUnderRel_def = get_spec ¨$OpenUnderRelÆ;
=TEX
=SML
set_goal([], ¨µf∑ (HeredRel f) ClosedUnderRel fÆ);
a (rewrite_tac [HeredRel_def, ClosedUnderRel_def, HeredFun_Closed_thm]);
val HeredRel_Closed_thm = save_pop_thm "HeredRel_Closed_thm";
=TEX
=SML
set_goal([], ¨µf∑ (HeredRel f) OpenUnderRel fÆ);
a (rewrite_tac [HeredRel_def, OpenUnderRel_def, HeredFun_Open_thm]);
val HeredRel_Open_thm = save_pop_thm "HeredRel_Open_thm";
=TEX
=SML
set_goal([], ¨µs f∑ s ClosedUnderRel f ¥ HeredRel f Ä sÆ);
a (rewrite_tac [HeredRel_def, ClosedUnderRel_def, HeredFun_induction_thm]);
val HeredRel_induction_thm = save_pop_thm "HeredRel_induction_thm";
=TEX
}%ignore

=GFT
CoHeredRel_Closed_thm =
	Ù µf∑ (CoHeredRel f) ClosedUnderRel f
CoHeredRel_Open_thm =
	Ù µf∑ (CoHeredRel f) OpenUnderRel f
CoHeredRel_coinduction_thm =
	Ù µs f∑ s OpenUnderRel f ¥ s Ä CoHeredRel f
=TEX

\ignore{
=SML
set_goal([], ¨µf∑ (CoHeredRel f) ClosedUnderRel fÆ);
a (rewrite_tac [CoHeredRel_def, ClosedUnderRel_def, CoHeredFun_Closed_thm]);
val CoHeredRel_Closed_thm = save_pop_thm "CoHeredRel_Closed_thm";
=TEX
=SML
set_goal([], ¨µf∑ (CoHeredRel f) OpenUnderRel fÆ);
a (rewrite_tac [CoHeredRel_def, OpenUnderRel_def, CoHeredFun_Open_thm]);
val CoHeredRel_Open_thm = save_pop_thm "CoHeredRel_Open_thm";
=TEX
=SML
set_goal([], ¨µs f∑ s OpenUnderRel f ¥ s Ä CoHeredRel fÆ);
a (rewrite_tac [CoHeredRel_def, OpenUnderRel_def, CoHeredFun_coinduction_thm]);
val CoHeredRel_coinduction_thm = save_pop_thm "CoHeredRel_coinduction_thm";
=TEX
}%ignore

\subsection{Hereditarily Over a Property}

We now presume that the construction is always set formation and that the sets which are formed are those satisfying the given property.
However, everything is relativised to an arbitrary membership structure.

This is really (only a small generalisation of) what mathematicians call ``Hereditarily-P'' sets, so I shall give it its proper name.

A content relation is obtained from a property over a membership structure as follows:

πHOLCONST
‹ €Prop2Rel›: ('a SET ∏ ('a ≠ 'a ≠ BOOL)) ≠ ('a ≠ BOOL) ≠ ('a ≠ 'a ≠ BOOL)
˜¸¸¸¸¸¸
‹ µ (X, $<<) p∑ Prop2Rel (X, $<<) p = Ãx y∑ x << y ± p y
∞

πHOLCONST
‹ €Hereditary›: ('a SET ∏ ('a ≠ 'a ≠ BOOL)) ≠ ('a ≠ BOOL) ≠ 'a SET
˜¸¸¸¸¸¸
‹ µ (X, $<<) p∑ Hereditary (X, $<<) p = HeredRel (Prop2Rel (X, $<<) p)
∞

And its dual:

πHOLCONST
‹ €CoHereditary›: ('a SET ∏ ('a ≠ 'a ≠ BOOL)) ≠ ('a ≠ BOOL) ≠ 'a SET
˜¸¸¸¸¸¸
‹ µ (X, $<<) p∑ CoHereditary (X, $<<) p = CoHeredRel (Prop2Rel (X, $<<) p)
∞

To accomplish this we need the concepts of closure and co-closure for sets relative to one of our `content relations'

πHOLCONST
‹ $€ClosedUnderProp› : ('a SET ∏ ('a ≠ 'a ≠ BOOL)) ≠ 'a SET
‹ 			≠ ('a ≠ BOOL) ≠ BOOL
˜
‹ µ(X, $<<) s p∑ ClosedUnderProp (X, $<<) s p
‹ 	§ s ClosedUnderRel (Prop2Rel (X, $<<) p)
∞

πHOLCONST
‹ $€OpenUnderProp› : ('a SET ∏ ('a ≠ 'a ≠ BOOL)) ≠ 'a SET
‹ 			≠ ('a ≠ BOOL) ≠ BOOL
˜
‹ µ(X, $<<) s p∑ OpenUnderProp (X, $<<) s p
‹ 	§ s OpenUnderRel (Prop2Rel (X, $<<) p)
∞

=GFT
Hereditary_Closed_thm =
	Ù µ(X, $<<) p∑
	ClosedUnderProp (X, $<<) (Hereditary (X, $<<) p) p
Hereditary_Open_thm =
	Ù µ(X, $<<) p∑
	OpenUnderProp (X, $<<) (Hereditary (X, $<<) p) p
Hereditary_induction_thm =
	Ù µ(X, $<<) s p∑
	ClosedUnderProp (X, $<<) s p ¥ Hereditary (X, $<<) p Ä s
=TEX

\ignore{
=SML
val Prop2Rel_def = get_spec ¨Prop2RelÆ;
val Hereditary_def = get_spec ¨HereditaryÆ;
val CoHereditary_def = get_spec ¨CoHereditaryÆ;
val ClosedUnderProp_def = get_spec ¨$ClosedUnderPropÆ;
val OpenUnderProp_def = get_spec ¨$OpenUnderPropÆ;
=TEX
=SML
set_goal([], ¨µ(X, $<<) p∑ ClosedUnderProp (X, $<<) (Hereditary (X, $<<) p) pÆ);
a (rewrite_tac [Hereditary_def, ClosedUnderProp_def, HeredRel_Closed_thm]);
a (REPEAT strip_tac);
val Hereditary_Closed_thm = save_pop_thm "Hereditary_Closed_thm";
=TEX
=SML
set_goal([], ¨µ(X, $<<) p∑ OpenUnderProp (X, $<<) (Hereditary (X, $<<) p) pÆ);
a (rewrite_tac [Hereditary_def, OpenUnderProp_def, HeredRel_Open_thm]
	THEN REPEAT strip_tac);
val Hereditary_Open_thm = save_pop_thm "Hereditary_Open_thm";
=TEX
=SML
set_goal([], ¨µ(X, $<<) s p∑ ClosedUnderProp (X, $<<) s p ¥ Hereditary (X, $<<) p Ä sÆ);
a (rewrite_tac [Hereditary_def, ClosedUnderProp_def, HeredRel_induction_thm]
	THEN REPEAT strip_tac);
val Hereditary_induction_thm = save_pop_thm "Hereditary_induction_thm";
=TEX
}%ignore

=GFT
CoHereditary_Closed_thm =
	Ù µ(X, $<<) p∑
	ClosedUnderProp (X, $<<) (CoHereditary (X, $<<) p) p
CoHereditary_Open_thm =
	Ù µ(X, $<<) p∑
	OpenUnderProp (X, $<<) (CoHereditary (X, $<<) p) p
CoHereditary_coinduction_thm =
	Ù µ(X, $<<) s p∑
	OpenUnderProp (X, $<<) s p ¥ s Ä CoHereditary (X, $<<) p
=TEX

\ignore{
=SML
set_goal([], ¨µ(X, $<<) p∑ ClosedUnderProp (X, $<<) (CoHereditary (X, $<<) p) pÆ);
a (rewrite_tac [CoHereditary_def, ClosedUnderProp_def, CoHeredRel_Closed_thm]
	THEN REPEAT strip_tac);
val CoHereditary_Closed_thm = save_pop_thm "CoHereditary_Closed_thm";
=TEX
=SML
set_goal([], ¨µ(X, $<<) p∑ OpenUnderProp (X, $<<) (CoHereditary (X, $<<) p) pÆ);
a (rewrite_tac [CoHereditary_def, OpenUnderProp_def, CoHeredRel_Open_thm]
	THEN REPEAT strip_tac);
val CoHereditary_Open_thm = save_pop_thm "CoHereditary_Open_thm";
=TEX
=SML
set_goal([], ¨µ(X, $<<) s p∑ OpenUnderProp (X, $<<) s p ¥ s Ä CoHereditary (X, $<<) pÆ);
a (rewrite_tac [CoHereditary_def, OpenUnderProp_def]
	THEN REPEAT strip_tac);
a (all_asm_fc_tac [CoHeredRel_coinduction_thm]);
val CoHereditary_coinduction_thm = save_pop_thm "CoHereditary_coinduction_thm";
=TEX
}%ignore

\subsection{Sets Defined Using CCPs}

The next two variations on the theme move us closer to the form in which the constructors for an inductively defined set are likely to be presented, and in particular to the kinds of constructors whose definitions can be derived from a {\it signature} for the desired inductive type.
It is particularly relevant to inductive definitions in a type theory rather than a set theory, where the constructors may have diverse types and some work is involved in obtaining a monotonic function whose fixed point can be taken.

There are two cases we consider.

In the most common case the compounded constructor (operating over the disjoint union of mutually defined sets) is an injection, and the content relation is probably the best way to define the type, which turns out to be the field of the well-founded part of the content relation, so that a well-founded relation for inductive proofs comes easily.

In the less common case the compounded constructor is not injective, and cannot therefore be adequately represented by a content relation, so we use a function from content sets to the set of objects with that content (allowing that the same object may appear in more than one of these sets as a result of being constructible by more than one constructor).

A CCP (constructor, content, predicate triple) consisting of:
\begin{enumerate}
\item a compounded constructor function
\item a content function
\item a compounded predicate
\end{enumerate}

play an important role here and in the sequel and is therefore defined as a HOL labelled product as follows:

πHOLLABPROD €CCP›¸¸¸¸¸
‹ €Constructor›: 'b ≠ 'a;
‹ €Content›: 'b ≠ 'a SET;
‹ €Predicate›: 'b ≠ BOOL
∞¸¸¸¸¸¸¸¸¸¸¸¸¸¸

In this the type variable $'b$ is used for the type of the compounded constructor function which is derived from the type of the desired constructors as follows.

\begin{enumerate}
\item the type is the disjoint union of the domain types for each individual constructor
\item for each constructor the domain type is the product of the types of the domains if it is a curried constructor, e.g. for a constructor of type $X ≠ Y ≠ Z$ the domain type is $X ∏ Y$.
types to be introduced.
\end{enumerate}

The second type parameter is the representation type over which the constructors are defined, and which will be used to introduce the new types (if required).

A CCP can be converted into either a relation or a function as required for $HeredFun$ or $HeredRel$ using the following functions.

πHOLCONST
‹ €CCP2Fun›: ('a,'b)CCP ≠ ('a SET ≠ 'a SET)
˜¸¸¸¸¸¸
‹ µ ccp x∑ CCP2Fun ccp x =
‹	{y | ∂b∑ y = Constructor ccp b ± x = Content ccp b ± Predicate ccp b}
∞

πHOLCONST
‹ €CCP2Rel›: ('a,'b)CCP ≠ ('a ≠ 'a ≠ BOOL)
˜¸¸¸¸¸¸
‹ µ ccp x y∑ CCP2Rel ccp x y §
‹	∂b∑ y = Constructor ccp b ± x ç Content ccp b ± Predicate ccp b
∞

In cases such as that of the ``hereditarily pure functions'' which fall outside the scope of definition using $Hereditarily$ but are similar in spirit the desired effect can be obtained using a $CCP2$ in which the constructor is the identity function.
The predicate in this particular case would be the property of being a many one relation, and the content function would yield the field of the relation.
The $CCP2Rel$ conversion and $HeredRel$ would then yield the desired set and an induction principle.

\subsection{Using Multiple CCP's}

In principle it is possible to obtain a fixed point from a system of constructors via a single CCP in which the type variable $'b$ is instantiated to the disjoint union of the domains of the (uncurried) constructors.
This however leads, to unnecessarily large types, and to complications in the constructor function which arise from manipulating disjoint unions with many components.

The domain types of the constructors have only a transitory appearance in the process of obtaining a fixed point, as can be seen from the type of the functions $CCP2Fun$ and $CCP2Rel$ which convert a structure in which the type variable $'b$ occurs into one in which it does not occur.
This suggests that it may be best to convert each constructor individually into a content relation before attempting to compound the constructors and obtain a fixed point.

The details of how this can be done are sensitive to issues which have not yet been considered, relating to the manner in which constructors are compounded.
In the most common kind of inductive definition used in computer science it is expected that the constructors will be injective and will have disjoint ranges, resulting in an inductive type which is analogous to an initial or free algebra.
In other cases this may not be required.

The following definitions are intended only to address the former case.

In compounding the constructors it is necessary to ensure that the ranges of the constructors are disjoint in the compounded constructor, and also to ensure where there is more than one type that the types are disjoint, and that only objects of the appropriate `type' are supplied to the individual constructors in the compounded constructor.
The disjointness of the constructors is to be achieved by some kind of tagging operation in which the value yielded by a constructor is tagged with a value unique to that constructor.
This would also suffice to make the types disjoint, but it seems more convenient to use a double tagging to achieve the desired effect.
First the value is tagged by a number which discriminates between the constructors yielding values of a type, and then it is tagged again with the type.

This whole process can be accomplished by a single function application to a list of lists of constructor functions or relations, parameterised by an application specific tagging operation.

πHOLCONST
‹ €MapNFun›: (Ó ≠ 'a ≠ 'a) ≠ 'a LIST ≠ 'a LIST
˜¸¸¸¸¸¸
‹ µ tf al∑ MapNFun tf al = Map (Uncurry tf) (Combine (1 ..âL (Length al)) al)
∞
πHOLCONST
‹ €MapTag›: (Ó ≠ 'a ≠ 'a) ≠ ('a ≠ 'a) LIST ≠ ('a ≠ 'a) LIST
˜¸¸¸¸¸¸
‹ µ tf al∑ MapTag tf al = MapNFun (Ãn f a∑ tf n (f a)) al
∞
πHOLCONST
‹ €LiftTag›: (Ó ≠ 'a ≠ 'a) ≠ (Ó ≠ 'a SET ≠ 'a SET)
˜¸¸¸¸¸¸
‹ µ tf n s∑ LiftTag tf n s = {x | ∂y∑ y ç s ± x = tf n y}
∞
πHOLCONST
‹ €List2Set›: 'a LIST ≠ 'a SET
˜¸¸¸¸¸¸
‹ µl∑ List2Set l = {e | e çâL l}
∞
πHOLCONST
‹ €ListUnion›: 'a SET LIST ≠ 'a SET
˜¸¸¸¸¸¸
‹ µl∑ ListUnion l = ﬁ (List2Set l)
∞
πHOLCONST
‹ €ListFunUnion›: ('a SET ≠ 'a SET) LIST ≠ ('a SET ≠ 'a SET)
˜¸¸¸¸¸¸
‹ µl as∑ ListFunUnion l as = ListUnion (Map (Ãf∑ f as) l)
∞
πHOLCONST
‹ €CompoundFuns›: (Ó ≠ 'a ≠ 'a) ≠ ('a SET ≠ 'a SET) LIST LIST
‹		≠ ('a SET ≠ 'a SET)
˜¸¸¸¸¸¸
‹ µ tf asfll ∑ CompoundFuns tf asfll =
‹	ListFunUnion (Map	ListFunUnion (Map (MapTag (LiftTag tf)) asfll))
∞
πHOLCONST
‹ €HCF›: (Ó ≠ 'a ≠ 'a) ≠ ('a SET ≠ 'a SET) LIST LIST ≠ 'a SET
˜¸¸¸¸¸¸
‹ µ tf asfll ∑ HCF tf asfll = HeredFun (CompoundFuns tf asfll)
∞
πHOLCONST
‹ €LiftTag2›: (Ó ≠ 'a ≠ 'a) ≠ (Ó ≠ ('a ≠ 'a ≠ BOOL) ≠ ('a ≠ 'a ≠ BOOL))
˜¸¸¸¸¸¸
‹ µ tf n r∑ LiftTag2 tf n r = Ãx y∑ ∂z∑ r x z ± y = tf n z
∞
πHOLCONST
‹ €MapTag2›: (Ó ≠ 'a ≠ 'a) ≠ ('a ≠ 'a ≠ BOOL) LIST ≠ ('a ≠ 'a ≠ BOOL) LIST
˜¸¸¸¸¸¸
‹ µ tf rl∑ MapTag2 tf rl = MapNFun (Ãn r x y∑ ∂z∑ y = tf n z ± r x z) rl
∞
πHOLCONST
‹ €ListRelUnion›: ('a ≠ 'a ≠ BOOL) LIST ≠ ('a ≠ 'a ≠ BOOL)
˜¸¸¸¸¸¸
‹ µl x y∑ ListRelUnion l x y § ∂r∑ r çâL l ±  r x y
∞
πHOLCONST
‹ €CompoundRels›: (Ó ≠ 'a ≠ 'a) ≠ ('a ≠ 'a ≠ BOOL) LIST LIST ≠ ('a ≠ 'a ≠ BOOL)
˜¸¸¸¸¸¸
‹ µ tf arll ∑ CompoundRels tf arll =
‹	ListRelUnion (Map	ListRelUnion (Map (MapTag2 tf) arll))
∞
πHOLCONST
‹ €HCR›: (Ó ≠ 'a ≠ 'a) ≠ ('a ≠ 'a ≠ BOOL) LIST LIST ≠ 'a SET
˜¸¸¸¸¸¸
‹ µ tf asrll ∑ HCR tf asrll = HeredRel (CompoundRels tf asrll)
∞

\section{PSEUDO (CO-)INDUCTIVE DEFINITIONS}

This discussion is tainted by the attempt to support a tendentious application of the notion of pseudo-inductive definition to the construction of pure, non-well-founded ontologies of concrete categories and functors.
I don't now have much inclination to believe that it will serve that purpose, but nevertheless would like to understand the notion of pseudo-inductiveness and get some idea of what it is good for.
I therefore propose to remove from this section the material motivated by category theoretic ontology, and in the first instance focus on working over the ideas presented in \cite{forster92}.

Forster \cite{forster92}, introduces pseudo well-foundedness as way of getting a kind of inductive proof principle in NF.
A pseudo-well-founded universe is partitioned into two clasess, in a way which suggests that the desired split of the universe into categories and functors might be definable by adaptation of this principle.
To see the connection observe that the `constituents' of categories are functors, and the constuents of functors are categories.
This means that, in a well-founded universe, a slightly gerrimandered notion of rank (in which rank increases by exactly one as we pass from a functor to a category containing that functor or from a category to a functor over that category) assigns even ranks to categories and odd ranks to functors (we need to enhance the notion of odd and even to cover limit points, which I think need to be even). 
Not only are categories and functors distinguished by the parity of their rank, there is a difference in parity for every descending path according to whether it begins at a category or a functor.
This fits in with the game theoretic flavour of pseudo well-foundedness in which a game is just such a descending path, and the winner of the game is determined by the parity of its length.

For these reasons I thought it might be interesting to see how a `pseudo-inductive` definition adapted from Forster's notion of pseudo-well-foundedness worked in this application.

Since embarking on this path a second method occurred to me, which is to use co-induction.
For the purposes which Forster had in mind (a principle which could be added to the axioms of NF to exclude certain possibly pathological sets (like a set which is its own unit set) while still leaving the important well-founded sets) co-induction would not suffice, since it looks like co-induction for what its worth, comes for free in NF.
However, in this application, where we are filtering out all but categories and functors, the coinductive defintiion will actually do something, and the fact (if it is a fact) that a principle of co-well-foundedness is derivable in NF would suggest that this form of definitions will give the most liberal ontology of the selected kind.

Once co-induction occurs as an alternative non-well-foundedness preserving definitional method, the question arised whether there is a similar dual to psuedo-well foundedness, and how this `pseudo-co-induction' differs from pseduo- and co-induction, if at all.

=IGN
open_theory "rbjmisc";
force_new_theory "PI";
set_merge_pcs["hol1", "'savedthm_cs_∂_proof"];
=TEX

\subsection{Well Foundedness and Hereditarily Collections}

It would be a good idea eventually to define these first and check back that they are special cases of the pseudo versions and that the well-founded functor/category collections are contained in the pseudo-well-founded collections.

\subsection{Hereditarily and Co-Hereditarily PQ}

Though \cite{rbjt007} defines methods for inductive and co-inductive definition which generalise the notion of a `hereditarily P' set for arbitrary properties of sets P, it does not explicitly cover the present requirement for mutually dependent inductive definitions.
However, this can be achieved by two separate inductive definitions.

No additional machinery is required, the application to yield purely inductive and co-inductive conceptions of category and functor are shown in the next section.

\ignore{

Here is a stab at a {\it hereditarily P} construction suitably generalised.

πHOLCONST
‹ €HereditarilyPQ› : (('X ≠ 'X ) ∏ ('X ≠ 'X ) ∏ ('X ≠ BOOL) ∏ ('X ≠ BOOL)) 
‹		≠ ('X  ∏ 'X )
˜¸¸¸¸¸¸
‹ µc d P Q∑ HereditarilyPQ (c, d, P, Q) = 
‹	(• {X' | µx∑ P x ± (µy z∑ y ç (c x) ± z ç (d y) ¥ Q y ± z ç X') ¥ x ç X'},
‹	 • {Y' | µx∑ Q x ± (µy z∑ y ç (d x) ± z ç (c y) ¥ P y ± z ç Y') ¥ x ç Y'})
∞

}%ignore

\subsection{Pseudo-Well-Founded Collections}

I have previously done the kind of category theoretic construction in well-founded set theories.
The same method could be used here, but the result would be similar, the constructed domains would still be well-founded.

I am therefore hoping to extract from Forster's discussion about pseudo-induction some idea about how to do the construction without throwing away the non-well-founded sets.

First we define the concept ``pseudo-well-founded''.
The set theoretic language here (membership relation and power set) is the one which comes with ProofPower HOL (and is set theoretic syntax for predicates in a type theory), the target set theory is modelled as a membership relation (r) over some type (*X).
This is based on the definition in Thomas Forster's book, and is included mainly for reference.

The presentation has been restructured.
The restructuring serves three purposes.
The first is to expose the two classes which partition the universe so that we can talk about them (in the original they are existentially quantified in the definition.
This is done by splitting the definition into two parts, the existential quantification appearing in the second.
The second is to include the claim that these two classes exhaust the type under consideration in the second part, so that the first definition can still be used in a set theory which is not known to be pseudo-well-founded for talking about its pseudo-well-founded part.
Otherwise we would have to add an axiom to NFU for the construction we have in mind.
The third change is to split our definitions of {\it I\_closed} and {\it II\_closed}, to make the structure of proofs more transparent.

πHOLCONST
‹ €I_closed› : ('X ≠ 'X ≠ BOOL) ≠ 'X  ≠ BOOL
˜¸¸¸¸¸¸
‹ µr w∑ I_closed r w
‹	§ µx∑ (∂y∑ r y x ± µz∑ r z y ¥ z ç w) ¥ x ç w
∞
πHOLCONST
‹ €II_closed› : ('X ≠ 'X ≠ BOOL) ≠ 'X  ≠ BOOL
˜¸¸¸¸¸¸
‹ µr w∑ II_closed r w
‹	§ µx∑ (µy∑ r y x ¥ ∂z∑ r z y ± z ç w) ¥ x ç w
∞
πHOLCONST
‹ €I_closure› : ('X ≠ 'X ≠ BOOL) ≠ 'X 
˜¸¸¸¸¸¸
‹ µr∑ I_closure r = •{x | I_closed r x}
∞
πHOLCONST
‹ €II_closure› : ('X ≠ 'X ≠ BOOL) ≠ 'X 
˜¸¸¸¸¸¸
‹ µr∑ II_closure r = •{x | II_closed r x}
∞

πHOLCONST
‹ €PseudoWellFounded› : ('X ≠ 'X ≠ BOOL) ≠ BOOL
˜¸¸¸¸¸¸
‹ µr∑ PseudoWellFounded r §
‹	(I_closure r) ¿ (II_closure r) = Universe
∞

\ignore{
=SML
val I_closed_def = get_spec ¨I_closedÆ;
val II_closed_def = get_spec ¨II_closedÆ;
val I_closure_def = get_spec ¨I_closureÆ;
val II_closure_def = get_spec ¨II_closureÆ;
val PseudoWellFounded_def = get_spec ¨PseudoWellFoundedÆ;
=IGN
set_goal([], ¨µR∑ I_closure R ° II_closure R = {}Æ);
a (rewrite_tac [I_closure_def, II_closure_def, I_closed_def, II_closed_def]);
a (PC_T1 "hol1" rewrite_tac [] THEN contr_tac);

set_goal([], ¨µR∑ I_closure R ° II_closure R = {}Æ);
a (rewrite_tac [I_closure_def, II_closure_def]);
a (PC_T1 "hol1" rewrite_tac [] THEN contr_tac);
=SML
set_goal([], ¨µX' R∑ I_closed R X' ¥ I_closure R Ä X'Æ);
a (rewrite_tac [I_closure_def] THEN REPEAT strip_tac);
a (PC_T1 "hol1" asm_prove_tac[]);
val I_closure_lemma1 = pop_thm ();

set_goal([], ¨µX' R∑ II_closed R X' ¥ II_closure R Ä X'Æ);
a (rewrite_tac [II_closure_def] THEN REPEAT strip_tac);
a (PC_T1 "hol1" asm_prove_tac[]);
val II_closure_lemma1 = pop_thm ();

val p_induct_thm1 = save_thm ("p_induct_thm1", rewrite_rule [I_closed_def] I_closure_lemma1);
val p_induct_thm2 = save_thm ("p_induct_thm2", rewrite_rule [II_closed_def] II_closure_lemma1);

set_goal([], ¨µR x∑ x ç I_closure R ¥ ≥ x ç II_closure RÆ);


set_goal([], ¨µR∑ I_closure R ° II_closure R = {}Æ);

set_goal([], ¨µR∑ PseudoWellFounded R §
	∂Ic IIc∑ Ic ¿ IIc = Universe ± Ic ° IIc = {}
	± (µ X' R∑ (µ x∑ (µ y∑ R y x ¥ (∂ z∑ R z y ± z ç X')) ¥ x ç X')
		¥ IIc Ä X')
	± (µ X' R∑ (µ x∑ (∂ y∑ R y x ± (µ z∑ R z y ¥ z ç X')) ¥ x ç X')
		¥ Ic Ä X')
Æ);

=TEX
}%ignore

The following theorems correspond to the induction principles in \cite{forster92}, p14.

=GFT
p_induct_thm1 =
   Ù µ X' R
     ∑ (µ x∑ (∂ y∑ R y x ± (µ z∑ R z y ¥ z ç X')) ¥ x ç X')
         ¥ I_closure R Ä X'

p_induct_thm2 =
   Ù µ X' R
     ∑ (µ x∑ (µ y∑ R y x ¥ (∂ z∑ R z y ± z ç X')) ¥ x ç X')
         ¥ II_closure R Ä X'
=TEX



=GFT

=TEX

\ignore{
=SML
set_goal([], ¨µR∑ I_closed R (I_closure R)Æ);
a (PC_T1 "hol1" rewrite_tac [I_closure_def, I_closed_def] THEN REPEAT strip_tac);
a (REPEAT (asm_fc_tac[]));
val I_closed_closure_lemma = save_pop_thm "I_closed_closure_lemma";

set_goal([], ¨µR∑ II_closed R (II_closure R)Æ);
a (PC_T1 "hol1" rewrite_tac [II_closure_def, II_closed_def] THEN REPEAT strip_tac);
a (spec_nth_asm_tac 1 ¨xÆ);
a (REPEAT (asm_fc_tac[]));
val II_closed_closure_lemma = save_pop_thm "II_closed_closure_lemma";

set_goal([], ¨µR y∑ (µx∑ x ç y ¥ I_closed R x) ¥ I_closed R (•y)Æ);
a (rewrite_tac [I_closed_def] THEN REPEAT strip_tac);
a (REPEAT (asm_fc_tac[]));
val I_closed_•_lemma = save_pop_thm "I_closed_•_lemma";

set_goal([], ¨µR y∑ (µx∑ x ç y ¥ II_closed R x) ¥ II_closed R (•y)Æ);
a (rewrite_tac [II_closed_def] THEN REPEAT strip_tac);
a (asm_fc_tac []);
a (spec_nth_asm_tac 1 ¨xÆ);
a (REPEAT (asm_fc_tac[]));
val II_closed_•_lemma = save_pop_thm "II_closed_•_lemma";

=TEX
}%ignore

=GFT
I_closed_•_lemma =
   Ù µ R y∑ (µ x∑ x ç y ¥ I_closed R x) ¥ I_closed R (• y)

II_closed_•_lemma =
   Ù µ R y∑ (µ x∑ x ç y ¥ II_closed R x) ¥ II_closed R (• y)

I_closed_closure_lemma =
   Ù µ R∑ I_closed R (I_closure R)

II_closed_closure_lemma =
   Ù µ R∑ II_closed R (II_closure R)
=TEX

\ignore{
=IGN
set_goal([], ¨µR∑ I_closure R Ä Universe \ (II_closure R)Æ);
a strip_tac;
a (bc_tac [list_µ_elim [¨Universe \ (II_closure R)Æ, ¨RÆ] p_induct_thm1]);
a (PC_T1 "hol1" rewrite_tac [II_closure_def] THEN REPEAT strip_tac);
a (∂_tac ¨•{s' | ∂z'∑ R z' y ± II_closed R s' ± ≥ z' ç s'}Æ
	THEN PC_T1 "hol1" rewrite_tac[] THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a (lemma_tac ¨µ x∑ x ç {s'|∂ z'∑ R z' y ± II_closed R s' ± ≥ z' ç s'} ¥ II_closed R xÆ
	THEN1 (PC_T1 "hol1" prove_tac[]));
a (fc_tac [II_closed_•_lemma]);
(* *** Goal "2" *** *)

a (asm_tac II_closed_•_lemma);

rewrite_rule [II_closed_def] II_closed_closure_lemma;
II_closure_def;

a (PC_T1 "hol1" rewrite_tac [II_closure_def]);

=TEX
}%ignore


\ignore{
The following theorems show the correspondence between the definitions given above and definition 1.2.1 in \cite{Forster87}.
}%ignore

The idea is to use this to define a notion of "pseudo-hereditarily P" set for a property of sets P, analogously to the notion of a "heridtarily P" set in a well-founded set theory.

This is a bit too simplistic, because the idea of hereditarily P sets is {\it thin} in the following sense.
To prove that a set is hereditarily P you need only to know that each of its members is hereditarily P.
So, in a sense you are only looking one level down.
When you do this with categories and functors the categories and functors alternate as the rank increases.
You either need mutually recursive definitions or else the independent definitions of categories and functors have to look down two levels to express the required condition.
There is already something like this going on in the pseudo-well-foundedness condition.
I've no idea at present whether these work together or not.

\subsection{Pseudo-Well-Founded-PQ Collections}

This is derived from pseudo-well-foundedness by the following generalisations:

\begin{itemize}
\item instead of looking down one level at a time according to the membership relation, the property is parameterised by a function which extracts the `content' from an object.
This might be just the members, or it might be, say, the field of a function.
\item for each of the two classes in question there is an additional parameterised property which is required to be satisfied.
\end{itemize}

Note that we have apparently lost the membership relation here, which is effectively hidden in the content extractors {\it c} and {\it d}.

The structure of this definition is now broken down similarly to that of {\it PseudoWellFounded}.

πHOLCONST
‹ €P_closed› : (('X ≠ 'X ) ∏ ('X ≠ 'X ) ∏ ('X ≠ BOOL) ∏ ('X ≠ BOOL))
‹		≠ 'X  ≠ BOOL
˜¸¸¸¸¸¸
‹ µc d P Q w∑ P_closed (c, d, P, Q) w
‹	§ µx∑ P x ± (µy∑ y ç (c x) ¥ Q y ± (∂z∑ z ç (d y) ± z ç w)) ¥ x ç w
∞

πHOLCONST
‹ €Q_closed› : (('X ≠ 'X ) ∏ ('X ≠ 'X ) ∏ ('X ≠ BOOL) ∏ ('X ≠ BOOL))
‹		≠ 'X  ≠ BOOL
˜¸¸¸¸¸¸
‹ µc d P Q w∑ Q_closed (c, d, P, Q) w
‹	§ µx∑ Q x ± (∂y∑ y ç (d x) ± P y ± µz∑ z ç (c y) ¥ z ç w) ¥ x ç w
∞
πHOLCONST
‹ €P_closure› : (('X ≠ 'X ) ∏ ('X ≠ 'X ) ∏ ('X ≠ BOOL) ∏ ('X ≠ BOOL))
‹		≠ 'X 
˜¸¸¸¸¸¸
‹ µz∑ P_closure z = •{x | P_closed z x}
∞
πHOLCONST
‹ €Q_closure› : (('X ≠ 'X ) ∏ ('X ≠ 'X ) ∏ ('X ≠ BOOL) ∏ ('X ≠ BOOL))
‹		≠ 'X 
˜¸¸¸¸¸¸
‹ µz∑ Q_closure z = •{x | Q_closed z x}
∞

πHOLCONST
‹ €PseudoWellFoundedPQ› :
‹	(('X ≠ 'X ) ∏ ('X ≠ 'X ) ∏ ('X ≠ BOOL) ∏ ('X ≠ BOOL)) ≠ BOOL
˜¸¸¸¸¸¸
‹ µz∑ PseudoWellFoundedPQ z §
‹	(P_closure z) ° (Q_closure z) = {}
‹   ±	(P_closure z) ¿ (Q_closure z) = Universe
∞

Need to check that this encompasses pseudo-well-foundedness when suitably parameterised and that the `pseudo' bit only makes a difference for non-well-founded membership structures.

\ignore{
=SML
val P_closed_def = get_spec ¨P_closedÆ;
val Q_closed_def = get_spec ¨Q_closedÆ;
val P_closure_def = get_spec ¨P_closureÆ;
val Q_closure_def = get_spec ¨Q_closureÆ;
val PseudoWellFoundedPQ_def = get_spec ¨PseudoWellFoundedPQÆ;

set_goal([], ¨µc d P Q x∑ x ç P_closure (c, d, P, Q) ¥ P xÆ);
a (REPEAT µ_tac THEN rewrite_tac[P_closure_def, P_closed_def]
	THEN REPEAT strip_tac);
a (spec_nth_asm_tac 1 ¨{x | P x}Æ);
val P_closed_¥_P_thm = save_pop_thm "P_closed_¥_P_thm";

set_goal([], ¨µc d P Q x∑ x ç Q_closure (c, d, P, Q) ¥ Q xÆ);
a (REPEAT µ_tac THEN rewrite_tac[Q_closure_def, Q_closed_def]
	THEN REPEAT strip_tac);
a (spec_nth_asm_tac 1 ¨{x | Q x}Æ);
val Q_closed_¥_Q_thm = save_pop_thm "Q_closed_¥_Q_thm";

=IGN
set_goal([], ¨µc d P Q∑ P_closed (c, d, P, Q) (P_closure (c, d, P, Q))Æ);
a (REPEAT µ_tac THEN rewrite_tac[P_closed_def]
	THEN REPEAT strip_tac);
a (rewrite_tac[P_closure_def, P_closed_def] THEN REPEAT strip_tac);
a (asm_fc_tac[]);
a (spec_nth_asm_tac 4 ¨yÆ);
a (spec_nth_asm_tac 3 ¨zÆ);
a (spec_nth_asm_tac 6 ¨zÆ);
(* *** Goal "1" *** *)
a (all_fc_tac [P_closed_¥_P_thm]);
(* *** Goal "2" *** *)
a (spec_nth_asm_tac 9 ¨y'Æ);
a (lemma_tac ¨P zÆ THEN1 all_fc_tac [P_closed_¥_P_thm]);

a (asm_fc_tac[]);

val P_closed_¥_P_thm = save_pop_thm "P_closed_¥_P_thm";
=TEX
}%ignore

=GFT
P_closed_¥_P_thm =
	Ù µ c d P Q x∑ x ç P_closure (c, d, P, Q) ¥ P x

Q_closed_¥_Q_thm =
	Ù µ c d P Q x∑ x ç Q_closure (c, d, P, Q) ¥ Q x
=TEX

\subsection{Pseudo-Hereditarily-PQ Collections}

Even if we had a pseudo-well-founded universe in NFU, it would not be pseudo-well-founded-PQ for any interesting or useful properties P and Q.
The whole idea is to use these properties to create a pair of useful subclasses of the universe.
So what we want to do is just take the two closures resulting from P and Q, and use their union as new a psuedo-well-founded domain of discourse.
In fact, we won't take the union at all, we will be looking for a two-sorted foundational theory.

πHOLCONST
‹ €PseudoHereditarilyPQ› :
‹	(('X ≠ 'X ) ∏ ('X ≠ 'X ) ∏ ('X ≠ BOOL) ∏ ('X ≠ BOOL)) ≠ ('X  ∏ 'X )
˜¸¸¸¸¸¸
‹ µz∑ PseudoHereditarilyPQ z = (P_closure z, Q_closure z)
∞

Among the important properties which we hope this construction will have are:

\begin{itemize}
\item The values in the left collection will all have property P.
\item The values in the right collection will all have property Q.
\item Both collections will include the corresponding {\it HereditarilyPQ} sets.
\end{itemize}

I am by no means confident of any of these features at present.

\ignore{
=SML
val P_closed_def = get_spec ¨P_closedÆ;
val Q_closed_def = get_spec ¨Q_closedÆ;
val P_closure_def = get_spec ¨P_closureÆ;
val Q_closure_def = get_spec ¨Q_closureÆ;
val PseudoHereditarilyPQ_def = get_spec ¨PseudoHereditarilyPQÆ;
=TEX
}%ignore



\section{CODING CONSTRUCTIONS}

It is proposed in the first instance to use HOL types as ways of describing constructions.

It is also desirable to allow the domains of the constructors to be specified by predicates, especially since some type constructors like the power set will not be implementable without some constraint on the subsets.

\subsection{Constructor Translation Kits}

In order to make the translation of such a description of a system of constructors into a function whose fixedpoint can be taken to yield an implementation, the code will be parameterised by the necessary things to build the function.
For example, for type constructor allowed in the description a function is required to perform the construction of elements of that type over the chosen representation type.
So we need a map (in SML) from HOL type constructors to hol functions containing this information.

The type $CTK$ is defined as a 1-ary type constructor which in its in its primary role instantiated to type $TERM$.
When instantiated to $string$ the type can be used to package a set of aliases for these terms enabling the complex terms constructed for fixed points to be presented concisely in theory listings.
The aliases may be used temporarily just for the theory listing and then easily undeclared so that they do not interfere with parsing.

=SML
type 'a €CTK› = {
	tag : 'a,
	tagc : 'a,
	mk_leaf: 'a,
	node_constructors: 'a list,
	content_extractors: 'a list,
	leaf_injections: 'a list,
	leaf_content: 'a,
	ccp_converter: 'a,
	compound_fixp: 'a};
=TEX

\ignore{
=SML

=IGN
=TEX
}%ignore

\subsection{Lifting Over HOL Type Constructors}

The following functions allow the coding of constructors over a representation type to be written without concern for how the functions will be compounded.
They lift an operator over a representation type to be lifted to a functor which transforms constructors for the operand types into a constructor for the result type.

These lifting functions are specific to the HOL type constructors but independent of the representation type.

πHOLCONST
‹ €LiftProduct›: ('t ∏ 't ≠ 't) ≠ ('a ≠ 't) ≠ ('b≠ 't) ≠ ('a ∏ 'b ≠ 't)
˜¸¸¸¸¸¸
‹ µprod f g a b∑ LiftProduct prod f g (a, b) = prod (f a, g b)
∞

πHOLCONST
‹ €LiftSum›: ('t + 't ≠ 't) ≠ ('a ≠ 't) ≠ ('b≠ 't) ≠ ('a + 'b ≠ 't)
˜¸¸¸¸¸¸
‹ µsum f g ab∑ LiftSum sum f g ab = sum ((Funâ+ f g) ab)
∞

πHOLCONST
‹ €LiftList›: ('t LIST ≠ 't) ≠ ('a ≠ 't) ≠ ('a LIST ≠ 't)
˜¸¸¸¸¸¸
‹ µlist f al∑ LiftList list f al = list (Map f al)
∞

πHOLCONST
‹ €LiftSumUnion›: ('a ≠ 'u SET) ≠ ('b ≠ 'u SET) ≠ ('a + 'b ≠ 'u SET)
˜¸¸¸¸¸¸
‹ µcfl cfr ab∑ LiftSumUnion cfl cfr ab = if IsL ab then cfl (OutL ab) else cfr (OutR ab)
∞

πHOLCONST
‹ €LiftSumPred›: ('a ≠ BOOL) ≠ ('b ≠ BOOL) ≠ ('a + 'b ≠ BOOL)
˜¸¸¸¸¸¸
‹ µpl pr ab∑ LiftSumPred pl pr ab = if IsL ab then pl (OutL ab) else pr (OutR ab)
∞

\subsection{Constructors Over Trees}

Definitions of constructors for products and lists, and injections for disjoint unions.

I'm trying to make this a general as possible, the idea is to allow for the construction of inductive datatypes based on arbitrary trees.

Then constructions may are therefore be thought of as parameterised by:

\begin{enumerate}
\item a type of leaf values
\item a type of arc tags
\end{enumerate}

And the tree we construct is a tree whose paths may be as long as the well-ordering and whose nodes and arcs have the appropriate kinds of tags.

A tree is then ``implemented'' as a function from paths to node tags, where a path is itself a function from an initial segment of the domain of the well-ordering into the arc tags.
Both of these kinds of function are partial and are therefore represented as relations.

The fact that we are dealing with sets and partial function is here immaterial to the definition of the constructor function, and can be taken account of later in the process of constructing the inductive datatype, so the parameterisation is evident at this point only by the presence of three type variables.

I can't see how to make use of a well-ordering larger than the natural numbers so that's fixed, and that makes a path into a list of arcs.

\subsubsection{Some Types, Some Properties}

To make the type information in the theory listing less cluttered I will use some labelled product definitions to introduce types.

πHOLLABPROD €TREE›¸¸¸¸¸
‹ €Tree›: 'arc LIST ≠ 'leaf ≠ BOOL
∞¸¸¸¸¸¸¸¸¸¸¸¸¸¸

One could make a proper subtype here by incorporating the necessary conditions on the relations involved, but in the construction of an inductive datatype there will almost invariably be another subtyping involved and one will probably suffice.
However, it may be helpful at this point to define the conditions for a ``TREE'' to be a tree.
The conditions depend upon chosing a well-ordering of the index types, and are therefore parameterised by such a well-ordering.
There may not be to allow for this to be a well-ordering of a subset of the type, but since the definition of well-ordering we have is defined in such terms (i.e. as a property of set/relation pairs) we will define the well-formedness condition as accepting such a well-ordering.

πHOLCONST
‹ €ManyOne› : ('a ≠ 'b ≠ BOOL) ≠ BOOL
˜
‹ µr∑ ManyOne r § µx y z∑ r x y ± r x z ¥ y = z
∞

πHOLCONST
‹ €Domain› : ('a ≠ 'b ≠ BOOL) ≠ 'a SET
˜
‹ µr∑ Domain r = {x | ∂y∑ r x y}
∞

πHOLCONST
‹ €NullTree› : ('arc, 'leaf)TREE
˜
‹ NullTree = MkTREE(Ãal n∑ F)
∞

πHOLCONST
‹ €IsTree› : ('arc, 'leaf)TREE ≠ BOOL
˜
‹ µ t:('arc, 'leaf)TREE∑
‹	IsTree t §
‹	≥ t = NullTree
‹	± ManyOne (Tree t)
‹	± (µp q∑ p ç Domain (Tree t) ¥ ≥ Append p q ç Domain (Tree t))
∞

\subsubsection{A Generic Constructor}

We have a single constructor function which takes a 'arc indexed set of trees and a 'leaf value.
This constructs a new tree from whose root node has the supplied value and whose children are the supplied trees, placed on the arc names used to index them.

The paths through the tree are therefore the paths of the original trees with a new arc slotted in at the head of each path.

πHOLCONST
‹ €MkTree› : ('arc ≠ ('arc, 'leaf)TREE ≠ BOOL) ≠ ('arc, 'leaf)TREE
˜
‹ µc∑ MkTree c = MkTREE (Ã path leaf∑
‹	∂ tr∑ c (Hd path) tr ± Tree tr (Tail path) leaf)
∞

Though this was written for use in inductive datatypes, I don't know a reason why it could not be used for co-inductive datatypes.
Presumably you have the same kind of definition but take the maximal rather than the minimal fixed point.

This construction is only one-one subject to some constraints on the supplied map, as follows:

πHOLCONST
‹ €NiceChildren› : ('arc ≠ ('arc, 'leaf)TREE ≠ BOOL) ≠ BOOL
˜
‹ µc∑ NiceChildren c § ManyOne c ± ≥ ∂a∑ c a NullTree
∞

\ignore{
=SML
val Tree_def = get_spec ¨TreeÆ;
val MkTree_def = get_spec ¨MkTreeÆ;
val NullTree_def = get_spec ¨NullTreeÆ;
val ManyOne_def = get_spec ¨ManyOneÆ;
val NiceChildren_def = get_spec ¨NiceChildrenÆ;

set_goal([], ¨∂DestTree : ('arc, 'leaf)TREE ≠ ('arc ≠ ('arc, 'leaf)TREE ≠ BOOL) ∑
	µc∑ NiceChildren c ¥ DestTree (MkTree c) = cÆ);
a (∂_tac ¨Ãt:('arc, 'leaf)TREE∑
		let tr = Tree t
		in  (Ãa:'arc; tr2∑ Tree tr2 = (Ãal:'arc LIST; n:'leaf∑ tr (Cons a al) n)
			± ≥ tr2 = NullTree)
		   Æ THEN rewrite_tac [let_def, Tree_def, MkTree_def]
	THEN REPEAT strip_tac);
a (rewrite_tac [ext_thm] THEN REPEAT µ_tac);	
a (cases_tac ¨c x x'Æ
	THEN TRY (asm_rewrite_tac[])
	THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a (∂_tac ¨x'Æ THEN asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a (all_fc_tac [NiceChildren_def]);
a (all_fc_tac [ManyOne_def]);
a (POP_ASM_T discard_tac THEN asm_rewrite_tac []);
(* *** Goal "3" *** *)
a (all_fc_tac [NiceChildren_def]);
a (swap_nth_asm_concl_tac 1 THEN strip_tac);
a (∂_tac ¨xÆ
	THEN POP_ASM_T (rewrite_thm_tac o eq_sym_rule)
	THEN strip_tac);
(* *** Goal "4" *** *)
a (POP_ASM_T ante_tac THEN rewrite_tac [NullTree_def]);
a (LEMMA_T ¨x' = MkTREE (Ã al n∑ F) § Tree x' = (Ã al n∑ F)Æ
	rewrite_thm_tac);
(* *** Goal "4.1" *** *)
a (REPEAT strip_tac THEN TRY (asm_rewrite_tac [Tree_def]));
a (SYM_ASMS_T rewrite_tac);
a (rewrite_tac[Tree_def]);
(* *** Goal "4.2" *** *)
a (rewrite_tac [ext_thm] THEN REPEAT strip_tac);	
a (swap_nth_asm_concl_tac 2);
a (spec_nth_asm_tac 1 ¨x''Æ);
a (spec_nth_asm_tac 1 ¨x'''Æ);
(* *** Goal "4.2.1" *** *)
a (all_asm_fc_tac[]);
(* *** Goal "4.2.2" *** *)
a (lemma_tac ¨µ x'' x'''∑ (∂ tr∑ c x tr ± Tree tr x'' x''') § Tree tr x'' x'''Æ
	THEN REPEAT strip_tac THEN TRY (asm_rewrite_tac[]));
(* *** Goal "4.2.2.1" *** *)
a (all_fc_tac [NiceChildren_def]);
a (all_fc_tac [ManyOne_def]);
a (all_var_elim_asm_tac);
(* *** Goal "4.2.2.2" *** *)
a (∂_tac ¨trÆ THEN asm_rewrite_tac[]);
(* *** Goal "4.2.2.3" *** *)
a (rename_tac []);
a (DROP_NTH_ASM_T 5 ante_tac);
a (DROP_NTH_ASM_T 1 rewrite_thm_tac
	THEN strip_tac);
a (lemma_tac ¨Tree x' = Tree trÆ
	THEN1 (rewrite_tac [ext_thm]
		THEN REPEAT µ_tac
		THEN (POP_ASM_T rewrite_thm_tac)));
a (LEMMA_T ¨MkTREE (Tree x') = MkTREE (Tree tr)Æ ante_tac
	THEN1 (asm_rewrite_tac []));
a (rewrite_tac [Tree_def] THEN strip_tac THEN asm_rewrite_tac[]);
val _ = save_cs_∂_thm (pop_thm());
=TEX
}%ignore

πHOLCONST
‹ €DestTree› : ('arc, 'leaf)TREE ≠ ('arc ≠ ('arc, 'leaf)TREE ≠ BOOL) 
˜
‹ µc∑ NiceChildren c ¥ DestTree (MkTree c) = c
∞

\subsubsection{Specific Constructors}

The idea here is to code up the details of how to construct appropriate data for MkTree for the commonly expected type constructors in an inductive datatype definition.

πHOLCONST
‹ €MkLeafTree› : 'leaf ≠ ('arc, 'leaf)TREE
˜
‹ µl∑ MkLeafTree l = MkTREE (Ãarc leaf∑ arc = [] ± leaf = l)
∞

πHOLCONST
€MkProdTree› : (BOOL ≠ 'arc) ≠ (('arc, 'leaf)TREE) ∏ (('arc, 'leaf)TREE)
‹ 		≠ ('arc, 'leaf)TREE
˜
‹ µai l r∑
‹ 	MkProdTree ai (l, r) = MkTree 
‹ 	(Ãarc tree∑ arc = (ai T) ± tree = l
‹ 		≤ arc = (ai F) ± tree = r)
∞

πHOLCONST
‹ €MkSumTree› : (BOOL ≠ 'arc)
‹ 		≠ (('arc, 'leaf)TREE) + (('arc, 'leaf)TREE)
‹ 		≠ ('arc, 'leaf)TREE
˜
‹ µai t∑
‹ 	MkSumTree ai t = MkTree 
‹ 	(Ãarc tree∑ if IsL t then arc = (ai T) ± tree = OutL t
‹ 		else arc = (ai F) ± tree = OutR t)
∞

πHOLCONST
‹ €MkArcTree› : 'arc ≠ ('arc, 'leaf)TREE ≠ ('arc, 'leaf)TREE
˜
‹ µa t∑
‹ 	MkArcTree a t = MkTree (Ãarc tree∑ arc = a ± tree = t)
∞

πHOLCONST
‹ €MkTagTree› : (Ó ≠ 'arc) ≠ Ó ≠ ('arc, 'leaf)TREE ≠ ('arc, 'leaf)TREE
˜
‹ µai n t∑
‹ 	MkTagTree ai n t = MkArcTree (ai n) t
∞

πHOLCONST
‹ €IsTagTree› : (Ó ≠ 'arc) ≠ Ó ≠ ('arc, 'leaf)TREE ≠ BOOL
˜
‹ 	µai n t∑ IsTagTree ai n t § ∂t2∑ t = MkTagTree ai n t2 
∞

πHOLCONST
‹ €UnTagTree› : ('arc, 'leaf)TREE ≠ ('arc, 'leaf)TREE
˜
‹ 	µt∑ ∂ t2 a∑ t = MkArcTree a t2 ¥ UnTagTree t = t2
∞

πHOLCONST
‹ €MkListTree› : (Ó ≠ 'arc) ≠ ('arc, 'leaf)TREE LIST ≠ ('arc, 'leaf)TREE
˜
‹ µai trl∑
‹ 	MkListTree ai trl = MkTree
‹ 	(Ãarc tree∑ ∂n∑ arc = (ai n) ± (n, tree) ç ListRel trl)
∞

Node injections will be dynamically constructed.

Arc injections are fixed in any particular implementation of these inductive datatypes, determined by the range of type constructors to be supported.
The arc type has to have a cardinality which is an upper bound of the cardinalities of those required by the type constructors.
So, for the above set of constructors $Ó$ suffices and the arc injectors are therefore defined as follows:

πHOLCONST
‹ €AiOneToN› : ONE ≠ Ó;  AiBoolToN : BOOL ≠ Ó; AiNToN : Ó ≠ Ó
˜
‹ 	(µone∑ AiOneToN one = 0)
‹ ±	(µb∑ AiBoolToN b = if b then 1 else 0)
‹ ±	(µn∑ AiNToN n = n)
∞

\subsection{An Ó Tree Constructor Translator Kit}

In order to make the definitions of types no more prolix than need be it is desirable not to use expressions in making up constructor toolkits.
So we here define constants for making a default toolkit based on trees with natural number arcs.

\subsubsection{Special Constructors}

The following definition instantiates the tree constructors to the injections into $Ó$ and lifts them to give the functions required for a $CTK$.

πHOLCONST
‹ €NTreeTag›: Ó ≠ ('a  ≠ (Ó, 'leaf)TREE) ≠ ('a  ≠ (Ó, 'leaf)TREE)
˜¸¸¸¸¸¸
‹ 	µn f∑ NTreeTag n f = (MkTagTree AiNToN n) o f
∞

πHOLCONST
‹ €NTreeIsTag›: Ó ≠ (Ó, 'leaf)TREE ≠ BOOL
˜¸¸¸¸¸¸
‹ 	NTreeIsTag = IsTagTree AiNToN
∞

\subsubsection{Node Constructors}

πHOLCONST
‹ €NTreeMkList›: ('a ≠ (Ó, 'leaf)TREE) ≠ ('a LIST ≠ (Ó, 'leaf)TREE)
˜¸¸¸¸¸¸
‹ 	 NTreeMkList = LiftList (MkListTree AiNToN)
∞

πHOLCONST
‹ €NTreeMkProd›: ('a ≠ (Ó, 'leaf)TREE) ≠ ('b ≠ (Ó, 'leaf)TREE)
‹	 ≠ ('a ∏ 'b ≠ (Ó, 'leaf)TREE);
‹ €NTreeMkSum›: ('a ≠ (Ó, 'leaf)TREE) ≠ ('b ≠ (Ó, 'leaf)TREE)
‹	 ≠ ('a + 'b ≠ (Ó, 'leaf)TREE)
˜¸¸¸¸¸¸
‹ 	NTreeMkProd = LiftProduct (MkProdTree AiBoolToN)
‹ ±	NTreeMkSum = LiftSum (MkSumTree AiBoolToN)
∞

\subsubsection{Content Extractors}

πHOLCONST
‹ €NTrListC›: ('a ≠ (Ó, 'leaf)TREE SET) ≠ ('a LIST ≠ (Ó, 'leaf)TREE SET)
˜¸¸¸¸¸¸
‹ 	 NTrListC = LiftList (Ãsl∑ ﬁ {x | x çâL sl})
∞

πHOLCONST
‹ €NTrProdC›: ('a ≠ (Ó, 'leaf)TREE SET) ≠ ('b ≠ (Ó, 'leaf)TREE SET)
‹	 ≠ ('a ∏ 'b ≠ (Ó, 'leaf)TREE SET);
‹ €NTrSumC›: ('a ≠ (Ó, 'leaf)TREE SET) ≠ ('b ≠ (Ó, 'leaf)TREE SET)
‹	 ≠ ('a + 'b ≠ (Ó, 'leaf)TREE SET)
˜¸¸¸¸¸¸
‹ 	NTrProdC = LiftProduct (Uncurry $¿)
‹ ±	NTrSumC = LiftSum (Ãx∑ if IsL x then OutL x else OutR x)
∞

πHOLCONST
‹ €NTrLeafC›: ('a ≠ (Ó, 'leaf)TREE SET)
˜¸¸¸¸¸¸
‹ 	 µl∑ NTrLeafC l = {}
∞

This function tags content as required by content extractors on type variables for the new types.
It also makes a unit set of the result.

πHOLCONST
‹ €NTreeTagC›: Ó ≠ (Ó, 'leaf)TREE ≠ (Ó, 'leaf)TREE SET
˜¸¸¸¸¸¸
‹ 	µn t∑ NTreeTagC n t = {MkTagTree AiNToN n t}
∞

\subsubsection{Ntree Ctk}

The following definition gives the required ccp to relation conversion:

πHOLCONST
‹ €CR›: ('b ≠ 'a) ≠ ('b ≠ 'a SET) ≠ ('b ≠ BOOL) ≠ ('a ≠ 'a ≠ BOOL)
˜¸¸¸¸¸¸
‹ 	µtor tent pred∑ CR tor tent pred = CCP2Rel (MkCCP tor tent pred)
∞

This definition provides the compounder which combines the relations for all the constructors and takes the fixed point.

πHOLCONST
‹ €FR›: ((Ó, 'a) TREE ≠ (Ó, 'a) TREE ≠ BOOL) LIST LIST ≠ (Ó, 'a) TREE SET
˜¸¸¸¸¸¸
‹ 	µrll∑ FR rll = HeredRel (CompoundRels (MkTagTree AiNToN) rll)
∞

=SML
val €ntree_ctk›:TERM CTK = {
	tag = ¨NTreeTagÆ,
	tagc = ¨NTreeTagCÆ,
	mk_leaf = ¨MkLeafTreeÆ,
	node_constructors = [¨NTreeMkProdÆ, ¨NTreeMkSumÆ, ¨NTreeMkListÆ],
	leaf_injections = [¨MkLeafTree:CHAR≠(Ó, CHAR)TREEÆ],
	content_extractors = [¨NTrProdCÆ, ¨NTrSumCÆ, ¨NTrListCÆ],
	leaf_content = ¨NTrLeafCÆ,
	ccp_converter = ¨CRÆ,
	compound_fixp = ¨FRÆ
};
val ctk_aliases:string CTK ={
	tag = "’",
	tagc = "◊",
	mk_leaf = "«",
	node_constructors = ["∏", "+", "∆"],
	leaf_injections = ["“"],
	content_extractors = ["∏", "+", "∆"],
	leaf_content = "“",
	ccp_converter = "ò",
	compound_fixp = "ä"
};

fun declare_ctk_aliases (ctk: TERM CTK) (sctk:string CTK) =
 let
	fun map_declare_alias (sl, tl) = map declare_alias (combine sl tl);
	val _ = declare_alias (#tag sctk, #tag ctk);
	val _ = declare_alias (#tagc sctk, #tagc ctk);
	val _ = declare_alias (#mk_leaf sctk, #mk_leaf ctk);
	val _ = map_declare_alias (#node_constructors sctk, #node_constructors ctk);
	val _ = map_declare_alias (#leaf_injections sctk, #leaf_injections ctk);
	val _ = map_declare_alias (#content_extractors sctk, #content_extractors ctk);
	val _ = declare_alias (#leaf_content sctk, #leaf_content ctk);
	val _ = declare_alias (#ccp_converter sctk, #ccp_converter ctk);
	val _ = declare_alias (#compound_fixp sctk, #compound_fixp ctk)
	in ()
	end;

fun undeclare_ctk_aliases (ctk: TERM CTK) (sctk:string CTK) =
 let
	fun map_undeclare_alias (sl, tl) = map undeclare_alias (combine sl tl);
	val _ = undeclare_alias (#tag sctk, #tag ctk);
	val _ = undeclare_alias (#tagc sctk, #tagc ctk);
	val _ = undeclare_alias (#mk_leaf sctk, #mk_leaf ctk);
	val _ = map_undeclare_alias (#node_constructors sctk, #node_constructors ctk);
	val _ = map_undeclare_alias (#leaf_injections sctk, #leaf_injections ctk);
	val _ = map_undeclare_alias (#content_extractors sctk, #content_extractors ctk);
	val _ = undeclare_alias (#leaf_content sctk, #leaf_content ctk);
	val _ = undeclare_alias (#ccp_converter sctk, #ccp_converter ctk);
	val _ = undeclare_alias (#compound_fixp sctk, #compound_fixp ctk)
	in ()
	end;

=TEX

\ignore{

\subsection{Coding into Membership Structures}

We provide here a method of coding inductely defined sets into membership structures.
This supports coding in the following three ways:

\begin{enumerate}
\item into a membership structure of choice and a ordered pair construction over that structure
\item into the natural numbers, given a suitable relation over the natural numbers
\item into the finite Von Neuman ordinals in a membership structure
\end{enumerate}

In relation to the first method, the Sierpinski and Quine ordered pair construction are provided.
In relation to the second, a method of encoding the hereditarily finite sets into natural numbers is provided.

One way to approach this would be to provide metalanguage facilities parameterized by membership structures with ordered pair constructors for preparing contructor translation kits giving fixed points which are in the membership structure.

There are two disadvantages to this.

The first small disadvantage is that either the facility would have to perform definitions for the constants in each CTK it produces, causing a proliferation of new constant definitions, or else expressions would have to be used, which would exacerbate the complexity of the terms involved.

The second disdvantage is that such a facility would not permit reasoning in general about what can be coded in membership structures.

To permit proof (for example) of a generalised negative definability result obtained via construction of a liar sentence, it is desirable that the parameterisation by membership structure should take place in the object rather than the metalangage.

We will therefore be defining a CTK in which the representation type is the domain of a membership structure which is expected (together with an ordered pair constructor) as an argument by the constructors in the CTK, which delivers not simply a fixed point, but a function from such a structure to a fixed point.

We might as well treat the necessary injection from the natural numbers into the membership structure in the same way as the pairing constructor.


 πHOLCONST
‹ SierpinskiPair ('a SET ∏ ('a ≠ 'a ≠ BOOL)) ≠ 'a ∏ 'a ≠ 'a
 ˜¸¸¸¸¸¸
‹ µ (S, $çâm) (x,y) = 
 ∞


 πHOLCONST
‹ MSUPair ('a SET ∏ ('a ≠ 'a ≠ BOOL)) ≠ 'a ∏ 'a ≠ 'a
 ˜¸¸¸¸¸¸
‹ µ (S, $çâm) (x,y)∑ MSUPair (S, $çâm) (x,y) = 
 ∞

\subsection{Constructing a Fixed Point}

The following function takes a HOL type and a list of constructors and computes a compound constructor.
The HOL type should have a sum of any finite number of distinct type variables as its codomain
The constructors should include one for each type constructor which is involved in the recursion.

=SML
fun match_mk_cons (t, u) = list_match_mk_app (¨ConsÆ, (t::u::[]));
fun list_match_mk_cons l = foldr match_mk_cons ¨NilÆ l;
=IGN
fun match_mk_sum (t, u) = list_match_mk_app (¨FunSumÆ, (t::u::[]));
fun list_match_mk_sum (h::tl) = lfoldr match_mk_sum h tl;

fun match_mk_sum_union (t, u) = list_match_mk_app (¨LiftSumUnionÆ, (t::u::[]));
fun list_match_mk_sum_union (h::tl) = lfoldr match_mk_sum_union h tl;

fun match_mk_sum_pred (t, u) = list_match_mk_app (¨LiftSumPredÆ, (t::u::[]));
fun list_match_mk_sum_pred (h::tl) = lfoldr match_mk_sum_pred h tl;

fun tc_of_constructor c = (fst o dest_ctype o last o front) ((strip_≠_type o type_of) c);
=SML
fun node_constructor_pair c = ((fst o dest_ctype o last o front) ((strip_≠_type o type_of) c), c);

fun leaf_injection_pair li = ((fst o dest_ctype o fst o dest_≠_type o type_of) li, li);

val node_extractor_pair = node_constructor_pair;

fun leaf_extractor_pair t li = ((fst o dest_ctype o fst o dest_≠_type o type_of) li, t);

local
 fun aux1 (a,b) =
	let val (n,t) = dest_var a
	    val (tt::tl) = right_rotate_list (strip_≠_type t)
	in (n, length tl, list_mk_∏_type tl, tt, b) end;
 fun aux2 (_,_,_,d,_) = [dest_vartype d]
in
 fun sigproc sig1 =
  let    val sig2 = map aux1 sig1;
	val new_types = list_cup (map aux2 sig2)
	val sig3 = map (fn x => filter (fn (_,_,_,y,_) => x = dest_vartype y) sig2) new_types;
  in (new_types, sig3)
  end
end;

fun translate_mapper (ctk:TERM CTK) =
 let val cd = list_to_sdict (
		  (map node_constructor_pair (#node_constructors ctk))
		@ (map leaf_injection_pair (#leaf_injections ctk)))
 in (fn tcn =>
	let val Value x = s_lookup tcn cd
	in fn tl => list_match_mk_app (x, tl)
	end)
 end;

fun extract_mapper (ctk:TERM CTK) =
 let val cd = list_to_sdict (
		  (map node_extractor_pair (#content_extractors ctk))
		@ (map (leaf_extractor_pair (#leaf_content ctk)) (#leaf_injections ctk)))
 in (fn tcn =>
	let val Value x = s_lookup tcn cd
	in fn tl => list_match_mk_app (x, tl)
	end)
 end;

val constructor_types = [
	(¨MkVarType: STRING ≠ 'TYPEÆ,
				¨Ãx:STRING∑ Hd x = '''Æ),
	(¨MkCType: STRING ≠ 'TYPE LIST ≠'TYPEÆ,
				¨Ã(x:STRING, y:'TYPE LIST)∑ ≥ Hd x = '''Æ),
	(¨MkVarTerm: STRING ≠ 'TYPE ≠'TERMÆ,
				¨Ã(x:STRING, y:'TYPE)∑ Hd x = '''Æ),
	(¨MkCTerm: STRING ≠ 'TYPE ≠'TERMÆ,
				¨Ã(x:STRING, y:'TYPE)∑ ≥ Hd x = '''Æ),
	(¨MkLamTerm: STRING ≠ 'TYPE ≠ 'TERM ≠ 'TERMÆ,
				¨Ã(x:STRING, y:'TYPE, z:'TERM)∑ Hd x = '''Æ),
	(¨MkAppTerm: 'TERM ≠ 'TERM ≠ 'TERMÆ,
				¨Ã(x:'TERM, y:'TERM)∑ TÆ)
];

fun translate_sig ctk sign =
 let
	val psig = sigproc sign;
	val newtyvars = fst psig;
	fun tagnum tv = mk_Ó (list_pos tv newtyvars);
	val cf = translate_mapper ctk;
	val tag = #tag  ctk;
	val tagc = #tagc ctk;
	fun id_vf x = ¨IÆ;
     	fun aux (_,_,ty1,_,_) = gen_type_map cf id_vf ty1;
	fun tvcon_vf tv = match_mk_app (tagc, tagnum tv);
	val xf = extract_mapper ctk;
     	fun aux2 (_,_,ty1,_,_) = gen_type_map xf tvcon_vf ty1;
	val dtll = map (map (fn x as (a,b,c,d,e) =>
		list_match_mk_app (#ccp_converter ctk, [aux x, aux2 x, e]))) (snd psig)
	val tll = list_match_mk_cons (map list_match_mk_cons dtll)
 in      match_mk_app (#compound_fixp ctk, tll)
 end;

=IGN
set_flag ("pp_use_alias", true);
declare_ctk_aliases ntree_ctk ctk_aliases;
translate_sig ntree_ctk constructor_types;
=TEX

}%ignore

\section{MAKING NEW TYPES}

The last stage in this process takes place where the objective is to introduce new types and constructors over the new types.
The preceding material enables the description of a system of constructors to be translated into a realisation of that system over various sets.

This final stage involves the creation of a new type (possibly a type constructor) for each of the distinct sets which are the co-domains of the constructors, the definition of operators over these types corresponding to the constructors, and the transfer of the properties of the sets to theorems over the types.

These facilities will I hope be orthogonal to most aspects of variation in the definition of the underlying sets.
It is most strongly motivated by the recursive datatypes of computer science, where there is a desire to abstract away from the details of how the constructions are coded, and may not be required in metatheoretic applications.
An example of the latter applications is where the system of constructors is providing a coding of syntax into some domain of interest (as in Goedel numbering).
However, in other metatheoretic studies, where the details of the construction are important and specific to the application, e.g. in the definition of mutually dependent hereditarily pure concrete functors and  categories, it may be desired at the end to abstract away from the constructions and have separate new types for functors and categories.

{\let\Section\section
\def\section#1{\Section{#1}\label{TheoryListing}}
\include{fixp.th}
}  %\let

\twocolumn[\section{INDEX}\label{INDEX}]
{\small\printindex}

\end{document}
=SML
val aliasflag = set_flag ("pp_use_alias", true);
declare_ctk_aliases ntree_ctk ctk_aliases;
output_theory{out_file="fixp.th.doc", theory="fixp"};
undeclare_ctk_aliases ntree_ctk ctk_aliases;
set_flag ("pp_use_alias", aliasflag);
=TEX