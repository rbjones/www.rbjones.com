=IGN
$Id: t010.doc,v 1.14 2010/08/08 15:50:44 rbj Exp $
=TEX
\documentclass[11pt,a4paper]{article}
\usepackage{latexsym}
\usepackage{ProofPower}
\ftlinepenalty=9999
\tabstop=0.25in
\usepackage{A4}
\def\N{\mathbb{N}}
\def\D{\mathbb{D}}
\def\B{\mathbb{B}}
\def\R{\mathbb{R}}
\def\Z{\mathbb{Z}}
\def\Q{\mathbb{Q}}

\def\Hide#1{\relax}
\newcommand{\ignore}[1]{}

\title{Miscellaneous Tactics}
\author{Roger Bishop Jones}
\date{$ $Date: 2010/08/08 15:50:44 $ $}

\makeindex
\usepackage[pdftex]{hyperref}

\begin{document}
\vfill
\maketitle
\begin{abstract}
Several structures providing tactics, tacticals, etc. for theories, forward chaining, backward chaining, theory trawling et.al.
\end{abstract}
\vfill

\begin{centering}

\href{http://www.rbjones.com/rbjpub/pp/doc/t010.pdf}
{http://www.rbjones.com/rbjpub/pp/doc/t010.pdf}

$ $Id: t010.doc,v 1.14 2010/08/08 15:50:44 rbj Exp $ $

\bf Copyright \copyright\ : Roger Bishop Jones \\

\end{centering}

\newpage
\tableofcontents
\newpage
%%%%

{\raggedright
\bibliographystyle{fmu}
\bibliography{rbj,fmu}
} %\raggedright

\section{Introduction}

For context and motivation see \cite{rbjt000}.

Several structures are provided, each section below provides a signature and a structure matching the signature (though the code is not listed).

=SML
infix 4 AND_OR_T;
infix 4 AND_OR;
open_theory "basic_hol";
set_pc "basic_hol";
=TEX

To enable the use of square subset and three-bar equivalence (without the compliance tool) the following script is included:

=SML
val _ =	let open ReaderWriterSupport.PrettyNames;
	in add_new_symbols [ (["sqsubseteq2"], Value "√", Simple) ]
        end
handle _ => ();
val _ =	let open ReaderWriterSupport.PrettyNames;
	in add_new_symbols [ (["identical2"], Value "È", Simple) ]
        end
handle _ => ();
=TEX

\section{Sundry Tacticals etc.}

=DOC
signature €RbjTactics1› = sig
=DESCRIBE
A canon is provided for use with backchaining, and an elaboration of the backchaining facilities which is intended to solve certain kinds of goal by repeated backchaining.
=ENDDOC

=DOC
val €pc_canon›: string -> CANON -> CANON;
=DESCRIBE
Creates a CANON which executes in a specific proof context.
=ENDDOC

=DOC
val €rule_canon›: (THM -> THM) -> CANON;
=DESCRIBE
Converts a rule into a CANON which yeilds a singleton list containing the result of applying the rule to the argument of the CANON.
=ENDDOC

=DOC
val €¥_T_canon›: CANON;
=DESCRIBE
If in $asms Ù conc$, $conc$ is a universally quantified implication, then $¥\_T\_canon (asms Ù conc)$ is $[asms Ù conc]$, otherwise it is $[asms Ù conc ¥ T]$.
=ENDDOC

=DOC
val €§_FC_T›: (THM list -> TACTIC) -> THM -> TACTIC;
=DESCRIBE
For doing forward chaining using $fc\_§\_canon$.
=ENDDOC

=DOC
val €all_¥_intro_canon›: CANON;
=DESCRIBE
This is $rule\_canon$ $all\_¥\_intro$.
=SEEALSO
$rule\_canon$, $all\_¥\_intro$
=ENDDOC

=DOC
val €abc_canon›: CANON;
=DESCRIBE
A CANON for stripping theorems for backward chaining (used by $abc\_tac$ q.v.).
It removes universal quantifiers, splits conjunctions into two, undisharges implications repeatedly until these can no longer be done, then it discarges all the assumptions and closes the result.
=ENDDOC

=DOC
val €abc_tac›: THM list -> TACTIC;
val €asm_abc_tac›: THM list -> TACTIC;
=DESCRIBE
A backchaining tactic which preprocesses theorems using $abc\_canon$ and then repeatedly backchains, terminating only if the conclusion can be reduced to $T$ and discharged.
The $asm\_$ version uses the assumptions as rules or for reducing the conclusion to $T$.
=ENDDOC

=DOC
val €map_eq_sym_rule› : THM -> THM;
val €list_map_eq_sym_rule› : THM list -> THM list;
val €SYM_ASMS_T› : (THM list -> TACTIC) -> TACTIC;
=DESCRIBE
These are for turning round equations in order to use them for rewriting, when the equation is not at the top level.

$map\_eq\_sym\_rule$ turns round the equations in the conclusion of the theorem, wherever they occur.

$list\_map\_eq\_sym\_rule$ does the same thing to every one of a list of theorems.

$SYM\_ASMS\_T$ $thmltac$ applies $list\_map\_eq\_sym\_rule$ to the list of assumptions and then passes the result to $thmltac$.

=SEEALSO
$eq\_sym\_conv$, $eq\_sym\_rule$
=ENDDOC

=DOC
val €split_pair_conv› : TERM -> THM;
val €split_pair_rewrite_tac› : TERM list -> THM list -> TACTIC;
val €map_uncurry_conv› : CONV;
val €map_uncurry_rule› : THM -> THM;
=DESCRIBE
These facilities are to permit rewriting with the definition of or theorems about functions which take pairs as arguments, and are defined using paired abstraction or pattern matching on pairs.

$split\_pair\_conv$ $¨tmÆ$ yields the theorem $Ù tm = (Fst tm, Snd tm)$.

$split\_pair\_rewrite\_tac$, when supplied with a list of terms which have the type of ordered pairs, will expand each occurence of a term in the list to an explicit ordered pair using  $split\_pair\_conv$,
and will then apply $pure\_rewrite\_tac$ to the theorems.

$map\_uncurry\_conv$ takes a term and eliminates all occurences of $Uncurry$ in it by rewriting with the definition and beta reducing the result, and then eliminates all resulting terms of the form $(Fst tm, Snd tm)$ in favour of $tm$.

$map\_uncurry\_rule$ applies $map\_uncurry\_conv$ to the conclusion of a theorem.
The effect is to make a definition or theorem using pair patterns work for rewriting in cases where the argument is not supplied as an explicit pair, {\it provided that a paired abstraction was used in a universal quantification enclosing the equation}.
So if you want to formulate definitions and generalise them with this rule, use paired abstractions in the quantifiers.

=GFT Example
(concl o map_uncurry_rule) (asm_rule ¨µx y (v, w)∑ A (x,y) (v,w) = x=v ± y=wÆ);
val it = ¨µ x y p∑ A (x, y) p = x = Fst p ± y = Snd pÆ : TERM
=TEX
=ENDDOC


=DOC
val €rule_asm_tac› : TERM -> (THM -> THM) -> TACTIC;
val €rule_nth_asm_tac› : int -> (THM -> THM) -> TACTIC;
=DESCRIBE
For transforming assumptions in situ.

=GFT Definitions
fun rule_asm_tac term rule = DROP_ASM_T term (strip_asm_tac o rule);
fun rule_nth_asm_tac int rule = DROP_NTH_ASM_T int (strip_asm_tac o rule);
=TEX
=ENDDOC

=DOC
val €try› : ('a -> 'a) -> ('a -> 'a);
=DESCRIBE
Intended for application to rules, but more generally applicable, $try f a$ is $f a$ unless an exception is raised during its evaluation, in which case it is $a$.
=GFT Definition
fun €try› f a = f a handle _ => a;
=TEX
=ENDDOC

=DOC
val €Ø_top_anf_tac› : TACTIC;
=DESCRIBE
Convert real arithmetic subexpressions of the conclusion of the current goal to normal form.
=GFT Example
set_goal([], ¨µx y z:Ø∑ z = if x = y then (z +âR y) *âR x else x *âR (z -âR y)Æ);
a Ø_top_anf_tac;
(* *** Goal "" *** *)

(* ?Ù *)  ¨µ x y z∑ z = (if x = y then x *âR y +âR x *âR z else ~âR x *âR y +âR x *âR z)Æ
=TEX
=GFT Definition
val €Ø_top_anf_tac› = conv_tac (TOP_MAP_C Ø_anf_conv);
=TEX
=ENDDOC

=DOC
val €COND_CASES_T› : TERM -> THM_TACTIC -> TACTIC;
val €cond_cases_tac› : TERM -> TACTIC;
=DESCRIBE
A version of {\it CASES\_T} for use in rewriting conditional goals.
It does a case split assuming the term argument or its denial and then rewrites with that asssumption before applying the thm tactical argument.

A version of {\it cases\_tac} for use in rewriting conditional goals.
It does a case split assuming the argument or its denial and then rewrites with the un-stripped asssumption before stripping it into the assumptions. 
=GFT Example
set_goal([], ¨x +âR y +âR z = if x = y ± y = z then x *âR (ÓØ 3) else x +âR y +âR zÆ);
a (cond_cases_tac ¨x = y ± y = zÆ);
(* *** Goal "" *** *)

(*  2 *)  ¨x = yÆ
(*  1 *)  ¨y = zÆ

(* ?Ù *)  ¨z + z + z = z * 3.Æ
=TEX
=GFT Definition
fun €COND_CASES_T› x tt = CASES_T x (fn y => TRY (rewrite_tac [y]) THEN (tt y));
fun €cond_cases_tac› x = COND_CASES_T x strip_asm_tac;
=TEX
=ENDDOC

=SML
end; (* of signature RbjTactics1 *)
=TEX

=SML
structure €RbjTactics1› : RbjTactics1 = struct
=TEX

\ignore{
=SML
fun (€pc_canon›: string -> CANON -> CANON) string canon = strip_±_rule o (pc_rule string (list_±_intro o canon));

fun (€rule_canon›: (THM -> THM) -> CANON) rule thm = [rule thm];

fun (€¥_T_canon›:CANON) thm =
	if is_¥ ((snd o strip_µ) (concl thm))
	then [thm]
	else [¥_intro ¨TÆ thm];

fun €§_FC_T› tac thm = GET_ASMS_T (tac o (fc_rule (fc_§_canon thm)));

val €all_¥_intro_canon›: CANON = rule_canon all_¥_intro;

val €abc_canon› =
	REPEAT_CAN (
		simple_µ_rewrite_canon
		ORELSE_CAN (rule_canon undisch_rule)
		ORELSE_CAN ±_rewrite_canon)
	THEN_CAN all_¥_intro_canon
	THEN_CAN ¥_T_canon;

fun €abc_tac› thml =
	let val thms = flat (map abc_canon thml)
	in REPEAT (accept_tac t_thm ORELSE (bc_tac thms))
	end;

fun €asm_abc_tac› thml (asms, conc) =
	abc_tac (thml @ (map asm_rule asms)) (asms, conc);
=TEX
Some functions which turn round equations before using them.
=SML
fun €map_eq_sym_rule› thm = conv_rule (ONCE_MAP_C eq_sym_conv) thm;
fun €list_map_eq_sym_rule› thms = map (fn th => map_eq_sym_rule th handle _=> th) thms;
fun €SYM_ASMS_T› tltt = GET_ASMS_T (tltt o list_map_eq_sym_rule);
=TEX
For rewriting with definitions which abstract over pairs:

=SML
fun €split_pair_conv› t = prove_rule [] ¨ëtÆ = (Fst ëtÆ, Snd ëtÆ)Æ;
fun €split_pair_rewrite_tac› tl thms =
	pure_once_rewrite_tac (map split_pair_conv tl)
	THEN TRY (pure_rewrite_tac thms);

local	val uncurry_thm = tac_proof (
		([], ¨µf∑ Uncurry f = Ãp∑ f (Fst p) (Snd p)Æ),
		rewrite_tac [ext_thm, uncurry_def]);
	val pair_lemma = nth 2 (strip_±_rule pair_ops_def);
	val uc_conv = (simple_eq_match_conv1 uncurry_thm)
		THEN_C (Ã_C ((RATOR_C ¬_conv) THEN_C ¬_conv));
in
	val €map_uncurry_conv› = MAP_C uc_conv THEN_C pure_rewrite_conv [pair_lemma]
end;

val €map_uncurry_rule› = conv_rule map_uncurry_conv;

fun €rule_asm_tac term› rule = DROP_ASM_T term (strip_asm_tac o rule);
fun €rule_nth_asm_tac› int rule = DROP_NTH_ASM_T int (strip_asm_tac o rule);

fun €try› f a = f a handle _ => a;
=TEX
A tactic for normal form conversion of real expressions.
=SML
val €Ø_top_anf_tac› = conv_tac (TOP_MAP_C Ø_anf_conv);
=TEX
A case splitting tactic for conditional goals.
=SML
fun €COND_CASES_T› x tt = CASES_T x (fn y => TRY (rewrite_tac [y]) THEN (tt y));
fun €cond_cases_tac› x = COND_CASES_T x strip_asm_tac;
=TEX
}%ignore

=SML
end; (* of structure RbjTactics1 *)
=TEX

\section{Stripping With Failure}

=DOC
signature €StripFail› = sig
=DESCRIBE
This signature provides facilities for stripping assumptions which fail if the current goal remains unchanged.
This is so that tactics which generate new assumptions, e.g. $fc\_tac$ can be repeated until no new assumptions are generated.
=ENDDOC

=DOC
val €check_asm_tac1› : THM -> TACTIC;
=DESCRIBE
$check\_asm\_tac1$ is a similar to $check\_asm\_tac$ but will fail rather than leave the goal unchanged.

$check\_asm\_tac1\,thm$ checks the form of the theorem, $thm$,
and then takes the first applicable action from the following table:

{\centering
\begin{tabular}{|l|p{4in}|}\hline
$thm$ & action \\ \hline
$á Ù t$ & proves goal if its conclusion is $t$ \\ \hline
$á Ù T$ & as $fail\_tac$ \\ \hline
$á Ù F$ & proves goal\\ \hline
$á Ù ≥t$ & proves goal if $t$ in assumptions, fails if $≥t$ is in assumptions, else as $asm\_tac$\\ \hline
$á Ù t$ & proves goal if $≥t$ in assumptions, fails if $t$ is in assumptions, else as $asm\_tac$\\ \hline
\end{tabular}}

During the search through the assumptions in the last two cases,
$check\_asm\_tac1$ also checks to see whether any of the assumptions is
equal to the conclusion of the goal, and if so proves the goal.
It also checks to see if the conclusion of the theorem
is already an assumption, in which case the tactic fails.
When all the assumptions have been examined, if none of the
above actions is applicable, the conclusion of the theorem is
added to the assumption list.

=USES
Tactic programming.
=SEEALSO
$check\_asm\_tac$, $strip\_asm\_tac1$.
=ENDDOC

=DOC
val €strip_asm_tac1› : THM -> TACTIC;
=DESCRIBE
$strip\_asm\_tac1$ is a tactic for stripping down or otherwise transforming a theorem before adding it into the assumptions.

The transformations it undertakes are determined primarily by the current proof context which contains a conversion for stripping assumptions, but there are in addition a small number of effects which cannot be achieved by a conversion and are built into this tactic.

First the current stripping conversion will be applied repeatedly until it no longer applies.

Then the following simplification techniques will be tried.
Using $sat$ as an abbreviation for $strip\_asm\_tac$:
=GFT
sat (Ù a ± b) 			≠	sat (Ù a) THEN sat (Ù b)
sat (∂x∑a)			≠	sat (a[x'/x] Ù a[x'/x])
sat (Ù a ≤ b)({á} t)		≠	sat (a Ù a) ({á} t) ; sat (b Ù b) ({á} t)
=TEX

The effect is to break conjunctions into two separate theorems, to do a case split on disjunctions and to skolemise existentials.

After all of the available transformation techniques have been exhausted $strip\_asm\_tac$ then passes the theorems to $check\_asm\_tac1$ (q.v.) to discharge the goal or to generate additional assumptions.
=SEEALSO
$STRIP\_THM\_THEN$, used to implement this function.
$check\_asm\_tac1$, $strip\_tac$, $strip\-\_asm\-\_conv$.
=ENDDOC

=DOC
val €strip_asms_tac1› : THM list -> TACTIC;
=DESCRIBE
$strip\_asms\_tac1$ is a tactic for stripping down or otherwise transforming a list of theorems before adding them into the assumptions.

The effect is similar to applying $strip\_asm\_tac1$ to each of the theorems, except that it will fail only if every application of $strip\_asm\_tac1$ fails, i.e. if the total effect is null.

=SEEALSO
$STRIP\_THM\_THEN1$, used to implement this function.
$check\_asm\_tac1$, $strip\_tac$, $strip\-\_asm\-\_conv$.
=ENDDOC

=DOC
val €AND_OR_T› : TACTIC * TACTIC -> TACTIC;
val €AND_OR› : TACTIC * TACTIC -> TACTIC;
=DESCRIBE
$t1 THEN\_ORELSE\_T t2$ has the same effect as $((TRY t1) THEN t2) ORELSE t1$ but is faster.
$THEN\_ORELSE$ is an alias for $THEN\_ORELSE\_T$.
=SEEALSO
$THEN$, $ORELSE$, $TRY$
=ENDDOC

=DOC
val €±_THEN_T1› : (THM -> TACTIC) -> (THM -> TACTIC);
val €±_THEN1› : (THM -> TACTIC) -> (THM -> TACTIC);
=DESCRIBE
Similar in effect to $±\_THEN$ but will fail only if both the conjuncts fail.

A theorem tactical to apply a given theorem tactic to both conjuncts of 
a theorem of the form $á Ù t1 ± t2$.
=GFT
±_THEN1 thmtac (á Ù t1 ± t2) = thmtac (á Ù t1) AND_OR thmtac (á Ù t2)
=TEX
=SEEALSO
$±\_THEN$
=ENDDOC

=DOC
val €STRIP_THM_THEN1› : THM_TACTICAL;
=DESCRIBE
$STRIP\_THM\_THEN1$ provides a general purpose way of
stripping or transforming theorems before
using them in a tactic proof.
$STRIP\_THM\_THEN1$ attempts to apply
the conversion held for the function in the current proof context, which is
extracted by $current\_ad\_st\_conv$.
to rewrite the theorem.
If that fails it attempts to apply a theorem tactical from the following list (in order):
=GFT
±_THEN1,			≤_THEN,		SIMPLE_∂_THEN
=TEX
The conversion in the current proof context
got by $current\_ad\_st\_conv$ (q.v.)
is derived by applying $eqn\_cxt\_conv$ to an equational context in the proof context extracted by $get\_st\_eqn\_cxt$.

The function is partially evaluated with only the
theorem tactic and theorem arguments.
=SEEALSO
$STRIP\_THM\_THEN$
=ENDDOC

=DOC
val €SOME_T› : TACTIC list -> TACTIC;
=DESCRIBE
$SOME\_T$ is similar to $EVERY\_T$ except that it fails only if all the tactics fail.

$SOME\_T$ $tlist$ is a tactic that applies the head of $tlist$ to its subgoal, and
recursively applies the tail of $tlist$ to each resulting subgoal.
If any application of a tactic fails then the failure is ignored, but if no applications succeed then $SOME\_T$ will fail.

$SOME$ is NOT an alias for $SOME\_T$ (its a already a constructor).
$SOME$ $[]$ is equal to $fail\_tac$.
=EXAMPLE
=GFT
SOME [µ_tac, ±_tac, µ_tac] 
	is equivalent to
µ_tac AND_OR ±_tac AND_OR µ_tac
=TEX
=SEEALSO
$EVERY\_T$
=ENDDOC

=DOC
val €MAP_SOME_T› : ('a -> TACTIC) -> 'a list -> TACTIC;
val €MAP_SOME› : ('a -> TACTIC) -> 'a list -> TACTIC;
=DESCRIBE
$MAP\_SOME\_T$ is the same as $MAP\_EVERY\_T$ except that it will fail only if no resulting application of a tactic succeeds.

$MAP\_SOME\_T$ $mapf$ $alist$ maps $mapf$ over $alist$,
and then applies the resulting list of tactics to the goal
in sequence (in the same manner as $SOME$, q.v.).
$MAP\_SOME$ is an alias for $MAP\_SOME\_T$.
=SEEALSO
$MAP\_EVERY$
=ENDDOC

=SML
end; (* of signature StripFail *)
=TEX

=SML
structure StripFail : StripFail = struct
=TEX

\ignore{
=SML
fun €check_asm_tac1› (thm : THM) : TACTIC = (fn gl as (seqasms, conc) =>
	let	val t = concl thm;
	in	if t ~=$ conc
		then accept_tac thm
		else if is_t t
		then fail_tac
		else if is_f t
		then f_thm_tac thm
		else if is_≥ t
		then	let	val t' = dest_≥ t;
				fun aux (asm :: more) = (
					if t ~=$ asm
					then fail_tac
					else if asm ~=$ t'
					then accept_tac (≥_elim conc (asm_rule asm) thm)
					else if asm ~=$ conc
					then accept_tac (asm_rule asm)
					else aux more
				) | aux [] = asm_tac thm;
			in	aux seqasms
			end
		else	let	fun aux (asm :: more) = (
					if t ~=$ asm
					then fail_tac
					else if is_≥ asm andalso (dest_≥ asm) ~=$ t
					then accept_tac (≥_elim conc thm (asm_rule asm))
					else if asm ~=$ conc
					then accept_tac (asm_rule asm)
					else aux more
					) | aux [] = asm_tac thm;
			in	aux seqasms
			end
	end	gl
);
=TEX

=SML
fun ((tac1 : TACTIC) €AND_OR_T› (tac2 : TACTIC)) : TACTIC = (fn gl =>
	let	val (fok, (sgs1, pf)) = (true, tac1 gl) handle (Fail _) => (false, id_tac gl)
	in	let val (sgs2pfs2) = (map tac2 sgs1);
		in	(flat (map fst sgs2pfs2),
			pf o map_shape (map (fn (sgs, pf) => (pf, length sgs))sgs2pfs2))
		end handle (Fail _) =>
			if fok then (sgs1, pf) else fail_tac gl
	end
);
val op €AND_OR› = op AND_OR_T;
=TEX
=SML
fun €±_THEN_T1› (ttac : THM -> TACTIC) : THM -> TACTIC = (fn thm => 
	let	val thm1 = ±_left_elim thm;
		val thm2 = ±_right_elim thm;
	in	ttac thm1 AND_OR ttac thm2
	end
	handle ex => divert ex "±_left_elim" "±_THEN1" 28032 
		[fn () => string_of_thm thm]
);
val €±_THEN1› = ±_THEN_T1;
=TEX

=SML
val €STRIP_THM_THEN1› : THM_TACTICAL = (fn ttac:THM_TACTIC => 
	fn thm :THM =>
	(FIRST_TTCL[CONV_THEN (current_ad_st_conv()),
		±_THEN1, 
		≤_THEN, 
		SIMPLE_∂_THEN]
	ORELSE_TTCL
		FAIL_WITH_THEN "STRIP_THM_THEN1" 28003 
			[fn () => string_of_thm thm])
	ttac
	thm
);
=TEX
=SML
fun €SOME_T› (tacs : TACTIC list) :  TACTIC = (fn gl =>
	(fold (op AND_OR) tacs fail_tac) gl
);
=TEX
=SML
fun €MAP_SOME_T› (tacf : 'a -> TACTIC) (things : 'a list) : TACTIC = (
	SOME_T (map tacf things)
);
=TEX
=SML
val €MAP_SOME› : ('a -> TACTIC) -> 'a list -> TACTIC = MAP_SOME_T;
=TEX

=SML
val €strip_asm_tac1› = REPEAT_TTCL STRIP_THM_THEN1 check_asm_tac1;
val €strip_asms_tac1› = MAP_SOME strip_asm_tac1;
=TEX


}%ignore

=SML
end; (* of structure StripFail *)
=TEX

\section{Theories, Proof Contexts and Consistency}

=DOC
signature €PreConsisProof› = sig
=DESCRIBE
This signature provide the wherewithal to conduct a consistency proof for a HOL constant specification before introducing the specification, so that the specification can be seen to be consistent and will appear in the theory listing as if no consistency proof had been necessary.

The signature also provides some procedures to incorporate exception handling require when a document is required to create or to recreate a theory, and must therefore first delete things which are not necessarily present, similarly for proof contexts and other functions for manipulating proof contexts.
=ENDDOC

\subsection{Doing Consistency Proofs before Axiomatic Descriptions}

=DOC
val €save_cs_∂_thm› : THM -> unit;
=DESCRIBE
This function may be used to provide to the system a theorem which establishes the consistency of a HOL constant specification about to be introduced.

To avoid getting theory listings in which the definitions of some constants are given using $ConstSpec$ I like to do any necessary consistency proofs before introducing the constant specification which needs them.
For this to do any good, the automatic consistency prover has to know that I done it.

If used in conjunction with the partial proof context $'savedthm_cs_∂_conv$ the theorem will be used to establish the consistency of the specification avoid the need to place a consistency caveat on the stored form of the specification in the theory.
=SEEALSO
=ENDDOC

=DOC
(* Proof Context: €'savedthm_cs_∂_proof› *)
=DESCRIBE
This partial proof context contains only the existence prover $savedthm\_cs\_∂\_conv$ which attempts to ``prove'' the consistency of a specification by referring to a standard location in which the consistency theorem may have previously been saved.
=SEEALSO
$savedthm\_cs\_∂\_conv$, $save\_cs\_∂\_thm$
=ENDDOC

\subsection{Partial Primitive Recursive Definitions}


=DOC
val €evaluate_∂_cd_thm2› : THM ->
	(TERM list * int list * TYPE * (TERM list)list * THM);
=DESCRIBE
This is an adaptation of $evaluate\_∂\_cd\_thm$ to allow for functions defined over a part of a type by primitive recursion, i.e. for a partial function defined as a loose definition of a total function.
For this purpose the uniqueness property is not to be expected, though a weak analogue might be obtained.
The following documentation comes from the original, modified as necessary.

This gives the sophisticated user direct access to the standard internal mechanism
set by $pp'set\_eval\_ad\_∂\_cd\_thm$.
Its input theorem is of the ``standard'' form of a primitive recursion theorem or pattern matching theorem, except that the existential is not unique:
=GFT
µ fn1 fn2 ...∑ ∂f∑
(µ a11 ...∑ f (dc1[a11,...]) = fn1 (patt11[f,a11...]) (patt12[f,a11,...]) ...) ±
(µ a21 ...∑ f (dc2[a21,...]) = fn1 (patt21[f,a21...]) (patt22[f,a21,...]) ...) ±
...
=TEX
Compare this with:
=GFT
prim_rec_thm = Ù µ z s∑ ∂â1 f∑ (f 0 = z) ± (µ n∑ f (n + 1) = s (f n) n)  
=TEX
The uniqueness of the function $f$ is not required for consistency proofs, and in some cases may not be provable, so this variant is for use where the recursion theorem merely asserts existence rather than unique existence.

The $fn_i$ (in the example: $z$ and $s$) are the new functions which express the behaviour
of each data constructor.
$f$ ($f$) is the function defined by clausal definitions.
The $a_{ij}$ ($n$ in the second conjunct) are the free variables of the data construction.
The $dc_i$ ($n+1$ and $0$) are data constructions, as in the example given these do not need to be the original data constructors of a type, just applications of constants and variables.
The $patt_{ij}$ ($f\ n$, $n$) are the arguments to the new functions. 
They may involve uses of the clausally defined function.

The result of this function is:
the list of data constructions,
a list of free variable counts in each data construction,
the type of $f$,
a list of free variables in each data construction,
and a theorem of the form:
=GFT
Ù µ pred1 ...∑
(∂ f∑ (µ a11 ...∑ pred1 (dc1[...]) (patt1[...]) ..) ± ...) §
((µ x11 ... x1n∑ ∂ y1∑ pred1 y11 x11 ...) ± ...) ≤
(pp'TS(∂ f∑ (µ a11 ...∑ pred1 (dc1[...]) (patt1[...]) ..) ± ...))
=TEX
This is in a convenient form for proving the existence of
clausally defined functions, in particular
recursive functions within $basic\_prove\_∂\_conv$.
The $pred_i$, $x_{ij}$ and $y_i$ are generated by $gen\_vars$.
$pp'TS$ is an identity function, with defining theorem
in theory ``misc'' of key ``pp'ts$\_$def''.

This function uses the same error codes as the original, so error message 58007 will have the wrong text and should be understood as below.
=FAILURE
58007	?0 is not of the form: `Ù µ ...∑ ∂â1 f∑ ...`
58008	?0 has a conjunct not of the form: ¨µ ...∑ f dc = ...Æ
58009	?0 has a conjunct not of the form: ¨µ ...∑ f dc = ...Æ 
	where f is the function whose existence is to be proven
58021	Failed to prove new theorem based on ?0
58023	?0 has a conjunct not of the form: ¨µ ...P...∑ f dc = P ...Æ 
=ENDDOC


=DOC
val €∂_¥_conv› : CONV;
=DESCRIBE
Conversion that pushes an existential through an implication
where the bound variable is free in the antecedent:
=ENDDOC

=DOC
val €prove_∂_¥_conv› : CONV;
=DESCRIBE
Conversion to prove the result of applying the basic existence proving conversion to a conditional function definition using $∂\_¥\_conv$ to push the existential for the function value through the condition and then discarding the antecedent.
=ENDDOC

\subsection{Force New Theory}

=DOC
val €force_new_theory› : string -> unit;
=DESCRIBE
This is just to save the exception handling which otherwise has to appear at the top of every document which creates a \Product theory.

It deletes the old theory (if present, from your previous build, by using $force\_delete\_theory$) and all its children and starts the theory afresh.
=SEEALSO
$force\_delete\_theory$, $force\_new\_pc$
=ENDDOC

\subsection{Proof Contexts}

=DOC
val €force_new_pc› : string -> unit;
=DESCRIBE
This is just to save the exception handling which otherwise has to appear at the top of every document which creates a \Product proof context.

It deletes the old proof context (if present, from your previous build, using $delete\_pc$) and starts the proof context afresh.
=SEEALSO
$force\_new\_theory$, $delete\_pc$
=ENDDOC

=DOC
val €add_pc_thms› : string -> THM list -> unit;
val €add_pc_thms1› : string -> THM list -> unit;
=DESCRIBE
These function allows you to add theorems to a proof context.
{\it add\_pc\_thms} adds them for all three purposes (stripping conclusions and assumptions and rewriting).
{\it add\_pc\_thms1} omits assumption stripping.
=SEEALSO
$add\_rw\_thms$, $add\_sc\_thms$, $add\_st\_thms$
=ENDDOC

=SML
end; (* of signature PreConsisProof *)
=TEX

=SML
structure €PreConsisProof› : PreConsisProof = struct
=TEX

\subsection{Partial Primitive Recursive Definitions}

For each item of clausal definition material we hold:
\begin{enumerate}
\item
The list of data constructor recognisers.
These are the generic terms which must be matchable to the actual argument.
\item
The number of free variables there should be in the use of the constructor (e.g. 2 for $Cons$, 0 for $Nil$).
\item
An instance of the most general type of the function's argument.
\item
A list of dummy arguments for each ``constructor'', to allow dummy
conjuncts to be created.
\item
The actual theorem.
The theorem is an equation, whose LHS is of the form:
\begin{itemize}
\item
Universally quantify by one predicate per ``constructor'',
\item
Existentially quantify by function, $f$,
\item
one conjunct per constructor, in same order as predicates.
\item
Each conjunct will universally quantified in the order that
the the free variables of the subterm to which $f$ is first applied, that is a recognised argument by the data constructor
recogniser.
\item
The body of the conjunct will be the associated predicate
applied to each available use of $f$ and its arguments,
the first being the recognised argument.
\end{itemize}
 
\end{enumerate}

=SML
val lthy = get_current_theory_name ();
val _ = open_theory "basic_hol";
val _ = push_merge_pcs ["'propositions","'paired_abstractions"];
=TEX
To make certain functions independent of proof context changes we need to create a (temporary) build proof context equivalent
to the supplied ``predicates'', in the fields that matter.
As we have not commited the sources, we have to do this the hard way:
=SML
fun lget x = fst(hd x);
val _ = new_pc "build_predicates";
val _ = set_rw_eqn_cxt ((lget o get_rw_eqn_cxt) "'propositions" @
		(lget o get_rw_eqn_cxt) "'paired_abstractions")
		"build_predicates";
val _ = set_sc_eqn_cxt ((lget o get_sc_eqn_cxt) "'propositions" @
		(lget o get_sc_eqn_cxt) "'paired_abstractions")
		"build_predicates";
val _ = set_st_eqn_cxt ((lget o get_st_eqn_cxt) "'propositions" @
		(lget o get_st_eqn_cxt) "'paired_abstractions")
		"build_predicates";
val _ = set_rw_canons ((lget o get_rw_canons) "'propositions" @
		(lget o get_rw_canons) "'paired_abstractions")
		"build_predicates";
=TEX

Flatten a paired structure:
=SML
val €strip_pair› :TERM -> TERM list = strip_leaves dest_pair;
=TEX
Flatten a conjunction structure ($strip_±$ only flattens to the right):
=SML
val €full_strip_±› : TERM -> TERM list = strip_leaves dest_±;
=TEX

We wish to ``mark'' some terms, to prevent stripping going too far.
We use $pp'TS$ as a marker.

``mark'' a term:
=SML
local
	val ci = ¨pp'TS:BOOL ≠ BOOLÆ;
in
fun €mark› (tm:TERM):TERM = mk_app(ci,tm)
end;
=TEX

These are calculated from a clausal definition theorem by:
=SML
local
	val aux_thm = tac_proof(([],¨µ p q ∑ (p § (q ≤ pp'TS p)) § (q ¥ p)Æ),
		rewrite_tac[get_defn "misc" "pp'ts_def"] THEN
		REPEAT strip_tac);
	val stored_build_predicates_pc = pending_push_pc "build_predicates";
in
fun €evaluate_∂_cd_thm2› (thm : THM) = (
let	val (new_fns,ue) = strip_µ (concl thm);
	val all_nf = flat(map strip_pair new_fns);
	val (f,bdy) = dest_simple_∂â1 ue handle _ => dest_simple_∂ ue;
	val conjs = full_strip_± bdy;
	fun aux conj = (
	let	val (vs,bdy) = strip_µ conj;
		val (lhs,rhs) = dest_eq bdy;
		val (f',recog) = dest_app lhs;
		val sideeffect = if f =$ f'
			then ()
			else thm_fail "evaluate_∂_cd_thm" 58009 [thm];
		val (nf,args) = strip_app rhs;
		val sideeffect = if present (op =$) nf all_nf
			then ()
			else thm_fail "evaluate_∂_cd_thm" 58023 [thm];
	in
		(recog, (lhs :: args), nf)
	end);
	val proc_conjs = map aux conjs;
	val preds = gen_vars (BOOL :: (map (fn (_,xs,_) => 
		list_mk_≠_type(map type_of xs @ [BOOL]))
		proc_conjs))
 		[concl thm];
	val other_pred = hd preds;
	val preds' = tl preds;
	val preds_conjs = combine preds' proc_conjs;
	val tm1 = list_mk_±(map (fn (pred,(recog,args,_)) => 
		list_mk_simple_µ(rev(frees recog),
			list_mk_app(pred,args)))
		preds_conjs
		@ [other_pred]);
	val tm2 = mk_simple_∂(f, tm1);
	fun aux1 (pred,(recog,args,_)) = (
	let	val gvs = gen_vars (map type_of args) (pred :: args);
	in
		list_mk_simple_µ(tl gvs,
			mk_simple_∂(hd gvs,
			list_mk_app(pred, gvs)))
	end);
	val tm3 = list_mk_±((map aux1 preds_conjs) @ [other_pred]);
	val tm4 = mk_≤(tm3, mark tm2);
	val tm5 = list_mk_simple_µ(preds' @ [other_pred],
		mk_eq(tm2,tm4));
	fun mk_spec (pred,(recog,args,_)) = (
	let	val gvs_args = gen_vars(map type_of args)[pred];
	in
		list_mk_simple_Ã(tl gvs_args,
		mk_≈(hd gvs_args,
		list_mk_app(pred,gvs_args)))
	end);
	val thm_specs = map (fn bdr =>
		mk_spec(find preds_conjs (fn (_,(_,_,abdr)) => bdr =$ abdr)))
		new_fns;
=TEX
Now prove the theorem whose conclusion we have just generated.
Do this in the (temporary) proof context ``build$\_$predicates'', not the current one.
=SML
	val dummy = stored_build_predicates_pc();
	val cd_thm = tac_proof((asms thm,tm5),
		pure_rewrite_tac[aux_thm] THEN
		REPEAT µ_tac THEN
		¥_T(fn athm => MAP_EVERY_T asm_tac (strip_±_rule athm)) THEN
		strip_asm_tac (list_simple_µ_elim thm_specs thm) THEN
		simple_∂_tac f THEN asm_rewrite_tac[] THEN
		REPEAT (±_tac ORELSE_T simple_µ_tac) THEN
		(fn (seqasms,gl) =>
		(let val (pred,args) = strip_app gl;
		in
		DROP_ASM_T (find seqasms (fn asm =>
			let val (_,bdy) = strip_µ asm;
				val (_,bdy') = dest_simple_∂ bdy;
				val (pred',_) = strip_app bdy'
			in
				pred =$ pred'
			end
			handle Fail _ => false))
			(rewrite_thm_tac o ∂_≈_rule o
			list_simple_µ_elim(tl args))
		end) (seqasms,gl)))
		handle complaint =>
		(pop_pc();
		raise complaint); 
	val dummy = pop_pc();
	val recogs = map (fn (x,_,_) => x) proc_conjs;
	val nfrees_recogs = map (length o frees) recogs;
	val gen_f = type_of f;
	val dummies = map (rev o frees) recogs;
in
	(recogs, nfrees_recogs, gen_f, dummies, cd_thm)
end
handle complaint =>
list_divert complaint "evaluate_∂_cd_thm" 
	[("dest_simple_∂â1",58007,[fn () => string_of_thm thm]),
	("dest_app",58008,[fn () => string_of_thm thm]),
	("dest_eq",58008,[fn () => string_of_thm thm]),
	("tac_proof",58021,[fn () => string_of_thm thm])
	]
);
end;
=TEX

=SML
val _ = pp'set_eval_ad_∂_cd_thms (map evaluate_∂_cd_thm2);
val _ = delete_pc "build_predicates";
val _ = pop_pc();
val _ = open_theory lthy;
=TEX

Conversion (written by rda) that pushes an existential through an implication
where the bound variable is free in the antecedent:

=SML
val €∂_¥_conv› : CONV = (
	let	val €∂_¥_lemma› = prove_rule[]
			¨µp q∑ (∂f∑q ¥ p f) § (q ¥ ∂f∑p f)Æ;
	in	fn tm =>
		let	val (f, b) = dest_simple_∂ tm;
			val (q, pf) = dest_¥ b;
			val p = mk_simple_Ã(f, pf);
			val thm1 = list_µ_elim[p, q] ∂_¥_lemma;
			val thm2 = conv_rule(LEFT_C(BINDER_C (RIGHT_C ¬_conv))) thm1;
			val thm3 = conv_rule(RIGHT_C(RIGHT_C(BINDER_C ¬_conv))) thm2;
			val thm4 = simple_eq_match_conv thm3 tm;
		in	thm4
		end
	end
);
=TEX

Conversion (written by rda) to prove the result of applying the basic existence proving conversion to a conditional function definition using the above conversion to push the existential for the function value through the condition and then discarding the antecedent.

=SML
val €prove_∂_¥_conv› : CONV = (fn tm =>
	let	val thm1 = tac_proof (([], tm),
				REPEAT strip_tac
			THEN	conv_tac ∂_¥_conv
			THEN	¥_T discard_tac
			THEN	conv_tac basic_prove_∂_conv);
		val thm2 = §_t_intro thm1;
	in	thm2
	end
);
=TEX

\ignore{
=SML
fun €force_new_theory› name =
  let val _ = force_delete_theory name handle _ => ();
  in new_theory name
end;
=TEX

=SML
fun €force_new_pc› name =
  let val _ = delete_pc name handle _ => ();
  in new_pc name
end;
=TEX

=SML
fun €add_pc_thms› pc thms =
		(add_rw_thms thms pc;
		add_sc_thms thms pc;
 		add_st_thms thms pc);
=TEX

=SML
fun €add_pc_thms1› pc thms =
		(add_rw_thms thms pc;
		add_sc_thms thms pc);
=TEX
}

A new value of type $ref THM$ called $saved\_cs\_∂\_thm$ is used to store consistency results.

=SML
val saved_cs_∂_thm = ref t_thm;
=TEX

=SML
fun save_cs_∂_thm thm = (saved_cs_∂_thm := thm);
=TEX

I also have a special partial proof context with a consistency prover which knows to look for the consistency proof in this special place.
This is the consistency prover:

=SML
fun €savedthm_cs_∂_conv› x =
	if x =$ (concl(!saved_cs_∂_thm))
	then (§_t_intro (!saved_cs_∂_thm)) handle _ => (* eq_ *) refl_conv x
	else (* eq_ *) refl_conv x;
=TEX

and here's the proof context containing it:


Store the above in a proof context:

=SML
val _ = force_new_pc €"'prove_∂_¥_conv"›;
val _ = set_cs_∂_convs [prove_∂_¥_conv] "'prove_∂_¥_conv";
val _ = commit_pc "'prove_∂_¥_conv";
=TEX

=SML
val _ = force_new_pc €"'savedthm_cs_∂_proof"›;
val _ = set_cs_∂_convs [prove_∂_¥_conv, savedthm_cs_∂_conv] "'savedthm_cs_∂_proof";
val _ = set_pr_conv basic_prove_conv "'savedthm_cs_∂_proof";
val _ = set_pr_tac basic_prove_tac "'savedthm_cs_∂_proof";
val _ = commit_pc "'savedthm_cs_∂_proof";
=IGN
current_ad_cs_∂_conv();
=TEX

=SML
end; (* of structure PreConsisProof *)
=TEX

\section{Unifying Forward Chaining}

\subsection{Specifications}

=DOC
signature €UnifyForwardChain› = sig
=DESCRIBE
This is the signature of facilities for forward chaining based on unification rather than matching.
=ENDDOC

=DOC
val €simple_¥_unify_mp_rule1› : THM -> THM -> THM ;
=DESCRIBE
A unifying Modus Ponens rule for an implicative theorem.
=FRULE 1 Rule
¥_unify_mp_rule1
˜
á1 Ù µ x1 ...∑ t1 ¥ t2;
á2 Ù µ y1 ...∑ t1'
˜
á1 ¿ á2 Ù µ z1 ...∑ t2'
=TEX
where $t1'$ is unifiable with $t1$.
Type instantiation and substitution is permitted for the $xâi$ in $t1$, the and $yâi$ in $t1'$ and instantiation of the type variables in $t1$ which do not occur in á1 and those in $t1'$ which do not occur in á2.
$t2'$ is obtained from $t2$ by applying to it the substitution to $t1$ required for its unification.
The $zâi$ will be the variables free in t2' which were not previously free either in $t2$ or $t1'$.
No type instantiation or substitution will occur in the assumptions of either theorem.

Pairs are not supported in the bindings.
=FAILURE
7044	Cannot match ?0 and ?1
7045	?0 is not of the form `á Ù µ x1 ... xn ∑ u ¥ v`
=ENDDOC

=DOC
val €¥_unify_mp_rule1› : THM -> THM -> THM ;
=DESCRIBE
A matching Modus Ponens rule for an implicative theorem, supporting paired abstraction.
=FRULE 1 Rule
¥_unify_mp_rule1
˜
á1 Ù µ x1 ...∑ t1 ¥ t2;
á2 Ù µ y1 ...∑ t1'
˜
á1 ¿ á2 Ù µ z1 ...∑ t2'
=TEX
where $t1'$ is unifiable with $t1$.
Type instantiation and substitution is permitted for the $xâi$ in $t1$, the and $yâi$ in $t1'$ and instantiation of the type variables in $t1$ which do not occur in á1 and those in $t1'$ which do not occur in á2.
$t2'$ is obtained from $t2$ by applying to it the substitution to $t1$ required for its unification.
The $zâi$ will be the variables free in t2' which were not previously free either in $t2$ or $t1'$.
No type instantiation or substitution will occur in the assumptions of either theorem.

Pairs are supported in the bindings.
=FAILURE
7044	Cannot match ?0 and ?1
7045	?0 is not of the form `á Ù µ x1 ... xn ∑ u ¥ v`
=ENDDOC

=DOC
val €unify_forward_chain_rule› : THM list -> THM list -> THM list;
val €ufc_rule› : THM list -> THM list -> THM list;
=DESCRIBE
This is a rule which uses a list of possibly universally
quantified implications and a list of
other theorems to infer new theorems, using
=INLINEFT
¥_unify_mp_rule1
. (
=INLINEFT
ufc_rule
=TEX
\ is an alias for
=INLINEFT
unify_forward_chain_rule
=TEX
.)
=INLINEFT
ufc_rule imps ants
=TEX
\ returns the list of all theorems which may be derived by
applying
=INLINEFT
¥_unify_mp_rule1
=TEX
\ to a theorem from $imps$ and one from $ants$.
As a special case, if any theorem to be returned is determined
to have $¨FÆ$ as its conclusion, the first such found wil be returned as a singleton list.
In order to work well in conjunction with
=INLINEFT
fc_canon
=TEX
\ and
=INLINEFT
ufc_tac
=TEX
\ the theorems returned by
=INLINEFT
¥_unify_mp_rule1
=TEX
\ are transformed as follows:

\begin{enumerate}
\item
Theorems of the form:
=INLINEFT
Ù µ xâ1 ...∑ tâ1 ¥ tâ2 ¥ ... ¥ ≥tâk ¥ F
=TEX
\ have their final implication changed to
=INLINEFT
tâk
=TEX
.
\item
Theorems of the form:
=INLINEFT
Ù µ xâ1 ...∑ tâ1 ¥ tâ2 ¥ ... ¥ tâk ¥ F
=TEX
\ have their final implication changed to
=INLINEFT
¥\≥tâk
=TEX
.
\item
All theorems are universally quantified over all the variables which
appear free in their conclusions but not in their assumptions
(using
=INLINEFT
all_µ_intro
=TEX
).
\end{enumerate}
Note that the use of
=INLINEFT
¥_unify_mp_rule1
=TEX
\ gives some control over the number of results generated, since
variables which appear free in $imps$ are not considered as candidates
for instantiation.

The rule does not check that the theorems in its first argument
are (possible universally) quantified implications.
Theorems which are not of this form will be ignored.
=SEEALSO
$unify\_forward\_chain\_tac$, $forward\_chain\_canon$.
=ENDDOC

=DOC
val €UFC_T1› :
	(THM -> THM list) -> (THM list -> TACTIC) -> THM list -> TACTIC;
val €ALL_UFC_T1› :
	(THM -> THM list) -> (THM list -> TACTIC) -> THM list -> TACTIC;
val €ASM_UFC_T1› : 
	(THM -> THM list) -> (THM list -> TACTIC) -> THM list -> TACTIC;
val €ALL_ASM_UFC_T1› : 
	(THM -> THM list) -> (THM list -> TACTIC) -> THM list -> TACTIC;
=DESCRIBE
These are tacticals which use theorems whose conclusions are
implications, or from which implications can be derived,
to reason forwards from the assumptions of a goal.

The description of 
=INLINEFT
ufc_tac
=TEX
\ should be consulted for the basic forward chaining algorithms used.
The significance of the final argument and of the presence or absence of
=INLINEFT
ASM
=TEX
\ and
=INLINEFT
ALL
=TEX
\ in the name is exactly as for
=INLINEFT
fc_tac
=TEX
\ and its relatives.

The tacticals allow variation of the canonicalisation function
used to obtain implications from the argument theorems and of
the tactic generating function used to process the theorems derived
by the forward inference.
The canonicalisation function to use is the first argument
and the tactic generating function is the second.
(Related tacticals with names ending in
=INLINEFT
T
=TEX
\ rather than
=INLINEFT
T1
=TEX
\ are also available for the simpler case when
wants to use the same canonicalisation function as
=INLINEFT
fc_tac
=TEX
\ and just to vary the tactic generating function.)

\paragraph{Examples}

If the theorem argument comprises only implications
which are to be used without canonicalisation, one might use:
=INLINEFT
UFC_T1 id_canon (MAP_SOME strip_asm_tac)
=TEX
.

If one has an instance of $t1$ as an assumption and one wishes to
use the bi-implication in a theorem of the form
=INLINEFT
Ù t1 ¥ (t2 § t3)
=TEX
\ for rewriting, one might use
=INLINEFT
UFC_T1 id_canon rewrite_tac
=TEX
.

=SEEALSO
$ufc\_tac$, $asm\_ufc\_tac$, $bc\_tac$, $UFC\_T$.
=ENDDOC

=DOC
val €UFC_T› :
	(THM list -> TACTIC) -> THM list -> TACTIC;
val €ALL_UFC_T› :
	(THM list -> TACTIC) -> THM list -> TACTIC;
val €ASM_UFC_T› :
	(THM list -> TACTIC) -> THM list -> TACTIC;
val €ALL_ASM_UFC_T› :
	(THM list -> TACTIC) -> THM list -> TACTIC;
val €ALL_UFC_§_T› :
	(THM list -> TACTIC) -> THM list -> TACTIC;
val €ALL_ASM_UFC_§_T› :
	(THM list -> TACTIC) -> THM list -> TACTIC;
=DESCRIBE
These are tacticals which use theorems whose conclusions are
implications, or from which implications can be derived,
to reason forwards from the assumptions of a goal.
(The tacticals with
=INLINEFT
UFC
=TEX
\ are aliases for the corresponding ones with
=INLINEFT
UNIFY_FORWARD_CHAIN
=TEX
.)

The description of 
=INLINEFT
ufc_tac
=TEX
\ should be consulted for the basic forward chaining algorithms used.
The significance of the final argument and of the presence or absence of
=INLINEFT
ASM
=TEX
\ and
=INLINEFT
ALL
=TEX
\ in the name is exactly as for
=INLINEFT
ufc_tac
=TEX
\ and its relatives.

The tacticals allow variation of
the tactic generating function used to process the theorems derived
by the forward inference.
The tactic generating function to be used is given as the first
argument.

\paragraph{Examples}
=INLINEFT
ufc_tac
=TEX
\ is the same as:
=INLINEFT
UFC_T strip_asm_tac1
=TEX
.

To rewrite the goal with the results of the forward inference one
could use
=INLINEFT
UFC_T rewrite_tac
=TEX
.
=SEEALSO
$ufc\_tac$, $asm\_ufc\_tac$, $UFC\_T1$.
=ENDDOC

=DOC
val €ufc_tac› : THM list -> TACTIC;
val €all_ufc_tac› : THM list -> TACTIC;
val €asm_ufc_tac› : THM list -> TACTIC;
val €all_asm_ufc_tac› : THM list -> TACTIC;
val €all_ufc_§_tac› : THM list -> TACTIC;
val €all_asm_ufc_§_tac› : THM list -> TACTIC;
val €all_ufc_§_rewrite_tac› : THM list -> TACTIC;
val €all_asm_ufc_§_rewrite_tac› : THM list -> TACTIC;
=DESCRIBE
These are tactics which use theorems whose conclusions are
implications, or from which implications can be derived using
the canonicalisation function
=INLINEFT
fc_canon
=TEX
, q.v., to reason forwards from the assumptions of a goal.

The basic step is to take a theorem of the form
=INLINEFT
á Ù t1 ¥ t2
=TEX
\ and an assumption of the form
=INLINEFT
t1'
=TEX
\ where $t1'$ is unifiable with $t1$ and to deduce the
corresponding instance of $t2'$. The new theorem,
=INLINEFT
Ñ Ù t2'
=TEX
\ say, may then be stripped into the assumptions.

In the case of
=INLINEFT
ufc_tac
=TEX
\ the implicative theorem is always derived from the list
of theorems given as an argument.
In the case of
=INLINEFT
asm_ufc_tac
=TEX
\ the assumptions are also used.
In all of the tactics the rule 
=INLINEFT
fc_canon
=TEX
\ is used to derive an implicative canonical form from the
candidate implicative theorems.
Normally combination of an implicative theorem and an assumption
is then tried in turn and all resulting theorems are stripped into
the assumptions of the goal.
However, if the chaining results contain a theorem whose conclusion is ¨FÆ then the first such found will be stripped
into the assumptions, and all other theorems discarded.

If one of the implications has the form
=INLINEFT
t1 ¥ t2 ¥ t3
=TEX
\ or
=INLINEFT
t1 ± t2 ¥ t3
=TEX
\ and if assumptions matching $t1$ and $t2$ are available,
=INLINEFT
ufc_tac
=TEX
\ or
=INLINEFT
asm_ufc_tac
=TEX
\ will derive an intermediate implication
=INLINEFT
t2 ¥ t3
=TEX
\ and
=INLINEFT
asm_ufc_tac
=TEX
\ could then be used to derive $t3$.
The variants with $all\_$ may be used to derive $t3$ directly without
generating any intermediate implications in the assumptions.
They work like the corresponding tactic without $all\_$ but any theorems
which are derived which are themselves implications are not stripped into
the assumptions but instead are used recursively to derive further theorems.
When no new implications are derivable all of the non-implicative theorems
derived during the process are stripped into the assumptions.

Note that the use of
=INLINEFT
fc_canon
=TEX
\ implies that conversions from the
proof context are applied to generate implications.
E.g., in an appropriate proof-context covering set theory,
=INLINEFT
a Ä b
=TEX
\ might be treated as the implication
=INLINEFT
µx∑x ç a ¥ x ç b
=TEX
.
Also variables which appear free in a theorem are not considered as candidates
for instantiation
(in order to give some control over the number of results generated).
The tacticals,
=INLINEFT
UFC_T1
=TEX
\ and 
=INLINEFT
ASM_UFC_T1
=TEX
\ may be used to avoid the use of
=INLINEFT
fc_canon
=TEX
.

For example, the tactic:
=GFT
asm_ufc_tac[] THEN asm_ufc_tac[]
=TEX
will prove the goal:
=GFT
{p x, µx∑p x ¥ q x, µx∑q x ¥ r x} r x.
=TEX

The variants with $§$ in the name use $fc_§_canon$ instead of $fc_canon$ for processing the rules so that a concluding equivalence is not broken into implications and the results of forward chaining can be used for rewriting (however, this still won't work unless there are outer quantifiers to prevent the equivalence from being broken up when stripped into the assumptions).

All of these tactics add the results into the assumptions using $strip_asms_tac1$ and therefore fail if no new assumptions are added (unless the goal is discharged), except the ones whose name includes $rewrite$ which attempt the rewrite the conclusion of the goal with the results instead of stripping them into the assumptions.

=SEEALSO
$bc\_tac$,
$UFC\_T$,
$ASM\_UFC\_T$,
$UFC\_T1$,
$ASM\_UFC\_T1$.
=ENDDOC

=SML
end; (* of signature UnifyForwardChain *)
=TEX

\subsection{Implementation}

=SML
structure €UnifyForwardChain› : UnifyForwardChain = struct
=TEX

\ignore{
=SML
val €was_theory› = get_current_theory_name ();
val _ = open_theory "basic_hol";
val _ = set_merge_pcs ["'propositions", "'simple_abstractions"];
=TEX
}%ignore

In $unify\_¥\_mp_rule$ the two theorems will be unified as necessary to permit inference by modus ponens.
Only variables universally quantified at the outer level will be candidates for instantiation, and in each of the premises only type variables which do not appear in the assumptions will be elegible for instantiation.
The two theorems are stripped of their outer universal quantifiers and the antecedent of the first (which must be an implication) will also be stripped of universal quantifiers and will then be unified with the second (without permitting substitution for the quanitifiers on the antecedent).
If this suceeds the consequent is inferred (after adding quantifiers as necessary to the second theorem and instantiating the quantifiers as necessary in the first theorem).
Then any variables which are free in the result but were previously bound are rebound.

\ignore{

=SML
open Resolution; open Unification; open StripFail; open RbjTactics1

fun €simple_¥_unify_mp_rule1› ith ath =
 let	val s1 = ¥_elim ith ath;
 in
	s1
 end handle (Fail _) =>
	let
	val (iasms, iconc) = dest_thm ith;
	val (aasms, aconc) = dest_thm ath;
	fun ttys t =  map mk_vartype (term_tyvars t);
	fun ittys (asms, conc) =  (ttys conc) drop
		(fn x => present (op =:) x (list_union (op =:) (map ttys asms)));
	val iityvs = ittys (iasms, iconc);
	val aityvs = ittys (aasms, aconc);
	val (ivars, barei) = strip_µ iconc;
	val (avars, barea) = strip_µ aconc;
	val (ai, c) = dest_¥ barei;
	val (aivars, bareai) = strip_µ ai;
	val subs = new_subs 40;
	val ((ityi, ites) , (atyi, ates)) =
		term_unify subs [] [] (
			(bareai, ivars, iityvs),
			(barea, avars, aityvs));
	val _ = init_subs subs;
	fun laux [] t = t
	|   laux ((nt1, t1)::tl) t = if t1 =$ t then nt1 else laux tl t;
	val ites2 = map (laux ites) ivars;
	val ates2 = map (laux ates) avars;
	val ni = list_µ_elim ites2 (inst_type_rule ityi ith);
	val na = list_µ_elim ates2 (inst_type_rule atyi ath);
	val naithm = list_µ_intro aivars na;
	val othm = ¥_elim ni naithm;
	val ccfrees = frees (concl othm);
	val cafrees = list_union (op =$) (map frees (asms othm));
	val bindvars = ccfrees drop (fn x => (present (op =$) x cafrees))
	in (list_µ_intro bindvars othm)
end;
=IGN
simple_¥_unify_mp_rule1 (asm_rule ¨a ¥ bÆ) (asm_rule ¨a:BOOLÆ);
simple_¥_unify_mp_rule1 (asm_rule ¨µx v∑ ((Ãz∑z)x, v) = y ¥ xÆ) (asm_rule ¨µa b∑ ((Ãq∑q)a:BOOL, b)=yÆ);
simple_¥_unify_mp_rule1 (asm_rule ¨µ (y:'a) (x:'a) ($<<:'a≠'a≠BOOL) (X:'a SET)∑
				Snd (TranClsr (X, $<<)) x y ¥ ≥ x ç X ¥ FÆ)
		 (asm_rule ¨Snd (TranClsr (X:'a SET, $<<:'a≠'a≠BOOL)) (x'':'a) (x':'a):BOOLÆ);
simple_¥_unify_mp_rule1 (asm_rule ¨µx y (X:'a SET)∑ x ç X ¥ y ç X ¥ {x; y} ç  XÆ)
	(asm_rule ¨(y:'a) ç XÆ);
simple_¥_unify_mp_rule1 (hd(fc_canon (asm_rule ¨µ A:'a SET
           ∑ (µ x:'a∑ x ç A ¥ x ç X) ± ≥ (µ x:'a∑ ≥ x ç A)
               ¥ (∂ x:'a∑ x ç A ± (µ y:'a∑ y ç A ± ≥ y = x ¥ ≥ y << x))Æ)))
	(asm_rule ¨µ x:'a∑ x ç A ¥ x ç XÆ);
simple_¥_unify_mp_rule1 (hd(fc_canon (asm_rule ¨µ (G: ('a≠'b)≠('a≠'b)) (X:'a SET) ($<<: 'a≠'a≠BOOL)
     ∑ FunctRespects G (X, $<<)
         = (µ g h x
         ∑ x ç X ¥ (µ y∑ y ç X ± y << x ¥ g y = h y) ¥ G g x = G h x)Æ)))
	(asm_rule ¨µ (G: ('a≠'b)≠('a≠'b)) (X:'a SET) ($<<: 'a≠'a≠BOOL)∑
		FunctRespects G (X, $<<):BOOLÆ);
=SML
val €all_µ_uncurry_rule› = conv_rule(TRY_C all_µ_uncurry_conv);

fun €¥_unify_mp_rule1› (thm1 : THM) : THM -> THM = (
let	val thm1' = all_µ_uncurry_rule thm1;
	val r' = simple_¥_unify_mp_rule1 thm1'
		handle complaint =>
		pass_on complaint "simple_¥_unify_mp_rule1"
			"¥_unify_mp_rule1";
in
	(fn (thm2 : THM) =>
	r' thm2
	handle complaint => reraise complaint "¥_unify_mp_rule1")
end);
=IGN
¥_unify_mp_rule1 (asm_rule ¨µ(x, y):Ó ∏ Ó∑ y = x * x ¥ y æ 0 ± qÆ) (asm_rule ¨µv w q:Ó∑ v = w * wÆ);
¥_unify_mp_rule1 (asm_rule ¨µ(x, y):Ó ∏ Ó∑ y = x * x ¥ y æ 0 ± qÆ) (asm_rule ¨µv w q:Ó∑ v = w * wÆ);
¥_unify_mp_rule1 (asm_rule ¨µ y x $<< X∑ Snd (TranClsr (X, $<<)) x y ¥ ≥ x ç X ¥ FÆ)
		 (asm_rule ¨Snd (TranClsr (X, $<<)) x'' x'Æ);
¥_unify_mp_rule1 ((hd o fc_canon o asm_rule) ¨µ X $<< G (x:'a)
           ∑ x ç X ± UniquePartFixp (TcUpTo (X, $<<) x) G
               ¥ (µ f∑ PartFunEquiv (TcUpTo (X, $<<) x) (G f) f ¥ UniqueVal (X, $<<) G x = f x)Æ)
	(asm_rule ¨x'' ç (X:'a SET)Æ);
¥_unify_mp_rule1 (asm_rule ¨µ(x, y) (X:'a SET)∑ x ç X ¥ y ç X ¥ {x; y} ç  XÆ)
	(asm_rule ¨(y:'a) ç XÆ);
¥_unify_mp_rule1 (hd(fc_canon (asm_rule ¨µ A
           ∑ (µ x∑ x ç A ¥ x ç X) ± ≥ (µ x∑ ≥ x ç A)
               ¥ (∂ x∑ x ç A ± (µ y∑ y ç A ± ≥ y = x ¥ ≥ y << x))Æ)))
	(asm_rule ¨µ x∑ x ç A ¥ x ç XÆ);
=SML
local
val €≥_convs› = map
	(fn t => simple_eq_match_conv1
		(all_µ_intro (tac_proof(([], t), simple_taut_tac))))
	[¨≥t ¥ F § tÆ, ¨t ¥ F § ≥tÆ];
in
fun €unify_forward_chain_rule› (imps : THM list) (ants : THM list) : THM list = (
let	val imp_rules = mapfilter ¥_unify_mp_rule1 imps;
	fun aux1 acc _ [] = (acc
	) | aux1 acc (i :: il) (al as (a :: _)) = (
		(let val res = i a
		in
		if concl res =$ mk_f
		then [res]
		else
		(aux1 (res::acc) il al)
		end)
		handle Fail _ => aux1 acc il al
	) | aux1 acc [] (_ :: al) = (aux1 acc imp_rules al
	);
	fun aux2 thm = (
		case dest_term (concl thm) of
			Dµ (x, b) => (
				let val th = aux2 (asm_rule b);
				in µ_intro x (prove_asm_rule (µ_elim x thm) th)
				end
		) |	D¥ (a, b) => (
				(conv_rule(FIRST_C ≥_convs) thm)
				handle Fail _ =>
				let val th = aux2 (asm_rule b);
				in ¥_intro a (prove_asm_rule(undisch_rule thm) th)
				end
		) |	_ => fail "" 99999 []
	);
	fun aux3 th = aux2 th handle Fail _ => th;
in	map aux3 (aux1 [] imp_rules ants)
end);
end;

val €ufc_rule› : THM list -> THM list -> THM list = unify_forward_chain_rule;

=IGN
ufc_rule [(asm_rule ¨µ(x, y):Ó ∏ Ó∑ y = x * x ¥ y æ 0 ± qÆ)] [(asm_rule ¨µv w q:Ó∑ v = w * wÆ)];
ufc_rule [(asm_rule ¨µ y x $<< X∑ Snd (TranClsr (X, $<<)) x y ¥ x ç XÆ)]
		 [(asm_rule ¨Snd (TranClsr (X, $<<)) x'' x'Æ)];
ufc_rule [asm_rule¨µ X $<< G x
           ∑ x ç X ± UniquePartFixp (TcUpTo (X, $<<) x) G
               ¥ (µ f∑ PartFunEquiv (TcUpTo (X, $<<) x) (G f) f ¥ UniqueVal (X, $<<) G x = f x)Æ]
	[asm_rule ¨x'' ç XÆ,
	asm_rule ¨UniquePartFixp (TcUpTo (X, $<<) x'') GÆ];
ufc_rule [(asm_rule ¨µ(x, y) (X:'a SET)∑ x ç X ¥ y ç X ¥ {x; y} ç  XÆ)]
	[asm_rule ¨(y:'a) ç XÆ];
ufc_rule [(asm_rule ¨µ(x:'a, y:'b) (X:'a SET) (Y:'b SET)∑ x ç X ¥ y ç Y ¥ {x, y} ç  (X ∏ Y)Æ)]
	[asm_rule ¨(y:'b) ç XÆ];
ufc_rule [tac_proof (([], ¨µ(x:'a, y:'b) (X:'a SET) (Y:'b SET)∑ x ç X ¥ y ç Y ¥ {x, y} ç  (X ∏ Y)Æ),
	(REPEAT strip_tac
	THEN asm_rewrite_tac[sets_ext_clauses, get_spec ¨$∏Æ]
	THEN REPEAT strip_tac THEN asm_rewrite_tac[]))]
	[asm_rule ¨(y:'b) ç XÆ];
ufc_rule [(asm_rule ¨µ(X:'a SET) (x:'a)∑ x ç X ¥ ∂y∑ y ç X ¥ {x, y} ç  (X ∏ X)Æ)]
	[asm_rule ¨(y:'a) ç XÆ];
ufc_rule [(asm_rule ¨µ(X:'a SET) (x:'a)∑ ∂y∑ x ç X ¥ y ç X ¥ {x, y} ç  (X ∏ X)Æ)]
	[asm_rule ¨(y:'a) ç XÆ];
ufc_rule (fc_canon (asm_rule ¨µ A
           ∑ (µ x∑ x ç A ¥ x ç X) ± ≥ (µ x∑ ≥ x ç A)
               ¥ (∂ x∑ x ç A ± (µ y∑ y ç A ± ≥ y = x ¥ ≥ y << x))Æ))
	[asm_rule ¨µ x∑ x ç A ¥ x ç XÆ];
ufc_rule (fc_canon (asm_rule ¨µ G (X, $<<)
     ∑ FunctRespects G (X, $<<)
         = (µ g h x
         ∑ x ç X ¥ (µ y∑ y ç X ± y << x ¥ g y = h y) ¥ G g x = G h x)Æ))
	[asm_rule ¨FunctRespects G (X, $<<):BOOLÆ];
fc_rule (fc_canon (asm_rule ¨µ G (X, $<<)
     ∑ FunctRespects G (X, $<<)
         = (µ g h x
         ∑ x ç X ¥ (µ y∑ y ç X ± y << x ¥ g y = h y) ¥ G g x = G h x)Æ))
	[asm_rule ¨FunctRespects G (X, $<<):BOOLÆ];
ufc_rule (fc_canon (asm_rule ¨µ (G: ('a≠'b)≠('a≠'b)) (X:'a SET, $<<: 'a≠'a≠BOOL)
     ∑ FunctRespects G (X, $<<)
         = (µ g h x
         ∑ x ç X ¥ (µ y∑ y ç X ± y << x ¥ g y = h y) ¥ G g x = G h x)Æ))
	[asm_rule ¨µ (G: ('a≠'b)≠('a≠'b)) (X:'a SET, $<<: 'a≠'a≠BOOL)∑
		FunctRespects G (X, $<<):BOOLÆ];
=TEX

=SML
fun €UFC_T1›
	(can : THM -> THM list)
	(ttac : THM list -> TACTIC)
	(thms : THM list)
	: TACTIC = (fn gl as (asms, _) =>
	let	val asmthms = map asm_rule asms;
	in	ttac(ufc_rule(flat(map can thms)) asmthms) gl
	end
);
=TEX
=SML
fun €ASM_UFC_T1›
	(can : THM -> THM list)
	(ttac : THM list -> TACTIC)
	(thms : THM list)
	: TACTIC = (fn gl as (asms, _) =>
	let	val asmthms = map asm_rule asms;
	in	ttac(ufc_rule(flat(map can (thms@asmthms))) asmthms) gl
	end
);

val €UFC_T› = UFC_T1 fc_canon;
val €ASM_UFC_T› = ASM_UFC_T1 fc_canon;

val €ufc_tac› : THM list -> TACTIC = UFC_T strip_asms_tac1;
val €asm_ufc_tac› : THM list -> TACTIC = ASM_UFC_T strip_asms_tac1;

fun €ALL_UFC_T1› (can : CANON) (ttac : THM list -> TACTIC) (ths : THM list) : TACTIC = (
	let	fun aux1 acc [] = acc
		|   aux1 (imps, others) (th :: more) = (
			if is_¥ (snd(strip_µ(concl th)))
			then aux1 (th :: imps, others) more
			else aux1 (imps, th :: others) more
		);
		fun aux2 acc imps = (
			UFC_T1 id_canon (fn thl =>
				let	val (imps, others) = aux1 ([], acc) thl;
				in	if	is_nil imps
					then	ttac others
					else	aux2 others imps
				end
			) imps
		);
		val ths' = flat (map can ths);
	in	aux2 [] (ths' drop (not o is_¥ o snd o strip_µ o concl))
	end
);
val €ALL_UFC_T› : (THM list -> TACTIC) -> THM list -> TACTIC = ALL_UFC_T1 fc_canon;

fun €ALL_ASM_UFC_T1› (can : CANON) (ttac : THM list -> TACTIC) (thms : THM list) : TACTIC = (
	GET_ASMS_T (fn asm_thms => ALL_UFC_T1 can ttac (thms @ asm_thms)));
fun €ALL_ASM_UFC_T› (ttac : THM list -> TACTIC) (ths : THM list) : TACTIC = (
	GET_ASMS_T (fn thl => ALL_UFC_T ttac (thl @ ths)));

val €all_ufc_tac› : THM list -> TACTIC = ALL_UFC_T strip_asms_tac1;
val €all_asm_ufc_tac› : THM list -> TACTIC = ALL_ASM_UFC_T strip_asms_tac1;

val €ALL_UFC_§_T› = ALL_UFC_T1 fc_§_canon;
val €ALL_ASM_UFC_§_T› = ALL_ASM_UFC_T1 fc_§_canon;

val €all_ufc_§_tac› = ALL_UFC_§_T strip_asms_tac1;
val €all_asm_ufc_§_tac› = ALL_ASM_UFC_§_T strip_asms_tac1;

val €all_ufc_§_rewrite_tac› = ALL_UFC_§_T rewrite_tac;
val €all_asm_ufc_§_rewrite_tac› = ALL_ASM_UFC_§_T rewrite_tac;
=TEX
} %ignore

=SML
end; (* of structure UnifyForwardChain *)
=TEX

\section{Trawling for Useful Theorems}

=DOC
signature €Trawling› = sig
=DESCRIBE
The functions in this signature search the ancestors of the current theory for theorems which do something with the current goal, i.e. which rewrite the conclusion, backward chain from it, or forward chain from the assumptions.
=ENDDOC

=DOC
datatype €THMDET› = Spec of TERM | Thm of (string * string);
val €on_conc› : (TERM -> 'a) -> 'a;
val €on_asms› : (TERM list -> 'a) -> 'a;
val €rew_thms› : TERM -> ((int * THMDET) * THM) list;
val €rew_specs› : TERM -> ((int * THMDET) * THM) list;
val €bc_thms› : TERM -> ((int * THMDET) * THM) list;
val €fc_thms› : TERM list -> ((int * THMDET) * THM) list;
val €all_fc_thms› : TERM list -> ((int * THMDET) * THM) list;
val €todo› : unit -> {bc: int, fc: int, rw: int};
val €td_thml› : THMDET list -> THM list;
=DESCRIBE
$on\_conc$ and $on\_asms$ apply their arguments respectively to the conclusion or the list of assmuptions of the current goal.

$rew\_thms$, $rew\_specs$, $bc\_thms$ retrieve respectively theorems ($thms$) or specifications ($specs$) which can be used to sucessfully rewrite ($rew$) or backchain from ($bc$) the term supplied as an argument.

$fc\_thms$ and $all\_fc\_thms$, when supplied with a list of assumptions, retrieve theorems which will yield results using $fc\_tac$ and $all\_fc\_tac$.

$todo()$ returns a count of how many theorems or specifications are applicable to the current goal, classified according to the method of application.
$bc$ = back chaining, $fc$ = forward chaining, $rw$ = rewriting.
=ENDDOC

=SML
end; (* of signature Trawling *)
=TEX

=SML
structure €Trawling› : Trawling = struct
=TEX

\ignore{
=SML

val avoid_theories = ref ["min", "log", "misc", "sets", "combin", "pair", "list"];
val avoid_constants = ref [""];
val avoid_specs: string list ref = ref [""];

datatype THMDET =
		Spec of TERM
	|	Thm of (string * string);

fun is_defined_constant s =
	let val theoryname = get_const_theory s;
	    val defn = get_defn theoryname s
	in true
	end
	handle _ => false;

fun defined_consts t =
	let val consts = term_consts t
	in filter
		(fn x => not ((fst x) mem !avoid_constants)
		andalso is_defined_constant (fst x))
	   consts
	end;

fun defined_const_names t = map fst (defined_consts t);

fun on_conc f = f (snd (top_goal()));

fun on_asms f =
	let val (asms, concl) = top_goal()
	in f asms
	end;

fun on_goal f =
	let val (asms, concl) = top_goal()
	in  flat(map f (concl :: asms))
	end;

fun term_const_specs t =
	let fun gs (s,t) =
		let val c = mk_const (s,t)
		in (if	s mem !avoid_specs orelse
			(get_const_theory s) mem !avoid_theories
		   then []
		   else [(Spec c, get_spec c)]) handle _ => []
		end
	in flat (map gs (term_consts t))
	end;

fun const_theories t = list_cup (map (fn x => [get_const_theory x]) (defined_const_names t));

fun ancestor_theories t = filter (fn x => not (x mem !avoid_theories)) (get_ancestors t);

fun thy_thms t = map (fn (s,thm) => (Thm(t, hd s), thm)) (get_thms t);

fun const_thms t = flat(map thy_thms (const_theories t));

fun ancestor_thms t = flat(map thy_thms (ancestor_theories t));

fun rewriting_thm t thm =
	let val t' = pure_once_rewrite_conv [thm] t
	in true
	end handle _ => false;

local open RbjTactics1 in
fun srewriting_thm t thm = rewriting_thm t (map_eq_sym_rule thm) handle _ => false;
end;

fun fc_thm ts thm =
	let val thms = fc_rule (fc_canon thm) (map asm_rule ts)
	in (fn [] => false | _ => true) thms
	end handle _ => false;

fun all_fc_thm ts thm =
	let val (gl, pr) = all_fc_tac [thm] (ts, ¨FÆ)
	in if length gl = 1 andalso length (fst (hd gl)) = length ts
		then false else true
	end handle _ => false;

fun bc_thm c thm =
	let val (gl, pr) = bc_tac [thm] ([], c)
	in if length gl = 1 andalso (snd (hd gl)) =$ c
		then false else true
	end handle _ => false;

fun numthms n [] = []
|   numthms n ((thmdets, thm)::t) = ((n, thmdets), thm):: (numthms (n+1) t);

fun rew_specs t =
	let val thms = term_const_specs t
	in numthms 1 (filter ((rewriting_thm t) o snd) thms)
	end;

fun terml_const_specs tl = flat (map term_const_specs tl);

fun fc_specs ts =
	let val thms = terml_const_specs ts
	in numthms 1 (filter ((fc_thm ts) o snd) thms)
	end;

fun bc_specs t =
	let val thms = term_const_specs t
	in numthms 1 (filter ((bc_thm t) o snd) thms)
	end;

fun rew_thms t =
	let val thms = (ancestor_thms "-") @ (term_const_specs t)
	in numthms 1 (filter ((rewriting_thm t) o snd) thms)
	end;

fun srew_thms t =
	let val thms = (ancestor_thms "-") @ (term_const_specs t)
	in numthms 1 (filter ((srewriting_thm t) o snd) thms)
	end;

fun fc_thms tl =
	let val thms = (ancestor_thms "-") @ (terml_const_specs tl)
	in numthms 1 (filter ((fc_thm tl) o snd) thms)
	end;

fun all_fc_thms tl =
	let val thms = (ancestor_thms "-") @ (terml_const_specs tl)
	in numthms 1 (filter ((all_fc_thm tl) o snd) thms)
	end;

fun bc_thms t =
	let val thms = (ancestor_thms "-") @ (term_const_specs t)
	in numthms 1 (filter ((bc_thm t) o snd) thms)
	end;

fun rew_thms2 t =
	let val thms = (ancestor_thms "-") @ (term_const_specs t)
	in numthms 1 (flat (map (fn (sl, th) =>
		[(sl, (th, (snd o dest_eq)(concl (pure_once_rewrite_conv [th] t))))]
		handle _ => []) thms))
	end;

fun rew_thms3 t =
	let val thms = (ancestor_thms "-") @ (term_const_specs t)
	in numthms 1 (flat (map (fn (sl, th) =>
		[(sl, (snd o dest_eq)(concl (pure_once_rewrite_conv [th] t)))]
		handle _ => []) thms))
	end;

fun const_rewrite_conv t =
	let val thms = map snd (rew_thms t)
	in rewrite_conv thms t
	end;

fun with_conc_thms f =
	let fun ff t = f (map snd (rew_thms t))
	in on_conc ff
	end;

fun with_conc_specs f =
	let fun ff t = f (map snd (rew_specs t))
	in on_conc ff
	end;

fun td_thm (Thm (thyn, thmn)) = get_thm thyn thmn
|   td_thm (Spec s) = get_spec s;

fun td_thml tdl = map td_thm tdl;

fun numl2tdl tdsl nl =
 map (fn chose => (snd o fst o chose) tdsl) (map (fn n=> nth (n-1)) nl);

fun todo () =
	let val rw = length (on_conc rew_thms)
	    val bc = length (on_conc bc_thms)
	    val fc = length (on_asms fc_thms)
	in {rw = rw, bc = bc, fc = fc}
	end;
=TEX
}%ignore

=SML
end; (* of structure Trawling *)
=TEX

\section{For Inductive and Coinductive Definitions}

\subsection{Some Handy SML functions}

The following functions have been moved here from \cite{rbjt007}.

=SML
fun lfoldl f a [] = a
|  lfoldl f a (h::t) = lfoldl f (f (a, h)) t;

fun lfoldr f a [] = a
|  lfoldr f a (h::t) = f (a, (lfoldr f h t));

fun €list_s_enter› [] d = d
|   list_s_enter ((s,v)::t) d = list_s_enter t (s_enter s v d); 

fun €list_to_sdict› l = list_s_enter l initial_s_dict;

fun €list_pos› e [] = 0
|   list_pos e (h::t) =
	if h = e
	then 1
	else	let val p = list_pos e t 
		in if p = 0 then 0 else p+1
		end;

val €strip_≠_type› = strip_spine_right dest_≠_type;

fun €list_mk_∏_type› (h::t) = lfoldr mk_∏_type h t;

fun match_mk_app (f, a) = mk_app(f,a) handle _ => ¨ëfÆ ëaÆÆ;

fun list_match_mk_app (f, al) = lfoldl match_mk_app f al;
=TEX

=SML
fun gen_type_map cf vf ty =
	let fun aux (Vartype v) = vf v
	|       aux (Ctype (s, tl)) = cf s ((map (aux o dest_simple_type)) tl)
	in aux (dest_simple_type ty)
	end;

local fun front_last [e] = ([], e)
      |   front_last (f::t) = 
	   let val (f2, l) = front_last t
	   in (f::f2, l)
	   end
in fun €front› x = let val (f,l) = front_last x in f end
   fun €last› x = let val (f,l) = front_last x in l end
   fun €right_rotate_list› [] = []
   |   right_rotate_list [e] = [e]
   |   right_rotate_list x = let val (f,l) = front_last x in l :: f end
   fun €left_rotate_list› [] = []
   |   left_rotate_list [e] = [e]
   |   left_rotate_list (h::t) = t @ [h]
end;
=TEX

\subsection{False Equations Between Set Displays}

The following code defines a conversion for transforming (into $¨FÆ$) false equations between set displays.

=SML
infix symdiff;

fun x €symdiff› y = (x diff y) cup (y diff x);

fun dest_enum l =
	(fn DEnumSet els => els
	|  Dö t => []) (dest_term l);

fun enum_eq_sdiff t =
	let val DEq (lhs, rhs) = dest_term t
	in (dest_enum lhs) symdiff (dest_enum rhs)
	end;

fun €false_enum_eq_conv› t =
	let val (dt :: _) = enum_eq_sdiff t
	in 
		tac_proof(([], ¨ëtÆ § FÆ),
			rewrite_tac [sets_ext_clauses]
			THEN ≥_in_tac
			THEN ∂_tac dt THEN prove_tac[])
	end handle _ => fail_conv t;

val €false_enum_eq_tac› = conv_tac (MAP_C false_enum_eq_conv); 
=TEX

\twocolumn[\section{INDEX}\label{INDEX}]
{\small\printindex}

\end{document}
