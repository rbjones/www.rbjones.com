=IGN
$Id: t001.doc,v 1.11 2009/05/21 08:59:45 rbj Exp $
=TEX
\documentclass[11pt,a4paper]{article}
\usepackage{latexsym}
\usepackage{ProofPower}
\ftlinepenalty=9999
\usepackage{A4}

\def\ExpName{\mbox{{\sf exp}}}
\def\Exp#1{\ExpName(#1)}

\tabstop=0.4in
\newcommand{\ignore}[1]{}

\makeindex
\title{Abstract Semantics and Metaphysics}
\author{Roger Bishop Jones}
\makeindex
\author{R.B.Jones\\ rbj01@rbjones.com}
\date{\ }

\usepackage[unicode,pdftex]{hyperref}
\hypersetup{pdfauthor={Roger Bishop Jones}}
\hypersetup{colorlinks=true, urlcolor=blue, citecolor=black, filecolor=black, linkcolor=blue}

\begin{document}
\begin{titlepage}
\maketitle
\begin{abstract}
Some generic formal models of abstract semantics.
\end{abstract}
\vfill

\begin{centering}
{\footnotesize

Created 2004/07/15

Last Change $ $Date: 2009/05/21 08:59:45 $ $

\href{http://www.rbjones.com/rbjpub/pp/doc/t001.pdf}
{http://www.rbjones.com/rbjpub/pp/doc/t001.pdf}

$ $Id: t001.doc,v 1.11 2009/05/21 08:59:45 rbj Exp $ $

\copyright\ Roger Bishop Jones; Licenced under Gnu LGPL

}%footnotesize
\end{centering}

\thispagestyle{empty}
\end{titlepage}
\newpage
\addtocounter{page}{1}
%\section{DOCUMENT CONTROL}
%\subsection{Contents list}
\tableofcontents
%\newpage
%\subsection{Document cross references}


{\raggedright
\bibliographystyle{fmu}
\bibliography{rbj,fmu}
} %\raggedright

\newpage
\section{INTRODUCTION}

This document has now become a place for trying out small exercises in formalisation, primarily related to philosophical problems.

To model the fundamental notion of ``logical truth'', we consider various ways in which the semantics of languages can be formally defined.
There are many ways of doing this.
The choice of how to render the semantics may be part of the process of defining a language or class of languages.
Definitions of logical truth are then specific to classes of languages which have the same kind of formal semantics.

\section{BARE BONED TRUTH CONDITIONS}\label{Bare-Boned Truth-Conditions}

\ignore{
\subsection{Technical Prelude}

First of all, we must give the the ML commands to  introduce the new theory ``analytic'' as a child of the theory ``hol''.

=SML
open_theory "misc2";
force_new_theory "t001a";
set_merge_pcs["misc21"];
=TEX
}%ignore


\subsection{Types}

The following ``primitive'' types are introduced:

=SML
new_type("S",0);  (* sentences *) 
new_type("C",0);  (* contexts *)
new_type("W",0);  (* possible worlds *)
new_type("P",0);  (* propositions *)
=TEX

\subsection{The Semantics}

The semantics of our language comes in two parts.
A semantic map which delivers propositions, the meanings of sentences in context,
and a propositional evaluation map, which extracts truth conditions from a proposition.

The purpose of this document is not to consider the semantics of any particular language but to reason about semantics and concepts defined in terms of semantics.
We could have used variables for the semantics, but this time I decided to use loosely defined constants.
So the following definitions only tell you the type of the semantic map and the evaluation map, they don't tell you anything more than that, so any results we subsequently obtain using these definitions will hold good for any language with a semantics of the type stipluated here.

¹HOLCONST
Ü ÛsmÝ : S ¸ C ­ P
÷üüüüüü
Ü T
°

¹HOLCONST
Ü ÛpemÝ : P ¸ W ­ TTV
÷üüüüüü
Ü T
°

Note that $TTV$ is a type consisting of three `truth' values, whose names are: $pTrue$, $pFalse$ and $pU$.

\subsection{Necessity}

A proposition is `necessarily t' if it takes truth value `t' in every possible world.

¹HOLCONST
Ü ÛnecessarilyÝ : TTV ­ P ­ BOOL
÷üüüüüü
Ü µt:TTV; p:P· necessarily t p ¤ µw:W· pem(p, w) = t
°

A proposition is {\it necessary} (simpliciter) if it is {\it necessarily t} for some truth value {\it t}.

¹HOLCONST
Ü ÛnecessaryÝ : P ­ BOOL
÷üüüüüü
Ü µp:P· necessary p ¤ ¶t· necessarily t p
°

¹HOLCONST
Ü ÛcontingentÝ : P ­ BOOL
÷üüüüüü
Ü µp:P· contingent p ¤ ¶w1 w2· ³ pem(p, w1) = pem(p, w2)
°

\subsection{True in Virtue of Meaning}

A common definition of ``analytic'' is as `true in virtue of meaning', so we will now try to formalise that idea. 
If the truth value of a sentence can be ascertained from its meaning only, i.e. without taking into account any `extra-linguistic fact' (in Quine's words), i.e. without knowing anything about what possible world is actual.
This can only be known if it takes the same truth value in every possible world.

This can be generalised to an arbitrary truth value.

Therefore we define:

=SML
declare_infix (300, "by_meaning");
=TEX

¹HOLCONST
Ü $Ûby_meaningÝ : TTV ­ (S ¸ C) ­ BOOL
÷üüüüüü
Ü µt:TTV; s:S; c:C· t by_meaning (s, c) ¤ µp· pem (sm(s, c), p) = t
°

\subsection{Expresses a Necessary Proposition}

My preferred definition of analyticity is that a sentence is analytic if the proposition it expresses is necessarily true.
Again we generalise to an arbitrary truth value.
I'll make this infix as well.

=SML
declare_infix (300, "analytic");
=TEX

¹HOLCONST
Ü $ÛanalyticÝ : TTV ­ (S ¸ C) ­ BOOL
÷üüüüüü
Ü µt:TTV; s:S; c:C· t analytic (s, c) ¤ necessarily t (sm(s, c))
°

Now we prove that these two conception of analyticity are the same.

The proof is trivial, exanding the relevant definitions yields a universally quantified identity equation (apart from the names of the bound variables).
In the following proof script, the necessary rewriting is broken into two stages to show the identity.

=SML
set_goal([], ¬µt s c· t analytic (s,c) ¤ t by_meaning (s, c)®);
a (pure_rewrite_tac (map get_spec [¬$analytic®, ¬$by_meaning®, ¬necessarily®]));
=GFT
(* *** Goal "" *** *)

(* ?ô *)  ¬µ t s c· (µ w· pem (sm (s, c), w) = t) = (µ p· pem (sm (s, c), p) = t)®
=SML
a (rewrite_tac[]);
val analyticity_lemma1 = save_pop_thm "analyticity_lemma1";
=TEX

\section{KANT'S DEFINITION OF ANALYTICITY}

\subsection{First Shot}

Kant defined analyticity only for "subject predicate" sentences, and some have therefore supposed this to be less general than more recent formulations.
However, asssuming only that the notion of analyticity is to be preserved by logical equivalence we can show that Kant's definition is equivalent to the preceding ones.

There is an awkwardness in generalising this notion to three truth values, so I will do it only for the one.

We will first define predicate inclusion.

=SML
declare_infix (300, "contains");
=TEX

¹HOLCONST
Ü $ÛcontainsÝ : ('a ­ BOOL) ­ ('a ­ BOOL) ­ BOOL
÷üüüüüü
Ü µP Q· P contains Q ¤ µx· Q x ´ P x
°

$P\ contains\ Q$ is a way of writing a subject predicate assertion in which the subject is $Q$ and the predicate is $P$ (this is Aristotelian terminology, we don't use predication in this way in modern logic).

Now we show that every judgement is equivalent to one in "subject predicate" form:

=GFT
kantian_lemma =
	ô µ SS· ¶ P Q· SS ¤ P contains Q
=TEX

=SML
set_goal([], ¬µSS· ¶P Q· SS ¤ P contains Q®);
a (strip_tac THEN ¶_tac ¬Ìx· SS® THEN ¶_tac ¬Ìx· T®);
a (rewrite_tac [get_spec ¬$contains®]);
val kantian_lemma =  save_pop_thm "kantian_lemma";
=TEX

This lemma may be applied generally, thus:

=SML
val î_gt_trans = µ_elim ¬µx y z:î· x > y ± y > z ´ x > z® kantian_lemma;
=TEX
yields:
=GFT
val î_gt_trans =
   ô ¶ P Q· (µ x y z· x > y ± y > z ´ x > z) ¤ P contains Q
=TEX

However, this is smoke and mirrors, because though it appears to be saying something about propositions, it is really about truth values.
i.e. we have proven that every sentence has the same truth value as some sentence in subject predicate form, i.e. that there is a false sentence and a true sentence in subject predicate form.

To have a relevance to the scope of Kant's definition of analyticity we need some real metatheoretic reasoning in which we talk about meanings of judgements.

\subsection{Fuller Treatment}

The treatment in the previous section is not wholly convincing.

A sufficient reason for this is that the central thesis is not itself formalised.
Insofar as there is any doubt about the thesis it therefore fails to improve the situation, and the question arises whether the theorems proven really establish the intended result.

The thesis is that, under certain provisos, Kant's definition of analyticity is equivalent to a definition along the lines of "true in virtue of meaning".
However, it seems probable that the conditions under which Kant's definition holds good differ significantly from those in which the other definition is applicable.
To formulate the thesis it is therefore necessary to establish some sufficient (and preferably necessary) conditions for both definitions to be applicable.

The required result is a general result covering a class of descriptive languages, and I think this will be better expressed if we abandon the previous methods of formalising in relation to some loosely specified but fixed (constant) language, and talk about languages using variables.

I will therefore start from scratch but replicate the same basic idea of what a descriptive language is.

Kant talks about "judgements", I will treat these as sentences in context.


\ignore{
\subsection{Technical Prelude}

First of all, we must give the the ML commands to  introduce the new theory ``t001b'' as a child of the theory ``hol''.

=SML
open_theory "misc2";
force_new_theory "t001b";
set_merge_pcs["misc21"];
=TEX
}%ignore

\subsection{Types}

In this version type variables will be used where constants were previously used, as follows:

\begin{itemize}
\item['S] Sentences
\item['C] Contexts
\item['P] Propositions
\item['W] Possible Worlds
\end{itemize}

\subsection{The Semantics}

The semantics of a `descriptive' language comes in two parts.
A semantic map which delivers propositions, the meanings of sentences in context,
and a propositional evaluation map, which extracts truth conditions from a proposition.

The purpose of this document is not to consider the semantics of any particular language but to reason about semantics and concepts defined in terms of semantics.

The following type abbreviations give the type of the semantics of a descriptive language.

=SML
(* Semantic Map *)
declare_type_abbrev ("SM", ["'C", "'P", "'S"], 'S ¸ 'C ­ 'P®);

(* Propositional Evaluation Map *)
declare_type_abbrev ("PEM", ["'P", "'W"], 'P ¸ 'W ­ BOOL®);

(* Language *)
declare_type_abbrev ("LAN", ["'C", "'P", "'S", "'W"], ('C, 'P, 'W)SM ¸ ('P, 'W)PEM®);
=TEX

\subsection{Necessity}

A proposition is `necessary' if it takes truth value `T' in every possible world, the definition is parameterised by a propositional evaluation map.

¹HOLCONST
Ü ÛnecessaryÝ : ('P, 'W)PEM ­ 'P ­ BOOL
÷üüüüüü
Ü µpem (p:'P)· necessary pem p ¤ µw:'W· pem(p, w) = T
°

¹HOLCONST
Ü ÛcontradictoryÝ : ('P, 'W)PEM ­ 'P ­ BOOL
÷üüüüüü
Ü µpem (p:'P)· contradictory pem p ¤ µw:'W· pem(p, w) = F
°

¹HOLCONST
Ü ÛcontingentÝ : ('P, 'W)PEM ­ 'P ­ BOOL
÷üüüüüü
Ü µpem (p:'P)· contingent pem p ¤ ¶w1 w2:'W· ³ pem(p, w1) = pem(p, w2)
°

\section{ARISTOTLE'S METAPHYSICS}

This section is for some experiments in formalising in HOL of material modelling Aristotle's metaphysics which originated in work of Grice and Code and came to me from a \href{http://rbjones.com/pipermail/hist-analytic_rbjones.com/2009q2/000258.html}{posting of J.L. Speranza} on the hist-analytic mailing list.

What Speranza posted was the list of formulae which are named below as c01 through c31 (though not exactly as given, I have massaged them to be acceptable to HOL and also have quantified over all free variables).

My aim at present is to come up with a model which satisfies these propositions.

A new theory is needed which I will call ``ariscat'' and some goobledy-gook to set that up:

=SML
open_theory "misc2";
force_new_theory "ariscat";
=TEX

\ignore{
=SML
force_new_pc Û"'ariscat"Ý;
merge_pcs ["'savedthm_cs_¶_proof"] "'ariscat";
set_merge_pcs ["misc2", "'ariscat"];
=TEX
}%ignore

I will use the following names as infix relations, so they are here so declared.

=SML
declare_infix (300, "½");
declare_infix (300, "izz");
declare_infix (300, "hazz");
declare_infix (300, "predicable_of");
declare_infix (300, "essentially_predicable_of");
declare_infix (300, "accidentally_predicable_of");
=TEX

and we might as well define equality without further ado:

¹HOLCONST
Ü $Û½Ý : 'a ­ 'a ­ BOOL
÷üüüüüü
Ü µx y· x ½ y ¤ ³ x = y
°

\subsection{Aristotelian Category Theory}

Aristotle has a system of categories, and these seem central to the topic.
Much hang on what these are, and to get a nice structure to our theory it seems advisable to do a bit of ``category theory'' first.
Of course this is not at all the same thing as the branch of mathematics which now goes by that name, but the choice of name for the mathematics was not entirely quixotic and at some point it might be interesting to think about the relationship between the two kinds of category theory.

Much of the semi-formal material which we are trying to fully formalise involves general talk about the kinds of things which are found in categories.
On the face of it the formulae are probably intended as schemas in a first order predicate calculus, which is certainly not they way we will treat them, so a few words explaining why not are in order here.

We are working here in a higher-order logic.
In a first-order logic, it is not possible for quantify over anything but individuals.
In first order set theory we get around that restriction by having ``individuals'' which are surrogates for all kinds of higher order objects.
In set theory we can, by quantifying over the individuals encompass objects which represent properties of functions of every conceivable type.
Some pragmatic issues remain which we need not go into here.

When a first-order formalisation is attempted without benefit of the machinery of set theory, it often proves necessary to use schemata, which are a syntactic surrogate for quantification over higher types.
A well known example is the theory PA, a first order version of Peano's axioms for arithmetic.
Peano himself formulated his axioms for arithmetic before first order logic was invented, before indeed the foundational problems which provoked the development of type theories.
His axiom of induction involved quantification over properties along the following lines:

=GFT
	ô µp· p(0) ± (µx· p(x) ´ p(x + 1)) ´ µx· p(x)
=TEX

Which we may paraphrase:
\begin{quote}
for all properties {it p}, if {\it p} hold for 0 and whenever {\it p} is true of some natural number it is true also of its successor, then {\it p} will be true of all natural numbers
\end{quote}

In the first order formalisation of Peano Arithmetic, known as PA, we cannot quantify over properties, so we use instead an axiom schemata, which lifts the quantification into the metalanguage and changes from quantifying over numbers to quantifying over formulae.
Thus we have intsead something like:

=GFT
	ô P(0) ± (µx· P(x) ´ P(x + 1)) ´ µx· P(x)
=TEX

Where $P$ is not a predicate in the object language, but a syntactic function in the metalanguage which yields formula.
The first order axiom schemata describes an infinite set of properly first order axioms obtained by substituting arbitrary formulae inc which $0$ occurs for $P(0)$, and corresponding formulae for $P(x)$ and $P(x+1)$ in which $x$ and $x+1$ respectively replace occurences of $0$ in the first formula.





Among these categories that of substances plays a special role.
Substances can be particular in which case they correspond to some individual, or not, in which case they are sets of individuals.
The particulars of the other categories are attributes, and the non-individuals are sets of attributes.
I don't think you can have sigleton sets, so we can model all these categories as sets of sets in which the singleton sets are the individuals.
Attributes can also be considered as sets of individual substances and so there is a type difference between the category of substances and the other categories.

The following introduce new types and type abbreviations for modelling Aristotle's categories.

\begin{description}
\item ACAT is a type of attribute categories
\item ISUB is a type of individual substances
\item CATM is the type of the things which are in categories.

This is a `disjoint union', which means that there are two kinds of thing which one finds in categories, either a set of individual substances (using singleton sets to represent individual substances), or a set of properties of individual substances tagged with an attribute category.

\item CAT is a type abbreviation for a notion of category which is either an attribute category or some other category (which will stand for the category of substances).

\end{description}


=SML
new_type(Û"ACAT"Ý, 0);
new_type(Û"ISUB"Ý, 0);
declare_type_abbrev (Û"CATM"Ý, [], ISUB ð + (ACAT ¸ (ISUB ­ BOOL)ð)®);
declare_type_abbrev (Û"CAT"Ý, [], ONE + ACAT®);
=TEX

We name the category of substances.

¹HOLCONST
Ü ÛCatSubsÝ : CAT
÷üüüüüü
Ü CatSubs = InL One
°


Now we define various operators over categories and their constituents which suffice for the development of an appropriate theory, in the context of which rest of the Aristotelian terminology will we hope prove definable.

First ``projection'' functions which yield the constituents of $MCAT$s.

¹HOLCONST
Ü ÛCatÝ : CATM ­ CAT
÷üüüüüü
Ü µx· Cat x = if IsL x then CatSubs else InR(Fst (OutR x))
°

=GFT
=TEX

\ignore{
=SML
set_goal([], ¬µA· Cat A = CatSubs ¤ IsL A®);
=TEX
}%ignore


¹HOLCONST
Ü ÛIndvSetÝ : CATM ­ ISUB ð
÷üüüüüü
Ü µx· IndvSet x = OutL x
°

¹HOLCONST
Ü ÛAttrSetÝ : CATM ­ (ISUB ­ BOOL)ð
÷üüüüüü
Ü µx· AttrSet x = Snd(OutR x)
°

This one turns out handy.

¹HOLCONST
Ü ÛCatSetÝ : CATM ­ (ISUB + (ISUB ­ BOOL))ð
÷üüüüüü
Ü µx· CatSet x =
Ü	if Cat x = CatSubs
Ü	then {y | ¶z· z  IndvSet x ± y = InL z}
Ü	else {y | ¶z· z  AttrSet x ± y = InR z}
°

With these definitions in place we get a useful characterisation of identity for elements of $CATM$.

=GFT
catm_eq_lemma =
	ô µ A B· A = B ¤ Cat A = Cat B ± CatSet A = CatSet B
=TEX

\ignore{
=SML
set_goal([], ¬µA B· A = B ¤ Cat A =  Cat B ± CatSet A = CatSet B®);
a (REPEAT µ_tac THEN rewrite_tac [get_spec ¬Cat®, get_spec ¬CatSet®]);
a (strip_asm_tac (µ_elim ¬A® sum_cases_thm) THEN asm_rewrite_tac[]
	THEN REPEAT_N 3 (TRY strip_tac)
	THEN_TRY asm_rewrite_tac[]);
(* *** Goal "1" *** *)
a (POP_ASM_T (asm_tac o eq_sym_rule)
	THEN asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a (lemma_tac ¬IsL B®);
(* *** Goal "2.1" *** *)
a (swap_nth_asm_concl_tac 2
	THEN asm_rewrite_tac[get_spec ¬CatSubs®]);
(* *** Goal "2.2" *** *)
a (swap_nth_asm_concl_tac 2
	THEN rewrite_tac[asm_rule ¬IsL B®, sets_ext_clauses, get_spec ¬IndvSet®]);
a (strip_tac);
a (lemma_tac ¬³ y = OutL B®);
(* *** Goal "2.2.1" *** *)
a (swap_nth_asm_concl_tac 1 THEN asm_rewrite_tac[get_spec ¬InL®]);
a (GET_ASM_T ¬IsL B® (rewrite_thm_tac o (rewrite_rule [sum_clauses])));
(* *** Goal "2.2.2" *** *)
a (swap_nth_asm_concl_tac 1 THEN rewrite_tac[sets_ext_clauses]);
a (swap_nth_asm_concl_tac 1);
(* *** Goal "2.2.2.1" *** *)
a (strip_tac THEN ¶_tac ¬InL x® THEN asm_rewrite_tac[]);
a (contr_tac THEN asm_fc_tac[] THEN_TRY all_var_elim_asm_tac);
a (spec_nth_asm_tac 2 ¬x®);
(* *** Goal "2.2.2.2" *** *)
a (strip_tac THEN ¶_tac ¬InL x® THEN asm_rewrite_tac[]);
a (contr_tac THEN asm_fc_tac[] THEN_TRY all_var_elim_asm_tac);
a (spec_nth_asm_tac 1 ¬x®);
(* *** Goal "3" *** *)
a (POP_ASM_T (asm_tac o eq_sym_rule) THEN asm_rewrite_tac[]);
(* *** Goal "4" *** *)
a (lemma_tac ¬³ IsL B®);
(* *** Goal "4.1" *** *)
a (swap_nth_asm_concl_tac 2
	THEN asm_rewrite_tac[get_spec ¬CatSubs®]);
(* *** Goal "4.2" *** *)
a (swap_nth_asm_concl_tac 2
	THEN rewrite_tac[asm_rule ¬³ IsL B®, sets_ext_clauses, get_spec ¬IndvSet®]);
a (strip_tac);
a (lemma_tac ¬³ z = OutR B®);
(* *** Goal "4.2.1" *** *)
a (swap_nth_asm_concl_tac 1 THEN asm_rewrite_tac[get_spec ¬InR®]);
a (LEMMA_T ¬IsR B® (rewrite_thm_tac o (rewrite_rule [sum_clauses])));
a (DROP_ASM_T ¬³ IsL B® ante_tac
	THEN strip_asm_tac (µ_elim ¬B® sum_cases_thm)
	THEN asm_rewrite_tac[]);
(* *** Goal "4.2.2" *** *)
a (asm_rewrite_tac[get_spec ¬CatSubs®, get_spec ¬AttrSet®]);
a (lemma_tac ¬³ Snd z = Snd(OutR B)®
	THEN1 swap_asm_concl_tac ¬³ z = OutR B®);
(* *** Goal "4.2.2.1" *** *)
a (LEMMA_T ¬z = (Fst z, Snd z)® pure_once_rewrite_thm_tac THEN1 prove_tac[]);
a (pure_asm_rewrite_tac[]);
a (LEMMA_T ¬Fst z = Fst (OutR B)® rewrite_thm_tac);
a (swap_asm_concl_tac ¬InR (Fst z) = (if IsL B then CatSubs else InR (Fst (OutR B)))®);
a (asm_rewrite_tac[]);
a (swap_nth_asm_concl_tac 1);
a (rewrite_tac [sets_ext_clauses]);
a (swap_nth_asm_concl_tac 1);
a (strip_tac THEN ¶_tac ¬InR x® THEN asm_rewrite_tac[]);
a (REPEAT strip_tac THEN_TRY all_var_elim_asm_tac);
a (spec_nth_asm_tac 1 ¬x®);
a (spec_nth_asm_tac 1 ¬z'®);
(* *** Goal "4.2.2.2.2" *** *)
a (strip_tac THEN ¶_tac ¬InR x® THEN asm_rewrite_tac[]);
a (REPEAT strip_tac THEN_TRY all_var_elim_asm_tac);
(* *** Goal "4.2.2.2.2.1" *** *)
a (¶_tac ¬x®);
a (asm_rewrite_tac []);
(* *** Goal "4.2.2.2.2.2" *** *)
a (¶_tac ¬z'®);
a (asm_rewrite_tac []);
val catm_eq_lemma = save_pop_thm "catm_eq_lemma";
=TEX
}%ignore

Now we can define predication.
We do this in terms of Grice's $izz$ and $hass$.

¹HOLCONST
Ü $ÛizzÝ : CATM ­ CATM ­ BOOL
÷üüüüüü
Ü µA B· A izz B ¤ Cat A = Cat B ± CatSet A  CatSet B
°

¹HOLCONST
Ü $ÛhazzÝ : CATM ­ CATM ­ BOOL
÷üüüüüü
Ü µA B· A hazz B ¤ Cat A = CatSubs ± ³ Cat B = CatSubs
Ü	± ¶a· a  AttrSet B ± µs· s  IndvSet A ´ a s
°

That was reasonably neat, but the definition of $izz$ isn't terribly convenient for proving things.
Lets have some $izz$ lemmas:

=GFT
izz_lemma1 =
    ô µ A B· Cat A = CatSubs ´ (A izz B ¤ Cat B = CatSubs ± IndvSet A  IndvSet B)

izz_lemma2 =
    ô µ A B· Cat B = CatSubs ´ (A izz B ¤ Cat A = CatSubs ± IndvSet A  IndvSet B)

izz_lemma3 =
    ô µ A B· ³ Cat A = CatSubs ´ (A izz B ¤ Cat B = Cat A ± AttrSet A  AttrSet B)

izz_lemma4 =
    ô µ A B· ³ Cat B = CatSubs ´ (A izz B ¤ Cat B = Cat A ± AttrSet A  AttrSet B)
=TEX

\ignore{
=SML
set_goal([], ¬µA B· Cat A = CatSubs ´ (A izz B ¤ Cat B = CatSubs ± IndvSet A  IndvSet B)®);
a (REPEAT µ_tac THEN rewrite_tac[get_spec ¬$izz®, get_spec ¬CatSet®]); 
a (strip_tac THEN_TRY asm_rewrite_tac[] THEN REPEAT strip_tac THEN_TRY asm_rewrite_tac[]);
(* *** Goal "1" *** *)
a (POP_ASM_T ante_tac THEN asm_rewrite_tac[sets_ext_clauses] THEN REPEAT strip_tac);
a (spec_nth_asm_tac 2 ¬(InL x):ISUB + (ISUB ­ BOOL)®);
(* *** Goal "1.1" *** *)
a (spec_nth_asm_tac 1 ¬x®);
(* *** Goal "1.2" *** *)
a (asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a (POP_ASM_T ante_tac THEN asm_rewrite_tac[sets_ext_clauses] THEN REPEAT strip_tac);
a (¶_tac ¬z® THEN asm_rewrite_tac[]);
a (all_asm_fc_tac[]);
val izz_lemma1 = save_pop_thm "izz_lemma1";

set_goal([], ¬µA B· Cat B = CatSubs ´ (A izz B ¤ Cat A = CatSubs ± IndvSet A  IndvSet B)®);
a (REPEAT µ_tac THEN rewrite_tac[get_spec ¬$izz®, get_spec ¬CatSet®]); 
a (strip_tac THEN_TRY asm_rewrite_tac[] THEN REPEAT strip_tac THEN_TRY asm_rewrite_tac[]);
(* *** Goal "1" *** *)
a (POP_ASM_T ante_tac THEN asm_rewrite_tac[sets_ext_clauses] THEN REPEAT strip_tac);
a (spec_nth_asm_tac 2 ¬(InL x):ISUB + (ISUB ­ BOOL)®);
(* *** Goal "1.1" *** *)
a (spec_nth_asm_tac 1 ¬x®);
(* *** Goal "1.2" *** *)
a (asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a (POP_ASM_T ante_tac THEN asm_rewrite_tac[sets_ext_clauses] THEN REPEAT strip_tac);
a (¶_tac ¬z® THEN asm_rewrite_tac[]);
a (all_asm_fc_tac[]);
val izz_lemma2 = save_pop_thm "izz_lemma2";

set_goal([], ¬µA B· ³ Cat A = CatSubs ´ (A izz B ¤ Cat B = Cat A ± AttrSet A  AttrSet B)®);
a (REPEAT µ_tac THEN rewrite_tac[get_spec ¬$izz®, get_spec ¬CatSet®]); 
a (strip_tac THEN_TRY asm_rewrite_tac[] THEN REPEAT strip_tac THEN_TRY asm_rewrite_tac[]);
(* *** Goal "1" *** *)
a (POP_ASM_T ante_tac THEN asm_rewrite_tac[sets_ext_clauses]);
a (DROP_NTH_ASM_T 2 ante_tac THEN asm_rewrite_tac[] THEN strip_tac THEN asm_rewrite_tac[] THEN REPEAT strip_tac);
a (spec_nth_asm_tac 2 ¬(InR x):ISUB + (ISUB ­ BOOL)®);
(* *** Goal "1.1" *** *)
a (spec_nth_asm_tac 1 ¬x®);
(* *** Goal "1.2" *** *)
a (asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a (POP_ASM_T ante_tac THEN asm_rewrite_tac[sets_ext_clauses] THEN REPEAT strip_tac);
a (¶_tac ¬z® THEN asm_rewrite_tac[]);
a (all_asm_fc_tac[]);
val izz_lemma3 = save_pop_thm "izz_lemma3";

set_goal([], ¬µA B· ³ Cat B = CatSubs ´ (A izz B ¤ Cat B = Cat A ± AttrSet A  AttrSet B)®);
a (REPEAT µ_tac THEN rewrite_tac[get_spec ¬$izz®, get_spec ¬CatSet®]); 
a (strip_tac THEN_TRY asm_rewrite_tac[] THEN REPEAT strip_tac THEN_TRY asm_rewrite_tac[]);
(* *** Goal "1" *** *)
a (POP_ASM_T ante_tac THEN asm_rewrite_tac[sets_ext_clauses] THEN REPEAT strip_tac);
a (spec_nth_asm_tac 2 ¬(InR x):ISUB + (ISUB ­ BOOL)®);
(* *** Goal "1.1" *** *)
a (spec_nth_asm_tac 1 ¬x®);
(* *** Goal "1.2" *** *)
a (asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a (POP_ASM_T ante_tac 
	THEN SYM_ASMS_T rewrite_tac
	THEN asm_rewrite_tac[sets_ext_clauses]
	THEN REPEAT strip_tac);
a (¶_tac ¬z® THEN asm_rewrite_tac[]);
a (all_asm_fc_tac[]);
val izz_lemma4 = save_pop_thm "izz_lemma4";
=TEX
}%ignore

There is a certain amount of duplication of terminology here, since essential and accidental predication seem to be just $izz$ and $hazz$ backwards.
I'm not so happy with the ``ables'' here, for what is clearly meant is ``truly predicable'', which is not quite the same thing.
Better names would be simply ``is\_essentially'' and ``is\_accidentally'', lacking the ambiguity of ``able'' (but then they would have to be the other way round, exactly the same as $izz$ and $hazz$).

Anyway here are the definitions (keeping the names (more or less) as they were for the present):
¹HOLCONST
Ü $Ûessentially_predicable_ofÝ : CATM ­ CATM ­ BOOL
÷üüüüüü
Ü µA B· A essentially_predicable_of B ¤ B izz A
°

¹HOLCONST
Ü $Ûaccidentally_predicable_ofÝ : CATM ­ CATM ­ BOOL
÷üüüüüü
Ü µA B· A accidentally_predicable_of B ¤ B hazz A
°

Aristotelian predication is then:

¹HOLCONST
Ü $Ûpredicable_ofÝ : CATM ­ CATM ­ BOOL
÷üüüüüü
Ü µA B· A predicable_of B ¤ A essentially_predicable_of B ² A accidentally_predicable_of B
°

I shall omit $universal$ and $form$ for the present, since I don't know what they mean.

¹HOLCONST
Ü ÛparticularÝ : CATM ­ BOOL
÷üüüüüü
Ü µA· particular A ¤ ¶a· CatSet A = {a}
°

Now here's the list of things which Speranza posted (more or less) which I am calling ``conjectures'' and will attempt to prove.

=SML
val c01 = ¬µA· A izz A®;
val c02 = ¬µA B C· A izz B ± B izz C ´ A izz C®;
val c03 = ¬µA B· A hazz B ´ ³ A izz B®;

(* this is needed for c04 *)
val c04a = ¬µA B C· A hazz B ± B izz C ´ A hazz C®;

(* and this then is trivial since B serves as witness in the left-right direction *)
val c04 = ¬µA B· A hazz B ¤ ¶C· A hazz C ± C izz B®;

val c05 = ¬µx· universal x ´ form x®;

(* this one is false *)
val c06 = ¬µA B· A hazz B ± particular A ´ ¶C· C ½ A ± A izz B®; 
val c06n = ¬³ µA B· A hazz B ± particular A ´ ¶C· C ½ A ± A izz B®; 

val c07 = ¬µA B· A predicable_of B ¤ (B izz A) ² ¶C· B hazz C ± C izz A®;
val c08 = ¬µA· A essentially_predicable_of B ¤ B izz A®;
val c09 = ¬µA· A accidentally_predicable_of B ¤ ¶C· B hazz C ± C izz A®;
val c10 = ¬µA B· A = B ¤ A izz B ± B izz A®;

(* these are modal and require a different underlying model *)
val c11 = ¬µA B· individual A ¤ (Nec)(µ B· B izz A ´ A izz B)®;
val c12 = ¬µA· particular A ¤ (Nec)(µB· A predicable_of B ´ A izz B ± B izz A)®;
val c13 = ¬µA· universal A ¤ (Poss) ¶ B· (A predicable_of A ± ³(A izz B ± B izz A))®;

val c14 = ¬µA· thing A ´ individual A®;
val c15 = ¬µA· form A ´ thing A ± universal A®;
val c16 = ¬µA B· A predicable_of B ¤ (B izz A) ² ¶C· (thing C ± B hazz C ± C izz A)®;
val c17 = ¬µA· A essentially_predicable_of A®;
val c18 = ¬µA· A accidentally_predicable_of B ´ A ½ B®;
val c19 = ¬µA B· ³ (A accidentally_predicable_of B) ´ A ½ B®;
val c20 = ¬µA· particular A ´ individual A®;
val c21 = ¬µA· particular A ´ ³ ¶C· ³ C = A ± C izz A®;
val c22 = ¬³ ¶A· particular A ± form A®;
val c23 = ¬µA· form A ´ ³ ¶C· C ½ A ± C izz A®;
val c24 = ¬µX A· particular X ´ ¶B· form B ± A izz B®;
val c25 = ¬µA· form A ´ A predicable_of B ± A ½ B ´ B hazz A®;
val c26 = ¬µA B· form A ± particular B ´ (A predicable_of B ¤ B hazz A)®;
val c27 = ¬µA B· particular A ± universal B ± B predicable_of A
		´ ¶C· (A ½ C ± C essentially_predicable_of A)®;
val c28 = ¬(¶P· particular P ± ¶U· U predicable_of P) ´ ³ (µU· thing U)®;
val c29 = ¬µU· thing U®;
val c30 = ¬µA· particular A ´ ³ ¶B· (A ½ B ± B essentially_predicable_of A)®;
val c31 = ¬µA B· A predicable_of B ± A ½ B ´ A accidentally_predicable_of B®;
=TEX

I'm not going to show the proofs because they are unintelligible, but I will make a selection presentable.

\ignore{
=SML
set_goal([], c01);
a (REPEAT µ_tac THEN_TRY rewrite_tac [get_spec ¬$izz®]);
val l01 = save_pop_thm "l01";

set_goal([], c02);
a (REPEAT µ_tac THEN_TRY rewrite_tac [get_spec ¬$izz®]
	THEN REPEAT strip_tac
	THEN_TRY asm_rewrite_tac[]
	THEN all_asm_fc_tac[_trans_thm]);
val l02 = save_pop_thm "l02";

set_goal([], c03);
a (REPEAT µ_tac THEN_TRY rewrite_tac [get_spec ¬$izz®, get_spec ¬$hazz®] THEN contr_tac);
a (DROP_NTH_ASM_T 5 ante_tac
	THEN DROP_NTH_ASM_T 5 ante_tac
	THEN asm_rewrite_tac[]);
val l03 = save_pop_thm "l03";

set_goal([], c04a);
a (REPEAT µ_tac THEN rewrite_tac [get_spec ¬$hazz®, get_spec ¬CatSet®]
	THEN contr_tac);
(* *** Goal "1" *** *)
a (all_fc_tac [izz_lemma2]);
(* *** Goal "2" *** *)
a (all_asm_fc_tac[]);
a (all_fc_tac [list_µ_elim [¬B®] izz_lemma3]);
a (POP_ASM_T ante_tac THEN rewrite_tac [sets_ext_clauses]
	THEN REPEAT strip_tac
	THEN asm_fc_tac[]);
a (¶_tac ¬a® THEN contr_tac);
val l04a = save_pop_thm "l04a";

set_goal([], c04);
a (REPEAT strip_tac);
(* *** Goal "1" *** *)
a (¶_tac ¬B® THEN asm_rewrite_tac[l01]);
(* *** Goal "2" *** *)
a (all_fc_tac [list_µ_elim [¬A®, ¬C®] l04a]);
val l04 = save_pop_thm "l04";

set_goal([], c06n);
a (strip_tac);
a (¶_tac ¬InL{Åx:ISUB·T}:CATM® THEN strip_tac);
a (¶_tac ¬InR((Åx:ACAT·T), {Ìx:ISUB·T}):CATM® THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a (rewrite_tac (map get_spec [¬$hazz®, ¬Cat®, ¬CatSubs®]));
a (¶_tac ¬Ìx:ISUB·T®);
a (rewrite_tac (map get_spec [¬AttrSet®]));
(* *** Goal "2" *** *)
a (rewrite_tac (map get_spec [¬particular®]));
a (¶_tac ¬InL(Å x:ISUB· T):ISUB + (ISUB ­ BOOL)®);
a (rewrite_tac [get_spec ¬CatSet®, get_spec ¬Cat®, get_spec ¬IndvSet®, sets_ext_clauses]);
a (REPEAT strip_tac THEN_TRY asm_rewrite_tac[]);
a (¶_tac ¬Å x:ISUB· T®);
a (rewrite_tac[]);
(* *** Goal "3" *** *)
a (swap_nth_asm_concl_tac 1);
a (rewrite_tac[get_spec ¬$izz®, get_spec ¬Cat®, get_spec ¬CatSubs®]);
val l06n = save_pop_thm "l06n";

set_goal([], c07);
a (REPEAT µ_tac);
a (rewrite_tac [get_spec ¬$predicable_of®, get_spec ¬$essentially_predicable_of®,
		get_spec ¬$accidentally_predicable_of®]);
a (rewrite_tac [list_µ_elim [¬B®, ¬A®] l04]);
val l07 = save_pop_thm "l07";

set_goal([], c08);
a (rewrite_tac [get_spec ¬$essentially_predicable_of®]);
val l08 = save_pop_thm "l08";

set_goal([], c09);
a (REPEAT µ_tac);
a (rewrite_tac [get_spec ¬$accidentally_predicable_of®, list_µ_elim [¬B®, ¬A®] l04]);
val l09 = save_pop_thm "l09";

set_goal([], c10);
a (REPEAT µ_tac THEN rewrite_tac [get_spec ¬$izz®, catm_eq_lemma]);
a (REPEAT strip_tac THEN_TRY asm_rewrite_tac[]);
a (all_fc_tac [pc_rule1 "hol1" prove_rule [] ¬µa b· a  b ± b  a ´ a = b®]);
val l10 = save_pop_thm "l10";
=TEX
}%ignore

=GFT
l01	= ô µ A· A izz A
l02	= ô µ A B C· A izz B ± B izz C ´ A izz C
l03	= ô µ A B· A hazz B ´ ³ A izz B
l04a	= ô µ A B C· A hazz B ± B izz C ´ A hazz C
l04	= ô µ A B· A hazz B ¤ (¶ C· A hazz C ± C izz B) 
l06n	= ô ³ (µ A B· A hazz B ± particular A ´ (¶ C· C ½ A ± A izz B))
l07 	= ô µ A B· A predicable_of B ¤ B izz A ² (¶ C· B hazz C ± C izz A)
l08 	= ô µ A· A essentially_predicable_of B ¤ B izz A
l09 	= ô µ A· A accidentally_predicable_of B ¤ (¶ C· B hazz C ± C izz A)
l10	= ô µ A B· A = B ¤ A izz B ± B izz A
=TEX

{\let\Section\section
\newcounter{ThyNum}
\def\section#1{\Section{#1}
\addtocounter{ThyNum}{1}\label{Theory\arabic{ThyNum}}}
\include{t001a.th}
\include{t001b.th}
\include{ariscat.th}
}  %\let

\twocolumn[\section{INDEX}\label{index}]
{\small\printindex}

\end{document}
