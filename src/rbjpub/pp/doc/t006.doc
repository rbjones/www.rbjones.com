=IGN
$Id: t006.doc,v 1.2 2004/09/08 05:15:37 rbj Exp $
=TEX
\documentclass[11pt,a4paper]{article}
\usepackage{latexsym}
\usepackage{ProofPower}
\ftlinepenalty=9999
\tabstop=0.25in
\usepackage{A4}
\def\N{\mathbb{N}}
\def\D{\mathbb{D}}
\def\B{\mathbb{B}}
\def\R{\mathbb{R}}
\def\Z{\mathbb{Z}}
\def\Q{\mathbb{Q}}

\def\Hide#1{\relax}
\newcommand{\ignore}[1]{}

\title{Miscellanea}
\author{Roger Bishop Jones}
\makeindex
\begin{document}
\vfill
\maketitle
\begin{abstract}
This document contains things used by my other theories which do not particularly belong in them.
Some are bits of SML not associated with a theory.
Some are definitions or theorems which arguably belong in a theory already produced by someone else.
Its a holding location for things which will eventually find their place (or else be discarded).
\end{abstract}
\vfill
\newpage
\tableofcontents
\newpage
%%%%

\ignore{
{\raggedright
\bibliographystyle{fmu}
\bibliography{fmu}
} %\raggedright
}%ignore

\section{Specifications}

=DOC
signature ÛrbjmiscÝ = sig
=DESCRIBE
Various bindings.
=ENDDOC

=DOC
val Ûrule_canonÝ: (THM -> THM) -> CANON;
=DESCRIBE
Converts a rule into a CANON which yeilds a singleton list containing the result of applying the rule to the argument of the CANON.
=ENDDOC

=DOC
val Û´_T_canonÝ: CANON;
=DESCRIBE
If in $asms ô conc$, $conc$ is a universally quantified implication then $´\_T\_canon (asms ô conc)$ is $[asms ô conc]$, otherwise it is $[asms ô conc ´ T]$.
=ENDDOC

=DOC
val Ûabc_canonÝ: CANON;
=DESCRIBE
A CANON for stripping theorems for backward chaining (used by $abc\_tac$ q.v.).
It removes universal quantifiers, splits conjunctions into two, undisharges implications repeatedly until these can no longer be done, then it discarges all the assumptions and closes the result.
=ENDDOC

=DOC
val Ûabc_tacÝ: THM list -> TACTIC;
val Ûasm_abc_tacÝ: THM list -> TACTIC;
=DESCRIBE
A backchaining tactic which preprocesses theorems using $abc\_canon$ and then repeatedly backchains, terminating only if the conclusion can be reduced to $T$ and discharged.
The $asm\_$ version uses the assumptions as rules or for reducing the conclusion to $T$.
=ENDDOC

=SML
end; (* of signature rbjmisc *)
=TEX

=DOC
signature ÛUnifyForwardChainÝ = sig
=DESCRIBE
This is the signature of facilities for forward chaining based on unification rather than matching.
=ENDDOC

=DOC
val Ûsimple_´_unify_fc_rule1Ý: THM -> (TERM * TERM list * TYPE list)
	-> (TERM * TERM list * TYPE list)
	* ((TERM * TERM) list * (TYPE * TYPE) list)
	* (unit -> THM);
=DESCRIBE


In $simple\_´\_unify\_bc\_rule1 thm (tm, tml, tyl)$, $thm$ must be a theorem which is quantified implication and a $tm$ a term whose body (after stripping quantifiers) is unifiable with the conclusion of the implication by instantiating type variables $tyl$ and terms $tml$.
It unifies the stripped term with the conclusion of the theorem, applies the unifying substitutions to the theorem and returns the most general specialisation of the theorem in which the conclusion is unifiable with the term.
=ENDDOC

=DOC
val Û´_unify_fc_ruleÝ : THM -> THM -> THM ;
=DESCRIBE
A unifying Modus Ponens rule for an implicative theorem.
=FRULE 1 Rule
´_unify_mp_rule
÷
‡1 ô µ x1 ...· t1 ´ t2; ‡2 ô µ y1 ...· t1'
÷
‡1' À ‡2 ô µ y1 ...· t2'
=TEX
where we type instantiate, generalise and specialise
to get the first theorem's antecedent to match the conclusion of the
second theorem.
Universal quantification, or the lack of it, in the first theorem makes no difference to the matching.

This may be partially evaluated with only the first argument.
=SEEALSO
$´\_unify\_mp\_rule1$, $´\_match\_mp\_rule$, $´\_elim$
=FAILURE
7044	Cannot match ?0 and ?1
=ENDDOC
=DOC
val Û´_unify_mp_rule1Ý : THM -> THM -> THM ;
=DESCRIBE
A matching Modus Ponens rule for an implicative theorem.
=FRULE 1 Rule
´_unify_mp_rule
÷
‡1 ô µ x1 ...· t1 ´ t2; ‡2 ô µ y1 ...· t1'
÷
‡1 À ‡2 ô µ z1 ...· t2'
=TEX
where $t1'$ is unifiable with $t1$ under type instantiation
and substitution for the $x‰i$ in $t1$, the and $y‰i$ in $t1'$ and instantiation of the type variables in $t1$ which do not occur in ‡1 and those in $t1'$ which do not occur in ‡2, and where $t2'$
is obtained from $t2$ by appliying to it the substitution to $t1$ required for its unification.
No type instantiation or substitution will occur in the assumptions of either
theorem.
=FAILURE
7044	Cannot match ?0 and ?1
7045	?0 is not of the form `‡ ô µ x1 ... xn · u ´ v`
=ENDDOC

=DOC
val Ûunify_forward_chain_ruleÝ : THM list -> THM list -> THM list;
val Ûufc_ruleÝ : THM list -> THM list -> THM list;
=DESCRIBE
This is a rule which uses a list of possibly universally
quantified implications and a list of
other theorems to infer new theorems, using
=INLINEFT
´_unify_mp_rule1
. (
=INLINEFT
ufc_rule
=TEX
\ is an alias for
=INLINEFT
unify_forward_chain_rule
=TEX
.)
=INLINEFT
ufc_rule imps ants
=TEX
\ returns the list of all theorems which may be derived by
applying
=INLINEFT
´_unify_mp_rule1
=TEX
\ to a theorem from $imps$ and one from $ants$.
As a special case, if any theorem to be returned is determined
to have $¬F®$ as its conclusion, the first such found wil be returned as a singleton list.
In order to work well in conjunction with
=INLINEFT
fc_canon
=TEX
\ and
=INLINEFT
ufc_tac
=TEX
\ the theorems returned by
=INLINEFT
´_unify_mp_rule1
=TEX
\ are transformed as follows:

\begin{enumerate}
\item
Theorems of the form:
=INLINEFT
ô µ x‰1 ...· t‰1 ´ t‰2 ´ ... ´ ³t‰k ´ F
=TEX
\ have their final implication changed to
=INLINEFT
t‰k
=TEX
.
\item
Theorems of the form:
=INLINEFT
ô µ x‰1 ...· t‰1 ´ t‰2 ´ ... ´ t‰k ´ F
=TEX
\ have their final implication changed to
=INLINEFT
´\³t‰k
=TEX
.
\item
All theorems are universally quantified over all the variables which
appear free in their conclusions but not in their assumptions
(using
=INLINEFT
all_µ_intro
=TEX
).
\end{enumerate}
Note that the use of
=INLINEFT
´_unify_mp_rule1
=TEX
\ gives some control over the number of results generated, since
variables which appear free in $imps$ are not considered as candidates
for instantiation.

The rule does not check that the theorems in its first argument
are (possible universally) quantified implications.
Theorems which are not of this form will be ignored.
=SEEALSO
$unify\_forward\_chain\_tac$, $forward\_chain\_canon$.
=ENDDOC

=DOC
val Ûunify_forward_chain_tacÝ : THM list -> TACTIC;
val Ûufc_tacÝ : THM list -> TACTIC;
val Ûall_unify_forward_chain_tacÝ : THM list -> TACTIC;
val Ûall_ufc_tacÝ : THM list -> TACTIC;
val Ûasm_unify_forward_chain_tacÝ : THM list -> TACTIC;
val Ûasm_ufc_tacÝ : THM list -> TACTIC;
val Ûall_asm_unify_forward_chain_tacÝ : THM list -> TACTIC;
val Ûall_asm_ufc_tacÝ : THM list -> TACTIC;
=DESCRIBE
These are tactics which use theorems whose conclusions are
implications, or from which implications can be derived using
the canonicalisation function
=INLINEFT
fc_canon
=TEX
, q.v., to reason forwards from the assumptions of a goal. (The names
with
=INLINEFT
ufc
=TEX
\ are aliases for the corresponding ones with
=INLINEFT
unify_forward_chain
=TEX
.)

The basic step is to take a theorem of the form
=INLINEFT
‡ ô t1 ´ t2
=TEX
\ and an assumption of the form
=INLINEFT
t1'
=TEX
\ where $t1'$ is unifiable with $t1$ and to deduce the
corresponding instance of $t2'$. The new theorem,
=INLINEFT
„ ô t2'
=TEX
\ say, may then be stripped into the assumptions.

In the case of
=INLINEFT
ufc_tac
=TEX
\ the implicative theorem is always derived from the list
of theorems given as an argument.
In the case of
=INLINEFT
asm_ufc_tac
=TEX
\ the assumptions are also used.
In all of the tactics the rule 
=INLINEFT
ufc_canon
=TEX
\ is used to derive an implicative canonical form from the
candidate implicative theorems.
Normally combination of an implicative theorem and an assumption
is then tried in turn and all resulting theorems are stripped into
the assumptions of the goal.
However, if the chaining results contain a theorem whose conclusion is ¬F® then the first such found will be stripped
into the assumptions, and all other theorems discarded.

If one of the implications has the form
=INLINEFT
t1 ´ t2 ´ t3
=TEX
\ or
=INLINEFT
t1 ± t2 ´ t3
=TEX
\ and if assumptions matching $t1$ and $t2$ are available,
=INLINEFT
ufc_tac
=TEX
\ or
=INLINEFT
asm_ufc_tac
=TEX
\ will derive an intermediate implication
=INLINEFT
t2 ´ t3
=TEX
\ and
=INLINEFT
asm_ufc_tac
=TEX
\ could then be used to derive $t3$.
The variants with $all\_$ may be used to derive $t3$ directly without
generating any intermediate implications in the assumptions.
They work like the corresponding tactic without $all\_$ but any theorems
which are derived which are themselves implications are not stripped into
the assumptions but instead are used recursively to derive further theorems.
When no new implications are derivable all of the non-implicative theorems
derived during the process are stripped into the assumptions.

Note that the use of
=INLINEFT
fc_canon
=TEX
\ implies that conversions from the
proof context are applied to generate implications.
E.g., in an appropriate proof-context covering set theory,
=INLINEFT
a € b
=TEX
\ might be treated as the implication
=INLINEFT
µx·x  a ´ x  b
=TEX
.
Also variables which appear free in a theorem are not considered as candidates
for instantiation
(in order to give some control over the number of results generated).
The tacticals,
=INLINEFT
UFC_T1
=TEX
\ and 
=INLINEFT
ASM_UFC_T1
=TEX
\ may be used to avoid the use of
=INLINEFT
fc_canon
=TEX
.

For example, the tactic:
=GFT
asm_ufc_tac[] THEN asm_ufc_tac[]
=TEX
will prove the goal:
=GFT
{p x, µx·p x ´ q x, µx·q x ´ r x} r x.
=TEX
=SEEALSO
$bc\_tac$,
$UFC\_T$,
$ASM\_UFC\_T$,
$UFC\_T1$,
$ASM\_UFC\_T1$.
=ENDDOC

=DOC
val ÛUNIFY_FORWARD_CHAIN_TÝ :
	(THM list -> TACTIC) -> THM list -> TACTIC;
val ÛUFC_TÝ :
	(THM list -> TACTIC) -> THM list -> TACTIC;
val ÛALL_UNIFY_FORWARD_CHAIN_TÝ :
	(THM list -> TACTIC) -> THM list -> TACTIC;
val ÛALL_UFC_TÝ :
	(THM list -> TACTIC) -> THM list -> TACTIC;
val ÛASM_UNIFY_FORWARD_CHAIN_TÝ :
	(THM list -> TACTIC) -> THM list -> TACTIC;
val ÛASM_UFC_TÝ :
	(THM list -> TACTIC) -> THM list -> TACTIC;
val ÛALL_ASM_UNIFY_FORWARD_CHAIN_TÝ :
	(THM list -> TACTIC) -> THM list -> TACTIC;
val ÛALL_ASM_UFC_TÝ :
	(THM list -> TACTIC) -> THM list -> TACTIC;
=DESCRIBE
These are tacticals which use theorems whose conclusions are
implications, or from which implications can be derived,
to reason forwards from the assumptions of a goal.
(The tacticals with
=INLINEFT
UFC
=TEX
\ are aliases for the corresponding ones with
=INLINEFT
UNIFY_FORWARD_CHAIN
=TEX
.)

The description of 
=INLINEFT
ufc_tac
=TEX
\ should be consulted for the basic forward chaining algorithms used.
The significance of the final argument and of the presence or absence of
=INLINEFT
ASM
=TEX
\ and
=INLINEFT
ALL
=TEX
\ in the name is exactly as for
=INLINEFT
ufc_tac
=TEX
\ and its relatives.

The tacticals allow variation of
the tactic generating function used to process the theorems derived
by the forward inference.
The tactic generating function to be used is given as the first
argument.

\paragraph{Examples}
=INLINEFT
ufc_tac
=TEX
\ is the same as:
=INLINEFT
UFC_T (MAP_EVERY strip_asm_tac)
=TEX
.

To rewrite the goal with the results of the forward inference one
could use
=INLINEFT
UFC_T rewrite_tac
=TEX
.
=SEEALSO
$ufc\_tac$, $asm\_ufc\_tac$, $UFC\_T1$.
=ENDDOC

=DOC
val ÛUNIFY_FORWARD_CHAIN_T1Ý :
	(THM -> THM list) -> (THM list -> TACTIC) -> THM list -> TACTIC;
val ÛFC_T1Ý :
	(THM -> THM list) -> (THM list -> TACTIC) -> THM list -> TACTIC;
val ÛALL_UNIFY_FORWARD_CHAIN_T1Ý :
	(THM -> THM list) -> (THM list -> TACTIC) -> THM list -> TACTIC;
val ÛALL_UFC_T1Ý :
	(THM -> THM list) -> (THM list -> TACTIC) -> THM list -> TACTIC;
val ÛASM_UNIFY_FORWARD_CHAIN_T1Ý : 
	(THM -> THM list) -> (THM list -> TACTIC) -> THM list -> TACTIC;
val ÛASM_UFC_T1Ý : 
	(THM -> THM list) -> (THM list -> TACTIC) -> THM list -> TACTIC;
val ÛALL_ASM_UNIFY_FORWARD_CHAIN_T1Ý : 
	(THM -> THM list) -> (THM list -> TACTIC) -> THM list -> TACTIC;
val ÛALL_ASM_UFC_T1Ý : 
	(THM -> THM list) -> (THM list -> TACTIC) -> THM list -> TACTIC;
=DESCRIBE
These are tacticals which use theorems whose conclusions are
implications, or from which implications can be derived,
to reason forwards from the assumptions of a goal.
(The tacticals with
=INLINEFT
FC
=TEX
\ are aliases for the corresponding ones with
=INLINEFT
FORWARD_CHAIN
=TEX
.)

The description of 
=INLINEFT
fc_tac
=TEX
\ should be consulted for the basic forward chaining algorithms used.
The significance of the final argument and of the presence or absence of
=INLINEFT
ASM
=TEX
\ and
=INLINEFT
ALL
=TEX
\ in the name is exactly as for
=INLINEFT
fc_tac
=TEX
\ and its relatives.

The tacticals allow variation of the canonicalisation function
used to obtain implications from the argument theorems and of
the tactic generating function used to process the theorems derived
by the forward inference.
The canonicalisation function to use is the first argument
and the tactic generating function is the second.
(Related tacticals with names ending in
=INLINEFT
T
=TEX
\ rather than
=INLINEFT
T1
=TEX
\ are also available for the simpler case when
wants to use the same canonicalisation function as
=INLINEFT
fc_tac
=TEX
\ and just to vary the tactic generating function.)

\paragraph{Examples}

If the theorem argument comprises only implications
which are to be used without canonicalisation, one might use:
=INLINEFT
FC_T1 id_canon (MAP_EVERY strip_asm_tac)
=TEX
.

If one has an instance of $t1$ as an assumption and one wishes to
use the bi-implication in a theorem of the form
=INLINEFT
ô t1 ´ (t2 ¤ t3)
=TEX
\ for rewriting, one might use
=INLINEFT
FC_T1 id_canon rewrite_tac
=TEX
.

=SEEALSO
$fc\_tac$, $asm\_fc\_tac$, $bc\_tac$, $FC\_T$.
=ENDDOC

=SML
end; (* of signature UnifyingForwardChaining *)
=TEX
\section{Some SML procedures}

\subsection{Force New Theory}

This is just to save the exception handling which otherwise has to appear at the top of every document which creates a \Product theory.

First for deleting the old theory (from your previous build) and starting the theory afresh.

=SML
fun Ûforce_new_theoryÝ name =
  let val _ = force_delete_theory name handle _ => ();
  in new_theory name
end;
=TEX

Then something similar for an associated proof context.

=SML
fun Ûforce_new_pcÝ name =
  let val _ = delete_pc name handle _ => ();
  in new_pc name
end;
=TEX

=IGN
fun add_pc_thms pc thms =
		(add_rw_thms thms pc;
		add_sc_thms thms pc;
 		add_st_thms thms pc);
=TEX

\subsection{Doing Consistency Proofs before Axiomatic Descriptions}

To avoid getting theory listings in which the definitions of some constants are given using $ConstSpec$ I like to do any necessary consistency proofs before introducing the definition which needs them.
For this to do any good, the automatic consistency prover has to know that I done it.

I therefore introduce a new value of type $ref THM$ called $xl\_consistency\_result$.
When I do a consistency proof, I store the resulting theorem in this location.

=SML
val xl_consistency_result = ref t_thm;
=TEX

When I do a consistency proof, I store the resulting theorem in this location.
I use the following function to do that, to hide the implementation details.

=SML
fun xl_set_cs_¶_thm thm = (xl_consistency_result := thm);
=TEX

I also have a special partial proof context with a consistency prover which knows to look for the consistency proof in this special place.
This is the consistency prover:

=SML
open_theory "basic_hol";
set_pc "basic_hol";

local fun eq_refl_conv t = prove_rule [] (mk_eq (t,t))
in 
 fun xl_cs_¶_conv x =
	if x =$ (concl(!xl_consistency_result))
	then (¤_t_intro (!xl_consistency_result)) handle _ => eq_refl_conv x
	else eq_refl_conv x
end;
=TEX

and here's the proof context containing it:

=SML
force_new_pc "xl_cs_¶_conv";
set_cs_¶_convs [xl_cs_¶_conv] "xl_cs_¶_conv";
set_pr_conv basic_prove_conv "xl_cs_¶_conv";
set_pr_tac basic_prove_tac "xl_cs_¶_conv";
commit_pc "xl_cs_¶_conv";
=TEX

Then we go back to the $hol$ theory.

=SML
open_theory "hol";
set_pc "hol";
=TEX

\subsection{Sundry Tacticals etc.}

Some functions which turn round equations before using them.

=SML
fun Ûlist_eq_sym_ruleÝ thms = map (fn th => eq_sym_rule th handle _=> th) thms;
fun ÛSYM_ASMS_TÝ tltt = GET_ASMS_T (tltt o list_eq_sym_rule);
fun Ûtop_eq_sym_ruleÝ thm = conv_rule (ONCE_MAP_C eq_sym_conv) thm;
=TEX

For rewriting with definitions which abstract over pairs:

=SML
fun Ûsplit_pair_ruleÝ t = prove_rule [] ¬‘t® = (Fst ‘t®, Snd ‘t®)®;
fun Ûsplit_pair_rewrite_tacÝ tl thms =
	pure_once_rewrite_tac (map split_pair_rule tl)
	THEN TRY (pure_rewrite_tac thms);
=TEX

Some functions for chaining with equivalence theorems:

=SML
fun ÛALL_UFC_¤_TÝ tt = ALL_UFC_T1 fc_¤_canon tt;
fun Ûall_ufc_¤_tacÝ thms = ALL_UFC_¤_T (MAP_EVERY strip_asm_tac) thms;
=TEX

\ignore{
=SML
(* fun list_concat l = foldr (op @) [] l *);

val list_concat = flat;

fun (rule_canon: (THM -> THM) -> CANON) rule thm = [rule thm];

fun (´_T_canon:CANON) thm =
	if is_´ ((snd o strip_µ) (concl thm))
	then [thm]
	else [´_intro ¬T® thm];

val (all_´_intro_canon:CANON) = rule_canon all_´_intro;

val abc_canon =
	REPEAT_CAN (
		simple_µ_rewrite_canon
		ORELSE_CAN (rule_canon undisch_rule)
		ORELSE_CAN ±_rewrite_canon)
	THEN_CAN all_´_intro_canon
	THEN_CAN ´_T_canon;

fun abc_tac thml =
	let val thms = list_concat (map abc_canon thml)
	in REPEAT (accept_tac t_thm ORELSE (bc_tac thms))
	end;

fun asm_abc_tac thml (asms, conc) =
	abc_tac (thml @ (map asm_rule asms)) (asms, conc);
=IGN
val sets_ext_rule = pure_rewrite_rule [sets_ext_clauses];

val €_ext_canon = rule_canon (pure_once_rewrite_rule [sets_ext_clauses]);
fun gen_€_induct_rule thm term = (µ_elim (mk_app (¬$SetComp®, term)) thm);

fun spec_canon term = rule_canon (µ_elim term);
val €_induction_canon = 
	REPEAT_CAN (
		simple_µ_rewrite_canon
		ORELSE_CAN (rule_canon undisch_rule)
		ORELSE_CAN ±_rewrite_canon)
	THEN_CAN €_ext_canon
	THEN_CAN all_´_intro_canon;
fun €_induction_tac thm term:TACTIC = fn (asms, concl) =>
	let val thm1 = µ_elim (mk_set_comp (term, concl)) thm
	in (bc_tac (€_induction_canon thm1)) (asms, concl)
	end;
=TEX
}%ignore

A tactic for normal form conversion of real expressions.
=SML
val ¯_anf_tac = conv_tac (TOP_MAP_C ¯_anf_conv);
=TEX

=IGN
strip_´_rule;
strip_±_rule;
all_µ_elim;
THEN_CAN;
ORELSE_CAN;
REPEAT_CAN;
=TEX

Normal form conversion tactic for real expressions:

=IGN
val ¯_top_anf_tac = conv_tac (TOP_MAP_C ¯_anf_conv);
=TEX

\subsection{Unifying Chaining}

Some of the material used in implementing the Resolution structure but not exposed by it is of value here and so is copied, pro-tem, from that module.

=SML
open_theory "basic_hol";
=TEX

In $unify\_´\_mp_rule$ the two theorems will be unified as necessary to permit inference by modus ponens.
Only variables universally quantified at the outer level will be candidates for instantiation, and in each of the premises only type variables which do not appear in the assumptions will be elegible for instantiation.
The two theorems are stripped of their outer universal quantifiers and the antecedent of the first (which must be an implication) will then be unified with the second.
If this suceeds the consequent is inferred and any of the variables which were previously quantified over but now appear free in the conclusion are universally bound.

\ignore{
=SML
local open Resolution; open Unification
in
fun Ûsimple_´_unify_mp_rule1Ý ith ath =
 let	val s1 = ´_elim ith ath;
 in
	s1
 end handle (Fail _) =>
	let
	val (iasms, iconc) = dest_thm ith;
	val (aasms, aconc) = dest_thm ath;
	fun ttys t =  map mk_vartype (term_tyvars t);
	fun ittys (asms, conc) =  (ttys conc) drop
		(fn x => present (op =:) x (list_union (op =:) (map ttys asms)));
	val iityvs = ittys (iasms, iconc);
	val aityvs = ittys (aasms, aconc);
	val (ivars, barei) = strip_µ iconc;
	val (avars, barea) = strip_µ aconc;
	val (a1, c) = dest_´ barei;
	val fvs = ivars @ avars;
	val subs = new_subs 40;
	val ((ityi, ites) , (atyi, ates)) = term_unify subs [] [] (
			(a1, ivars, iityvs),
			(barea, avars, aityvs)
		);
	val _ = init_subs subs;
	fun laux [] t = t
	|   laux ((nt1, t1)::tl) t = if t1 =$ t then nt1 else laux tl t;
	val ites2 = map (laux ites) ivars;
	val ates2 = map (laux ates) avars;
	val ni = list_µ_elim ites2 (inst_type_rule ityi ith);
	val na = list_µ_elim ates2 (inst_type_rule atyi ath);
	val othm = ´_elim ni na;
	val ccfrees = frees (concl othm);
	val cafrees = list_union (op =$) (map frees (asms othm));
	val bindvars = ccfrees drop (fn x => (present (op =$) x cafrees))
	in (list_µ_intro bindvars othm)
	end
end;
=IGN
simple_´_unify_mp_rule1 (asm_rule ¬a ´ b®) (asm_rule ¬a:BOOL®);
simple_´_unify_mp_rule1 (asm_rule ¬µx v· ((Ìz·z)x, v) = y ´ x®) (asm_rule ¬µa b· ((Ìq·q)a:BOOL, b)=y®);
simple_´_unify_mp_rule1 (asm_rule ¬µ y x $<< X· Snd (TranClsr (X, $<<)) x y ´ ³ x  X ´ F®)
		 (asm_rule ¬Snd (TranClsr (X, $<<)) x'' x'®);
simple_´_unify_mp_rule1 (asm_rule ¬µx y (X:'a SET)· x  X ´ y  X ´ {x; y}  ð X®)
	(asm_rule ¬(y:'a)  X®);
=SML
val Ûall_µ_uncurry_ruleÝ = conv_rule(TRY_C all_µ_uncurry_conv);

fun Û´_unify_mp_rule1Ý (thm1 : THM) : THM -> THM = (
let	val thm1' = all_µ_uncurry_rule thm1;
	val r' = simple_´_unify_mp_rule1 thm1'
		handle complaint =>
		pass_on complaint "simple_´_unify_mp_rule1"
			"´_unify_mp_rule1";
in
	(fn (thm2 : THM) =>
	r' thm2
	handle complaint => reraise complaint "´_unify_mp_rule1")
end);
=IGN
´_unify_mp_rule1 (asm_rule ¬µ(x, y):î ¸ î· y = x * x ´ y ¾ 0 ± q®) (asm_rule ¬µv w q:î· v = w * w®);
´_unify_mp_rule1 (asm_rule ¬µ(x, y):î ¸ î· y = x * x ´ y ¾ 0 ± q®) (asm_rule ¬µv w q:î· v = w * w®);
´_unify_mp_rule1 (asm_rule ¬µ y x $<< X· Snd (TranClsr (X, $<<)) x y ´ ³ x  X ´ F®)
		 (asm_rule ¬Snd (TranClsr (X, $<<)) x'' x'®);
´_unify_mp_rule1 ((hd o fc_canon o asm_rule) ¬µ X $<< G (x:'a)
           · x  X ± UniquePartFixp (TcUpTo (X, $<<) x) G
               ´ (µ f· PartFunEquiv (TcUpTo (X, $<<) x) (G f) f ´ UniqueVal (X, $<<) G x = f x)®)
	(asm_rule ¬x''  (X:'a SET)®);
´_unify_mp_rule1 (asm_rule ¬µ(x, y) (X:'a SET)· x  X ´ y  X ´ {x; y}  ð X®)
	(asm_rule ¬(y:'a)  X®);
=SML
local
val Û³_convsÝ = map
	(fn t => simple_eq_match_conv1
		(all_µ_intro (tac_proof(([], t), simple_taut_tac))))
	[¬³t ´ F ¤ t®, ¬t ´ F ¤ ³t®];
in
fun Ûunify_forward_chain_ruleÝ (imps : THM list) (ants : THM list) : THM list = (
let	val imp_rules = mapfilter ´_unify_mp_rule1 imps;
	fun aux1 acc _ [] = (acc
	) | aux1 acc (i :: il) (al as (a :: _)) = (
		(let val res = i a
		in
		if concl res =$ mk_f
		then [res]
		else
		(aux1 (res::acc) il al)
		end)
		handle Fail _ => aux1 acc il al
	) | aux1 acc [] (_ :: al) = (aux1 acc imp_rules al
	);
	fun aux2 thm = (
		case dest_term (concl thm) of
			Dµ (x, b) => (
				let val th = aux2 (asm_rule b);
				in µ_intro x (prove_asm_rule (µ_elim x thm) th)
				end
		) |	D´ (a, b) => (
				(conv_rule(FIRST_C ³_convs) thm)
				handle Fail _ =>
				let val th = aux2 (asm_rule b);
				in ´_intro a (prove_asm_rule(undisch_rule thm) th)
				end
		) |	_ => fail "" 99999 []
	);
	fun aux3 th = aux2 th handle Fail _ => th;
in	map aux3 (aux1 [] imp_rules ants)
end);
end;

val Ûufc_ruleÝ : THM list -> THM list -> THM list = unify_forward_chain_rule;

=IGN
ufc_rule [(asm_rule ¬µ(x, y):î ¸ î· y = x * x ´ y ¾ 0 ± q®)] [(asm_rule ¬µv w q:î· v = w * w®)];
ufc_rule [(asm_rule ¬µ y x $<< X· Snd (TranClsr (X, $<<)) x y ´ x  X®)]
		 [(asm_rule ¬Snd (TranClsr (X, $<<)) x'' x'®)];
ufc_rule [asm_rule¬µ X $<< G x
           · x  X ± UniquePartFixp (TcUpTo (X, $<<) x) G
               ´ (µ f· PartFunEquiv (TcUpTo (X, $<<) x) (G f) f ´ UniqueVal (X, $<<) G x = f x)®]
	[asm_rule ¬x''  X®,
	asm_rule ¬UniquePartFixp (TcUpTo (X, $<<) x'') G®];
ufc_rule [(asm_rule ¬µ(x, y) (X:'a SET)· x  X ´ y  X ´ {x; y}  ð X®)]
	[asm_rule ¬(y:'a)  X®];
ufc_rule [(asm_rule ¬µ(x:'a, y:'b) (X:'a SET) (Y:'b SET)· x  X ´ y  Y ´ {x, y}  ð (X ¸ Y)®)]
	[asm_rule ¬(y:'b)  X®];
ufc_rule [tac_proof (([], ¬µ(x:'a, y:'b) (X:'a SET) (Y:'b SET)· x  X ´ y  Y ´ {x, y}  ð (X ¸ Y)®),
	(REPEAT strip_tac
	THEN asm_rewrite_tac[sets_ext_clauses, get_spec ¬$¸®]
	THEN REPEAT strip_tac THEN asm_rewrite_tac[]))]
	[asm_rule ¬(y:'b)  X®];
ufc_rule [(asm_rule ¬µ(X:'a SET) (x:'a)· x  X ´ ¶y· y  X ´ {x, y}  ð (X ¸ X)®)]
	[asm_rule ¬(y:'a)  X®];
ufc_rule [(asm_rule ¬µ(X:'a SET) (x:'a)· ¶y· x  X ´ y  X ´ {x, y}  ð (X ¸ X)®)]
	[asm_rule ¬(y:'a)  X®];
=TEX

=SML
fun ÛUFC_T1Ý
	(can : THM -> THM list)
	(ttac : THM list -> TACTIC)
	(thms : THM list)
	: TACTIC = (fn gl as (asms, _) =>
	let	val asmthms = map asm_rule asms;
	in	ttac(ufc_rule(flat(map can thms)) asmthms) gl
	end
);
=TEX
=SML
fun ÛASM_UFC_T1Ý
	(can : THM -> THM list)
	(ttac : THM list -> TACTIC)
	(thms : THM list)
	: TACTIC = (fn gl as (asms, _) =>
	let	val asmthms = map asm_rule asms;
	in	ttac(ufc_rule(flat(map can (thms@asmthms))) asmthms) gl
	end
);

val ÛUFC_TÝ = UFC_T1 fc_canon;
val ÛASM_UFC_TÝ = ASM_UFC_T1 fc_canon;
val Ûufc_tacÝ : THM list -> TACTIC = UFC_T (MAP_EVERY strip_asm_tac);
val Ûasm_ufc_tacÝ : THM list -> TACTIC = ASM_UFC_T (MAP_EVERY strip_asm_tac);

fun ÛALL_UFC_T1Ý (can : CANON) (ttac : THM list -> TACTIC) (ths : THM list) : TACTIC = (
	let	fun aux1 acc [] = acc
		|   aux1 (imps, others) (th :: more) = (
			if is_´ (snd(strip_µ(concl th)))
			then aux1 (th :: imps, others) more
			else aux1 (imps, th :: others) more
		);
		fun aux2 acc imps = (
			UFC_T1 id_canon (fn thl =>
				let	val (imps, others) = aux1 ([], acc) thl;
				in	if	is_nil imps
					then	ttac others
					else	aux2 others imps
				end
			) imps
		);
		val ths' = flat (map can ths);
	in	aux2 [] (ths' drop (not o is_´ o snd o strip_µ o concl))
	end
);

fun ÛALL_ASM_UFC_T1Ý (can : CANON) (ttac : THM list -> TACTIC) (thms : THM list) : TACTIC = (
	GET_ASMS_T (fn asm_thms => ALL_UFC_T1 can ttac (thms @ asm_thms))
);
val ALL_UFC_T : (THM list -> TACTIC) -> THM list -> TACTIC = ALL_UFC_T1 fc_canon;
val Ûall_ufc_tacÝ : THM list -> TACTIC = ALL_UFC_T (MAP_EVERY strip_asm_tac);
fun ÛALL_ASM_UFC_TÝ (ttac : THM list -> TACTIC) (ths : THM list) : TACTIC = (
	GET_ASMS_T (fn thl => ALL_UFC_T ttac (thl @ ths))
);
val Ûall_asm_ufc_tacÝ : THM list -> TACTIC = ALL_ASM_UFC_T (MAP_EVERY strip_asm_tac);
=TEX
=SML
fun ÛALL_UFC_¤_TÝ tt = ALL_UFC_T1 fc_¤_canon tt;
fun Ûall_ufc_¤_tacÝ thms = ALL_UFC_¤_T (MAP_EVERY strip_asm_tac) thms;
=TEX
} %ignore

\subsection{Unifying Backchaining}

=SML
open_theory "hol";
force_new_theory "rbjmisc";
=TEX

The idea here is to get a significant improvement in proof development productivity by getting a lot more
of the necessary instantiation of intermediate results done automatically.

This is approached as a ``backchaining'' problem for two reasons:
\begin{enumerate}
\item the conclusion of the goal provides valuable information for constraining the search space
\item the assumption that a theorems will be used from left to right also helps avoid explosion of the  search space
\end{enumerate}

In fact, the approach we adopt here makes the search into the transformation of a single conjecture which initially grows in size as the problem is picked apart, but eventually collapses if a proof is successful.

\subsubsection{Rule Management}

The methods used for storing an retrieving rules have some significance for performance and effectiveness, though these are less important than the search strategy.
For example, to maximise performance in rule matching a unifying rule database would be possible, which efficiently retrieves all the rules which match a target term.

The purpose of this signature is to make a clean interface to the rule end of the backchaining so that an implementation of backchaining can start out rather crudely in this area and perhaps be improved later.

=DOC
signature ÛRuleManagerÝ = sig
=DESCRIBE
This is the signature of types and functions for managing and using a collection of rules for chaining.
At present oriented to back-chaining.
=ENDDOC

=DOC
type RULEDB
=DESCRIBE

=ENDDOC

=SML
end; (* of signature RuleManager *)
=TEX

\subsubsection{Search Management}


=DOC
signature ÛUnifyingBackchainingÝ = sig
=DESCRIBE

=ENDDOC

=DOC
val Ûunify_backchain_ruleÝ : (TYPE list) -> (TERM list)
	->	(THM * TERM list * TYPE list)
	->	(TERM * TERM list * TYPE list)
	-> 	THM * ((TYPE * TYPE) list * (TERM * TERM) list) *
   		((TYPE * TYPE) list * (TERM * TERM) list);
=DESCRIBE
This function is a variant on $term\_unify$ q.v. in which the first term to be unified is suppled as the right hand side of an implication which is the conclusion of some theorem.
In addition to the substitutions necessary to unify the two terms, the function returns the left had side of the implication after performing on it the unifying substitution for the right hand side, and a function which will infer the instantiated right hand side as a theorem from a theorem whose conclusion is the instantiated left hand side.

Thus from a theorem:
=GFT
thm =	asms ô lhs ´ rhs
=TEX
and a term $tm$:

=GFT
	unify_backchain_rule avtyl avtml (thm, tml1, tyl1) (tm, tml2, tyl2)
=TEX

yields $(thm2, (thmtytyl, thmtmtml), (tmtytyl, tmtmtml))$, where:

\begin{description}
\item[avtyl] is a list of type variables to be avoided
\item[avtml] is a list of term variables to be avoided
\item[thm] is a theorem whose conclusion is an implication the right hand side of which is to be unified with $tm$
\item[tml1] is the list of term variables which may be instantiated in $thm$
\item[tyl1] is the list of type variables which may be instantiated in $thm$
\item[tm] is a term to be unified with the right hand side of the implication in the conclusion of $thm$
\item[tml2] is the list of term variables which may be instantiated in $tm$
\item[tyl2] is the list of type variables which may be instantiated in $tm$
\item[thm2] is the instance of $tm$ resulting from application of the unifying substitution
\item[thmtytyl] is the list of pairs of types to be substituted in $thm$
\item[thmtmtml] is the list of pairs of term to be substituted in $thm$
\item[tmtytyl] is the list of pairs of types to be substituted in $tm$
\item[tmtmtml] is the list of pairs of term to be substituted in $tm$
\end{description}
=ENDDOC

=SML
end; (* signature UnifyingBackchaining *)
=TEX

=SML
structure UnifyingBackchaining: UnifyingBackchaining = struct
=TEX
...
\ignore{
=SML
local open Resolution; open Unification
in
fun unify_backchain_rule avtyl avtml (thm, tml1, tyl1) (tm, tml2, tyl2) =
	let
	val subs = new_subs 40;
	val (_, rhs) = (dest_´ o concl) thm;
	val ((thmtytyl, thmtmtml) , (tmtytyl, tmtmtml)) = term_unify subs avtyl avtml (
			(rhs, tml1, tyl1),
			(tm, tml2, tyl2)
		);
	val _ = init_subs subs;
	val thm2 = inst_term_rule thmtmtml (inst_type_rule thmtytyl thm);
	in (thm2, (thmtytyl, thmtmtml), (tmtytyl, tmtmtml))
	end
end;
=TEX
}%ignore
=SML
end;
open UnifyingBackchaining;
=TEX
=IGN
unify_backchain_rule [] []
	(all_µ_elim ¯_¼_antisym_thm, [¬x:¯®, ¬y:¯®], [])
	(¬v *‰R w = z®, [¬v:¯®, ¬w:¯®], []);
=TEX
=SML
datatype BCP = 
	BcDone
|	BcFailed
|	BcIncomplete;

datatype BCS =
	BcLeft
|	BcRight;

(* In a Back Chain Tree, think of 'a as a goal and 'b as a proof *)

datatype ('a, 'b) BCT =
	Bc± of BCP * ('a * ('a, 'b) BCT * ('a, 'b) BCT)
|	Bc² of BCP * ('a * BCS * ('a, 'b) BCT * ('a, 'b) BCT)
| 	BcRules of BCP * ('a * ('b * ('a, 'b) BCT) list)
| 	BcLeaf of BCP * 'a;

(* UARDB stands for Unifying & Anti-unifying Rule Data Base
It is a function which takes some target term and returns all the
rules which can be used to infer a term unifiable with the target,
together with the antiunifier of all the results, i.e. as much as
can be inferred about the result from the knowledge that it must
be proved by one of the selected rules.
*)

type ('a, 'b) UARDB = 'a -> ('b * ('a, 'b) BCT) list;

fun	bct2bcp (Bc± (x,y)) = x
|	bct2bcp (Bc² (x,y)) = x
|	bct2bcp (BcRules (x,y)) = x
|	bct2bcp (BcLeaf (x,y)) = x;

fun bcp_and (BcDone, BcDone)	= BcDone
|   bcp_and (BcFailed, _)		= BcFailed	
|   bcp_and (_, BcFailed)		= BcFailed	
|   bcp_and (_, _)		= BcIncomplete;	

fun bcp_or (BcDone, _)		= (BcDone, BcLeft)
|   bcp_or (_, BcDone)		= (BcDone, BcRight)
|   bcp_or (BcFailed, BcFailed)	= (BcFailed, BcLeft)	
|   bcp_or (_, _)			= (BcIncomplete, BcLeft);	

val bcp_or2 = fst o bcp_or;

=IGN

fun
  bct_map f (Bc± (bcp, (a, bct1, bct2))) =
	let	val bct1' = bct_map f bct1;
		val bct2' = bct_map f bct2;
	in (Bc± (bcp_and (bct2bcp bct1', bct2bcp bct2'), (a, bct1', bct2')))
	end
| bct_map f (Bc² (bcp, (a, bcs, bct1, bct2))) =
	let	val bct1' = bct_map f bct1;
		val bct2' = bct_map f bct2;
		val (bcp', bcs') = bcp_or (bct2bcp bct1', bct2bcp bct2');
	in (Bc² (bcp', (a, bcs', bct1', bct2')))
	end
| bct_map f (BcRules (bcp, (a, []))) = BcRules (bcp, (a, []))
| bct_map f (BcRules (bcp, (a, hr::trl))) =
	let	val (hprf, bcth) = hr;
		val bcth' = bct_map f bcth;
		val hr' = (hprf, bcth');
		val (BcRules (tbcp', (a', trl'))) = bct_map f (BcRules (bcp, (a, trl)));
	in (BcRules (bcp_or2 (bct2bcp bcth', tbcp'), (a, hr'::trl')))
	end
| bct_map f (BcLeaf (bcp, a)) = f a;


=TEX

\subsection{Trawling for Useful Theorems}

The following functions search the ancestors of the current theory for theorems which do something with the current goal, i.e. which rewrite the conclusion, backward chain from it, or forward chain from the assumptions.

I will supply some details here if I ever get these into a state fit for anyone else.

\ignore{
=IGN
set_goal([¬x ¼ y:î®], ¬µx y· Suc x > x + y®);
=SML
val avoid_theories = ref ["min", "log", "misc", "sets", "combin", "pair", "list"];
val avoid_constants = ref [""];
val avoid_specs: string list ref = ref [""];

datatype THMDET =
		Spec of TERM
	|	Thm of (string * string);

fun is_defined_constant s =
	let val theoryname = get_const_theory s;
	    val defn = get_defn theoryname s
	in true
	end
	handle _ => false;

fun defined_consts t =
	let val consts = term_consts t
	in filter
		(fn x => not ((fst x) mem !avoid_constants)
		andalso is_defined_constant (fst x))
	   consts
	end;

fun defined_const_names t = map fst (defined_consts t);

fun on_conc f = f (snd (top_goal()));

fun on_asms f =
	let val (asms, concl) = top_goal()
	in f asms
	end;

fun on_goal f =
	let val (asms, concl) = top_goal()
	in  list_concat(map f (concl :: asms))
	end;

fun term_const_specs t =
	let fun gs (s,t) =
		let val c = mk_const (s,t)
		in (if	s mem !avoid_specs orelse
			(get_const_theory s) mem !avoid_theories
		   then []
		   else [(Spec c, get_spec c)]) handle _ => []
		end
	in list_concat (map gs (term_consts t))
	end;

fun const_theories t = list_cup (map (fn x => [get_const_theory x]) (defined_const_names t));

fun ancestor_theories t = filter (fn x => not (x mem !avoid_theories)) (get_ancestors t);

fun thy_thms t = map (fn (s,thm) => (Thm(t, hd s), thm)) (get_thms t);

fun const_thms t = list_concat(map thy_thms (const_theories t));

fun ancestor_thms t = list_concat(map thy_thms (ancestor_theories t));

fun rewriting_thm t thm =
	let val t' = pure_once_rewrite_conv [thm] t
	in true
	end handle _ => false;

fun srewriting_thm t thm = rewriting_thm t (top_eq_sym_rule thm) handle _ => false;

fun fc_thm ts thm =
	let val thms = fc_rule (fc_canon thm) (map asm_rule ts)
	in (fn [] => false | _ => true) thms
	end handle _ => false;

fun all_fc_thm ts thm =
	let val (gl, pr) = all_fc_tac [thm] (ts, ¬F®)
	in if length gl = 1 andalso length (fst (hd gl)) = length ts
		then false else true
	end handle _ => false;

fun bc_thm c thm =
	let val (gl, pr) = bc_tac [thm] ([], c)
	in if length gl = 1 andalso (snd (hd gl)) =$ c
		then false else true
	end handle _ => false;

fun numthms n [] = []
|   numthms n ((thmdets, thm)::t) = ((n, thmdets), thm):: (numthms (n+1) t);

fun rew_specs t =
	let val thms = term_const_specs t
	in numthms 1 (filter ((rewriting_thm t) o snd) thms)
	end;

fun terml_const_specs tl = list_concat (map term_const_specs tl);

fun fc_specs ts =
	let val thms = terml_const_specs ts
	in numthms 1 (filter ((fc_thm ts) o snd) thms)
	end;

fun bc_specs t =
	let val thms = term_const_specs t
	in numthms 1 (filter ((bc_thm t) o snd) thms)
	end;

fun rew_thms t =
	let val thms = (ancestor_thms "-") @ (term_const_specs t)
	in numthms 1 (filter ((rewriting_thm t) o snd) thms)
	end;

fun srew_thms t =
	let val thms = (ancestor_thms "-") @ (term_const_specs t)
	in numthms 1 (filter ((srewriting_thm t) o snd) thms)
	end;

fun fc_thms tl =
	let val thms = (ancestor_thms "-") @ (terml_const_specs tl)
	in numthms 1 (filter ((fc_thm tl) o snd) thms)
	end;

fun all_fc_thms tl =
	let val thms = (ancestor_thms "-") @ (terml_const_specs tl)
	in numthms 1 (filter ((all_fc_thm tl) o snd) thms)
	end;

fun bc_thms t =
	let val thms = (ancestor_thms "-") @ (term_const_specs t)
	in numthms 1 (filter ((bc_thm t) o snd) thms)
	end;

fun rew_thms2 t =
	let val thms = (ancestor_thms "-") @ (term_const_specs t)
	in numthms 1 (list_concat (map (fn (sl, th) =>
		[(sl, (th, (snd o dest_eq)(concl (pure_once_rewrite_conv [th] t))))]
		handle _ => []) thms))
	end;

fun rew_thms3 t =
	let val thms = (ancestor_thms "-") @ (term_const_specs t)
	in numthms 1 (list_concat (map (fn (sl, th) =>
		[(sl, (snd o dest_eq)(concl (pure_once_rewrite_conv [th] t)))]
		handle _ => []) thms))
	end;

fun const_rewrite_conv t =
	let val thms = map snd (rew_thms t)
	in rewrite_conv thms t
	end;

fun with_conc_thms f =
	let fun ff t = f (map snd (rew_thms t))
	in on_conc ff
	end;

fun with_conc_specs f =
	let fun ff t = f (map snd (rew_specs t))
	in on_conc ff
	end;

fun td_thm (Thm (thyn, thmn)) = get_thm thyn thmn
|   td_thm (Spec s) = get_spec s;

fun td_thml tdl = map td_thm tdl;

fun numl2tdl tdsl nl =
 map (fn chose => (snd o fst o chose) tdsl) (map (fn n=> nth (n-1)) nl);

fun todo () =
	let val rw = length (on_conc rew_thms)
	    val bc = length (on_conc bc_thms)
	    val fc = length (on_asms fc_thms)
	in {rw = rw, bc = bc, fc = fc}
	end;
=TEX
}%ignore

\section{The Theory rbjmisc}

All the theorems are placed in the one temporary location, which therefore must have as ancestors all the theories which are being extended.

There is one section in this document, following this one, for each theory to which an addition is being made so new parents may be added in those sections, or new proof contexts used.

\section{Real numbers and Analysis}

=SML
new_parent"analysis";
set_merge_pcs["basic_hol1", "'sets_alg", "'¯", "xl_cs_¶_conv"];
=TEX

\subsection{Products}

=GFT
¯_prod_sign_iff_clauses 
ô (µ x y· î¯ 0 <‰R x *‰R y		¤ î¯ 0 <‰R x ± î¯ 0 <‰R y ² x <‰R î¯ 0 ± y <‰R î¯ 0)
± (µ x y· x *‰R y <‰R î¯ 0		¤ î¯ 0 <‰R x ± y <‰R î¯ 0 ² x <‰R î¯ 0 ± î¯ 0 <‰R y)
± (µ x y· î¯ 0 ¼‰R x *‰R y		¤ î¯ 0 ¼‰R x ± î¯ 0 ¼‰R y ² x ¼‰R î¯ 0 ± y ¼‰R î¯ 0)
± (µ x y· x *‰R y ¼‰R î¯ 0		¤ î¯ 0 ¼‰R x ± y ¼‰R î¯ 0 ² x ¼‰R î¯ 0 ± î¯ 0 ¼‰R y)
± (µ x y· x *‰R y = î¯ 0		¤ x = î¯ 0 ² y = î¯ 0)
± (µ x y· î¯ 0 = x *‰R y		¤ x = î¯ 0 ² y = î¯ 0)
=TEX

\ignore{
=SML
set_goal([], ¬µ x y·
	(î¯ 0 <‰R x ± î¯ 0 <‰R y ´ î¯ 0 <‰R x *‰R y)
	± (x <‰R î¯ 0 ± y <‰R î¯ 0 ´ î¯ 0 <‰R x *‰R y)
	± (x <‰R î¯ 0 ± î¯ 0 <‰R y ´ x *‰R y <‰R î¯ 0)
	± (î¯ 0 <‰R x ± y <‰R î¯ 0 ´ x *‰R y <‰R î¯ 0)
	± (x = î¯ 0 ² y = î¯ 0 ´ x *‰R y = î¯ 0)
®);
a (REPEAT strip_tac
	THEN TRY (asm_rewrite_tac[]));
(* *** Goal "1" *** *)
a (all_asm_fc_tac [¯_0_less_0_less_times_thm]);
(* *** Goal "2" *** *)
a (all_asm_fc_tac [¯_less_0_less_thm]);
a (LEMMA_T ¬î¯ 0 <‰R (~‰R x) *‰R (~‰R y)® ante_tac
	THEN1 all_asm_fc_tac [¯_0_less_0_less_times_thm]);
a (rewrite_tac(td_thml[Thm ("\175", "\175_times_minus_thm")]));
(* *** Goal "3" *** *)
a (once_rewrite_tac [¯_less_0_less_thm]);
a (rewrite_tac[]);
a (lemma_tac ¬î¯ 0 <‰R (~‰R x)®
	THEN1 (ALL_ASM_FC_T (MAP_EVERY ante_tac) [¯_less_0_less_thm]
		THEN rewrite_tac[]
		THEN REPEAT strip_tac));
a (all_asm_fc_tac [¯_0_less_0_less_times_thm]);
a (lemma_tac ¬~‰R (x *‰R y) = ~‰R x *‰R y®
	THEN1 (PC_T1 "¯_lin_arith" prove_tac[]));
a (asm_rewrite_tac[]);
(* *** Goal "4" *** *)
a (once_rewrite_tac [¯_less_0_less_thm]);
a (rewrite_tac[]);
a (lemma_tac ¬î¯ 0 <‰R (~‰R y)®
	THEN1 (ALL_ASM_FC_T (MAP_EVERY ante_tac) [¯_less_0_less_thm]
		THEN rewrite_tac[]
		THEN REPEAT strip_tac));
a (all_asm_fc_tac [¯_0_less_0_less_times_thm]);
a (lemma_tac ¬~‰R (x *‰R y) = x *‰R ~‰R y®
	THEN1 (PC_T1 "¯_lin_arith" prove_tac[]));
a (asm_rewrite_tac[]);
val ¯_product_sign_lemma = pop_thm ();
=TEX
=SML
set_goal([], ¬µ x y·
	(î¯ 0 <‰R x *‰R y ´ î¯ 0 <‰R x ± î¯ 0 <‰R y ² x <‰R î¯ 0 ± y <‰R î¯ 0)
	± (x *‰R y <‰R î¯ 0 ´ î¯ 0 <‰R x ± y <‰R î¯ 0 ² î¯ 0 <‰R y ± x <‰R î¯ 0)
	± (x *‰R y = î¯ 0 ´ x = î¯ 0 ² y = î¯ 0)
®);
a contr_tac;
(* *** Goal "1" *** *)
a (strip_asm_tac (list_µ_elim [¬x®, ¬î¯ 0®] ¯_less_cases_thm));
a (DROP_NTH_ASM_T 4 ante_tac THEN asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a (strip_asm_tac (list_µ_elim [¬x®, ¬î¯ 0®] ¯_less_cases_thm));
(* *** Goal "2.1" *** *)
a (strip_asm_tac (list_µ_elim [¬y®, ¬î¯ 0®] ¯_less_cases_thm));
(* *** Goal "2.1.1" *** *)
a (DROP_NTH_ASM_T 5 ante_tac THEN asm_rewrite_tac[]);
(* *** Goal "2.1.2" *** *)
a (all_asm_fc_tac[¯_product_sign_lemma]);
a (all_asm_fc_tac[¯_less_trans_thm]);
(* *** Goal "2.2" *** *)
a (DROP_NTH_ASM_T 4 ante_tac THEN asm_rewrite_tac[]);
(* *** Goal "3" *** *)
a (strip_asm_tac (list_µ_elim [¬y®, ¬î¯ 0®] ¯_less_cases_thm));
(* *** Goal "3.1" *** *)
a (strip_asm_tac (list_µ_elim [¬x®, ¬î¯ 0®] ¯_less_cases_thm));
(* *** Goal "3.1.1" *** *)
a (DROP_NTH_ASM_T 5 ante_tac THEN asm_rewrite_tac[]);
(* *** Goal "3.1.2" *** *)
a (all_asm_fc_tac[¯_product_sign_lemma]);
a (all_asm_fc_tac[¯_less_trans_thm]);
(* *** Goal "3.2" *** *)
a (DROP_NTH_ASM_T 4 ante_tac THEN asm_rewrite_tac[]);
(* *** Goal "4" *** *)
a (strip_asm_tac (list_µ_elim [¬y®, ¬î¯ 0®] ¯_less_cases_thm));
a (DROP_NTH_ASM_T 4 ante_tac THEN asm_rewrite_tac[]);
(* *** Goal "5" *** *)
a (strip_asm_tac (list_µ_elim [¬x®, ¬î¯ 0®] ¯_less_cases_thm));
(* *** Goal "5.1" *** *)
a (strip_asm_tac (list_µ_elim [¬y®, ¬î¯ 0®] ¯_less_cases_thm));
(* *** Goal "5.1.1" *** *)
a (all_asm_fc_tac[¯_product_sign_lemma]);
a (all_asm_fc_tac[¯_less_trans_thm]);
(* *** Goal "5.1.2" *** *)
a (DROP_NTH_ASM_T 5 ante_tac THEN asm_rewrite_tac[]);
(* *** Goal "5.2" *** *)
a (DROP_NTH_ASM_T 4 ante_tac THEN asm_rewrite_tac[]);
(* *** Goal "6" *** *)
a (strip_asm_tac (list_µ_elim [¬x®, ¬î¯ 0®] ¯_less_cases_thm));
a (DROP_NTH_ASM_T 4 ante_tac THEN asm_rewrite_tac[]);
(* *** Goal "7" *** *)
a (strip_asm_tac (list_µ_elim [¬y®, ¬î¯ 0®] ¯_less_cases_thm));
a (DROP_NTH_ASM_T 4 ante_tac THEN asm_rewrite_tac[]);
(* *** Goal "8" *** *)
a (strip_asm_tac (list_µ_elim [¬y®, ¬î¯ 0®] ¯_less_cases_thm));
(* *** Goal "8.1" *** *)
a (strip_asm_tac (list_µ_elim [¬x®, ¬î¯ 0®] ¯_less_cases_thm));
(* *** Goal "8.1.1" *** *)
a (DROP_NTH_ASM_T 5 ante_tac THEN asm_rewrite_tac[]);
(* *** Goal "8.1.2" *** *)
a (DROP_NTH_ASM_T 5 ante_tac THEN asm_rewrite_tac[]);
(* *** Goal "8.2" *** *)
a (strip_asm_tac (list_µ_elim [¬x®, ¬î¯ 0®] ¯_less_cases_thm));
(* *** Goal "8.2.1" *** *)
a (DROP_NTH_ASM_T 5 ante_tac THEN asm_rewrite_tac[]);
(* *** Goal "8.2.2" *** *)
a (all_asm_fc_tac[¯_product_sign_lemma]);
a (all_asm_fc_tac[¯_less_trans_thm]);
(* *** Goal "9" *** *)
a (strip_asm_tac (list_µ_elim [¬x®, ¬î¯ 0®] ¯_less_cases_thm));
(* *** Goal "9.1" *** *)
a (strip_asm_tac (list_µ_elim [¬y®, ¬î¯ 0®] ¯_less_cases_thm));
(* *** Goal "9.1.1" *** *)
a (all_asm_fc_tac[¯_product_sign_lemma]);
a (DROP_NTH_ASM_T 4 ante_tac THEN asm_rewrite_tac[]);
(* *** Goal "9.1.2" *** *)
a (all_asm_fc_tac[¯_product_sign_lemma]);
a (DROP_NTH_ASM_T 4 ante_tac THEN asm_rewrite_tac[]);
(* *** Goal "9.2" *** *)
a (strip_asm_tac (list_µ_elim [¬y®, ¬î¯ 0®] ¯_less_cases_thm));
(* *** Goal "9.2.1" *** *)
a (all_asm_fc_tac[¯_product_sign_lemma]);
a (DROP_NTH_ASM_T 4 ante_tac THEN asm_rewrite_tac[]);
(* *** Goal "9.2.2" *** *)
a (all_asm_fc_tac[¯_product_sign_lemma]);
a (DROP_NTH_ASM_T 4 ante_tac THEN asm_rewrite_tac[]);
val ¯_product_sign_cp_lemma = pop_thm ();
=TEX
=SML
set_goal([], ¬(µ x y· î¯ 0 <‰R x *‰R y ¤ î¯ 0 <‰R x ± î¯ 0 <‰R y
		² x <‰R î¯ 0 ± y <‰R î¯ 0)
	± (µ x y· x *‰R y <‰R î¯ 0 ¤ î¯ 0 <‰R x ± y <‰R î¯ 0
		² x <‰R î¯ 0 ± î¯ 0 <‰R y)
	± (µ x y· x *‰R y = î¯ 0 ¤ x = î¯ 0 ² y = î¯ 0)
	± (µ x y· î¯ 0 = x *‰R y ¤ x = î¯ 0 ² y = î¯ 0)®);
a (REPEAT strip_tac
	THEN TRY (asm_rewrite_tac [])
	THEN TRY (all_fc_tac [¯_product_sign_lemma,
	¯_product_sign_cp_lemma]));
a (DROP_NTH_ASM_T 2 (asm_tac o (conv_rule eq_sym_conv))
	THEN fc_tac [¯_product_sign_cp_lemma]
	THEN asm_rewrite_tac[]);
val ¯_prod_sign_iff_lemma = pop_thm ();
=TEX
=SML
set_goal([], ¬(µ x y· î¯ 0 ¼‰R x *‰R y ¤ î¯ 0 ¼‰R x ± î¯ 0 ¼‰R y
		² x ¼‰R î¯ 0 ± y ¼‰R î¯ 0)
	± (µ x y· x *‰R y ¼‰R î¯ 0 ¤ î¯ 0 ¼‰R x ± y ¼‰R î¯ 0
		² x ¼‰R î¯ 0 ± î¯ 0 ¼‰R y)
	± (µ x y· x *‰R y = î¯ 0 ¤ x = î¯ 0 ² y = î¯ 0)
	± (µ x y· î¯ 0 = x *‰R y ¤ x = î¯ 0 ² y = î¯ 0)®);
a (rewrite_tac [get_spec ¬$¼‰R®, ¯_prod_sign_iff_lemma]
	THEN (PC_T1 "¯_lin_arith" prove_tac[]));
val ¯_prod_sign_iff_lemma2 = pop_thm ();
=TEX
=SML
set_goal([], ¬(µ x y· î¯ 0 <‰R x *‰R y ¤ î¯ 0 <‰R x ± î¯ 0 <‰R y
		² x <‰R î¯ 0 ± y <‰R î¯ 0)
	± (µ x y· x *‰R y <‰R î¯ 0 ¤ î¯ 0 <‰R x ± y <‰R î¯ 0
		² x <‰R î¯ 0 ± î¯ 0 <‰R y)
	± (µ x y· î¯ 0 ¼‰R x *‰R y ¤ î¯ 0 ¼‰R x ± î¯ 0 ¼‰R y
		² x ¼‰R î¯ 0 ± y ¼‰R î¯ 0)
	± (µ x y· x *‰R y ¼‰R î¯ 0 ¤ î¯ 0 ¼‰R x ± y ¼‰R î¯ 0
		² x ¼‰R î¯ 0 ± î¯ 0 ¼‰R y)
	± (µ x y· x *‰R y = î¯ 0 ¤ x = î¯ 0 ² y = î¯ 0)
	± (µ x y· î¯ 0 = x *‰R y ¤ x = î¯ 0 ² y = î¯ 0)®);
a (rewrite_tac [¯_prod_sign_iff_lemma, ¯_prod_sign_iff_lemma2]
	THEN (PC_T1 "¯_lin_arith" prove_tac[]));
val ¯_prod_sign_iff_clauses = save_pop_thm "¯_prod_sign_iff_clauses";
=TEX
}%ignore

\ignore{

=SML
set_goal([], ¬µ x y z· î¯ 0 <‰R x ± y <‰R z ´ y *‰R x <‰R z *‰R x®);
a (REPEAT strip_tac);
a (all_fc_tac [¯_times_mono_thm]);
a (PC_T1 "¯_lin_arith" asm_prove_tac[]);
val ¯_times_mono_thm1 = save_pop_thm "¯_times_mono_thm1";
=TEX

=SML

set_goal([], ¬µ x y z· î¯ 0 ¼‰R x ± y ¼‰R z ´ x *‰R y ¼‰R x *‰R z®);
a (rewrite_tac [get_spec ¬$¼‰R®]
	THEN REPEAT strip_tac
	THEN TRY (asm_rewrite_tac[])
	THEN TRY (SYM_ASMS_T rewrite_tac)
	THEN TRY (all_fc_tac
	[¯_times_mono_thm, ¯_times_mono_thm1, ¯_less_trans_thm]));
val ¯_times_mono_thm2 = save_pop_thm "¯_times_mono_thm2";

set_goal([], ¬µ x y z· î¯ 0 ¼‰R x ± y ¼‰R z ´ y *‰R x ¼‰R z *‰R x®);
a (rewrite_tac [get_spec ¬$¼‰R®]
	THEN REPEAT strip_tac
	THEN TRY (asm_rewrite_tac[])
	THEN TRY (SYM_ASMS_T rewrite_tac)
	THEN TRY (all_fc_tac
	[¯_times_mono_thm, ¯_times_mono_thm1, ¯_less_trans_thm]));
val ¯_times_mono_thm3 = save_pop_thm "¯_times_mono_thm3";
=TEX

=SML
set_goal([], ¬µ w x y z· î¯ 0 <‰R w ± î¯ 0 <‰R y ± w <‰R x ± y <‰R z ´ w *‰R y <‰R x *‰R z®);
a (REPEAT strip_tac);
a (lemma_tac ¬î¯ 0 <‰R z ± î¯ 0 <‰R x®
	THEN1 (all_asm_fc_tac[¯_less_trans_thm])
	THEN REPEAT strip_tac);
a (lemma_tac ¬w *‰R y <‰R w *‰R z®
	THEN1 (all_asm_fc_tac[¯_times_mono_thm, ¯_times_mono_thm1, ¯_less_trans_thm]));
a (lemma_tac ¬w *‰R z <‰R x *‰R z®
	THEN1 (strip_asm_tac (list_µ_elim [¬z®, ¬w®, ¬x®] ¯_times_mono_thm1)));
a (strip_asm_tac (list_µ_elim [¬w *‰R y®, ¬w *‰R z®, ¬x *‰R z®] ¯_less_trans_thm));
val ¯_times_mono_thm4 = save_pop_thm "¯_times_mono_thm4";
=TEX

=SML
set_goal([], ¬µ w x y z· î¯ 0 ¼‰R w ± î¯ 0 ¼‰R y ± w ¼‰R x ± y ¼‰R z ´ w *‰R y ¼‰R x *‰R z®);
a (REPEAT strip_tac);
a (lemma_tac ¬î¯ 0 ¼‰R z ± î¯ 0 ¼‰R x®
	THEN1 (all_asm_fc_tac[¯_¼_trans_thm])
	THEN REPEAT strip_tac);
a (lemma_tac ¬w *‰R y ¼‰R w *‰R z®
	THEN1 (all_asm_fc_tac[¯_times_mono_thm2, ¯_times_mono_thm3, ¯_¼_trans_thm]));
a (lemma_tac ¬w *‰R z ¼‰R x *‰R z®
	THEN1 (strip_asm_tac (list_µ_elim [¬z®, ¬w®, ¬x®] ¯_times_mono_thm3)));
a (strip_asm_tac (list_µ_elim [¬w *‰R y®, ¬w *‰R z®, ¬x *‰R z®] ¯_¼_trans_thm));
val ¯_times_mono_thm5 = save_pop_thm "¯_times_mono_thm5";
=TEX
}%ignore

\subsection{Squares}

\ignore{
=SML
set_goal([], ¬µ x y· î¯ 0 <‰R x ± x <‰R y ´ x *‰R x <‰R y *‰R y®);
a (REPEAT strip_tac);
a (all_asm_fc_tac [¯_less_trans_thm]);
a (strip_asm_tac (list_µ_elim [¬x®, ¬y®, ¬x®, ¬y®] ¯_times_mono_thm4));
val ¯_square_mono_thm = save_pop_thm "¯_square_mono_thm";
=TEX

=SML
set_goal([], ¬µ x y· î¯ 0 ¼‰R x ± x ¼‰R y ´ x *‰R x ¼‰R y *‰R y®);
a (REPEAT strip_tac);
a (all_asm_fc_tac [¯_¼_trans_thm]);
a (strip_asm_tac (list_µ_elim [¬x®, ¬y®, ¬x®, ¬y®] ¯_times_mono_thm5));
val ¯_square_mono_thm1 = save_pop_thm "¯_square_mono_thm1";
=TEX

=SML
set_goal([], ¬µ x y z· î¯ 0 <‰R x ± î¯ 0 <‰R y ± x *‰R x <‰R y *‰R y ´ x <‰R y®);
a (REPEAT strip_tac);
a (strip_asm_tac (all_µ_elim ¯_less_cases_thm));
(* *** Goal "1" *** *)
a (DROP_ASM_T ¬x *‰R x <‰R y *‰R y® ante_tac
	THEN asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a (strip_asm_tac (list_µ_elim [¬y®, ¬x®] ¯_square_mono_thm));
a (all_fc_tac [¯_less_antisym_thm]);
val ¯_square_less_less_thm = save_pop_thm "¯_square_less_less_thm";
=TEX

-SML
set_goal([], ¬µ x y· î¯ 0 <‰R x ± î¯ 0 <‰R y ´ (x *‰R x <‰R y *‰R y ¤ x <‰R y)®);
a (REPEAT strip_tac);
(* *** Goal "1" *** *)
a (all_fc_tac [¯_square_less_less_thm]);
(* *** Goal "2" *** *)
a (all_fc_tac [¯_square_mono_thm]);
val ¯_square_less_iff_less_thm = save_pop_thm "¯_square_less_iff_less_thm";
=TEX

-SML
set_goal([], ¬µ x y· î¯ 0 ¼‰R x ± î¯ 0 ¼‰R y ´ (x *‰R x ¼‰R y *‰R y ¤ x ¼‰R y)®);
a (REPEAT strip_tac);
(* *** Goal "1" *** *)
a (all_fc_tac [¯_square_¼_¼_thm]);
(* *** Goal "2" *** *)
a (all_fc_tac [¯_square_mono_thm1]);
val ¯_square_¼_iff_¼_thm = save_pop_thm "¯_square_¼_iff_¼_thm";
=TEX

=SML
set_goal([], ¬µx y:¯· î¯ 0 <‰R x ± î¯ 0 <‰R y ± y *‰R y = x *‰R x ´ x = y®);
a (REPEAT strip_tac);
a (strip_asm_tac (all_µ_elim ¯_less_cases_thm)
	THEN (fc_tac [¯_times_mono_thm]));
(* *** Goal "1" *** *)
a (lemma_tac ¬x *‰R x <‰R x *‰R y®
	THEN1 asm_fc_tac []);
a (lemma_tac ¬x *‰R y <‰R y *‰R y®
	THEN1 all_fc_tac [list_µ_elim [¬y®, ¬x®, ¬y®] ¯_times_mono_thm1]);
a (ALL_FC_T (MAP_EVERY ante_tac) [¯_less_trans_thm]
	THEN asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a (lemma_tac ¬x *‰R y <‰R x *‰R x®
	THEN1 asm_fc_tac []);
a (lemma_tac ¬y *‰R y <‰R x *‰R y®
	THEN1 all_fc_tac [list_µ_elim [¬y®, ¬y®, ¬x®] ¯_times_mono_thm1]);
a (ALL_FC_T (MAP_EVERY ante_tac) [¯_less_trans_thm]
	THEN asm_rewrite_tac[]);
val ¯_square_eq_thm1 = save_pop_thm "¯_square_eq_thm1";
=TEX

=SML
set_goal([], ¬µx y:¯· î¯ 0 ¼‰R x ± î¯ 0 ¼‰R y ± y *‰R y = x *‰R x ´ x = y®);
a (rewrite_tac[get_spec ¬$¼‰R®]);
a (rewrite_tac (map eq_sym_conv [¬î¯ 0 = x®, ¬î¯ 0 = y®])
	THEN REPEAT strip_tac
	THEN TRY (asm_rewrite_tac[]));
(* *** Goal "1" *** *)
a (all_fc_tac [¯_square_eq_thm1]);
(* *** Goal "2" *** *)
a (POP_ASM_T ante_tac THEN asm_rewrite_tac[¯_prod_sign_iff_clauses]);
(* *** Goal "3" *** *)
a (POP_ASM_T ante_tac
	THEN asm_rewrite_tac[¯_prod_sign_iff_clauses]
	THEN STRIP_T rewrite_thm_tac);
val ¯_square_eq_thm2 = save_pop_thm "¯_square_eq_thm2";
=TEX

=SML
set_goal([], ¬µ x y· î¯ 0 <‰R x ± î¯ 0 <‰R y ´ (x *‰R x = y *‰R y ¤ x = y)®);
a (REPEAT strip_tac
	THEN TRY (asm_rewrite_tac[]));
a (strip_asm_tac (all_µ_elim ¯_less_cases_thm)
	THEN (ALL_FC_T (MAP_EVERY ante_tac) [¯_square_mono_thm])
	THEN TRY (asm_rewrite_tac[]));
a (strip_asm_tac (list_µ_elim [¬y®, ¬x®] ¯_square_mono_thm)
	THEN POP_ASM_T ante_tac
	THEN TRY (asm_rewrite_tac[]));
val ¯_square_eq_eq_thm = save_pop_thm "¯_square_eq_eq_thm";
=TEX

=SML
set_goal([], ¬µ x y· î¯ 0 ¼‰R x ± î¯ 0 ¼‰R y ´ (x *‰R x = y *‰R y ¤ x = y)®);
a (rewrite_tac[get_spec ¬$¼‰R®]
	THEN REPEAT strip_tac
	THEN TRY (SYM_ASMS_T rewrite_tac));
(* *** Goal "1" *** *)
a (all_fc_tac [¯_square_eq_eq_thm]);
(* *** Goal "2" *** *)
a (POP_ASM_T ante_tac
	THEN SYM_ASMS_T rewrite_tac
	THEN rewrite_tac [¯_prod_sign_iff_clauses]);
(* *** Goal "3" *** *)
a (POP_ASM_T ante_tac
	THEN SYM_ASMS_T rewrite_tac
	THEN rewrite_tac [¯_prod_sign_iff_clauses]
	THEN strip_tac
	THEN asm_rewrite_tac[]);
val ¯_square_eq_eq_thm2 = save_pop_thm "¯_square_eq_eq_thm2";
=TEX

=SML
set_goal([], ¬µ x y· î¯ 0 ¼‰R x ± î¯ 0 ¼‰R y ± x *‰R x ¼‰R y *‰R y ´ x ¼‰R y®);
a (REPEAT strip_tac);
a (strip_asm_tac (all_µ_elim ¯_less_cases_thm));
(* *** Goal "1" *** *)
a (asm_rewrite_tac[get_spec ¬$¼‰R®]);
(* *** Goal "2" *** *)
a (DROP_ASM_T ¬x *‰R x ¼‰R y *‰R y® ante_tac
	THEN asm_rewrite_tac[]);
(* *** Goal "3" *** *)
a (strip_asm_tac (list_µ_elim [¬y®, ¬x®] ¯_square_mono_thm1));
(* *** Goal "3.1" *** *)
a (POP_ASM_T ante_tac THEN asm_rewrite_tac[get_spec ¬$¼‰R®]);
(* *** Goal "3.2" *** *)
a (all_fc_tac [pc_rule1 "¯_lin_arith"
	prove_rule [] ¬µx y:¯· x ¼‰R y ± y ¼‰R x ´ x = y®]);
a (all_fc_tac [¯_square_eq_eq_thm2]);
a (asm_rewrite_tac [get_spec ¬$¼‰R®]);
val ¯_square_¼_¼_thm = save_pop_thm "¯_square_¼_¼_thm";
=TEX

=SML
set_goal([], ¬µ x y· x *‰R x = y *‰R y ¤ Abs x = Abs y®);
a (REPEAT µ_tac
	THEN rewrite_tac [get_spec ¬Abs‰R®]
	THEN cases_tac ¬î¯ 0 ¼‰R x®
	THEN cases_tac ¬î¯ 0 ¼‰R y®
	THEN TRY (asm_rewrite_tac[])
	);
(* *** Goal "1" *** *)
a (strip_asm_tac (all_µ_elim ¯_square_eq_eq_thm2)
	THEN TRY (asm_rewrite_tac[]));
(* *** Goal "2" *** *)
a (all_asm_ante_tac
	THEN lemma_tac ¬¶ z· y = ~‰R z®
	THEN1 (¶_tac ¬~‰R y®
		THEN rewrite_tac[])
	THEN asm_rewrite_tac [¯_times_minus_thm]
	THEN REPEAT strip_tac);
(* *** Goal "2.1" *** *)
a (lemma_tac ¬î¯ 0 ¼‰R z®
	THEN1 (PC_T1 "¯_lin_arith" asm_prove_tac []));
a (strip_asm_tac (list_µ_elim [¬x®, ¬z®] ¯_square_eq_eq_thm2)
	THEN TRY (asm_rewrite_tac[]));
(* *** Goal "2.2" *** *)
a (lemma_tac ¬î¯ 0 ¼‰R z®
	THEN1 (PC_T1 "¯_lin_arith" asm_prove_tac []));
a (strip_asm_tac (list_µ_elim [¬x®, ¬z®] ¯_square_eq_eq_thm2)
	THEN TRY (asm_rewrite_tac[]));
(* *** Goal "3" *** *)
a (all_asm_ante_tac
	THEN lemma_tac ¬¶ z· x = ~‰R z®
	THEN1 (¶_tac ¬~‰R x®
		THEN rewrite_tac[])
	THEN asm_rewrite_tac [¯_times_minus_thm]);
a (strip_tac THEN strip_tac);
a (lemma_tac ¬î¯ 0 ¼‰R z®
	THEN1 (PC_T1 "¯_lin_arith" asm_prove_tac []));
a (strip_asm_tac (list_µ_elim [¬z®, ¬y®] ¯_square_eq_eq_thm2)
	THEN TRY (asm_rewrite_tac[]));
(* *** Goal "4" *** *)
a (all_asm_ante_tac
	THEN lemma_tac ¬¶ z· x = ~‰R z®
	THEN1 (¶_tac ¬~‰R x®
		THEN rewrite_tac[])
	THEN lemma_tac ¬¶ v· y = ~‰R v®
	THEN1 (¶_tac ¬~‰R y®
		THEN rewrite_tac[])
	THEN asm_rewrite_tac[]
	THEN strip_tac THEN strip_tac);
a (lemma_tac ¬î¯ 0 ¼‰R z®
	THEN1 (PC_T1 "¯_lin_arith" asm_prove_tac []));
a (lemma_tac ¬î¯ 0 ¼‰R v®
	THEN1 (PC_T1 "¯_lin_arith" asm_prove_tac []));
a (strip_asm_tac (list_µ_elim [¬z®, ¬v®] ¯_square_eq_eq_thm2)
	THEN TRY (asm_rewrite_tac[¯_times_minus_thm]));
val ¯_square_eq_iff_abs_eq_thm = save_pop_thm "¯_square_eq_iff_abs_eq_thm";
=TEX

=SML
set_goal([], ¬µx:¯· î¯ 0 ¼ x ^ 2®);
a (rewrite_tac [¯_î_exp_square_thm, ¯_prod_sign_iff_clauses]);
a (PC_T1 "¯_lin_arith" prove_tac[]);
val ¯_square_pos_thm = save_pop_thm "¯_square_pos_thm";
=TEX
}%ignore

\subsection{Sums}

\ignore{
=SML
set_goal([], ¬µx y:¯· î¯ 0 ¼ x ± î¯ 0 ¼ y ´ î¯ 0 ¼ x + y®);
a (PC_T1 "¯_lin_arith" prove_tac[]);
val ¯_sum_pos_thm = save_pop_thm "¯_sum_pos_thm";
=TEX

=SML
set_goal([], ¬µ x y:¯· î¯ 0 ¼ x ^‰N 2 +‰R y ^‰N 2®);
a (REPEAT µ_tac);
a (lemma_tac ¬î¯ 0 ¼ x ^ 2 ± î¯ 0 ¼ y ^ 2®
	THEN1 rewrite_tac [¯_square_pos_thm]);
a (all_fc_tac [¯_sum_pos_thm]);
val ¯_sum_square_pos_thm = save_pop_thm "¯_sum_square_pos_thm";
=TEX

=SML
set_goal([], ¬µx y: ¯· x^2 + y^2 = î¯ 0 ¤ x = î¯ 0 ± y = î¯ 0®);
a (REPEAT_N 5 strip_tac THEN TRY (asm_rewrite_tac[]));
a (lemma_tac ¬î¯ 0 ¼ x ^ 2 ± î¯ 0 ¼ y ^ 2®
	THEN1 rewrite_tac [¯_square_pos_thm]);
a (ALL_FC_T (MAP_EVERY (asm_tac o (rewrite_rule [¯_î_exp_square_thm, ¯_prod_sign_iff_clauses])))
	[pc_rule1 "¯_lin_arith" prove_rule []
	¬µx y: ¯·î¯ 0 ¼ x ± î¯ 0 ¼ y ´ x + y = î¯ 0 ´ x = î¯ 0 ± y = î¯ 0®]
	THEN asm_rewrite_tac[]);
val ¯_sum_square_zero_thm = save_pop_thm "¯_sum_square_zero_thm";
=TEX

=SML
set_goal([], ¬µx y:¯· î¯ 0 ¼ x ± î¯ 0 ¼ y
	´ (x + y = î¯ 0 ¤ x = î¯ 0 ± y = î¯ 0)®);
a (PC_T1 "¯_lin_arith" prove_tac[]);
val ¯_sum_zero_thm = save_pop_thm "¯_sum_zero_thm";
=TEX

=SML
set_goal([], ¬µ x y:¯· Abs (x ^‰N 2 +‰R y ^‰N 2) = x ^‰N 2 +‰R y ^‰N 2®);
a (REPEAT µ_tac);
a (asm_rewrite_tac [get_spec ¬Abs‰R®, ¯_sum_square_pos_thm]);
val ¯_abs_sum_square_thm = save_pop_thm "¯_abs_sum_square_thm";
=TEX


=SML
val ¯_plus_mono_thm = save_thm ("¯_plus_mono_thm", pc_rule1 "¯_lin_arith" prove_rule []
	¬µu v x y· u ¼‰R v ± x ¼‰R y ´ u +‰R x ¼‰R v +‰R y®);
=TEX
}%ignore

\subsection{Abs}

The following arithmetic results are obtained for reasoning about norms on real vector spaces, in particular to prove that $Abs$ is a norm over the reals and that the defined product operation over norms yields a norm.

=GFT
¯_Abs_Norm_clauses 
ô (µ v· î¯ 0 ¼‰R Abs‰R v)
± (µ v· (Abs‰R v = î¯ 0) ¤ v = î¯ 0)
± (µ x v· Abs‰R (x *‰R v) = Abs‰R x *‰R Abs‰R v)
± (µ v w· Abs‰R (v +‰R w) ¼‰R Abs‰R v +‰R Abs‰R w)
=TEX

\ignore{
=SML
set_goal([], ¬(µ v· î¯ 0 ¼‰R Abs‰R v)
             ± (µ v· (Abs‰R v = î¯ 0) = v = î¯ 0)
             ± (µ x v· Abs‰R (x *‰R v) = Abs‰R x *‰R Abs‰R v)
             ± (µ v w· Abs‰R (v +‰R w) ¼‰R Abs‰R v +‰R Abs‰R w)®);
a (rewrite_tac [get_spec ¬Abs‰R®, get_spec ¬$¼‰R®, ¯_prod_sign_iff_clauses]);
a (REPEAT ±_tac THEN REPEAT µ_tac);
(* *** Goal "1" *** *)
a (CASES_T ¬î¯ 0 < v ² î¯ 0 = v® asm_tac
	THEN TRY (asm_rewrite_tac[]));
a (PC_T1 "¯_lin_arith" asm_prove_tac[]);
(* *** Goal "2" *** *)
a (CASES_T ¬î¯ 0 < v ² î¯ 0 = v® asm_tac
	THEN TRY (asm_rewrite_tac[])
	THEN TRY (PC_T1 "¯_lin_arith" asm_prove_tac[]));
(* *** Goal "3" *** *)
a (strip_asm_tac (list_µ_elim [¬x®, ¬î¯ 0®] ¯_less_cases_thm)
	THEN asm_rewrite_tac[]
	THEN (strip_asm_tac (list_µ_elim [¬v®, ¬î¯ 0®] ¯_less_cases_thm))
	THEN asm_rewrite_tac[]);
(* *** Goal "3.1" *** *)
a (LEMMA_T ¬³(î¯ 0 < x ² î¯ 0 = x)® asm_tac
	THEN1 PC_T1 "¯_lin_arith" asm_prove_tac[]);
a (LEMMA_T ¬³(î¯ 0 < v ² î¯ 0 = v)® asm_tac
	THEN1 PC_T1 "¯_lin_arith" asm_prove_tac[]);
a (asm_rewrite_tac[¯_times_minus_thm]);
(* *** Goal "3.2" *** *)
a (LEMMA_T ¬³(î¯ 0 < x ² î¯ 0 = x)® asm_tac
	THEN1 PC_T1 "¯_lin_arith" asm_prove_tac[]);
a (LEMMA_T ¬³(v < î¯ 0 ² x = î¯ 0 ² v = î¯ 0)® asm_tac
	THEN1 PC_T1 "¯_lin_arith" asm_prove_tac[]);
a (asm_rewrite_tac[¯_times_minus_thm]);
(* *** Goal "3.3" *** *)
a (LEMMA_T ¬³(î¯ 0 < v ² î¯ 0 = v)® asm_tac
	THEN1 PC_T1 "¯_lin_arith" asm_prove_tac[]);
a (asm_rewrite_tac[¯_times_minus_thm]);
a (LEMMA_T ¬³(x < î¯ 0 ² x = î¯ 0 ² v = î¯ 0)® asm_tac
	THEN1 PC_T1 "¯_lin_arith" asm_prove_tac[]);
a (asm_rewrite_tac[¯_times_minus_thm]);
(* *** Goal "4" *** *)
a (strip_asm_tac (list_µ_elim [¬w®, ¬î¯ 0®] ¯_less_cases_thm)
	THEN TRY (asm_rewrite_tac[])
	THEN (strip_asm_tac (list_µ_elim [¬v®, ¬î¯ 0®] ¯_less_cases_thm))
	THEN TRY (asm_rewrite_tac[]));
(* *** Goal "4.1" *** *)
a (LEMMA_T ¬³(î¯ 0 <‰R v ² î¯ 0 = v)® rewrite_thm_tac
	THEN1 PC_T1 "¯_lin_arith" asm_prove_tac[]);
a (LEMMA_T ¬³(î¯ 0 <‰R w ² î¯ 0 = w)® rewrite_thm_tac
	THEN1 PC_T1 "¯_lin_arith" asm_prove_tac[]);
a (LEMMA_T ¬³(î¯ 0 <‰R v +‰R w ² î¯ 0 = v +‰R w)® rewrite_thm_tac
	THEN1 PC_T1 "¯_lin_arith" asm_prove_tac[]);
(* *** Goal "4.2" *** *)
a (LEMMA_T ¬³(î¯ 0 <‰R w ² î¯ 0 = w)® rewrite_thm_tac
	THEN1 PC_T1 "¯_lin_arith" asm_prove_tac[]);
a (CASES_T ¬î¯ 0 <‰R v +‰R w ² î¯ 0 = v +‰R w® rewrite_thm_tac
	THEN TRY (PC_T1 "¯_lin_arith" asm_prove_tac[]));
(* *** Goal "4.3" *** *)
a (LEMMA_T ¬³(î¯ 0 <‰R v ² î¯ 0 = v)® rewrite_thm_tac
	THEN1 PC_T1 "¯_lin_arith" asm_prove_tac[]);
a (CASES_T ¬î¯ 0 <‰R v +‰R w ² î¯ 0 = v +‰R w® rewrite_thm_tac
	THEN TRY (PC_T1 "¯_lin_arith" asm_prove_tac[]));
(* *** Goal "4.4" *** *)
a (CASES_T ¬î¯ 0 <‰R v +‰R w ² î¯ 0 = v +‰R w® rewrite_thm_tac
	THEN TRY (PC_T1 "¯_lin_arith" asm_prove_tac[]));
val ¯_Abs_Norm_clauses = save_pop_thm "¯_Abs_Norm_clauses";
=TEX

=SML
set_goal([], ¬µx:¯· x ¼‰R Abs x®);
a (REPEAT strip_tac
	THEN rewrite_tac [get_spec ¬Abs‰R®]
	THEN cases_tac ¬î¯ 0 ¼‰R x®
	THEN asm_rewrite_tac[]
	THEN PC_T1 "¯_lin_arith" asm_prove_tac[]);
val ¯_¼_abs_thm = save_pop_thm "¯_¼_abs_thm";
=TEX

=SML
set_goal([], ¬µx:¯· î¯ 0 ¼‰R x ´ Abs x = x®);
a (REPEAT strip_tac
	THEN rewrite_tac [get_spec ¬Abs‰R®]
	THEN asm_rewrite_tac []);
val ¯_abs_pos_id_thm = save_pop_thm "¯_abs_pos_id_thm";
=TEX

=SML
set_goal([], ¬µx y:¯· î¯ 0 ¼‰R x ± x ¼‰R y ´ Abs x ¼‰R Abs y®);
a (REPEAT strip_tac
	THEN rewrite_tac [get_spec ¬Abs‰R®]
	THEN cases_tac ¬î¯ 0 ¼‰R x®
	THEN cases_tac ¬î¯ 0 ¼‰R y®
	THEN asm_rewrite_tac[]
	THEN PC_T1 "¯_lin_arith" asm_prove_tac[]);
val ¯_abs_mono_thm = save_pop_thm "¯_abs_mono_thm";
=TEX

=SML
set_goal([], ¬µx y:¯· x ^ 2 = y ^ 2 ´ Abs x = Abs y®);
a (rewrite_tac [¯_î_exp_square_thm, get_spec ¬Abs‰R®]
	THEN REPEAT strip_tac);
a (cases_tac ¬î¯ 0 ¼‰R x®
	THEN asm_rewrite_tac[]);
(* *** Goal "1" *** *)
a (cases_tac ¬î¯ 0 ¼‰R y®
	THEN asm_rewrite_tac[]);
(* *** Goal "1.1" *** *)
a (strip_asm_tac (list_µ_elim [¬y®, ¬x®] ¯_square_eq_thm2)
	THEN asm_rewrite_tac[]);
(* *** Goal "1.2" *** *)
a (all_asm_ante_tac);
a (lemma_tac ¬¶z· y = ~‰R z®
	THEN1 (¶_tac ¬~‰R y® THEN rewrite_tac[])
	THEN asm_rewrite_tac[¯_times_minus_thm]
	THEN REPEAT strip_tac);
a (lemma_tac ¬î¯ 0 ¼‰R z®
	THEN1 (PC_T1 "¯_lin_arith" asm_prove_tac[]));
a (all_fc_tac [¯_square_eq_thm2]
	THEN asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a (all_asm_ante_tac);
a (lemma_tac ¬¶z· x = ~‰R z®
	THEN1 (¶_tac ¬~‰R x® THEN rewrite_tac[])
	THEN asm_rewrite_tac[¯_times_minus_thm]
	THEN REPEAT strip_tac);
a (lemma_tac ¬î¯ 0 ¼‰R z®
	THEN1 (PC_T1 "¯_lin_arith" asm_prove_tac[]));
a (cases_tac ¬î¯ 0 ¼‰R y®
	THEN asm_rewrite_tac[]);
(* *** Goal "2.1" *** *)
a (strip_asm_tac (list_µ_elim [¬y®, ¬z®] ¯_square_eq_thm2)
	THEN asm_rewrite_tac[]);
(* *** Goal "2.2" *** *)
a (all_asm_ante_tac);
a (lemma_tac ¬¶v· y = ~‰R v®
	THEN1 (¶_tac ¬~‰R y® THEN rewrite_tac[])
	THEN asm_rewrite_tac[¯_times_minus_thm]
	THEN REPEAT strip_tac);
a (lemma_tac ¬î¯ 0 ¼‰R v®
	THEN1 (PC_T1 "¯_lin_arith" asm_prove_tac[]));
a (strip_asm_tac (list_µ_elim [¬v®, ¬z®] ¯_square_eq_thm2)
	THEN asm_rewrite_tac[]);
val ¯_square_eq_abs_thm = pop_thm ();
=TEX

=SML
set_goal([], ¬µx y:¯· Abs x = Abs y ´ x ^ 2 = y ^ 2®);
a (REPEAT µ_tac
	THEN rewrite_tac [get_spec ¬Abs‰R®]
	THEN cases_tac ¬î¯ 0 ¼‰R x®
	THEN cases_tac ¬î¯ 0 ¼‰R y®
	THEN asm_rewrite_tac[]
	THEN strip_tac
	THEN TRY (asm_rewrite_tac[¯_î_exp_square_thm, ¯_times_minus_thm]));
(* *** Goal "1" *** *)
a (POP_ASM_T (rewrite_thm_tac o eq_sym_rule));
a (asm_rewrite_tac[¯_times_minus_thm]);
(* *** Goal "2" *** *)
a (LEMMA_T ¬~‰R (~‰R x) = ~‰R (~‰R y)® (asm_tac o (rewrite_rule[]))
	THEN1 (pure_asm_rewrite_tac[]
		THEN rewrite_tac[])
	THEN asm_rewrite_tac[]);
val ¯_abs_eq_square_thm = pop_thm ();
=TEX

=SML
set_goal([], ¬µx y:¯· x ^ 2 = y ^ 2 ¤ Abs x = Abs y®);
a (REPEAT strip_tac
	THEN all_fc_tac [¯_square_eq_abs_thm, ¯_abs_eq_square_thm]
	THEN asm_rewrite_tac[]);
val ¯_square_eq_abs_thm = save_pop_thm "¯_square_eq_abs_thm";
=TEX

=SML
set_goal([], ¬µx:¯· Abs (x *‰R x) = x *‰R x®);
a (REPEAT strip_tac
	THEN rewrite_tac [get_spec ¬Abs‰R®]);
a (LEMMA_T ¬î¯ 0 ¼‰R x *‰R x® rewrite_thm_tac
	THEN1 (rewrite_tac [¯_prod_sign_iff_clauses]
		THEN PC_T1 "¯_lin_arith" prove_tac[]));
val ¯_abs_square_thm1 = save_pop_thm "¯_abs_square_thm1";
=TEX

=SML
set_goal([], ¬µ x y· x *‰R x ¼‰R y *‰R y ´ Abs x ¼‰R Abs y®);
a (REPEAT strip_tac
	THEN bc_tac [¯_square_¼_¼_thm]
	THEN TRY (rewrite_tac [¯_Abs_Norm_clauses]));
a (asm_rewrite_tac [top_eq_sym_rule ¯_Abs_Norm_clauses,
	¯_abs_square_thm1]);
val ¯_square_¼_abs_¼_thm = save_pop_thm "¯_square_¼_abs_¼_thm";
=TEX

=SML
set_goal([], ¬µ x y· Abs x ¼‰R Abs y ´ x *‰R x ¼‰R y *‰R y®);
a (REPEAT strip_tac);
a (lemma_tac ¬î¯ 0 ¼‰R Abs x®
	THEN1 rewrite_tac [¯_Abs_Norm_clauses]);
a (ALL_FC_T (MAP_EVERY ante_tac) [¯_square_mono_thm1]);
a (rewrite_tac [top_eq_sym_rule ¯_Abs_Norm_clauses,
	¯_abs_square_thm1]);
val ¯_abs_¼_square_¼_thm = save_pop_thm "¯_abs_¼_square_¼_thm";
=TEX

=SML
set_goal([], ¬µ x y· x *‰R x ¼‰R y *‰R y ¤ Abs x ¼‰R Abs y®);
a (REPEAT µ_tac THEN strip_tac
	THEN rewrite_tac [¯_abs_¼_square_¼_thm, ¯_square_¼_abs_¼_thm]);
val ¯_square_¼_iff_abs_¼_thm = save_pop_thm "¯_square_¼_iff_abs_¼_thm";
=TEX

=SML
set_goal([], ¬µ x y· x *‰R x <‰R y *‰R y ¤ Abs x <‰R Abs y®);
a (REPEAT strip_tac);
(* *** Goal "1" *** *)
a (lemma_tac ¬Abs‰R x ¼‰R Abs‰R y®);
(* *** Goal "1.1" *** *)
a (lemma_tac ¬x *‰R x ¼‰R y *‰R y®
	THEN1 asm_rewrite_tac [get_spec ¬$¼‰R®]);
a (bc_tac [¯_square_¼_iff_abs_¼_thm] THEN strip_tac);
(* *** Goal "1.2" *** *)
a (POP_ASM_T ante_tac
	THEN rewrite_tac [get_spec ¬$¼‰R®]
	THEN REPEAT strip_tac);
a (DROP_NTH_ASM_T 2 ante_tac
	THEN LEMMA_T ¬x *‰R x = y *‰R y® rewrite_thm_tac
	THEN1 asm_rewrite_tac [¯_square_eq_iff_abs_eq_thm]);
(* *** Goal "2" *** *)
a (lemma_tac ¬x *‰R x ¼‰R y *‰R y®);
a (lemma_tac ¬Abs x ¼‰R Abs y®
	THEN1 asm_rewrite_tac [get_spec ¬$¼‰R®]);
a (bc_tac [¯_abs_¼_square_¼_thm] THEN strip_tac);
(* *** Goal "2.2" *** *)
a (POP_ASM_T ante_tac
	THEN rewrite_tac [get_spec ¬$¼‰R®]
	THEN REPEAT strip_tac);
a (DROP_NTH_ASM_T 2 ante_tac
	THEN LEMMA_T ¬Abs x = Abs y® rewrite_thm_tac
	THEN1 asm_rewrite_tac [top_eq_sym_rule ¯_square_eq_iff_abs_eq_thm]);
val ¯_square_less_iff_abs_less_thm = save_pop_thm "¯_square_less_iff_abs_less_thm";
=TEX

=SML
set_goal([], ¬µx:¯· Abs (x ^‰N 2) = x ^‰N 2®);
a (rewrite_tac [¯_î_exp_square_thm, ¯_abs_square_thm1]);
val ¯_abs_square_thm2 = save_pop_thm "¯_abs_square_thm2";
=TEX

=SML
set_goal([], ¬µx y:¯· Abs (x *‰R y) = (Abs x) *‰R (Abs y)®);
a (REPEAT strip_tac
	THEN rewrite_tac [get_spec ¬Abs‰R®]);
a (cases_tac ¬î¯ 0 ¼‰R x® THEN cases_tac ¬î¯ 0 ¼‰R y®
	THEN TRY (asm_rewrite_tac[]));
(* *** Goal "1" *** *)
a (lemma_tac ¬î¯ 0 ¼‰R x *‰R y®
	THEN1 (rewrite_tac [¯_prod_sign_iff_clauses]
		THEN contr_tac)
	THEN asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a (cases_tac ¬x = î¯ 0® THEN TRY (asm_rewrite_tac[]));
a (lemma_tac ¬³ î¯ 0 ¼‰R x *‰R y®
	THEN1 (rewrite_tac [¯_prod_sign_iff_clauses]
		THEN REPEAT strip_tac
		THEN TRY (PC_T1 "¯_lin_arith" asm_prove_tac[]))
	THEN asm_rewrite_tac[¯_times_minus_thm]);
(* *** Goal "3" *** *)
a (cases_tac ¬y = î¯ 0® THEN TRY (asm_rewrite_tac[]));
a (lemma_tac ¬³ î¯ 0 ¼‰R x *‰R y®
	THEN1 (rewrite_tac [¯_prod_sign_iff_clauses]
		THEN REPEAT strip_tac
		THEN TRY (PC_T1 "¯_lin_arith" asm_prove_tac[]))
	THEN asm_rewrite_tac[¯_times_minus_thm]);
(* *** Goal "4" *** *)
a (lemma_tac ¬î¯ 0 ¼‰R x *‰R y®
	THEN1 (rewrite_tac [¯_prod_sign_iff_clauses]
		THEN (PC_T1 "¯_lin_arith" asm_prove_tac[]))
	THEN asm_rewrite_tac[¯_times_minus_thm]);
val ¯_abs_prod_thm = save_pop_thm "¯_abs_prod_thm";
=TEX

}%ignore

\subsection{Square Root}

\ignore{
=SML
push_goal ([], ¬¶Sqrt· µ x· î¯ 0 ¼ Sqrt x ± (Sqrt x)^2 = Abs x®);
a(prove_¶_tac THEN strip_tac);
a (lemma_tac ¬î¯ 0 ¼ Abs x'®
	THEN1 (rewrite_tac [¯_0_¼_abs_thm]));
a (all_fc_tac [square_root_thm1]);
a(¶_tac ¬y® THEN asm_rewrite_tac[]);
val _ = xl_set_cs_¶_thm (pop_thm());
=TEX
}%\ignore

¹HOLCONST
Ü ÛSqrtÝ :¯ ­ ¯
÷üüüüüü
Ü µ x· î¯ 0 ¼ Sqrt x 
Ü ± (Sqrt x)^2 = Abs x
°

\ignore{

=SML
set_goal([], ¬µx y:¯· Sqrt x = Sqrt y ´ Abs x = Abs y®);
a (REPEAT strip_tac);
a (LEMMA_T ¬(Sqrt x) ^‰N 2 = (Sqrt y) ^‰N 2® ante_tac
	THEN1 asm_rewrite_tac[]);
a (rewrite_tac [get_spec ¬Sqrt®]);
val ¯_sqrt_abs_thm1 = pop_thm ();
=TEX

=SML
set_goal([], ¬µx:¯· Sqrt x = î¯ 0 ¤ x = î¯ 0®);
a (REPEAT strip_tac THEN TRY (asm_rewrite_tac[]));
a (contr_tac THEN lemma_tac ¬î¯ 0 <‰R Sqrt x ^‰N 2®
	THEN1 rewrite_tac[get_spec ¬Sqrt®,
	get_spec ¬Abs‰R®,
	get_spec ¬$¼‰R®]);
(* *** Goal "1.1" *** *)
a (cases_tac ¬î¯ 0 <‰R x ² î¯ 0 = x®
	THEN asm_rewrite_tac[]
	THEN PC_T1 "¯_lin_arith" asm_prove_tac[]);
(* *** Goal "1.2" *** *)
a (POP_ASM_T ante_tac
	THEN asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a (strip_asm_tac (rewrite_rule [¯_î_exp_square_thm, ¯_prod_sign_iff_clauses]
	(µ_elim ¬î¯ 0® (get_spec ¬Sqrt®))));
val sqrt_thm1 = save_pop_thm "sqrt_thm1";
=TEX

=SML
set_goal([], ¬µx y:¯· Sqrt (x ^ 2 + y ^ 2) = î¯ 0 ¤ x = î¯ 0 ± y = î¯ 0®);
a (REPEAT µ_tac THEN rewrite_tac [sqrt_thm1]);
a (lemma_tac ¬î¯ 0 ¼ x ^ 2 ± î¯ 0 ¼ y ^ 2®
	THEN1 (rewrite_tac [¯_square_pos_thm]));
a (lemma_tac ¬î¯ 0 ¼ x ^ 2 + y ^ 2®
	THEN1 (all_fc_tac [¯_sum_pos_thm]));
a (LEMMA_T ¬(x ^‰N 2 + y ^‰N 2 = î¯ 0)
		= (x ^‰N 2 = î¯ 0 ± y ^‰N 2 = î¯ 0)®
	rewrite_thm_tac
	THEN1 (ALL_FC_T1 fc_¤_canon rewrite_tac [¯_sum_zero_thm]));
a (rewrite_tac[¯_î_exp_square_thm, ¯_prod_sign_iff_clauses]);
val sqrt_square_thm = save_pop_thm "sqrt_square_thm";
=TEX
}%\ignore

\ignore{

=SML
set_goal([], ¬µx:¯· Abs(Sqrt x) = Sqrt x
	± Abs (Abs x) = Abs x
	± Abs (î¯ 0) = î¯ 0
	± Abs (~‰R  x) = Abs x®);
a (REPEAT strip_tac
	THEN TRY (rewrite_tac [get_spec ¬Abs‰R®, get_spec ¬Sqrt®]));
(* *** Goal "1" *** *)
a (cases_tac ¬î¯ 0 ¼‰R x®
	THEN asm_rewrite_tac[]);
a (lemma_tac ¬î¯ 0 ¼‰R ~‰R x®
	THEN1 (PC_T1 "¯_lin_arith" asm_prove_tac[]));
a (asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a (rewrite_tac [get_spec ¬$¼‰R®]);
a (strip_asm_tac (list_µ_elim [¬î¯ 0®, ¬x®] ¯_less_cases_thm)
	THEN TRY (asm_rewrite_tac[]));
(* *** Goal "2.1" *** *)
a (LEMMA_T ¬³ (î¯ 0 <‰R ~‰R x ² î¯ 0 = ~‰R x)® rewrite_thm_tac
	THEN1 (PC_T1 "¯_lin_arith" asm_prove_tac[]));
(* *** Goal "2.2" *** *)
a (LEMMA_T ¬x = î¯ 0® rewrite_thm_tac
	THEN1 (PC_T1 "¯_lin_arith" asm_prove_tac[]));
(* *** Goal "2.3" *** *)
a (LEMMA_T ¬î¯ 0 <‰R ~‰R x® rewrite_thm_tac
	THEN1 (PC_T1 "¯_lin_arith" asm_prove_tac[]));
a (LEMMA_T ¬³ (î¯ 0 <‰R x ² î¯ 0 = x)® rewrite_thm_tac
	THEN1 (PC_T1 "¯_lin_arith" asm_prove_tac[]));
val ¯_abs_clauses1 = pop_thm ();
=TEX

=SML
set_goal([], ¬µx:¯· Sqrt (~‰R x) = Sqrt x®);
a (strip_tac);
a (lemma_tac ¬Sqrt (~‰R x) ^‰N 2 = Abs‰R x®
	THEN1 (strip_asm_tac (µ_elim ¬~‰R x® (get_spec ¬Sqrt®))
		THEN asm_rewrite_tac[¯_abs_clauses1]));
a (lemma_tac ¬(Sqrt x) ^‰N 2 = Abs‰R x®
	THEN1 (strip_asm_tac (µ_elim ¬x® (get_spec ¬Sqrt®))
		THEN asm_rewrite_tac[¯_abs_clauses1]));
a (lemma_tac ¬Sqrt (~‰R x) ^‰N 2 = Sqrt x ^‰N 2®
	THEN1 asm_rewrite_tac[]);
a (ALL_FC_T (MAP_EVERY ante_tac) [¯_square_eq_abs_thm]
	THEN rewrite_tac [¯_abs_clauses1]
	THEN strip_tac);
val ¯_sqrt_minus_thm = save_pop_thm "¯_sqrt_minus_thm";
=TEX

=SML
set_goal([], ¬µx:¯· Sqrt(Abs x) = Sqrt x®);
a (REPEAT strip_tac
	THEN TRY (rewrite_tac [get_spec ¬Abs‰R®, get_spec ¬Sqrt®]));
a (cases_tac ¬î¯ 0 ¼‰R x®
	THEN asm_rewrite_tac[¯_sqrt_minus_thm]);
val ¯_sqrt_abs_thm = pop_thm ();
=TEX

=SML
set_goal([], ¬µx:¯· Sqrt(Abs x) = Sqrt x
	± Abs(Sqrt x) = Sqrt x
	± Abs (Abs x) = Abs x
	± Abs (î¯ 0) = î¯ 0
	± Abs (~‰R  x) = Abs x®);
a (rewrite_tac[¯_abs_clauses1, ¯_sqrt_abs_thm]);
val ¯_abs_clauses = save_pop_thm "¯_abs_clauses";
=TEX

=SML
set_goal([], ¬µx y:¯· Abs x = Abs y ´ Sqrt x = Sqrt y®);
a (REPEAT µ_tac THEN rewrite_tac [get_spec ¬Abs‰R®]);
a (cases_tac ¬î¯ 0 ¼‰R x®
	THEN asm_rewrite_tac[]);
(* *** Goal "1" *** *)
a (cases_tac ¬î¯ 0 ¼‰R y®
	THEN REPEAT strip_tac
	THEN asm_rewrite_tac[¯_sqrt_minus_thm]);
(* *** Goal "2" *** *)
a (cases_tac ¬î¯ 0 ¼‰R y®
	THEN (asm_rewrite_tac[])
	THEN REPEAT strip_tac
	THEN TRY (asm_rewrite_tac[¯_sqrt_minus_thm]));
(* *** Goal "2.1" *** *)
a (LEMMA_T ¬y = ~‰R x® rewrite_thm_tac
	THEN1 asm_rewrite_tac[]);
a (rewrite_tac[¯_sqrt_minus_thm]);
(* *** Goal "2.2" *** *)
a (LEMMA_T ¬x = y® rewrite_thm_tac
	THEN1 (PC_T1 "¯_lin_arith" asm_prove_tac[]));
val ¯_sqrt_abs_thm2 = pop_thm ();
=TEX

=SML
set_goal([], ¬µx y:¯· Sqrt x = Sqrt y ¤ Abs x = Abs y®);
a (REPEAT strip_tac THEN all_fc_tac [¯_sqrt_abs_thm1, ¯_sqrt_abs_thm2]);
val ¯_sqrt_abs_thm = save_pop_thm "¯_sqrt_abs_thm";
=TEX

=SML
set_goal([], ¬µx y:¯· î¯ 0 ¼‰R x ± x ¼‰R y ´ Sqrt x ¼‰R Sqrt y®);
a (REPEAT strip_tac
	THEN bc_tac [¯_square_¼_¼_thm]
	THEN TRY (rewrite_tac [rewrite_rule [¯_î_exp_square_thm] (get_spec ¬Sqrt®)])
	THEN all_fc_tac [¯_abs_mono_thm]);
val ¯_sqrt_mono_thm = save_pop_thm "¯_sqrt_mono_thm";
=TEX

=SML
set_goal([], ¬µx:¯· Sqrt (x * x) = Abs x®);
a (strip_tac
	THEN lemma_tac ¬Sqrt (x *‰R x) ^‰N 2 = (Abs‰R x) ^‰N 2®
	THEN1 (rewrite_tac [rewrite_conv [¯_î_exp_square_thm] ¬(Abs‰R x) ^‰N 2®,
		get_spec ¬Sqrt®, get_spec ¬Abs‰R®, ¯_abs_square_thm1]
		THEN cases_tac ¬î¯ 0 ¼‰R x®
		THEN asm_rewrite_tac[¯_times_minus_thm]));
a (ALL_ASM_FC_T
	(MAP_EVERY (strip_asm_tac o (rewrite_rule [¯_abs_clauses1])))
	[¯_square_eq_abs_thm]);
val ¯_sqrt_square_thm1 = save_pop_thm "¯_sqrt_square_thm1";
=TEX

=SML
set_goal([], ¬µx:¯· Sqrt (x ^ 2) = Abs x®);
a (REPEAT strip_tac
	THEN rewrite_tac [¯_sqrt_square_thm1, ¯_î_exp_square_thm]);
val ¯_sqrt_square_thm2 = save_pop_thm "¯_sqrt_square_thm2";
=TEX

=SML
set_goal([], ¬µx y:¯· Sqrt (x * y) = Sqrt x * Sqrt y®);
a (REPEAT strip_tac
	THEN lemma_tac ¬(Sqrt x *‰R Sqrt y) *‰R (Sqrt x *‰R Sqrt y)
	 = (Sqrt x *‰R Sqrt x) *‰R (Sqrt y *‰R Sqrt y)®
	THEN1 rewrite_tac [µ_elim ¬Sqrt x® ¯_times_order_thm]);
a (lemma_tac ¬Sqrt x *‰R Sqrt x = Abs‰R x®
	THEN1 (rewrite_tac [rewrite_rule [¯_î_exp_square_thm]
			(µ_elim ¬x® (get_spec ¬Sqrt®))]));
a (lemma_tac ¬Sqrt y *‰R Sqrt y = Abs‰R y®
	THEN1 (rewrite_tac [rewrite_rule [¯_î_exp_square_thm]
			(µ_elim ¬y® (get_spec ¬Sqrt®))]));
a (DROP_NTH_ASM_T 3 ante_tac);
a (once_asm_rewrite_tac[]);
a (rewrite_tac[eq_sym_rule(rewrite_rule [¯_Abs_Norm_clauses, ¯_î_exp_square_thm]
	((±_right_elim o (µ_elim ¬x *‰R y®)) (get_spec ¬Sqrt®))),
	rewrite_rule [¯_î_exp_square_thm] ¯_square_eq_abs_thm,
	¯_abs_clauses]);
a (once_rewrite_tac [eq_sym_conv ¬Abs‰R (Sqrt x *‰R Sqrt y) = Sqrt (x *‰R y)®]
	THEN STRIP_T rewrite_thm_tac);
a (rewrite_tac [¯_abs_clauses, ¯_Abs_Norm_clauses]);
val ¯_sqrt_prod_thm = save_pop_thm "¯_sqrt_prod_thm";
=TEX

=SML
set_goal([], ¬µx y:¯· Sqrt(x + y) ¼ (Sqrt x) +‰R (Sqrt y)®);
a (REPEAT strip_tac);
a (LEMMA_T ¬Sqrt(x + y) = Abs (Sqrt(x + y))
	± (Sqrt x) +‰R (Sqrt y) = Abs((Sqrt x) +‰R (Sqrt y))®
	once_rewrite_thm_tac);
(* *** Goal "1" *** *)
a (lemma_tac ¬î¯ 0 ¼‰R Sqrt (x +‰R y) ± î¯ 0 ¼‰R Sqrt x +‰R Sqrt y®
	THEN1 (rewrite_tac [get_spec ¬Sqrt®]
		THEN bc_tac [¯_sum_pos_thm]
		THEN rewrite_tac [get_spec ¬Sqrt®])
	THEN ALL_FC_T rewrite_tac [¯_abs_pos_id_thm]);
(* *** Goal "2" *** *)
a (bc_tac [¯_square_¼_abs_¼_thm]);
a (rewrite_tac[rewrite_rule [¯_î_exp_square_thm] (get_spec ¬Sqrt®),
	¯_times_plus_distrib_thm]);
a (¯_anf_tac);
a (lemma_tac ¬Abs‰R (x +‰R y) ¼‰R (Abs‰R x) +‰R (Abs‰R y)®
	THEN1 rewrite_tac [¯_Abs_Norm_clauses]);
a (LEMMA_T ¬(Abs‰R x) +‰R (Abs‰R y) ¼‰R Abs‰R x +‰R Abs‰R y +‰R î¯ 2 *‰R Sqrt x *‰R Sqrt y®
	asm_tac
	THEN1 rewrite_tac [¯_prod_sign_iff_clauses, get_spec ¬Sqrt®]);
a (all_fc_tac [¯_¼_trans_thm]);
val sqrt_plus_thm = save_pop_thm "sqrt_plus_thm"; 
=TEX

}%ignore

\subsection{List Membership}

=SML
declare_infix(300, "‰L");
=TEX
¹HOLCONST
Ü $Û‰LÝ: 'a ­ 'a  LIST ­ BOOL
÷üüüüüü
Ü µ a b al· (a ‰L [] ¤ F)
Ü	± (a ‰L (Cons b al) ¤ a = b ² a ‰L al)
°

\subsection{Sums of Countable Collections of Reals}

In evaluating the cosmological consequences of Newton's Laws it is desirable to formulate them as cosmological theories in ways which do not prejudge such questions as whether the cardinality of the universe is finite.
To do this it is necessary to be able, where possible, to form the sum of an infinite set of reals, possibly even an uncountably infinite set of real numbers.

For the most general formulations it seems possible that the use of non-standard reals might be needed.
We are concerned here with what can be done with standard reals, i.e. with formalising the notion that some collection of real numbers has a finite sum.

The following definition gives the sum of a possibly finite or countable collection of real numbers.

=SML
declare_infix (300, ">");
=TEX
¹HOLCONST
Ü $Û>Ý : ('a ­ ¯ + ONE) ­ ¯ ­ BOOL
÷üüüüüü
Ü µc r· c > r ¤
Ü	¶s· (µ a n m· IsL (c a) ´ s n = s m ´ n = m)
Ü	´ (Series (Ìn· if IsR (c (s n)) then 0‰R else OutL (c (s n)))) -> r
°

\section{Group Theory}

=SML
new_parent "group_egs";
=TEX

\subsection{Group Products}

¹HOLCONST
Ü ÛGroupProductÝ : 'a GROUP ­ 'b GROUP ­ ('a ¸ 'b) GROUP
÷üüüüüü
Ü µ G H· GroupProduct G H =
Ü	let car = (Car G ¸ Car H)
Ü	and prod	(la, lb) (ra, rb) = ((la.ra) G, (lb.rb) H)
Ü	and unit = (Unit G, Unit H)
Ü	and inv (a, b) = ((a ›~) G, (b ›~) H)
Ü	in (car, prod, unit, inv)
°
=SML
declare_alias ("*", ¬GroupProduct®);
=TEX
\ignore{
=SML
val Ûgroup_defÝ = get_spec¬Group®;
val Ûgroup_unit_defÝ = get_spec¬Unit®;
val Ûgp_defÝ = get_spec¬GroupProduct®;
=TEX
=SML
set_goal([], ¬µg:'a GROUP; h:'b GROUP·
	g  Group ± h  Group ´ g * h  Group®);
a(rewrite_tac [get_spec ¬Group®,
	gp_def,
	group_unit_def,
	get_spec ¬$¸®,
	let_def]
	THEN REPEAT strip_tac
	THEN TRY (all_asm_fc_tac[]));
val Ûgroup_product_thmÝ = save_pop_thm "group_product_thm";
=TEX
}%ignore

=GFT
group_product_thm = ô µg:'a GROUP; h:'b GROUP·
	g  Group ± h  Group ´ g * h  Group
=TEX

\subsection{Abelian Groups}

¹HOLCONST
Ü ÛAbelianGroupÝ : 'a GROUP SET
÷üüüüüü
Ü µ G· G  AbelianGroup ¤ G  Group
Ü	± µ u v:'a· u  Car G ± v  Car G
Ü	         ´ (u.v) G = (v.u) G
°

\ignore{
=SML
val Ûabelian_group_defÝ = get_spec¬AbelianGroup®;
set_goal([], ¬µg:'a GROUP; h:'b GROUP·
	g  AbelianGroup ± h  AbelianGroup ±
	Car g = Universe ± Car h = Universe
	´ Car (g * h) = Universe®);
a(rewrite_tac [abelian_group_def,
	group_def,
	gp_def,
	group_unit_def,
	get_spec ¬$¸®,
	let_def]
	THEN REPEAT strip_tac
	THEN TRY (asm_rewrite_tac[sets_ext_clauses]));
val Ûabelian_group_product_lemmaÝ = save_pop_thm "abelian_group_product_lemma";
=TEX

=SML
set_goal([], ¬µg:'a GROUP; h:'b GROUP·
	g  AbelianGroup ± h  AbelianGroup 
	´ (g * h)  AbelianGroup®);
a (rewrite_tac [abelian_group_def]);
a (REPEAT strip_tac);
a (all_asm_fc_tac[group_product_thm]);
a (REPEAT_N 2 (POP_ASM_T ante_tac));
a (asm_rewrite_tac [
	gp_def,
	let_def,
	group_unit_def,
	get_spec ¬$¸®]);
a (REPEAT strip_tac
	THEN all_asm_fc_tac[]);
val Ûabelian_group_product_thmÝ = save_pop_thm "abelian_group_product_thm";
=TEX

=SML
set_goal([], ¬µG:'g GROUP; H:'h GROUP; x y:'g; v w:'h·
	((x,v) . (y, w)) (G * H)
	= ((x . y)G, (v . w)H)®);
a (REPEAT strip_tac
	THEN rewrite_tac [gp_def, let_def, group_unit_def]
	THEN REPEAT strip_tac);
val group_prod_prod_thm = save_pop_thm "group_prod_prod_thm";
=TEX
=SML
set_goal([], ¬µG:'g GROUP; H:'h GROUP; x y:'g ¸ 'h·
	(x . y) (G * H)
	= ((Fst x . Fst y)G, (Snd x . Snd y)H)®);
a (REPEAT strip_tac
	THEN rewrite_tac [gp_def, let_def, group_unit_def]
	THEN REPEAT strip_tac);
val group_prod_prod_thm1 = save_pop_thm "group_prod_prod_thm1";
=TEX

}%ignore

=GFT
abelian_group_product_thm = ô µg:'a GROUP; h:'b GROUP·
	g  AbelianGroup ± h  AbelianGroup ´ (g * h)  AbelianGroup
=TEX

\ignore{
=SML
set_goal([], ¬¯_plus  AbelianGroup®);
a (rewrite_tac [
	get_spec ¬AbelianGroup®,
	¯_plus_ops_thm,
	¯_plus_group_thm
	]);
val ¯_plus_abelian_thm = save_pop_thm "¯_plus_abelian_thm";
=TEX
} %ignore

=GFT
¯_plus_abelian_thm = ô ¯_plus  AbelianGroup
=TEX

\section{Topology}

=SML
new_parent "topology";
=TEX

\subsection{Bases etc.}

The following definitions belong properly in the theory ``topology''.

First we define the relationship between a $base$ and the topology of which it is a base.

=SML
declare_infix (300, "BaseOf");
=TEX

¹HOLCONST
Ü $ÛBaseOfÝ :  'a SET SET ­ 'a SET SET ­ BOOL
÷üüüüüü
Ü µ base topology· base BaseOf topology ¤
Ü	µs· s  topology ´ ¶ ss· ss € base ± s = Þ ss
°

However, what we really need here is the construction of a topology from an arbitrary set of sets, which is done as follows:

¹HOLCONST
Ü $ÛTopologyFromÝ :  'a SET SET ­ 'a SET SET
÷üüüüüü
Ü µ sets· TopologyFrom sets =
Ü	¥ {topology | topology  Topology ± sets € topology}
°

\ignore{

Prove that $TopologyFrom$ yields a topology.

}%ignore

{\let\Section\section
\def\section#1{\Section{#1}\label{TheoryListing}}
\include{rbjmisc.th}
}  %\let

\twocolumn[\section{INDEX}\label{INDEX}]
{\small\printindex}

\end{document}
=SML
set_flag ("pp_use_alias", true);
output_theory{out_file="rbjmisc.th.doc", theory="rbjmisc"};
set_flag ("pp_use_alias", false);
=TEX