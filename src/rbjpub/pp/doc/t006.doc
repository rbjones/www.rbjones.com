=IGN
$Id: t006.doc,v 1.29 2010/07/12 13:49:38 rbj Exp $
=TEX
\documentclass[11pt,a4paper]{article}
\usepackage{latexsym}
\usepackage{ProofPower}
\ftlinepenalty=9999
\tabstop=0.25in
\usepackage{A4}

\def\Hide#1{\relax}
\newcommand{\ignore}[1]{}

\title{Miscellanea}
\author{Roger Bishop Jones}
\date{\ }

\usepackage[unicode,pdftex]{hyperref}
\hypersetup{pdfauthor={Roger Bishop Jones}}
\hypersetup{colorlinks=true, urlcolor=black, citecolor=black, filecolor=black, linkcolor=black}

\makeindex
\begin{document}
\vfill
\maketitle
\begin{abstract}
This document contains things used by my other theories which do not particularly belong in them.
Definitions or theorems which arguably belong in a theory already produced by someone else.
\end{abstract}
\vfill
\begin{centering}
{\footnotesize

Date Created 2004/07/15

Last Changed $ $Date: 2010/07/12 13:49:38 $ $

\href{http://www.rbjones.com/rbjpub/pp/doc/t006.pdf}
{http://www.rbjones.com/rbjpub/pp/doc/t006.pdf}

$ $Id: t006.doc,v 1.29 2010/07/12 13:49:38 rbj Exp $ $

\copyright\ Roger Bishop Jones; Licenced under Gnu LGPL

}%footnotesize
\end{centering}

\newpage

{\setcounter{tocdepth}{4}
\parskip=0pt\tableofcontents}

%%%%

{\raggedright
\bibliographystyle{fmu}
\bibliography{rbj,fmu}
} %\raggedright

\section{The Theory rbjmisc}

For context and motivation see \cite{rbjt000}.

All the theorems are placed in the one temporary location, which therefore must have as ancestors all the theories which are being extended.

There is one section in this document, following this one, for each theory to which an addition is being made so new parents may be added in those sections, or new proof contexts used.

=SML
open PreConsisProof;
=TEX

=SML
open_theory "cache'rbjhol";
force_new_theory "rbjmisc";
val _ =	let open ReaderWriterSupport.PrettyNames;
	in add_new_symbols [ (["sqsubseteq2"], Value "√", Simple) ]
        end
handle _ => ();
new_parent "analysis";
new_parent "equiv_rel";
force_new_pc €"'rbjmisc"›;
merge_pcs ["'prove_∂_¥_conv", "'savedthm_cs_∂_proof"] "'rbjmisc";
set_merge_pcs ["basic_hol1", "'sets_alg", "'Ø", "'rbjmisc"];
open UnifyForwardChain; open RbjTactics1;
=TEX

\ignore{
 πHOLLABPROD EIGHTTUPLE¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	aaaa bbbb cccc dddd eeee ffff gggg hhhh: 'a
 ∞¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
}%ignore

\section{Combinators}

πHOLCONST
‹ $€CombC›: ('a ≠ 'b ≠ 'c) ≠ ('b ≠ 'a ≠ 'c)
˜¸¸¸¸¸¸
‹ µf∑ CombC f = Ãx y∑ f y x 
∞

=GFT
€combc_thm› = Ù µ f x y∑ CombC f x y = f y x
=TEX

\ignore{
=SML
set_goal([], ¨µf x y∑ CombC f x y = f y xÆ);
a (rewrite_tac [get_spec ¨CombCÆ]);
val combc_thm = save_pop_thm "combc_thm";
=TEX
}%ignore

πHOLCONST
‹ €BinComp› : ('a ≠ 'b ≠ 'c) ≠ ('d ≠ 'a) ≠ ('e ≠ 'b) ≠ ('d ≠ 'e ≠ 'c)
˜¸¸¸¸¸¸
‹ µ f g h∑ BinComp f g h = Ãx y∑ f (g x) (h y) 
∞

=GFT
€combc_thm› = Ù µ f x y∑ CombC f x y = f y x
=TEX

\ignore{
=SML
set_goal([], ¨µ f g h x y∑ BinComp f g h x y = f (g x) (h y)Æ);
a (rewrite_tac [get_spec ¨BinCompÆ]);
val bincomp_thm = save_pop_thm "bincomp_thm";
=TEX
}%ignore

\ignore{
=SML
add_pc_thms "'rbjmisc" (map get_spec [] @ [combc_thm, bincomp_thm]);
set_merge_pcs ["basic_hol1", "'sets_alg", "'Ø", "'rbjmisc"];
=TEX
}%ignore

\section{Predicate Calculus}

There is probably a better way of doing this (or a better thing to be doing).

In some circumstances $µ\_±\_out\_lemma$ can be used to avoid or postpone a case split.

=GFT
€µ_»_lemma› =
	Ù µ p∑ $µ p § (µ x∑ p x)

€µ_±_out_lemma› =
	Ù µ p q∑ $µ p ± $µ q § (µ x∑ p x ± q x)
=TEX

\ignore{
=SML
set_goal([], ¨µp:'a ≠ BOOL∑ $µ p § $µ Ãx∑ p xÆ);
a (REPEAT strip_tac);
a (POP_ASM_T (rewrite_thm_tac o (rewrite_rule []) o (once_rewrite_rule [map_eq_sym_rule »_axiom])));
a (once_rewrite_tac [map_eq_sym_rule »_axiom]);
a (asm_rewrite_tac[]);
val µ_»_lemma = save_pop_thm "µ_»_lemma";

set_goal([], ¨µp q:'a ≠ BOOL∑ $µ p ± $µ q § $µ Ãx∑ p x ± q xÆ);
a (REPEAT strip_tac);
a (GET_ASM_T ¨$µ pÆ (rewrite_thm_tac o (once_rewrite_rule [µ_»_lemma])));
a (GET_ASM_T ¨$µ qÆ (rewrite_thm_tac o (once_rewrite_rule [µ_»_lemma])));
a (once_rewrite_tac [µ_»_lemma]);
a (asm_rewrite_tac[]);
a (once_rewrite_tac [µ_»_lemma]);
a (asm_rewrite_tac[]);
val µ_±_out_lemma = save_pop_thm "µ_±_out_lemma";
=TEX
}%ignore

\section{Type Definition Lemmas}

\subsubsection{ManyOne}

The relations used in replacement must be ``ManyOne'' relations, otherwise the image may be larger than the domain, and Russell's paradox would reappear.

πHOLCONST
‹ €ManyOne› : ('a ≠ 'b ≠ BOOL) ≠ BOOL
˜
‹ µr∑ ManyOne r § µx y z∑ r x y ± r x z ¥ y = z
∞


=GFT
type_lemmas_thm2 =
   Ù µ pred
     ∑ (∂ f∑ TypeDefn pred f)
         ¥ (∂ abs rep
         ∑ (µ a∑ abs (rep a) = a)
             ± (µ r∑ pred r § rep (abs r) = r)
             ± OneOne rep)

type_defn_lemma1 =
   Ù µ f g∑ (µ x∑ f (g x) = x) ¥ (µ x y∑ g x = g y ¥ x = y)

type_defn_lemma2 =
   Ù µ p f g
     ∑ (µ x∑ p x ¥ f (g x) = x) ¥ (µ x y∑ p x ± p y ¥ g x = g y ¥ x = y)

type_defn_lemma3 =
   Ù (∂ f∑ TypeDefn (Ã x∑ T) f)
       ¥ (∂ abs rep∑ (µ a∑ abs (rep a) = a) ± (µ r∑ rep (abs r) = r))

oneone_contrapos_lemma =
	Ù OneOne f ¥ (µ x y∑ ≥ x = y ¥ ≥ f x = f y)
=TEX


\ignore{
=SML
set_goal([], ¨µ pred
     ∑ (∂ f: 'a ≠ 'b∑ TypeDefn pred f)
         ¥ (∂ abs (rep: 'a ≠ 'b)
         ∑ (µ a∑ abs (rep a) = a) ± (µ r∑ pred r § rep (abs r) = r)
	± OneOne rep)Æ);
a (REPEAT strip_tac THEN fc_tac [type_lemmas_thm]);
a (∂_tac ¨absÆ THEN ∂_tac ¨repÆ
	THEN asm_rewrite_tac[get_spec ¨OneOneÆ]
	THEN REPEAT strip_tac);
a (LEMMA_T ¨abs (rep x1) = abs(rep x2)Æ
	(rewrite_thm_tac o (rewrite_rule[asm_rule ¨µ a∑ abs (rep a) = aÆ]))
	THEN1 rewrite_tac[asm_rule ¨rep x1 = rep x2Æ]);
val type_lemmas_thm2 = save_pop_thm "type_lemmas_thm2";

set_goal([], ¨µf g∑ (µx∑f(g(x)) = x) ¥ (µx y∑ g x = g y ¥ x = y)Æ);
a (REPEAT strip_tac);
a (LEMMA_T ¨f(g(x)) = f(g(y))Æ ante_tac THEN1 rewrite_tac[asm_rule ¨g x = g yÆ]
	THEN asm_rewrite_tac[]);
val type_defn_lemma1 = save_pop_thm "type_defn_lemma1";

set_goal([], ¨µp f g∑ (µx∑ p x ¥ f(g(x)) = x) ¥ (µx y∑ p x ± p y ¥ g x = g y ¥ x = y)Æ);
a (REPEAT strip_tac);
a (LEMMA_T ¨f(g(x)) = f(g(y))Æ ante_tac THEN1 rewrite_tac[asm_rule ¨g x = g yÆ]);
a (LEMMA_T ¨f (g x) = xÆ rewrite_thm_tac THEN1 asm_fc_tac[]);
a (LEMMA_T ¨f (g y) = yÆ rewrite_thm_tac THEN1 asm_fc_tac[]);
val type_defn_lemma2 = save_pop_thm "type_defn_lemma2";

set_goal([], ¨(∂ f: 'a ≠ 'b∑ TypeDefn (Ãx∑T) f)
         ¥ ∂ abs (rep: 'a ≠ 'b)∑
	(µ a∑ abs (rep a) = a) ± (µ r∑ rep (abs r) = r)Æ);
a (REPEAT strip_tac);
a (fc_tac [type_lemmas_thm2]);
a (DROP_NTH_ASM_T 2 (asm_tac o (rewrite_rule[])));
a (∂_tac ¨absÆ THEN ∂_tac ¨repÆ THEN asm_rewrite_tac[]);
val type_defn_lemma3 = save_pop_thm "type_defn_lemma3";

set_goal([], ¨µf∑ OneOne f ¥ µx y∑ ≥ x = y ¥ ≥ f x = f yÆ);
a (strip_tac THEN rewrite_tac [get_spec ¨OneOneÆ] THEN contr_tac);
a (asm_fc_tac[]);
val oneone_contrapos_lemma = save_pop_thm "oneone_contrapos_lemma";
=TEX
}%ignore

\section{Sets}

\subsection{Pairwise Disjointness}

Here is a definition of ``Pairwise disjoint''.

πHOLCONST
‹ $€PDisj›: 'a  SET SET ≠ BOOL
˜¸¸¸¸¸¸
‹ µss∑ PDisj ss § ≥ ∂t u∑ {t; u} Ä ss ± ≥ t = u ± ≥ t ° u = {} 
∞

\subsection{Transitivity of Inclusion}

=GFT
€Ä_trans_thm› = Ù µ A B C∑ A Ä B ± B Ä C ¥ A Ä C
=TEX

\ignore{
=SML
val Ä_trans_thm = save_thm ("Ä_trans_thm", pc_rule1 "hol1" prove_rule []
	¨µA B C∑ A Ä B ± B Ä C ¥ A Ä CÆ);
=TEX
}%ignore

\subsection{Singleton Subsets}

=GFT
€singleton_subset_lemma› =
   Ù µ x v∑ {x} Ä V § x ç V
=TEX

\ignore{
=SML
set_goal ([], ¨µV x∑ {x} Ä V § x ç VÆ);
a (PC_T1 "hol1" prove_tac[]);
val singleton_subset_lemma = save_pop_thm "singleton_subset_lemma";
=TEX
}%ignore

\subsection{Image of a Set under a Function}

πHOLCONST
‹ €FunImage›: ('a ≠ 'b) ≠ 'a SET ≠ 'b SET
˜¸¸¸¸¸¸
‹ µf A∑ FunImage f A = {b | ∂a∑ a ç A ± f a = b}
∞

\subsection{Set Displays}

The following are introduced to facilitate reasoning about sets of truth values below.

=GFT
€insert_com_thm› = 
	Ù µ x y z∑ Insert x (Insert y z) = Insert y (Insert x z)

€insert_twice_thm› =
	Ù µ x y∑ Insert x (Insert x y) = Insert x y
=TEX

\ignore{
=SML
set_goal([], ¨µx y z∑ Insert x (Insert y z) = Insert y (Insert x z)Æ);
a (rewrite_tac [sets_ext_clauses, get_spec ¨InsertÆ] THEN REPEAT strip_tac);
val insert_com_thm = save_pop_thm "insert_com_thm";

set_goal([], ¨µx y∑ Insert x (Insert x y) = (Insert x y)Æ);
a (rewrite_tac [sets_ext_clauses, get_spec ¨InsertÆ] THEN REPEAT strip_tac);
val insert_twice_thm = save_pop_thm "insert_twice_thm";
=TEX
}%ignore

\ignore{
=SML
add_pc_thms "'rbjmisc" (map get_spec [] @ [singleton_subset_lemma, insert_twice_thm]);
set_merge_pcs ["basic_hol1", "'sets_alg", "'Ø", "'rbjmisc"];
=TEX
}%ignore

\subsection{NESET - A Type of Non-Empty Sets}

=SML
new_type_defn (["NESET"], "NESET", ["'a"],
	tac_proof (([], ¨∂x:'a ∑ (Ãy∑ ∂z∑ z ç y) xÆ),
	∂_tac ¨{≈x:'a∑T}Æ THEN rewrite_tac [] THEN ∂_tac ¨≈x:'a∑TÆ THEN rewrite_tac[]) );
=TEX

\ignore{
=SML
set_goal([], ¨∂(NeSet: 'a  ≠ 'a NESET) (PeSet : 'a NESET ≠ 'a )∑
	(µx∑ ∂y∑ y ç PeSet x)
	± (µx y∑ x = y § µz∑ z ç PeSet x § z ç PeSet y)
	± (µx y∑ x ç y ¥ PeSet (NeSet y) = y)
	± (µy∑ NeSet (PeSet y) = y)Æ);
a (strip_asm_tac (get_defn "-" "NESET"));
a (fc_tac [type_lemmas_thm2]);
a (lemma_tac ¨µ r z∑ z ç r ¥ rep (abs r) = rÆ
	THEN1 (REPEAT strip_tac));
(* *** Goal "1" *** *)
a (spec_nth_asm_tac 3 ¨rÆ
		THEN_TRY asm_fc_tac[]
		THEN (DROP_NTH_ASM_T 2 ante_tac)
		THEN rewrite_tac[] THEN strip_tac THEN asm_fc_tac[]);
(* *** Goal "2" *** *)
a (∂_tac ¨absÆ THEN ∂_tac ¨repÆ THEN asm_rewrite_tac [] THEN REPEAT strip_tac
	THEN_TRY all_var_elim_asm_tac THEN asm_fc_tac[] THEN_TRY asm_rewrite_tac[]);
(* *** Goal "2.1" *** *)
a (lemma_tac ¨rep(abs(rep x)) = rep xÆ
	THEN1 asm_rewrite_tac[]);
a (spec_nth_asm_tac 4 ¨rep xÆ);
a (POP_ASM_T ante_tac THEN rewrite_tac[]);
(* *** Goal "2.2" *** *)
a (fc_tac [get_spec ¨OneOneÆ]);
a (POP_ASM_T (strip_asm_tac o (rewrite_rule [])));
a (lemma_tac ¨rep x = rep yÆ THEN1 fc_tac [map_eq_sym_rule sets_ext_clauses]);
a (asm_fc_tac[]);
save_cs_∂_thm (pop_thm());
=TEX
}%ignore

πHOLCONST
‹ €NeSet› : 'a  ≠ 'a NESET;
‹ €PeSet› : 'a NESET ≠ 'a 
˜¸¸¸¸¸¸¸¸¸¸¸
‹	  (µx∑ ∂y∑ y ç PeSet x)
‹	± (µx y∑ x = y § µz∑ z ç PeSet x § z ç PeSet y)
‹	± (µx y∑ x ç y ¥ PeSet (NeSet y) = y)
‹	± (µy∑ NeSet (PeSet y) = y)
∞

=GFT
€NeSet_ne_thm› =
	Ù µ x∑ ∂ y∑ y ç PeSet x
€NeSet_ext_thm› =
	Ù µ x y∑ x = y § (µ z∑ z ç PeSet x § z ç PeSet y)
€NeSet_fc_thm› =
	Ù µ x y∑ x ç y ¥ PeSet (NeSet y) = y
€NeSet_PeSet_thm› =
	Ù µ y∑ NeSet (PeSet y) = y
=TEX

\ignore{
=SML
val [NeSet_ne_thm, NeSet_ext_thm, NeSet_fc_thm, NeSet_PeSet_thm] = strip_±_rule (get_spec ¨NeSetÆ);
=TEX
}%ignore

=GFT
€PeSet_Insert_thm› =
	Ù µ x y∑ PeSet (NeSet (Insert x y)) = Insert x y
=TEX

\ignore{
=SML
set_goal([], ¨µx y∑ PeSet(NeSet(Insert x y)) = (Insert x y)Æ);
a (REPEAT strip_tac);
a (bc_tac [list_µ_elim [¨xÆ, ¨Insert x yÆ] NeSet_fc_thm]);
a (rewrite_tac [get_spec ¨InsertÆ]);
val PeSet_Insert_thm = save_pop_thm "PeSet_Insert_thm";
=TEX
}%ignore

πHOLCONST
‹ €MemOf› : 'a NESET ≠ 'a
˜¸¸¸¸¸¸¸¸¸¸¸
‹	µx∑ MemOf x = ≈y∑ y ç PeSet x 
∞

=GFT
€MemOf_memof_thm› =
	Ù µ x∑ MemOf x ç PeSet x
€MemOf_NeSet_unit_thm› =
	Ù µ x∑ MemOf (NeSet {x}) = x
=TEX

\ignore{
=SML
set_goal([], ¨µx∑ MemOf x ç PeSet xÆ);
a (µ_tac THEN rewrite_tac [get_spec ¨MemOfÆ]);
a (≈_tac ¨≈ y∑ y ç PeSet xÆ);
a (rewrite_tac [NeSet_ne_thm]);
val MemOf_memof_thm = save_pop_thm "MemOf_memof_thm";

val MemOf_NeSet_unit_thm = save_thm ("MemOf_NeSet_unit_thm",
	all_µ_intro (rewrite_rule [PeSet_Insert_thm] (µ_elim ¨NeSet {x}Æ MemOf_memof_thm)));
=TEX
}%ignore

=SML
add_pc_thms1 "'rbjmisc" [NeSet_ne_thm];
add_pc_thms "'rbjmisc" [NeSet_PeSet_thm, MemOf_memof_thm, PeSet_Insert_thm, MemOf_NeSet_unit_thm];
=TEX


\section{Type OPT}

=SML
set_merge_pcs ["hol1", "'rbjmisc"];

new_type_defn (["OPT"], "OPT", ["'a"],
	tac_proof (([], ¨∂x:'a+ONE∑ (Ãy∑T) xÆ), ∂_tac ¨InR OneÆ THEN rewrite_tac []) );
=TEX

To make use of the type abbreviation `OPT' more readable the following constants are introduced:

\ignore{
=SML
set_goal([], ¨∂(Value:'a ≠ 'a OPT) Undefined∑
	OneOne Value
	± (µx∑ ≥ Value x = Undefined)
	± (µy∑ y = Undefined ≤ (∂z∑ y = Value z))Æ);
a (strip_asm_tac (get_defn "-" "OPT"));
a (fc_tac [type_lemmas_thm2]);
a (DROP_NTH_ASM_T 2 (asm_tac o (rewrite_rule[])));
a (fc_tac [get_spec ¨OneOneÆ] THEN POP_ASM_T (asm_tac o rewrite_rule[]));
a (∂_tac ¨Ãx∑ abs (InL x)Æ THEN ∂_tac ¨abs (InR One)Æ THEN rewrite_tac [] THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a (rewrite_tac[ get_spec ¨OneOneÆ] THEN REPEAT strip_tac);
a (lemma_tac ¨rep(abs(InL x1)) = rep(abs(InL x2))Æ THEN1 rewrite_tac[asm_rule ¨abs (InL x1) = abs (InL x2)Æ]);
a (POP_ASM_T (asm_tac o (rewrite_rule [asm_rule ¨µ r∑ rep (abs r) = rÆ])));
a strip_tac;
(* *** Goal "2" *** *)
a (contr_tac);
a (LEMMA_T ¨rep(abs(InL x)) = rep(abs(InR One))Æ (strip_asm_tac o (rewrite_rule [asm_rule ¨µ r∑ rep (abs r) = rÆ]))
	THEN1 rewrite_tac[asm_rule ¨abs (InL x) = abs (InR One)Æ]);
(* *** Goal "3" *** *)
a (strip_asm_tac (µ_elim ¨rep yÆ sum_cases_thm));
(* *** Goal "3.1" *** *)
a (∂_tac ¨y'Æ THEN rewrite_tac [map_eq_sym_rule (asm_rule ¨rep y = InL y'Æ), asm_rule ¨µ a∑ abs (rep a) = aÆ]);
(* *** Goal "3.2" *** *)
a (LEMMA_T ¨z = OneÆ asm_tac THEN1 rewrite_tac[]);
a (var_elim_asm_tac ¨z = OneÆ);
a (lemma_tac ¨abs(rep(y)) = abs(InR One)Æ THEN1 rewrite_tac[asm_rule ¨rep y = InR OneÆ]);
a (POP_ASM_T ante_tac THEN asm_rewrite_tac[]);
save_cs_∂_thm (pop_thm());
=TEX
}%ignore

πHOLCONST
‹ €Value› : 'a ≠ 'a OPT;
‹ €Undefined› : 'a OPT
˜¸¸¸¸¸¸¸¸¸¸¸
‹ OneOne Value
‹	± (µx∑ ≥ Value x = Undefined)
‹	± (µy∑ y = Undefined ≤ (∂z∑ y = Value z))
∞

=GFT
€opt_cases_thm› =
   Ù µ x∑ x = Undefined ≤ (∂ y∑ x = Value y)

€value_not_undefined_lemma› =
   Ù µ x∑ ≥ Value x = Undefined ± ≥ Undefined = Value x
=TEX

\ignore{
=SML
set_goal([], ¨µx∑ x = Undefined ≤ (∂y∑ x = Value y)Æ);
a strip_tac;
a (strip_asm_tac (get_spec ¨ValueÆ));
a (spec_nth_asm_tac 1 ¨xÆ THEN_TRY asm_rewrite_tac[]);
val opt_cases_thm = save_pop_thm "opt_cases_thm";

set_goal([], ¨µx∑ ≥ Value x = Undefined ± ≥ Undefined = Value xÆ);
a (strip_tac);
a (strip_asm_tac (get_spec ¨ValueÆ)
	THEN asm_rewrite_tac[]
	THEN SYM_ASMS_T rewrite_tac);
val value_not_undefined_lemma = save_pop_thm "value_not_undefined_lemma";

set_goal([], ¨µx y∑ Value x = Value y § x = yÆ);
a (REPEAT strip_tac THEN_TRY asm_rewrite_tac[]);
a (strip_asm_tac (rewrite_rule [get_spec ¨OneOneÆ] (get_spec ¨ValueÆ))
	THEN asm_fc_tac[]);
val value_oneone_lemma = save_pop_thm "value_oneone_lemma";

set_goal([], ¨∂ValueOf: 'a OPT ≠ 'a∑ µv∑ ValueOf (Value v) = vÆ);
a (∂_tac ¨Ãx∑ ≈ y∑ Value y = xÆ THEN rewrite_tac[get_spec ¨ValueÆ]
	THEN strip_tac);
a (≈_tac ¨≈ y∑ Value y = Value vÆ);
a (∂_tac ¨vÆ THEN rewrite_tac[]);
a (strip_asm_tac (get_spec ¨ValueÆ));
a (fc_tac [get_spec ¨OneOneÆ]);
a (POP_ASM_T ante_tac THEN rewrite_tac[] THEN strip_tac);
a (all_asm_fc_tac []);
save_cs_∂_thm (pop_thm());
=TEX
}%ignore

πHOLCONST
‹ €ValueOf› : 'a OPT ≠ 'a
˜¸¸¸¸¸¸¸¸¸¸¸
‹ µv∑ ValueOf (Value v) = v
∞

πHOLCONST
‹ €IsDefined› : 'a OPT ≠ BOOL
˜¸¸¸¸¸¸¸¸¸¸¸
‹ µv∑ IsDefined v § ≥ v = Undefined
∞

\subsection{Proof Contexts}

=SML
add_pc_thms "'rbjmisc" (map get_spec [¨IsDefinedÆ, ¨ValueOfÆ] @
	[value_not_undefined_lemma, value_oneone_lemma]);
set_merge_pcs ["basic_hol1", "'sets_alg", "'Ø", "'rbjmisc"];
=TEX

\section{Lists}

\subsection{List Membership}

=SML
declare_infix(300, "çâL");
=TEX

πHOLCONST
‹ $€çâL›: 'a ≠ 'a  LIST ≠ BOOL
˜¸¸¸¸¸¸
‹ µ a b al∑ (a çâL [] § F)
‹	± (a çâL (Cons b al) § a = b ≤ a çâL al)
∞

\subsection{Quantification}

πHOLCONST
‹ €µâL›: BOOL LIST ≠ BOOL
˜¸¸¸¸¸¸
‹ µ bl∑ µâL bl = Fold $± bl T
∞

πHOLCONST
‹ €∂âL›: BOOL LIST ≠ BOOL
˜¸¸¸¸¸¸
‹ µ bl∑ ∂âL bl = Fold $≤ bl F
∞

\subsection{Mapping Constructors}

The idea here is to facilitate the construction of a list of objects of some kind (typically a HOL labelled product), given a curried constructor and lists of the operands.
We will need a different one for each arity of constructor, so I will use a numeric suffix.

πHOLCONST
‹ €MapCfâ2›: ('a ≠ 'b ≠ 'c) ≠ 'a LIST ≠ 'b LIST ≠ 'c LIST
˜¸¸¸¸¸¸
‹ µ cf al bl∑  MapCfâ2 cf al bl = Map (Uncurry cf) (Combine al bl)
∞

πHOLCONST
‹ €MapCfâ3›: ('a ≠ 'b ≠ 'c ≠ 'd) ≠ 'a LIST ≠ 'b LIST ≠ 'c LIST ≠ 'd LIST
˜¸¸¸¸¸¸
‹ µ cf al bl cl∑  MapCfâ3 cf al bl cl =
	Map (Uncurry (Uncurry cf)) (Combine (Combine al bl) cl)
∞

\subsection{Liberal Combine}

This is a combine function which ``works'' with lists of different lengths.

πHOLCONST
‹ €Combine2›: 'a LIST ≠ 'b LIST ≠ ('a ∏ 'b) LIST
˜¸¸¸¸¸¸
‹   (µb∑  Combine2 [] b = [])
‹ ± (µa∑  Combine2 a [] = [])
‹ ± (µha ta hb tb∑ Combine2 (Cons ha ta) (Cons hb tb) = Cons (ha, hb) (Combine2 ta tb))
∞


\subsection{Lists of Sets}

πHOLCONST
‹ €List2Set›: 'a LIST ≠ 'a SET
˜¸¸¸¸¸¸
‹ µl∑ List2Set l = {e | e çâL l}
∞
πHOLCONST
‹ €ListUnion›: 'a SET LIST ≠ 'a SET
˜¸¸¸¸¸¸
‹ µl∑ ListUnion l = ﬁ (List2Set l)
∞
πHOLCONST
‹ €ListFunUnion›: ('a SET ≠ 'a SET) LIST ≠ ('a SET ≠ 'a SET)
˜¸¸¸¸¸¸
‹ µl as∑ ListFunUnion l as = ListUnion (Map (Ãf∑ f as) l)
∞

=GFT
€ListUnion_thm› =
   Ù ListUnion [] = {} ± (µ h t∑ ListUnion (Cons h t) = h ¿ ListUnion t)
=TEX

\ignore{
=SML
set_goal([], ¨ListUnion [] = {} ± µh t∑ ListUnion (Cons h t) = h ¿ (ListUnion t)Æ);
a (rewrite_tac ((map get_spec [¨ListUnionÆ, ¨FoldÆ, ¨List2SetÆ, ¨$çâLÆ])@[sets_ext_clauses])
	THEN REPEAT strip_tac THEN_TRY (all_asm_fc_tac[]));
(* *** Goal "1" *** *)
a ( ∂_tac ¨sÆ THEN asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a ( ∂_tac ¨hÆ THEN asm_rewrite_tac[]);
(* *** Goal "3" *** *)
a ( ∂_tac ¨sÆ THEN asm_rewrite_tac[]);
val ListUnion_thm = save_pop_thm "ListUnion";
=TEX
}%ignore

\subsection{Lists of Natural Numbers}

A function for making a list of ascending natural numbers.

=SML
declare_infix (300, "..âL");
=TEX
πHOLCONST
‹ $€..âL›: Ó ≠ Ó ≠ Ó LIST
˜¸¸¸¸¸¸
‹ µ x y∑ x ..âL 0 = []
‹ ± x ..âL (y + 1) = if x º y then (x ..âL y) @ [y+1] else []
∞

\section{Real Numbers and Analysis}

\subsection{Products}
=GFT
Ø_prod_sign_iff_clauses 
Ù (µ x y∑ ÓØ 0 <R x *âR y		§ ÓØ 0 <âR x ± ÓØ 0 <âR y ≤ x <âR ÓØ 0 ± y <âR ÓØ 0)
± (µ x y∑ x *âR y <âR ÓØ 0		§ ÓØ 0 <âR x ± y <âR ÓØ 0 ≤ x <âR ÓØ 0 ± ÓØ 0 <âR y)
± (µ x y∑ ÓØ 0 ºâR x *âR y		§ ÓØ 0 ºâR x ± ÓØ 0 ºâR y ≤ x ºâR ÓØ 0 ± y ºâR ÓØ 0)
± (µ x y∑ x *âR y ºâR ÓØ 0		§ ÓØ 0 ºâR x ± y ºâR ÓØ 0 ≤ x ºâR ÓØ 0 ± ÓØ 0 ºâR y)
± (µ x y∑ x *âR y = ÓØ 0		§ x = ÓØ 0 ≤ y = ÓØ 0)
± (µ x y∑ ÓØ 0 = x *âR y		§ x = ÓØ 0 ≤ y = ÓØ 0)
=TEX

\ignore{
=SML
set_goal([], ¨µ x y∑
	(ÓØ 0 <âR x ± ÓØ 0 <âR y ¥ ÓØ 0 <âR x *âR y)
	± (x <âR ÓØ 0 ± y <âR ÓØ 0 ¥ ÓØ 0 <âR x *âR y)
	± (x <âR ÓØ 0 ± ÓØ 0 <âR y ¥ x *âR y <âR ÓØ 0)
	± (ÓØ 0 <âR x ± y <âR ÓØ 0 ¥ x *âR y <âR ÓØ 0)
	± (x = ÓØ 0 ≤ y = ÓØ 0 ¥ x *âR y = ÓØ 0)
Æ);
a (REPEAT strip_tac
	THEN TRY (asm_rewrite_tac[]));
(* *** Goal "1" *** *)
a (all_asm_ufc_tac [Ø_0_less_0_less_times_thm]);
(* *** Goal "2" *** *)
a (all_asm_ufc_tac [Ø_less_0_less_thm]);
a (LEMMA_T ¨ÓØ 0 <âR (~âR x) *âR (~âR y)Æ ante_tac
	THEN1 all_asm_ufc_tac [Ø_0_less_0_less_times_thm]);
a (rewrite_tac[Ø_times_minus_thm]);
(* *** Goal "3" *** *)
a (once_rewrite_tac [Ø_less_0_less_thm]);
a (rewrite_tac[]);
a (lemma_tac ¨ÓØ 0 <âR (~âR x)Æ
	THEN1 (ALL_ASM_FC_T (MAP_EVERY ante_tac) [Ø_less_0_less_thm]
		THEN rewrite_tac[]
		THEN REPEAT strip_tac));
a (all_asm_ufc_tac [Ø_0_less_0_less_times_thm]);
a (lemma_tac ¨~âR (x *âR y) = ~âR x *âR yÆ
	THEN1 (PC_T1 "Ø_lin_arith" prove_tac[]));
a (asm_rewrite_tac[]);
(* *** Goal "4" *** *)
a (once_rewrite_tac [Ø_less_0_less_thm]);
a (rewrite_tac[]);
a (lemma_tac ¨ÓØ 0 <âR (~âR y)Æ
	THEN1 (ALL_ASM_FC_T (MAP_EVERY ante_tac) [Ø_less_0_less_thm]
		THEN rewrite_tac[]
		THEN REPEAT strip_tac));
a (all_asm_ufc_tac [Ø_0_less_0_less_times_thm]);
a (lemma_tac ¨~âR (x *âR y) = x *âR ~âR yÆ
	THEN1 (PC_T1 "Ø_lin_arith" prove_tac[]));
a (asm_rewrite_tac[]);
val Ø_product_sign_lemma = pop_thm ();
=TEX
=SML
set_goal([], ¨µ x y∑
	(ÓØ 0 <âR x *âR y ¥ ÓØ 0 <âR x ± ÓØ 0 <âR y ≤ x <âR ÓØ 0 ± y <âR ÓØ 0)
	± (x *âR y <âR ÓØ 0 ¥ ÓØ 0 <âR x ± y <âR ÓØ 0 ≤ ÓØ 0 <âR y ± x <âR ÓØ 0)
	± (x *âR y = ÓØ 0 ¥ x = ÓØ 0 ≤ y = ÓØ 0)
Æ);
a contr_tac;
(* *** Goal "1" *** *)
a (strip_asm_tac (list_µ_elim [¨xÆ, ¨ÓØ 0Æ] Ø_less_cases_thm));
a (DROP_NTH_ASM_T 4 ante_tac THEN asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a (strip_asm_tac (list_µ_elim [¨xÆ, ¨ÓØ 0Æ] Ø_less_cases_thm));
(* *** Goal "2.1" *** *)
a (strip_asm_tac (list_µ_elim [¨yÆ, ¨ÓØ 0Æ] Ø_less_cases_thm));
(* *** Goal "2.1.1" *** *)
a (DROP_NTH_ASM_T 5 ante_tac THEN asm_rewrite_tac[]);
(* *** Goal "2.1.2" *** *)
a (all_asm_ufc_tac[Ø_product_sign_lemma]);
a (all_asm_ufc_tac[Ø_less_trans_thm]);
(* *** Goal "2.2" *** *)
a (DROP_NTH_ASM_T 4 ante_tac THEN asm_rewrite_tac[]);
(* *** Goal "3" *** *)
a (strip_asm_tac (list_µ_elim [¨yÆ, ¨ÓØ 0Æ] Ø_less_cases_thm));
(* *** Goal "3.1" *** *)
a (strip_asm_tac (list_µ_elim [¨xÆ, ¨ÓØ 0Æ] Ø_less_cases_thm));
(* *** Goal "3.1.1" *** *)
a (DROP_NTH_ASM_T 5 ante_tac THEN asm_rewrite_tac[]);
(* *** Goal "3.1.2" *** *)
a (all_asm_ufc_tac[Ø_product_sign_lemma]);
a (all_asm_ufc_tac[Ø_less_trans_thm]);
(* *** Goal "3.2" *** *)
a (DROP_NTH_ASM_T 4 ante_tac THEN asm_rewrite_tac[]);
(* *** Goal "4" *** *)
a (strip_asm_tac (list_µ_elim [¨yÆ, ¨ÓØ 0Æ] Ø_less_cases_thm));
a (DROP_NTH_ASM_T 4 ante_tac THEN asm_rewrite_tac[]);
(* *** Goal "5" *** *)
a (strip_asm_tac (list_µ_elim [¨xÆ, ¨ÓØ 0Æ] Ø_less_cases_thm));
(* *** Goal "5.1" *** *)
a (strip_asm_tac (list_µ_elim [¨yÆ, ¨ÓØ 0Æ] Ø_less_cases_thm));
(* *** Goal "5.1.1" *** *)
a (all_asm_ufc_tac[Ø_product_sign_lemma]);
a (all_asm_ufc_tac[Ø_less_trans_thm]);
(* *** Goal "5.1.2" *** *)
a (DROP_NTH_ASM_T 5 ante_tac THEN asm_rewrite_tac[]);
(* *** Goal "5.2" *** *)
a (DROP_NTH_ASM_T 4 ante_tac THEN asm_rewrite_tac[]);
(* *** Goal "6" *** *)
a (strip_asm_tac (list_µ_elim [¨xÆ, ¨ÓØ 0Æ] Ø_less_cases_thm));
a (DROP_NTH_ASM_T 4 ante_tac THEN asm_rewrite_tac[]);
(* *** Goal "7" *** *)
a (strip_asm_tac (list_µ_elim [¨yÆ, ¨ÓØ 0Æ] Ø_less_cases_thm));
a (DROP_NTH_ASM_T 4 ante_tac THEN asm_rewrite_tac[]);
(* *** Goal "8" *** *)
a (strip_asm_tac (list_µ_elim [¨yÆ, ¨ÓØ 0Æ] Ø_less_cases_thm));
(* *** Goal "8.1" *** *)
a (strip_asm_tac (list_µ_elim [¨xÆ, ¨ÓØ 0Æ] Ø_less_cases_thm));
(* *** Goal "8.1.1" *** *)
a (DROP_NTH_ASM_T 5 ante_tac THEN asm_rewrite_tac[]);
(* *** Goal "8.1.2" *** *)
a (DROP_NTH_ASM_T 5 ante_tac THEN asm_rewrite_tac[]);
(* *** Goal "8.2" *** *)
a (strip_asm_tac (list_µ_elim [¨xÆ, ¨ÓØ 0Æ] Ø_less_cases_thm));
(* *** Goal "8.2.1" *** *)
a (DROP_NTH_ASM_T 5 ante_tac THEN asm_rewrite_tac[]);
(* *** Goal "8.2.2" *** *)
a (all_asm_ufc_tac[Ø_product_sign_lemma]);
a (all_asm_ufc_tac[Ø_less_trans_thm]);
(* *** Goal "9" *** *)
a (strip_asm_tac (list_µ_elim [¨xÆ, ¨ÓØ 0Æ] Ø_less_cases_thm));
(* *** Goal "9.1" *** *)
a (strip_asm_tac (list_µ_elim [¨yÆ, ¨ÓØ 0Æ] Ø_less_cases_thm));
(* *** Goal "9.1.1" *** *)
a (all_asm_ufc_tac[Ø_product_sign_lemma]);
a (DROP_NTH_ASM_T 5 ante_tac THEN asm_rewrite_tac[]);
(* *** Goal "9.1.2" *** *)
a (all_asm_ufc_tac[Ø_product_sign_lemma]);
a (DROP_NTH_ASM_T 5 ante_tac THEN asm_rewrite_tac[]);
(* *** Goal "9.2" *** *)
a (strip_asm_tac (list_µ_elim [¨yÆ, ¨ÓØ 0Æ] Ø_less_cases_thm));
(* *** Goal "9.2.1" *** *)
a (all_asm_ufc_tac[Ø_product_sign_lemma]);
a (DROP_NTH_ASM_T 5 ante_tac THEN asm_rewrite_tac[]);
(* *** Goal "9.2.2" *** *)
a (all_asm_ufc_tac[Ø_product_sign_lemma]);
a (DROP_NTH_ASM_T 5 ante_tac THEN asm_rewrite_tac[]);
val Ø_product_sign_cp_lemma = pop_thm ();
=TEX
=SML
set_goal([], ¨(µ x y∑ ÓØ 0 <âR x *âR y § ÓØ 0 <âR x ± ÓØ 0 <âR y
		≤ x <âR ÓØ 0 ± y <âR ÓØ 0)
	± (µ x y∑ x *âR y <âR ÓØ 0 § ÓØ 0 <âR x ± y <âR ÓØ 0
		≤ x <âR ÓØ 0 ± ÓØ 0 <âR y)
	± (µ x y∑ x *âR y = ÓØ 0 § x = ÓØ 0 ≤ y = ÓØ 0)
	± (µ x y∑ ÓØ 0 = x *âR y § x = ÓØ 0 ≤ y = ÓØ 0)Æ);
a (REPEAT strip_tac
	THEN TRY (asm_rewrite_tac [])
	THEN TRY (all_ufc_tac [Ø_product_sign_lemma,
	Ø_product_sign_cp_lemma]));
a (DROP_NTH_ASM_T 2 (asm_tac o (conv_rule eq_sym_conv))
	THEN ufc_tac [Ø_product_sign_cp_lemma]
	THEN asm_rewrite_tac[]);
val Ø_prod_sign_iff_lemma = pop_thm ();
=TEX
=SML
set_goal([], ¨(µ x y∑ ÓØ 0 ºâR x *âR y § ÓØ 0 ºâR x ± ÓØ 0 ºâR y
		≤ x ºâR ÓØ 0 ± y ºâR ÓØ 0)
	± (µ x y∑ x *âR y ºâR ÓØ 0 § ÓØ 0 ºâR x ± y ºâR ÓØ 0
		≤ x ºâR ÓØ 0 ± ÓØ 0 ºâR y)
	± (µ x y∑ x *âR y = ÓØ 0 § x = ÓØ 0 ≤ y = ÓØ 0)
	± (µ x y∑ ÓØ 0 = x *âR y § x = ÓØ 0 ≤ y = ÓØ 0)Æ);
a (rewrite_tac [get_spec ¨$ºâRÆ, Ø_prod_sign_iff_lemma]);
a (REPEAT_N 6 strip_tac THEN TRY (asm_rewrite_tac[])
	THEN (PC_T1 "Ø_lin_arith" prove_tac[]));
val Ø_prod_sign_iff_lemma2 = pop_thm ();
=TEX
=SML
set_goal([], ¨(µ x y∑ ÓØ 0 <âR x *âR y § ÓØ 0 <âR x ± ÓØ 0 <âR y
		≤ x <âR ÓØ 0 ± y <âR ÓØ 0)
	± (µ x y∑ x *âR y <âR ÓØ 0 § ÓØ 0 <âR x ± y <âR ÓØ 0
		≤ x <âR ÓØ 0 ± ÓØ 0 <âR y)
	± (µ x y∑ ÓØ 0 ºâR x *âR y § ÓØ 0 ºâR x ± ÓØ 0 ºâR y
		≤ x ºâR ÓØ 0 ± y ºâR ÓØ 0)
	± (µ x y∑ x *âR y ºâR ÓØ 0 § ÓØ 0 ºâR x ± y ºâR ÓØ 0
		≤ x ºâR ÓØ 0 ± ÓØ 0 ºâR y)
	± (µ x y∑ x *âR y = ÓØ 0 § x = ÓØ 0 ≤ y = ÓØ 0)
	± (µ x y∑ ÓØ 0 = x *âR y § x = ÓØ 0 ≤ y = ÓØ 0)Æ);
a (rewrite_tac [Ø_prod_sign_iff_lemma, Ø_prod_sign_iff_lemma2]
	THEN (PC_T1 "Ø_lin_arith" prove_tac[]));
val Ø_prod_sign_iff_clauses = save_pop_thm "Ø_prod_sign_iff_clauses";
=TEX
}%ignore

\ignore{

=SML
set_goal([], ¨µ x y z∑ ÓØ 0 <âR x ± y <âR z ¥ y *âR x <âR z *âR xÆ);
a (REPEAT strip_tac);
a (all_ufc_tac [Ø_times_mono_thm]);
a (PC_T1 "Ø_lin_arith" asm_prove_tac[]);
val Ø_times_mono_thm1 = save_pop_thm "Ø_times_mono_thm1";
=TEX

=SML

set_goal([], ¨µ x y z∑ ÓØ 0 ºâR x ± y ºâR z ¥ x *âR y ºâR x *âR zÆ);
a (rewrite_tac [get_spec ¨$ºâRÆ]
	THEN REPEAT strip_tac
	THEN TRY (asm_rewrite_tac[])
	THEN TRY (SYM_ASMS_T rewrite_tac)
	THEN TRY (all_ufc_tac
	[Ø_times_mono_thm, Ø_times_mono_thm1, Ø_less_trans_thm]));
val Ø_times_mono_thm2 = save_pop_thm "Ø_times_mono_thm2";

set_goal([], ¨µ x y z∑ ÓØ 0 ºâR x ± y ºâR z ¥ y *âR x ºâR z *âR xÆ);
a (rewrite_tac [get_spec ¨$ºâRÆ]
	THEN REPEAT strip_tac
	THEN TRY (asm_rewrite_tac[])
	THEN TRY (SYM_ASMS_T rewrite_tac)
	THEN TRY (all_ufc_tac
	[Ø_times_mono_thm, Ø_times_mono_thm1, Ø_less_trans_thm]));
val Ø_times_mono_thm3 = save_pop_thm "Ø_times_mono_thm3";
=TEX

=SML
set_goal([], ¨µ w x y z∑ ÓØ 0 <âR w ± ÓØ 0 <âR y ± w <âR x ± y <âR z ¥ w *âR y <âR x *âR zÆ);
a (REPEAT strip_tac);
a (lemma_tac ¨ÓØ 0 <âR z ± ÓØ 0 <âR xÆ
	THEN1 (all_asm_ufc_tac[Ø_less_trans_thm])
	THEN REPEAT strip_tac);
a (lemma_tac ¨w *âR y <âR w *âR zÆ
	THEN1 (all_asm_ufc_tac[Ø_times_mono_thm, Ø_times_mono_thm1, Ø_less_trans_thm]));
a (lemma_tac ¨w *âR z <âR x *âR zÆ
	THEN1 (strip_asm_tac (list_µ_elim [¨zÆ, ¨wÆ, ¨xÆ] Ø_times_mono_thm1)));
a (strip_asm_tac (list_µ_elim [¨w *âR yÆ, ¨w *âR zÆ, ¨x *âR zÆ] Ø_less_trans_thm));
val Ø_times_mono_thm4 = save_pop_thm "Ø_times_mono_thm4";
=TEX

=SML
set_goal([], ¨µ w x y z∑ ÓØ 0 ºâR w ± ÓØ 0 ºâR y ± w ºâR x ± y ºâR z ¥ w *âR y ºâR x *âR zÆ);
a (REPEAT strip_tac);
a (lemma_tac ¨ÓØ 0 ºâR z ± ÓØ 0 ºâR xÆ
	THEN1 (all_asm_ufc_tac[Ø_º_trans_thm])
	THEN REPEAT strip_tac);
a (lemma_tac ¨w *âR y ºâR w *âR zÆ
	THEN1 (all_asm_ufc_tac[Ø_times_mono_thm2, Ø_times_mono_thm3, Ø_º_trans_thm]));
a (lemma_tac ¨w *âR z ºâR x *âR zÆ
	THEN1 (strip_asm_tac (list_µ_elim [¨zÆ, ¨wÆ, ¨xÆ] Ø_times_mono_thm3)));
a (strip_asm_tac (list_µ_elim [¨w *âR yÆ, ¨w *âR zÆ, ¨x *âR zÆ] Ø_º_trans_thm));
val Ø_times_mono_thm5 = save_pop_thm "Ø_times_mono_thm5";
=TEX
}%ignore

\subsection{Squares}

\ignore{
=SML
set_goal([], ¨µ x y∑ ÓØ 0 <âR x ± x <âR y ¥ x *âR x <âR y *âR yÆ);
a (REPEAT strip_tac);
a (all_asm_ufc_tac [Ø_less_trans_thm]);
a (strip_asm_tac (list_µ_elim [¨xÆ, ¨yÆ, ¨xÆ, ¨yÆ] Ø_times_mono_thm4));
val Ø_square_mono_thm = save_pop_thm "Ø_square_mono_thm";
=TEX

=SML
set_goal([], ¨µ x y∑ ÓØ 0 ºâR x ± x ºâR y ¥ x *âR x ºâR y *âR yÆ);
a (REPEAT strip_tac);
a (all_asm_ufc_tac [Ø_º_trans_thm]);
a (strip_asm_tac (list_µ_elim [¨xÆ, ¨yÆ, ¨xÆ, ¨yÆ] Ø_times_mono_thm5));
val Ø_square_mono_thm1 = save_pop_thm "Ø_square_mono_thm1";
=TEX

=SML
set_goal([], ¨µ x y z∑ ÓØ 0 <âR x ± ÓØ 0 <âR y ± x *âR x <âR y *âR y ¥ x <âR yÆ);
a (REPEAT strip_tac);
a (strip_asm_tac (all_µ_elim Ø_less_cases_thm));
(* *** Goal "1" *** *)
a (DROP_ASM_T ¨x *âR x <âR y *âR yÆ ante_tac
	THEN asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a (strip_asm_tac (list_µ_elim [¨yÆ, ¨xÆ] Ø_square_mono_thm));
a (all_ufc_tac [Ø_less_antisym_thm]);
val Ø_square_less_less_thm = save_pop_thm "Ø_square_less_less_thm";
=TEX

-SML
set_goal([], ¨µ x y∑ ÓØ 0 <âR x ± ÓØ 0 <âR y ¥ (x *âR x <âR y *âR y § x <âR y)Æ);
a (REPEAT strip_tac);
(* *** Goal "1" *** *)
a (all_ufc_tac [Ø_square_less_less_thm]);
(* *** Goal "2" *** *)
a (all_ufc_tac [Ø_square_mono_thm]);
val Ø_square_less_iff_less_thm = save_pop_thm "Ø_square_less_iff_less_thm";
=TEX

=SML
set_goal([], ¨µx y:Ø∑ ÓØ 0 <âR x ± ÓØ 0 <âR y ± y *âR y = x *âR x ¥ x = yÆ);
a (REPEAT strip_tac);
a (strip_asm_tac (all_µ_elim Ø_less_cases_thm)
	THEN (ufc_tac [Ø_times_mono_thm]));
(* *** Goal "1" *** *)
a (lemma_tac ¨x *âR x <âR x *âR yÆ
	THEN1 asm_ufc_tac []);
a (lemma_tac ¨x *âR y <âR y *âR yÆ
	THEN1 all_ufc_tac [list_µ_elim [¨yÆ, ¨xÆ, ¨yÆ] Ø_times_mono_thm1]);
a (ALL_FC_T (MAP_EVERY ante_tac) [Ø_less_trans_thm]
	THEN asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a (lemma_tac ¨x *âR y <âR x *âR xÆ
	THEN1 asm_ufc_tac []);
a (lemma_tac ¨y *âR y <âR x *âR yÆ
	THEN1 all_ufc_tac [list_µ_elim [¨yÆ, ¨yÆ, ¨xÆ] Ø_times_mono_thm1]);
a (ALL_FC_T (MAP_EVERY ante_tac) [Ø_less_trans_thm]
	THEN asm_rewrite_tac[]);
val Ø_square_eq_thm1 = save_pop_thm "Ø_square_eq_thm1";
=TEX

=SML
set_goal([], ¨µx y:Ø∑ ÓØ 0 ºâR x ± ÓØ 0 ºâR y ± y *âR y = x *âR x ¥ x = yÆ);
a (rewrite_tac[get_spec ¨$ºâRÆ]);
a (rewrite_tac (map eq_sym_conv [¨ÓØ 0 = xÆ, ¨ÓØ 0 = yÆ])
	THEN REPEAT strip_tac
	THEN TRY (asm_rewrite_tac[]));
(* *** Goal "1" *** *)
a (all_ufc_tac [Ø_square_eq_thm1]);
(* *** Goal "2" *** *)
a (POP_ASM_T ante_tac THEN asm_rewrite_tac[Ø_prod_sign_iff_clauses]);
(* *** Goal "3" *** *)
a (POP_ASM_T ante_tac
	THEN asm_rewrite_tac[Ø_prod_sign_iff_clauses]
	THEN STRIP_T rewrite_thm_tac);
val Ø_square_eq_thm2 = save_pop_thm "Ø_square_eq_thm2";
=TEX

=SML
set_goal([], ¨µ x y∑ ÓØ 0 <âR x ± ÓØ 0 <âR y ¥ (x *âR x = y *âR y § x = y)Æ);
a (REPEAT strip_tac
	THEN TRY (asm_rewrite_tac[]));
a (strip_asm_tac (all_µ_elim Ø_less_cases_thm)
	THEN (ALL_FC_T (MAP_EVERY ante_tac) [Ø_square_mono_thm])
	THEN TRY (asm_rewrite_tac[]));
a (strip_asm_tac (list_µ_elim [¨yÆ, ¨xÆ] Ø_square_mono_thm)
	THEN POP_ASM_T ante_tac
	THEN TRY (asm_rewrite_tac[]));
val Ø_square_eq_eq_thm = save_pop_thm "Ø_square_eq_eq_thm";
=TEX

=SML
set_goal([], ¨µ x y∑ ÓØ 0 ºâR x ± ÓØ 0 ºâR y ¥ (x *âR x = y *âR y § x = y)Æ);
a (rewrite_tac[get_spec ¨$ºâRÆ]
	THEN REPEAT strip_tac
	THEN TRY (SYM_ASMS_T rewrite_tac));
(* *** Goal "1" *** *)
a (all_ufc_tac [Ø_square_eq_eq_thm]);
(* *** Goal "2" *** *)
a (POP_ASM_T ante_tac
	THEN SYM_ASMS_T rewrite_tac
	THEN rewrite_tac [Ø_prod_sign_iff_clauses]);
(* *** Goal "3" *** *)
a (POP_ASM_T ante_tac
	THEN SYM_ASMS_T rewrite_tac
	THEN rewrite_tac [Ø_prod_sign_iff_clauses]
	THEN strip_tac
	THEN asm_rewrite_tac[]);
val Ø_square_eq_eq_thm2 = save_pop_thm "Ø_square_eq_eq_thm2";
=TEX

=SML
set_goal([], ¨µ x y∑ ÓØ 0 ºâR x ± ÓØ 0 ºâR y ± x *âR x ºâR y *âR y ¥ x ºâR yÆ);
a (REPEAT strip_tac);
a (strip_asm_tac (all_µ_elim Ø_less_cases_thm));
(* *** Goal "1" *** *)
a (asm_rewrite_tac[get_spec ¨$ºâRÆ]);
(* *** Goal "2" *** *)
a (DROP_ASM_T ¨x *âR x ºâR y *âR yÆ ante_tac
	THEN asm_rewrite_tac[]);
(* *** Goal "3" *** *)
a (strip_asm_tac (list_µ_elim [¨yÆ, ¨xÆ] Ø_square_mono_thm1));
(* *** Goal "3.1" *** *)
a (POP_ASM_T ante_tac THEN asm_rewrite_tac[get_spec ¨$ºâRÆ]);
(* *** Goal "3.2" *** *)
a (all_ufc_tac [pc_rule1 "Ø_lin_arith"
	prove_rule [] ¨µx y:Ø∑ x ºâR y ± y ºâR x ¥ x = yÆ]);
a (all_ufc_tac [Ø_square_eq_eq_thm2]);
a (all_var_elim_asm_tac);
val Ø_square_º_º_thm = save_pop_thm "Ø_square_º_º_thm";
=TEX

=SML
set_goal([], ¨µ x y∑ ÓØ 0 ºâR x ± ÓØ 0 ºâR y ¥ (x *âR x ºâR y *âR y § x ºâR y)Æ);
a (REPEAT strip_tac);
(* *** Goal "1" *** *)
a (all_ufc_tac [Ø_square_º_º_thm]);
(* *** Goal "2" *** *)
a (all_ufc_tac [Ø_square_mono_thm1]);
val Ø_square_º_iff_º_thm = save_pop_thm "Ø_square_º_iff_º_thm";
=TEX

=SML
set_goal([], ¨µ x y∑ x *âR x = y *âR y § Abs x = Abs yÆ);
a (REPEAT µ_tac
	THEN rewrite_tac [get_spec ¨AbsâRÆ]
	THEN cases_tac ¨ÓØ 0 ºâR xÆ
	THEN cases_tac ¨ÓØ 0 ºâR yÆ
	THEN TRY (asm_rewrite_tac[])
	);
(* *** Goal "1" *** *)
a (all_ufc_§_rewrite_tac [Ø_square_eq_eq_thm2]); 
(* *** Goal "2" *** *)
a (all_asm_ante_tac
	THEN lemma_tac ¨∂ z∑ y = ~âR zÆ
	THEN1 (∂_tac ¨~âR yÆ
		THEN rewrite_tac[])
	THEN asm_rewrite_tac [Ø_times_minus_thm]
	THEN REPEAT strip_tac);
(* *** Goal "2.1" *** *)
a (lemma_tac ¨ÓØ 0 ºâR zÆ
	THEN1 (PC_T1 "Ø_lin_arith" asm_prove_tac []));
a (all_ufc_tac [Ø_square_eq_eq_thm2]); 
(* *** Goal "2.2" *** *)
a (asm_rewrite_tac []);
(* *** Goal "3" *** *)
a (all_asm_ante_tac
	THEN lemma_tac ¨∂ z∑ x = ~âR zÆ
	THEN1 (∂_tac ¨~âR xÆ
		THEN rewrite_tac[])
	THEN asm_rewrite_tac [Ø_times_minus_thm]);
a (strip_tac THEN strip_tac);
a (lemma_tac ¨ÓØ 0 ºâR zÆ
	THEN1 (PC_T1 "Ø_lin_arith" asm_prove_tac []));
a (all_ufc_§_rewrite_tac [Ø_square_eq_eq_thm2]); 
(* *** Goal "4" *** *)
a (all_asm_ante_tac
	THEN lemma_tac ¨∂ z∑ x = ~âR zÆ
	THEN1 (∂_tac ¨~âR xÆ
		THEN rewrite_tac[])
	THEN lemma_tac ¨∂ v∑ y = ~âR vÆ
	THEN1 (∂_tac ¨~âR yÆ
		THEN rewrite_tac[])
	THEN asm_rewrite_tac[]
	THEN strip_tac THEN strip_tac);
a (lemma_tac ¨ÓØ 0 ºâR zÆ
	THEN1 (PC_T1 "Ø_lin_arith" asm_prove_tac []));
a (lemma_tac ¨ÓØ 0 ºâR vÆ
	THEN1 (PC_T1 "Ø_lin_arith" asm_prove_tac []));
a (rewrite_tac [Ø_times_minus_thm]);
a (all_ufc_§_rewrite_tac [Ø_square_eq_eq_thm2]);
val Ø_square_eq_iff_abs_eq_thm = save_pop_thm "Ø_square_eq_iff_abs_eq_thm";
=TEX

=SML
set_goal([], ¨µx:Ø∑ ÓØ 0 º x ^ 2Æ);
a (rewrite_tac [Ø_Ó_exp_square_thm, Ø_prod_sign_iff_clauses]);
a (PC_T1 "Ø_lin_arith" prove_tac[]);
val Ø_square_pos_thm = save_pop_thm "Ø_square_pos_thm";
=TEX
}%ignore

\subsection{Sums}

\ignore{
=SML
set_goal([], ¨µx y:Ø∑ ÓØ 0 º x ± ÓØ 0 º y ¥ ÓØ 0 º x + yÆ);
a (PC_T1 "Ø_lin_arith" prove_tac[]);
val Ø_sum_pos_thm = save_pop_thm "Ø_sum_pos_thm";
=TEX

=SML
set_goal([], ¨µ x y:Ø∑ ÓØ 0 º x ^âN 2 +âR y ^âN 2Æ);
a (REPEAT µ_tac);
a (lemma_tac ¨ÓØ 0 º x ^ 2 ± ÓØ 0 º y ^ 2Æ
	THEN1 rewrite_tac [Ø_square_pos_thm]);
a (all_ufc_tac [Ø_sum_pos_thm]);
val Ø_sum_square_pos_thm = save_pop_thm "Ø_sum_square_pos_thm";
=TEX

=SML
set_goal([], ¨µx y: Ø∑ x^2 + y^2 = ÓØ 0 § x = ÓØ 0 ± y = ÓØ 0Æ);
a (REPEAT_N 5 strip_tac THEN TRY (asm_rewrite_tac[]));
a (lemma_tac ¨ÓØ 0 º x ^ 2 ± ÓØ 0 º y ^ 2Æ
	THEN1 rewrite_tac [Ø_square_pos_thm]);
a (ALL_FC_T (MAP_EVERY (asm_tac o (rewrite_rule [Ø_Ó_exp_square_thm, Ø_prod_sign_iff_clauses])))
	[pc_rule1 "Ø_lin_arith" prove_rule []
	¨µx y: Ø∑ÓØ 0 º x ± ÓØ 0 º y ¥ x + y = ÓØ 0 ¥ x = ÓØ 0 ± y = ÓØ 0Æ]
	THEN asm_rewrite_tac[]);
val Ø_sum_square_zero_thm = save_pop_thm "Ø_sum_square_zero_thm";
=TEX

=SML
set_goal([], ¨µx y:Ø∑ ÓØ 0 º x ± ÓØ 0 º y
	¥ (x + y = ÓØ 0 § x = ÓØ 0 ± y = ÓØ 0)Æ);
a (PC_T1 "Ø_lin_arith" prove_tac[]);
val Ø_sum_zero_thm = save_pop_thm "Ø_sum_zero_thm";
=TEX

=SML
set_goal([], ¨µ x y:Ø∑ Abs (x ^âN 2 +âR y ^âN 2) = x ^âN 2 +âR y ^âN 2Æ);
a (REPEAT µ_tac);
a (asm_rewrite_tac [get_spec ¨AbsâRÆ, Ø_sum_square_pos_thm]);
val Ø_abs_sum_square_thm = save_pop_thm "Ø_abs_sum_square_thm";
=TEX


=SML
val Ø_plus_mono_thm = save_thm ("Ø_plus_mono_thm", pc_rule1 "Ø_lin_arith" prove_rule []
	¨µu v x y∑ u ºâR v ± x ºâR y ¥ u +âR x ºâR v +âR yÆ);
=TEX
}%ignore

\subsection{Abs}

The following arithmetic results are obtained for reasoning about norms on real vector spaces, in particular to prove that $Abs$ is a norm over the reals and that the defined product operation over norms yields a norm.

=GFT
Ø_Abs_Norm_clauses 
Ù (µ v∑ ÓØ 0 ºâR AbsâR v)
± (µ v∑ (AbsâR v = ÓØ 0) § v = ÓØ 0)
± (µ x v∑ AbsâR (x *âR v) = AbsâR x *âR AbsâR v)
± (µ v w∑ AbsâR (v +âR w) ºâR AbsâR v +âR AbsâR w)
=TEX

\ignore{
=SML
set_goal([], ¨(µ v∑ ÓØ 0 ºâR AbsâR v)
             ± (µ v∑ (AbsâR v = ÓØ 0) = v = ÓØ 0)
             ± (µ x v∑ AbsâR (x *âR v) = AbsâR x *âR AbsâR v)
             ± (µ v w∑ AbsâR (v +âR w) ºâR AbsâR v +âR AbsâR w)Æ);
a (rewrite_tac [get_spec ¨AbsâRÆ, get_spec ¨$ºâRÆ, Ø_prod_sign_iff_clauses]);
a (REPEAT ±_tac THEN REPEAT µ_tac);
(* *** Goal "1" *** *)
a (CASES_T ¨ÓØ 0 < v ≤ ÓØ 0 = vÆ asm_tac
	THEN TRY (asm_rewrite_tac[]));
a (PC_T1 "Ø_lin_arith" asm_prove_tac[]);
(* *** Goal "2" *** *)
a (CASES_T ¨ÓØ 0 < v ≤ ÓØ 0 = vÆ asm_tac
	THEN TRY (asm_rewrite_tac[])
	THEN TRY (PC_T1 "Ø_lin_arith" asm_prove_tac[]));
(* *** Goal "3" *** *)
a (strip_asm_tac (list_µ_elim [¨xÆ, ¨ÓØ 0Æ] Ø_less_cases_thm)
	THEN asm_rewrite_tac[]
	THEN (strip_asm_tac (list_µ_elim [¨vÆ, ¨ÓØ 0Æ] Ø_less_cases_thm))
	THEN asm_rewrite_tac[]);
(* *** Goal "3.1" *** *)
a (LEMMA_T ¨≥(ÓØ 0 < x ≤ ÓØ 0 = x)Æ asm_tac
	THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a (LEMMA_T ¨≥(ÓØ 0 < v ≤ ÓØ 0 = v)Æ asm_tac
	THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a (asm_rewrite_tac[Ø_times_minus_thm]);
(* *** Goal "3.2" *** *)
a (LEMMA_T ¨≥(ÓØ 0 < x ≤ ÓØ 0 = x)Æ asm_tac
	THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a (LEMMA_T ¨≥(v < ÓØ 0 ≤ x = ÓØ 0 ≤ v = ÓØ 0)Æ asm_tac
	THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a (asm_rewrite_tac[Ø_times_minus_thm]);
(* *** Goal "3.3" *** *)
a (LEMMA_T ¨≥(ÓØ 0 < v ≤ ÓØ 0 = v)Æ asm_tac
	THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a (asm_rewrite_tac[Ø_times_minus_thm]);
a (LEMMA_T ¨≥(x < ÓØ 0 ≤ x = ÓØ 0 ≤ v = ÓØ 0)Æ asm_tac
	THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a (asm_rewrite_tac[Ø_times_minus_thm]);
(* *** Goal "4" *** *)
a (strip_asm_tac (list_µ_elim [¨wÆ, ¨ÓØ 0Æ] Ø_less_cases_thm)
	THEN TRY (asm_rewrite_tac[])
	THEN (strip_asm_tac (list_µ_elim [¨vÆ, ¨ÓØ 0Æ] Ø_less_cases_thm))
	THEN TRY (asm_rewrite_tac[]));
(* *** Goal "4.1" *** *)
a (LEMMA_T ¨≥(ÓØ 0 <âR v ≤ ÓØ 0 = v)Æ rewrite_thm_tac
	THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a (LEMMA_T ¨≥(ÓØ 0 <âR w ≤ ÓØ 0 = w)Æ rewrite_thm_tac
	THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a (LEMMA_T ¨≥(ÓØ 0 <âR v +âR w ≤ ÓØ 0 = v +âR w)Æ rewrite_thm_tac
	THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]);
(* *** Goal "4.2" *** *)
a (LEMMA_T ¨≥(ÓØ 0 <âR w ≤ ÓØ 0 = w)Æ rewrite_thm_tac
	THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a (CASES_T ¨ÓØ 0 <âR v +âR w ≤ ÓØ 0 = v +âR wÆ rewrite_thm_tac
	THEN TRY (PC_T1 "Ø_lin_arith" asm_prove_tac[]));
(* *** Goal "4.3" *** *)
a (LEMMA_T ¨≥(ÓØ 0 <âR v ≤ ÓØ 0 = v)Æ rewrite_thm_tac
	THEN1 PC_T1 "Ø_lin_arith" asm_prove_tac[]);
a (CASES_T ¨ÓØ 0 <âR v +âR w ≤ ÓØ 0 = v +âR wÆ rewrite_thm_tac
	THEN TRY (PC_T1 "Ø_lin_arith" asm_prove_tac[]));
(* *** Goal "4.4" *** *)
a (CASES_T ¨ÓØ 0 <âR v +âR w ≤ ÓØ 0 = v +âR wÆ rewrite_thm_tac
	THEN TRY (PC_T1 "Ø_lin_arith" asm_prove_tac[]));
val Ø_Abs_Norm_clauses = save_pop_thm "Ø_Abs_Norm_clauses";
=TEX

=SML
set_goal([], ¨µx:Ø∑ x ºâR Abs xÆ);
a (REPEAT strip_tac
	THEN rewrite_tac [get_spec ¨AbsâRÆ]
	THEN cases_tac ¨ÓØ 0 ºâR xÆ
	THEN asm_rewrite_tac[]
	THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]);
val Ø_º_abs_thm = save_pop_thm "Ø_º_abs_thm";
=TEX

=SML
set_goal([], ¨µx:Ø∑ ÓØ 0 ºâR x ¥ Abs x = xÆ);
a (REPEAT strip_tac
	THEN rewrite_tac [get_spec ¨AbsâRÆ]
	THEN asm_rewrite_tac []);
val Ø_abs_pos_id_thm = save_pop_thm "Ø_abs_pos_id_thm";
=TEX

=SML
set_goal([], ¨µx y:Ø∑ ÓØ 0 ºâR x ± x ºâR y ¥ Abs x ºâR Abs yÆ);
a (REPEAT strip_tac
	THEN rewrite_tac [get_spec ¨AbsâRÆ]
	THEN cases_tac ¨ÓØ 0 ºâR xÆ
	THEN cases_tac ¨ÓØ 0 ºâR yÆ
	THEN asm_rewrite_tac[]
	THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]);
val Ø_abs_mono_thm = save_pop_thm "Ø_abs_mono_thm";
=TEX

=SML
set_goal([], ¨µx y:Ø∑ x ^ 2 = y ^ 2 ¥ Abs x = Abs yÆ);
a (rewrite_tac [Ø_Ó_exp_square_thm, get_spec ¨AbsâRÆ]
	THEN REPEAT strip_tac);
a (cases_tac ¨ÓØ 0 ºâR xÆ
	THEN asm_rewrite_tac[]);
(* *** Goal "1" *** *)
a (cases_tac ¨ÓØ 0 ºâR yÆ
	THEN asm_rewrite_tac[]);
(* *** Goal "1.1" *** *)
a (all_asm_ufc_tac [Ø_square_eq_thm2] THEN asm_rewrite_tac[]);
(* *** Goal "1.2" *** *)
a (all_asm_ante_tac);
a (lemma_tac ¨∂z∑ y = ~âR zÆ
	THEN1 (∂_tac ¨~âR yÆ THEN rewrite_tac[])
	THEN asm_rewrite_tac[Ø_times_minus_thm]
	THEN REPEAT strip_tac);
a (lemma_tac ¨ÓØ 0 ºâR zÆ
	THEN1 (PC_T1 "Ø_lin_arith" asm_prove_tac[]));
a (all_ufc_tac [Ø_square_eq_thm2]
	THEN asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a (all_asm_ante_tac);
a (lemma_tac ¨∂z∑ x = ~âR zÆ
	THEN1 (∂_tac ¨~âR xÆ THEN rewrite_tac[])
	THEN asm_rewrite_tac[Ø_times_minus_thm]
	THEN REPEAT strip_tac);
a (lemma_tac ¨ÓØ 0 ºâR zÆ
	THEN1 (PC_T1 "Ø_lin_arith" asm_prove_tac[]));
a (cases_tac ¨ÓØ 0 ºâR yÆ
	THEN asm_rewrite_tac[]);
(* *** Goal "2.1" *** *)
a (all_asm_ufc_tac [Ø_square_eq_thm2] THEN asm_rewrite_tac[]);
(* *** Goal "2.2" *** *)
a (all_asm_ante_tac);
a (lemma_tac ¨∂v∑ y = ~âR vÆ
	THEN1 (∂_tac ¨~âR yÆ THEN rewrite_tac[])
	THEN asm_rewrite_tac[Ø_times_minus_thm]
	THEN REPEAT strip_tac);
a (lemma_tac ¨ÓØ 0 ºâR vÆ
	THEN1 (PC_T1 "Ø_lin_arith" asm_prove_tac[]));
a (all_asm_ufc_tac [Ø_square_eq_thm2] THEN asm_rewrite_tac[]);
val Ø_square_eq_abs_thm = pop_thm ();
=TEX

=SML
set_goal([], ¨µx y:Ø∑ Abs x = Abs y ¥ x ^ 2 = y ^ 2Æ);
a (REPEAT µ_tac
	THEN rewrite_tac [get_spec ¨AbsâRÆ]
	THEN cases_tac ¨ÓØ 0 ºâR xÆ
	THEN cases_tac ¨ÓØ 0 ºâR yÆ
	THEN asm_rewrite_tac[]
	THEN strip_tac
	THEN TRY (asm_rewrite_tac[Ø_Ó_exp_square_thm, Ø_times_minus_thm]));
(* *** Goal "1" *** *)
a (POP_ASM_T (rewrite_thm_tac o eq_sym_rule));
a (asm_rewrite_tac[Ø_times_minus_thm]);
(* *** Goal "2" *** *)
a (LEMMA_T ¨~âR (~âR x) = ~âR (~âR y)Æ (asm_tac o (rewrite_rule[]))
	THEN1 (pure_asm_rewrite_tac[]
		THEN rewrite_tac[])
	THEN asm_rewrite_tac[]);
val Ø_abs_eq_square_thm = pop_thm ();
=TEX

=SML
set_goal([], ¨µx y:Ø∑ x ^ 2 = y ^ 2 § Abs x = Abs yÆ);
a (REPEAT strip_tac
	THEN all_ufc_tac [Ø_square_eq_abs_thm, Ø_abs_eq_square_thm]
	THEN asm_rewrite_tac[]);
val Ø_square_eq_abs_thm = save_pop_thm "Ø_square_eq_abs_thm";
=TEX

=SML
set_goal([], ¨µx:Ø∑ Abs (x *âR x) = x *âR xÆ);
a (REPEAT strip_tac
	THEN rewrite_tac [get_spec ¨AbsâRÆ]);
a (LEMMA_T ¨ÓØ 0 ºâR x *âR xÆ rewrite_thm_tac
	THEN1 (rewrite_tac [Ø_prod_sign_iff_clauses]
		THEN PC_T1 "Ø_lin_arith" prove_tac[]));
val Ø_abs_square_thm1 = save_pop_thm "Ø_abs_square_thm1";
=TEX

=SML
set_goal([], ¨µ x y∑ x *âR x ºâR y *âR y ¥ Abs x ºâR Abs yÆ);
a (REPEAT strip_tac
	THEN bc_tac [Ø_square_º_º_thm]
	THEN TRY (rewrite_tac [Ø_Abs_Norm_clauses]));
a (asm_rewrite_tac [map_eq_sym_rule Ø_Abs_Norm_clauses,
	Ø_abs_square_thm1]);
val Ø_square_º_abs_º_thm = save_pop_thm "Ø_square_º_abs_º_thm";
=TEX

=SML
set_goal([], ¨µ x y∑ Abs x ºâR Abs y ¥ x *âR x ºâR y *âR yÆ);
a (REPEAT strip_tac);
a (lemma_tac ¨ÓØ 0 ºâR Abs xÆ
	THEN1 rewrite_tac [Ø_Abs_Norm_clauses]);
a (ALL_FC_T (MAP_EVERY ante_tac) [Ø_square_mono_thm1]);
a (rewrite_tac [map_eq_sym_rule Ø_Abs_Norm_clauses,
	Ø_abs_square_thm1]);
val Ø_abs_º_square_º_thm = save_pop_thm "Ø_abs_º_square_º_thm";
=TEX

=SML
set_goal([], ¨µ x y∑ x *âR x ºâR y *âR y § Abs x ºâR Abs yÆ);
a (REPEAT µ_tac THEN strip_tac
	THEN rewrite_tac [Ø_abs_º_square_º_thm, Ø_square_º_abs_º_thm]);
val Ø_square_º_iff_abs_º_thm = save_pop_thm "Ø_square_º_iff_abs_º_thm";
=TEX

=SML
set_goal([], ¨µ x y∑ x *âR x <âR y *âR y § Abs x <âR Abs yÆ);
a (REPEAT strip_tac);
(* *** Goal "1" *** *)
a (lemma_tac ¨AbsâR x ºâR AbsâR yÆ);
(* *** Goal "1.1" *** *)
a (lemma_tac ¨x *âR x ºâR y *âR yÆ
	THEN1 asm_rewrite_tac [get_spec ¨$ºâRÆ]);
a (bc_tac [Ø_square_º_iff_abs_º_thm] THEN strip_tac);
(* *** Goal "1.2" *** *)
a (POP_ASM_T ante_tac
	THEN rewrite_tac [get_spec ¨$ºâRÆ]
	THEN REPEAT strip_tac);
a (DROP_NTH_ASM_T 2 ante_tac
	THEN LEMMA_T ¨x *âR x = y *âR yÆ rewrite_thm_tac
	THEN1 asm_rewrite_tac [Ø_square_eq_iff_abs_eq_thm]);
(* *** Goal "2" *** *)
a (lemma_tac ¨x *âR x ºâR y *âR yÆ);
a (lemma_tac ¨Abs x ºâR Abs yÆ
	THEN1 asm_rewrite_tac [get_spec ¨$ºâRÆ]);
a (bc_tac [Ø_abs_º_square_º_thm] THEN strip_tac);
(* *** Goal "2.2" *** *)
a (POP_ASM_T ante_tac
	THEN rewrite_tac [get_spec ¨$ºâRÆ]
	THEN REPEAT strip_tac);
a (DROP_NTH_ASM_T 2 ante_tac
	THEN LEMMA_T ¨Abs x = Abs yÆ rewrite_thm_tac
	THEN1 asm_rewrite_tac [map_eq_sym_rule Ø_square_eq_iff_abs_eq_thm]);
val Ø_square_less_iff_abs_less_thm = save_pop_thm "Ø_square_less_iff_abs_less_thm";
=TEX

=SML
set_goal([], ¨µx:Ø∑ Abs (x ^âN 2) = x ^âN 2Æ);
a (rewrite_tac [Ø_Ó_exp_square_thm, Ø_abs_square_thm1]);
val Ø_abs_square_thm2 = save_pop_thm "Ø_abs_square_thm2";
=TEX

=SML
set_goal([], ¨µx y:Ø∑ Abs (x *âR y) = (Abs x) *âR (Abs y)Æ);
a (REPEAT strip_tac
	THEN rewrite_tac [get_spec ¨AbsâRÆ]);
a (cases_tac ¨ÓØ 0 ºâR xÆ THEN cases_tac ¨ÓØ 0 ºâR yÆ
	THEN TRY (asm_rewrite_tac[]));
(* *** Goal "1" *** *)
a (lemma_tac ¨ÓØ 0 ºâR x *âR yÆ
	THEN1 (rewrite_tac [Ø_prod_sign_iff_clauses]
		THEN contr_tac)
	THEN asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a (cases_tac ¨x = ÓØ 0Æ THEN TRY (asm_rewrite_tac[]));
a (lemma_tac ¨≥ ÓØ 0 ºâR x *âR yÆ
	THEN1 (rewrite_tac [Ø_prod_sign_iff_clauses]
		THEN REPEAT strip_tac
		THEN TRY (PC_T1 "Ø_lin_arith" asm_prove_tac[]))
	THEN asm_rewrite_tac[Ø_times_minus_thm]);
(* *** Goal "3" *** *)
a (cases_tac ¨y = ÓØ 0Æ THEN TRY (asm_rewrite_tac[]));
a (lemma_tac ¨≥ ÓØ 0 ºâR x *âR yÆ
	THEN1 (rewrite_tac [Ø_prod_sign_iff_clauses]
		THEN REPEAT strip_tac
		THEN TRY (PC_T1 "Ø_lin_arith" asm_prove_tac[]))
	THEN asm_rewrite_tac[Ø_times_minus_thm]);
(* *** Goal "4" *** *)
a (lemma_tac ¨ÓØ 0 ºâR x *âR yÆ
	THEN1 (rewrite_tac [Ø_prod_sign_iff_clauses]
		THEN (PC_T1 "Ø_lin_arith" asm_prove_tac[]))
	THEN asm_rewrite_tac[Ø_times_minus_thm]);
val Ø_abs_prod_thm = save_pop_thm "Ø_abs_prod_thm";
=TEX

}%ignore

\subsection{Square Root}

\ignore{
=SML
push_goal ([], ¨∂SqrtA∑ µ x∑ ÓØ 0 º SqrtA x ± (SqrtA x)^2 = Abs xÆ);
a(prove_∂_tac THEN strip_tac);
a (lemma_tac ¨ÓØ 0 º Abs x'Æ
	THEN1 (rewrite_tac [Ø_0_º_abs_thm]));
a (all_ufc_tac [square_root_thm1]);
a(∂_tac ¨yÆ THEN asm_rewrite_tac[]);
val _ = save_cs_∂_thm (pop_thm());
=TEX
}%ignore

πHOLCONST
‹ €SqrtA› :Ø ≠ Ø
˜¸¸¸¸¸¸
‹ µ x∑ ÓØ 0 º SqrtA x 
‹ ± (SqrtA x)^2 = Abs x
∞

\ignore{

=SML
set_goal([], ¨µx y:Ø∑ SqrtA x = SqrtA y ¥ Abs x = Abs yÆ);
a (REPEAT strip_tac);
a (LEMMA_T ¨(SqrtA x) ^âN 2 = (SqrtA y) ^âN 2Æ ante_tac
	THEN1 asm_rewrite_tac[]);
a (rewrite_tac [get_spec ¨SqrtAÆ]);
val Ø_sqrt_abs_thm1 = pop_thm ();
=TEX

=SML
set_goal([], ¨µx:Ø∑ SqrtA x = ÓØ 0 § x = ÓØ 0Æ);
a (REPEAT strip_tac THEN TRY (asm_rewrite_tac[]));
a (contr_tac THEN lemma_tac ¨ÓØ 0 <âR SqrtA x ^âN 2Æ
	THEN1 rewrite_tac[get_spec ¨SqrtAÆ,
	get_spec ¨AbsâRÆ,
	get_spec ¨$ºâRÆ]);
(* *** Goal "1.1" *** *)
a (cases_tac ¨ÓØ 0 <âR x ≤ ÓØ 0 = xÆ
	THEN asm_rewrite_tac[]
	THEN PC_T1 "Ø_lin_arith" asm_prove_tac[]);
(* *** Goal "1.2" *** *)
a (POP_ASM_T ante_tac
	THEN asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a (strip_asm_tac (rewrite_rule [Ø_Ó_exp_square_thm, Ø_prod_sign_iff_clauses]
	(µ_elim ¨ÓØ 0Æ (get_spec ¨SqrtAÆ))));
val sqrt_thm1 = save_pop_thm "sqrt_thm1";
=TEX

=SML
set_goal([], ¨µx y:Ø∑ SqrtA (x ^ 2 + y ^ 2) = ÓØ 0 § x = ÓØ 0 ± y = ÓØ 0Æ);
a (REPEAT µ_tac THEN rewrite_tac [sqrt_thm1]);
a (lemma_tac ¨ÓØ 0 º x ^ 2 ± ÓØ 0 º y ^ 2Æ
	THEN1 (rewrite_tac [Ø_square_pos_thm]));
a (lemma_tac ¨ÓØ 0 º x ^ 2 + y ^ 2Æ
	THEN1 (all_ufc_tac [Ø_sum_pos_thm]));
a (LEMMA_T ¨(x ^âN 2 + y ^âN 2 = ÓØ 0)
		= (x ^âN 2 = ÓØ 0 ± y ^âN 2 = ÓØ 0)Æ
	rewrite_thm_tac
	THEN1 (ALL_FC_T1 fc_§_canon rewrite_tac [Ø_sum_zero_thm]));
a (rewrite_tac[Ø_Ó_exp_square_thm, Ø_prod_sign_iff_clauses]);
val sqrt_square_thm = save_pop_thm "sqrt_square_thm";
=TEX
}%\ignore

\ignore{

=SML
set_goal([], ¨µx:Ø∑ Abs(SqrtA x) = SqrtA x
	± Abs (Abs x) = Abs x
	± Abs (ÓØ 0) = ÓØ 0
	± Abs (~âR  x) = Abs xÆ);
a (REPEAT strip_tac
	THEN TRY (rewrite_tac [get_spec ¨AbsâRÆ, get_spec ¨SqrtAÆ]));
(* *** Goal "1" *** *)
a (cases_tac ¨ÓØ 0 ºâR xÆ
	THEN asm_rewrite_tac[]);
a (lemma_tac ¨ÓØ 0 ºâR ~âR xÆ
	THEN1 (PC_T1 "Ø_lin_arith" asm_prove_tac[]));
a (asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a (rewrite_tac [get_spec ¨$ºâRÆ]);
a (strip_asm_tac (list_µ_elim [¨ÓØ 0Æ, ¨xÆ] Ø_less_cases_thm)
	THEN TRY (asm_rewrite_tac[]));
(* *** Goal "2.1" *** *)
a (LEMMA_T ¨≥ (ÓØ 0 <âR ~âR x ≤ ÓØ 0 = ~âR x)Æ rewrite_thm_tac
	THEN1 (PC_T1 "Ø_lin_arith" asm_prove_tac[]));
(* *** Goal "2.2" *** *)
a (LEMMA_T ¨x = ÓØ 0Æ rewrite_thm_tac
	THEN1 (PC_T1 "Ø_lin_arith" asm_prove_tac[]));
(* *** Goal "2.3" *** *)
a (LEMMA_T ¨ÓØ 0 <âR ~âR xÆ rewrite_thm_tac
	THEN1 (PC_T1 "Ø_lin_arith" asm_prove_tac[]));
a (LEMMA_T ¨≥ (ÓØ 0 <âR x ≤ ÓØ 0 = x)Æ rewrite_thm_tac
	THEN1 (PC_T1 "Ø_lin_arith" asm_prove_tac[]));
val Ø_abs_clauses1 = pop_thm ();
=TEX

=SML
set_goal([], ¨µx:Ø∑ SqrtA (~âR x) = SqrtA xÆ);
a (strip_tac);
a (lemma_tac ¨SqrtA (~âR x) ^âN 2 = AbsâR xÆ
	THEN1 (strip_asm_tac (µ_elim ¨~âR xÆ (get_spec ¨SqrtAÆ))
		THEN asm_rewrite_tac[Ø_abs_clauses1]));
a (lemma_tac ¨(SqrtA x) ^âN 2 = AbsâR xÆ
	THEN1 (strip_asm_tac (µ_elim ¨xÆ (get_spec ¨SqrtAÆ))
		THEN asm_rewrite_tac[Ø_abs_clauses1]));
a (lemma_tac ¨SqrtA (~âR x) ^âN 2 = SqrtA x ^âN 2Æ
	THEN1 asm_rewrite_tac[]);
a (ALL_FC_T (MAP_EVERY ante_tac) [Ø_square_eq_abs_thm]
	THEN rewrite_tac [Ø_abs_clauses1]
	THEN strip_tac);
val Ø_sqrt_minus_thm = save_pop_thm "Ø_sqrt_minus_thm";
=TEX

=SML
set_goal([], ¨µx:Ø∑ SqrtA(Abs x) = SqrtA xÆ);
a (REPEAT strip_tac
	THEN TRY (rewrite_tac [get_spec ¨AbsâRÆ, get_spec ¨SqrtAÆ]));
a (cases_tac ¨ÓØ 0 ºâR xÆ
	THEN asm_rewrite_tac[Ø_sqrt_minus_thm]);
val Ø_sqrt_abs_thm = pop_thm ();
=TEX

=SML
set_goal([], ¨µx:Ø∑ SqrtA(Abs x) = SqrtA x
	± Abs(SqrtA x) = SqrtA x
	± Abs (Abs x) = Abs x
	± Abs (ÓØ 0) = ÓØ 0
	± Abs (~âR  x) = Abs xÆ);
a (rewrite_tac[Ø_abs_clauses1, Ø_sqrt_abs_thm]);
val Ø_abs_clauses = save_pop_thm "Ø_abs_clauses";
=TEX

=SML
set_goal([], ¨µx y:Ø∑ Abs x = Abs y ¥ SqrtA x = SqrtA yÆ);
a (REPEAT µ_tac THEN rewrite_tac [get_spec ¨AbsâRÆ]);
a (cases_tac ¨ÓØ 0 ºâR xÆ
	THEN asm_rewrite_tac[]);
(* *** Goal "1" *** *)
a (cases_tac ¨ÓØ 0 ºâR yÆ
	THEN REPEAT strip_tac
	THEN asm_rewrite_tac[Ø_sqrt_minus_thm]);
(* *** Goal "2" *** *)
a (cases_tac ¨ÓØ 0 ºâR yÆ
	THEN (asm_rewrite_tac[])
	THEN REPEAT strip_tac
	THEN TRY (asm_rewrite_tac[Ø_sqrt_minus_thm]));
(* *** Goal "2.1" *** *)
a (LEMMA_T ¨y = ~âR xÆ rewrite_thm_tac
	THEN1 asm_rewrite_tac[]);
a (rewrite_tac[Ø_sqrt_minus_thm]);
(* *** Goal "2.2" *** *)
a (LEMMA_T ¨x = yÆ rewrite_thm_tac
	THEN1 (PC_T1 "Ø_lin_arith" asm_prove_tac[]));
val Ø_sqrt_abs_thm2 = pop_thm ();
=TEX

=SML
set_goal([], ¨µx y:Ø∑ SqrtA x = SqrtA y § Abs x = Abs yÆ);
a (REPEAT strip_tac THEN all_ufc_tac [Ø_sqrt_abs_thm1, Ø_sqrt_abs_thm2]);
val Ø_sqrt_abs_thm = save_pop_thm "Ø_sqrt_abs_thm";
=TEX

=SML
set_goal([], ¨µx y:Ø∑ ÓØ 0 ºâR x ± x ºâR y ¥ SqrtA x ºâR SqrtA yÆ);
a (REPEAT strip_tac
	THEN bc_tac [Ø_square_º_º_thm]
	THEN TRY (rewrite_tac [rewrite_rule [Ø_Ó_exp_square_thm] (get_spec ¨SqrtAÆ)])
	THEN all_ufc_tac [Ø_abs_mono_thm]);
val Ø_sqrt_mono_thm = save_pop_thm "Ø_sqrt_mono_thm";
=TEX

=SML
set_goal([], ¨µx:Ø∑ SqrtA (x * x) = Abs xÆ);
a (strip_tac
	THEN lemma_tac ¨SqrtA (x *âR x) ^âN 2 = (AbsâR x) ^âN 2Æ
	THEN1 (rewrite_tac [rewrite_conv [Ø_Ó_exp_square_thm] ¨(AbsâR x) ^âN 2Æ,
		get_spec ¨SqrtAÆ, get_spec ¨AbsâRÆ, Ø_abs_square_thm1]
		THEN cases_tac ¨ÓØ 0 ºâR xÆ
		THEN asm_rewrite_tac[Ø_times_minus_thm]));
a (ALL_ASM_FC_T
	(MAP_EVERY (strip_asm_tac o (rewrite_rule [Ø_abs_clauses1])))
	[Ø_square_eq_abs_thm]);
val Ø_sqrt_square_thm1 = save_pop_thm "Ø_sqrt_square_thm1";
=TEX

=SML
set_goal([], ¨µx:Ø∑ SqrtA (x ^ 2) = Abs xÆ);
a (REPEAT strip_tac
	THEN rewrite_tac [Ø_sqrt_square_thm1, Ø_Ó_exp_square_thm]);
val Ø_sqrt_square_thm2 = save_pop_thm "Ø_sqrt_square_thm2";
=TEX

=SML
set_goal([], ¨µx y:Ø∑ SqrtA (x * y) = SqrtA x * SqrtA yÆ);
a (REPEAT strip_tac
	THEN lemma_tac ¨(SqrtA x *âR SqrtA y) *âR (SqrtA x *âR SqrtA y)
	 = (SqrtA x *âR SqrtA x) *âR (SqrtA y *âR SqrtA y)Æ
	THEN1 rewrite_tac [µ_elim ¨SqrtA xÆ Ø_times_order_thm]);
a (lemma_tac ¨SqrtA x *âR SqrtA x = AbsâR xÆ
	THEN1 (rewrite_tac [rewrite_rule [Ø_Ó_exp_square_thm]
			(µ_elim ¨xÆ (get_spec ¨SqrtAÆ))]));
a (lemma_tac ¨SqrtA y *âR SqrtA y = AbsâR yÆ
	THEN1 (rewrite_tac [rewrite_rule [Ø_Ó_exp_square_thm]
			(µ_elim ¨yÆ (get_spec ¨SqrtAÆ))]));
a (DROP_NTH_ASM_T 3 ante_tac);
a (once_asm_rewrite_tac[]);
a (rewrite_tac[eq_sym_rule(rewrite_rule [Ø_Abs_Norm_clauses, Ø_Ó_exp_square_thm]
	((±_right_elim o (µ_elim ¨x *âR yÆ)) (get_spec ¨SqrtAÆ))),
	rewrite_rule [Ø_Ó_exp_square_thm] Ø_square_eq_abs_thm,
	Ø_abs_clauses]);
a (once_rewrite_tac [eq_sym_conv ¨AbsâR (SqrtA x *âR SqrtA y) = SqrtA (x *âR y)Æ]
	THEN STRIP_T rewrite_thm_tac);
a (rewrite_tac [Ø_abs_clauses, Ø_Abs_Norm_clauses]);
val Ø_sqrt_prod_thm = save_pop_thm "Ø_sqrt_prod_thm";
=TEX

=SML
set_goal([], ¨µx y:Ø∑ SqrtA(x + y) º (SqrtA x) +âR (SqrtA y)Æ);
a (REPEAT strip_tac);
a (LEMMA_T ¨SqrtA(x + y) = Abs (SqrtA(x + y))
	± (SqrtA x) +âR (SqrtA y) = Abs((SqrtA x) +âR (SqrtA y))Æ
	once_rewrite_thm_tac);
(* *** Goal "1" *** *)
a (lemma_tac ¨ÓØ 0 ºâR SqrtA (x +âR y) ± ÓØ 0 ºâR SqrtA x +âR SqrtA yÆ
	THEN1 (rewrite_tac [get_spec ¨SqrtAÆ]
		THEN bc_tac [Ø_sum_pos_thm]
		THEN rewrite_tac [get_spec ¨SqrtAÆ])
	THEN ALL_FC_T rewrite_tac [Ø_abs_pos_id_thm]);
(* *** Goal "2" *** *)
a (bc_tac [Ø_square_º_abs_º_thm]);
a (rewrite_tac[rewrite_rule [Ø_Ó_exp_square_thm] (get_spec ¨SqrtAÆ),
	Ø_times_plus_distrib_thm]);
a (Ø_top_anf_tac);
a (lemma_tac ¨AbsâR (x +âR y) ºâR (AbsâR x) +âR (AbsâR y)Æ
	THEN1 rewrite_tac [Ø_Abs_Norm_clauses]);
a (LEMMA_T ¨(AbsâR x) +âR (AbsâR y) ºâR AbsâR x +âR AbsâR y +âR ÓØ 2 *âR SqrtA x *âR SqrtA yÆ
	asm_tac
	THEN1 rewrite_tac [Ø_prod_sign_iff_clauses, get_spec ¨SqrtAÆ]);
a (all_ufc_tac [Ø_º_trans_thm]);
val sqrt_plus_thm = save_pop_thm "sqrt_plus_thm"; 
=TEX

}%ignore

\subsection{Sums of Countable Collections of Reals}

In evaluating the cosmological consequences of Newton's Laws it is desirable to formulate them as cosmological theories in ways which do not prejudge such questions as whether the cardinality of the universe is finite.
To do this it is necessary to be able, where possible, to form the sum of an infinite set of reals, possibly even an uncountably infinite set of real numbers.

For the most general formulations it seems possible that the use of non-standard reals might be needed.
We are concerned here with what can be done with standard reals, i.e. with formalising the notion that some collection of real numbers has a finite sum.

The following definition gives the sum of a possibly finite or countable collection of real numbers.

=SML
declare_infix (300, "è>");
=TEX
πHOLCONST
‹ $€è>› : ('a ≠ Ø + ONE) ≠ Ø ≠ BOOL
˜¸¸¸¸¸¸
‹ µc r∑ c è> r §
‹	∂s∑ (µ a n m∑ IsL (c a) ¥ s n = s m ¥ n = m)
‹	¥ (Series (Ãn∑ if IsR (c (s n)) then 0âR else OutL (c (s n)))) -> r
∞

\section{Cartesian and Dependent Products}

\subsection{Cartesian Products}

=GFT
€cp_eq_thm1› =
   Ù µ x y v w p q∑ p ç x ± q ç y ¥ (x ∏ y) = (v ∏ w) ¥ x = v ± y = w

€cp_eq_thm2› =
   Ù µ x y v w p∑ p ç (x ∏ y) ¥ (x ∏ y) = (v ∏ w) ¥ x = v ± y = w
=TEX

\ignore{
=SML
set_goal([], ¨µx y v w p q∑ p ç x ± q ç y ¥ (x ∏ y) = (v ∏ w) ¥ x = v ± y = wÆ);
a (REPEAT strip_tac THEN_TRY asm_rewrite_tac[]
	THEN POP_ASM_T ante_tac
	THEN rewrite_tac[sets_ext_clauses]
	THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a (lemma_tac ¨(x', q) ç (x ∏ y)Æ  THEN1 asm_rewrite_tac [rel_ç_in_clauses]); 
a (asm_fc_tac[]);
a (POP_ASM_T ante_tac THEN asm_rewrite_tac [rel_ç_in_clauses] THEN contr_tac); 
(* *** Goal "2" *** *)
a (lemma_tac ¨(p, q) ç (x ∏ y)Æ  THEN1 asm_rewrite_tac [rel_ç_in_clauses]); 
a (asm_fc_tac[]);
a (POP_ASM_T ante_tac THEN asm_rewrite_tac [rel_ç_in_clauses] THEN REPEAT strip_tac); 
a (lemma_tac ¨(x', q) ç (v ∏ w)Æ  THEN1 asm_rewrite_tac [rel_ç_in_clauses]); 
a (spec_nth_asm_tac 6 ¨(x', q)Æ);
a (POP_ASM_T ante_tac THEN asm_rewrite_tac [rel_ç_in_clauses] THEN contr_tac); 
(* *** Goal "3" *** *)
a (lemma_tac ¨(p, x') ç (x ∏ y)Æ  THEN1 asm_rewrite_tac [rel_ç_in_clauses]); 
a (asm_fc_tac[]);
a (POP_ASM_T ante_tac THEN asm_rewrite_tac [rel_ç_in_clauses] THEN contr_tac); 
(* *** Goal "4" *** *)
a (lemma_tac ¨(p, q) ç (x ∏ y)Æ  THEN1 asm_rewrite_tac [rel_ç_in_clauses]); 
a (asm_fc_tac[]);
a (POP_ASM_T ante_tac THEN asm_rewrite_tac [rel_ç_in_clauses] THEN REPEAT strip_tac); 
a (lemma_tac ¨(p, x') ç (v ∏ w)Æ  THEN1 asm_rewrite_tac [rel_ç_in_clauses]); 
a (spec_nth_asm_tac 6 ¨(p, x')Æ);
a (POP_ASM_T ante_tac THEN asm_rewrite_tac [rel_ç_in_clauses] THEN contr_tac); 
val cp_eq_thm1 = save_pop_thm "cp_eq_thm1";

set_goal([], ¨µx y v w p∑ p ç (x ∏ y) ¥ (x ∏ y) = (v ∏ w) ¥ x = v ± y = wÆ);
a (REPEAT_N 7 strip_tac);
a (DROP_NTH_ASM_T 2 ante_tac THEN split_pair_rewrite_tac [¨pÆ][rel_ç_in_clauses] THEN strip_tac);
a (all_fc_tac [cp_eq_thm1] THEN contr_tac);
val cp_eq_thm2 = save_pop_thm "cp_eq_thm2";
=TEX
}%ignore


=GFT
€cp_l_part_thm› = Ù µ l r x∑ x ç r ¥ l = {m|∂ p∑ p ç (l ∏ r) ± m = Fst p}

€cp_r_part_thm› = Ù µ l r x∑ x ç l ¥ r = {m|∂ p∑ p ç (l ∏ r) ± m = Snd p}

€cp_part_thm› =
   Ù µ l r x∑ x ç (l ∏ r)
         ¥ l = {m|∂ p∑ p ç (l ∏ r) ± m = Fst p}
           ± r = {m|∂ p∑ p ç (l ∏ r) ± m = Snd p}
=TEX

\ignore{
=SML
set_goal([], ¨µl r x∑ x ç r ¥ l = {m | ∂p∑ p ç (l ∏ r) ± m = Fst p}Æ);
a (REPEAT strip_tac THEN rewrite_tac [sets_ext_clauses]);
a (REPEAT strip_tac);
(* *** Goal "1" *** *)
a (∂_tac ¨x',xÆ THEN asm_rewrite_tac[rel_ç_in_clauses]);
(* *** Goal "2" *** *)
a (DROP_NTH_ASM_T 2 ante_tac THEN split_pair_rewrite_tac [¨pÆ][rel_ç_in_clauses]);
a (var_elim_asm_tac ¨x' = Fst pÆ THEN contr_tac);
val cp_l_part_thm = save_pop_thm "cp_l_part_thm";

set_goal([], ¨µl r x∑ x ç l ¥ r = {m | ∂p∑ p ç (l ∏ r) ± m = Snd p}Æ);
a (REPEAT strip_tac THEN rewrite_tac [sets_ext_clauses]);
a (REPEAT strip_tac);
(* *** Goal "1" *** *)
a (∂_tac ¨x,x'Æ THEN asm_rewrite_tac[rel_ç_in_clauses]);
(* *** Goal "2" *** *)
a (DROP_NTH_ASM_T 2 ante_tac THEN split_pair_rewrite_tac [¨pÆ][rel_ç_in_clauses]);
a (var_elim_asm_tac ¨x' = Snd pÆ THEN contr_tac);
val cp_r_part_thm = save_pop_thm "cp_r_part_thm";

set_goal([], ¨µl r x∑ x ç (l ∏ r) ¥
		  l = {m | ∂p∑ p ç (l ∏ r) ± m = Fst p}
		± r = {m | ∂p∑ p ç (l ∏ r) ± m = Snd p}Æ);
a (REPEAT µ_tac THEN split_pair_rewrite_tac [¨xÆ][rel_ç_in_clauses]);
a (REPEAT strip_tac THEN all_asm_fc_tac [cp_l_part_thm, cp_r_part_thm]);
a (spec_nth_asm_tac 4 ¨lÆ);
a (spec_nth_asm_tac 1 ¨rÆ);
val cp_part_thm = save_pop_thm "cp_part_thm";
=TEX
}%ignore

\subsection{Distributed Cartesian Product}

The "distributed cartesian product" is what you need to get the equivalance classes generated by two relations to the equivalence classes generated by the product of the equivalence relations (see section \ref{PER}).

=SML
declare_infix (340, "∏âD");
=TEX

πHOLCONST
‹ $€∏âD› : ('a SET SET) ≠ ('b SET SET) ≠  (('a ∏ 'b) SET SET)
˜¸¸¸¸¸¸
‹ µl r∑ l ∏âD r = {cp | ∂ leq req∑ leq ç l ± req ç r ± cp = (leq ∏ req)}
∞

=GFT
€∏âD_ext_thm› =
   Ù µ l r cp∑ cp ç l ∏âD r § (∂ leq req∑ leq ç l ± req ç r ± cp = (leq ∏ req))
=TEX

\ignore{
=SML
val ∏âD_def = get_spec ¨$∏âDÆ;

set_goal ([], ¨µl r cp∑ cp ç l ∏âD r § ∂ leq req∑ leq ç l ± req ç r ± cp = (leq ∏ req)Æ);
a (REPEAT µ_tac THEN rewrite_tac [∏âD_def, sets_ext_clauses]);
val ∏âD_ext_thm = save_pop_thm "∏âD_ext_thm";
=TEX
}%ignore

\subsection{Dependent Function Spaces ??}

Our generic treatment of algebraic operators represents operators as functions over indexed sets of arugments.
In order to take a quotient of an algebra involving such operators we need to lift the equivalence relation over the domain of the algebra to one over indexed sets of domain values.
This is taking an arbitrary power of the equivalence relation.

These indexed sets are actually functions, and the equivalence classes are like dependent function spaces, whose type corresponds to an indexed set of the equivalence classes over the domain, i.e. a function from the indexes into the set of equivalence classes.

It is therefore useful to define this dependent function space operation which may also be though of as a dependent cartesian power.

πHOLCONST
‹ €êâf› : 'b SET ≠ ('b ≠ 'a SET) ≠ ('b ≠ 'a) SET
˜¸¸¸¸¸¸
‹ µ is f∑ êâf is f = {g | µi∑ i ç is ¥ g i ç f i}
∞

Now we take a set of (probably equivalence) classes and map the dependent function space over all the indexed sets taken from this set.

πHOLCONST
‹ €∏âê› : 'b SET ≠ ('a SET SET) ≠ ('b ≠ 'a) SET SET
˜¸¸¸¸¸¸
‹ µ is ss∑ ∏âê is ss = {g | ∂h∑ (µi∑ i ç is ¥ h i ç ss) ± g = êâf is h}
∞

\section{Relation Products}

The kind of relation which we consider here is the kind which is used in the theory \emph{equiv\_rel}, structures represented by an ordered pair of which the first element is the domain of the relation and the second is a relation as a curried function of two operands into type \emph{BOOL}.


This section provides some small additions to the theory ``equiv\_rel'' related to lifting functions over quotients.

=SML
declare_infix(210, "RelProd");
declare_infix(230, "ºâl");
declare_infix(230, "ºâr");
=TEX

πHOLCONST
‹ €$RelProd› : ('a SET ∏ ('a ≠ 'a ≠ BOOL))
‹		≠ ('b SET ∏ ('b ≠ 'b ≠ BOOL))
‹		≠ (('a ∏ 'b) SET ∏ ('a ∏ 'b ≠ 'a ∏ 'b ≠ BOOL))
˜¸¸¸¸¸¸
‹ µ $ºâl $ºâr L R∑ ((L, $ºâl) RelProd (R, $ºâr)) =
‹	((L ∏ R),
‹	Ã(l1, r1) (l2, r2)∑ l1 ç L ± l2 ç L ± r1 ç R ± r2 ç R
‹			± l1 ºâl l2 ± r1 ºâr r2)
∞
=GFT
€RelProd_projections_thm› =
   Ù µ (L, $ºâl) (R, $ºâr)∑
	Fst ((L, $ºâl) RelProd (R, $ºâr)) = (L ∏ R)
      ± Snd ((L, $ºâl) RelProd (R, $ºâr)) = (Ã (l1, r1) (l2, r2)
        	   ∑ l1 ç L ± l2 ç L ± r1 ç R ± r2 ç R ± l1 ºâl l2 ± r1 ºâr r2)
=TEX

\ignore{
=SML
val RelProd_def = get_spec ¨$RelProdÆ;

push_pc "hol1";

set_goal([], ¨µ(L, $ºâl) (R, $ºâr)∑ Fst(((L, $ºâl) RelProd (R, $ºâr))) = (L ∏ R)
	± Snd(((L, $ºâl) RelProd (R, $ºâr))) = Ã(l1, r1) (l2, r2)∑ l1 ç L ± l2 ç L ± r1 ç R ± r2 ç R
			± l1 ºâl l2 ± r1 ºâr r2Æ);
a (rewrite_tac [RelProd_def] THEN REPEAT strip_tac);
val RelProd_projections_thm = save_pop_thm "RelProd_projections_thm";

pop_pc();
=TEX
}%ignore

\ignore{
=SML
add_pc_thms "'rbjmisc" (map get_spec [] @ [RelProd_projections_thm]);
set_merge_pcs ["basic_hol", "'sets_alg", "'Ø", "'rbjmisc"];
=TEX
}%ignore

The product construction preserves various properties of relations.

=GFT
€Trans_RelProd_thm› =
   Ù µ (L, $¶âl) (R, $¶âr)∑
	Trans (L, $¶âl) ± Trans (R, $¶âr) ¥ Trans ((L, $¶âl) RelProd (R, $¶âr))

€Sym_RelProd_thm› =
   Ù µ (L, $¶âl) (R, $¶âr)∑
	Sym (L, $¶âl) ± Sym (R, $¶âr) ¥ Sym ((L, $¶âl) RelProd (R, $¶âr))

€Refl_RelProd_thm› =
   Ù µ (L, $¶âl) (R, $¶âr)∑
	Refl (L, $¶âl) ± Refl (R, $¶âr) ¥ Refl ((L, $¶âl) RelProd (R, $¶âr))
=TEX

\ignore{
=SML
set_goal([], ¨µ(L, $¶âl) (R, $¶âr)∑ Trans(L, $¶âl) ± Trans(R, $¶âr) ¥ Trans ((L, $¶âl) RelProd (R, $¶âr))Æ);
a (REPEAT strip_tac);
a (fc_tac [equiv_def]);
a (fc_tac [trans_def]);
a (rewrite_tac [RelProd_def, trans_def]);
a (REPEAT strip_tac
	THEN_TRY (POP_ASM_T (strip_asm_tac o (rewrite_rule[rel_ç_in_clauses]) o (pure_once_rewrite_rule [prove_rule [] ¨x = (Fst x, Snd x)Æ])))
	THEN REPEAT (all_asm_ufc_tac[]));
val Trans_RelProd_thm = save_pop_thm "Trans_RelProd_thm";

set_goal([], ¨µ(L, $¶âl) (R, $¶âr)∑ Sym(L, $¶âl) ± Sym(R, $¶âr) ¥ Sym ((L, $¶âl) RelProd (R, $¶âr))Æ);
a (REPEAT strip_tac);
a (fc_tac [equiv_def]);
a (fc_tac [sym_def]);
a (rewrite_tac [RelProd_def, sym_def]);
a (REPEAT strip_tac
	THEN_TRY (POP_ASM_T (strip_asm_tac o (rewrite_rule[rel_ç_in_clauses]) o (pure_once_rewrite_rule [prove_rule [] ¨x = (Fst x, Snd x)Æ])))
	THEN REPEAT (all_asm_ufc_tac[]));
val Sym_RelProd_thm = save_pop_thm "Sym_RelProd_thm";

set_goal([], ¨µ(L, $¶âl) (R, $¶âr)∑ Refl(L, $¶âl) ± Refl(R, $¶âr) ¥ Refl ((L, $¶âl) RelProd (R, $¶âr))Æ);
a (REPEAT strip_tac);
a (fc_tac [equiv_def]);
a (fc_tac [refl_def]);
a (rewrite_tac [RelProd_def, refl_def]);
a (REPEAT strip_tac
	THEN_TRY (POP_ASM_T (strip_asm_tac o (rewrite_rule[rel_ç_in_clauses]) o (pure_once_rewrite_rule [prove_rule [] ¨x = (Fst x, Snd x)Æ])))
	THEN REPEAT (all_asm_ufc_tac[]));
val Refl_RelProd_thm = save_pop_thm "Refl_RelProd_thm";
=TEX
}%ignore

\section{Powers of Relations}

Universal algebra (below) involves operators of arbitrary arity, and reasoning generally about algebras involving such operators involves raising equivalence relations to arbitrary powers.

We define such operations first for relations in general.

The operators are represented by functions over indexed sets of arguments, the indexed sets being represented by total functions over a type of indexes, together with a subset of the type indicating the range of significance of the functions in the domain of the operators.
The operators are themselves also significant only for arguments all of which fall in some domain (the domain of a structure), but this need not concern us here.

Our concern here is not with the operators, but with quotients of the domain of the operators, and with the resulting equivalence relations over the domain of the operators.
So we want to take an equivalence relation over some type, together with a set of indices, and obtain an equivalence relation over the total functions from indexes to values in the domain.
We define this for arbitrary relations, and then prove (later) that when the relation is an equivalence the result will be an equivalence.

πHOLCONST
‹ €$RelPower› : ('a SET ∏ ('a ≠ 'a ≠ BOOL)) ≠ 'b SET
‹		≠ (('b ≠ 'a) SET ∏ (('b ≠ 'a) ≠ ('b ≠ 'a) ≠ BOOL))
˜¸¸¸¸¸¸
‹ µ D r is∑ RelPower (D, r) is =
‹	({f | µi∑ i ç is ¥ f i ç D}, Ãf g∑ µi∑ i ç is ¥ r (f i) (g i))
∞

We now show that this construction preserves various properties of the relation.
=GFT
€RelPower_Trans_thm› =
   Ù µ (D, r) is∑ Trans (D, r) ¥ Trans (RelPower (D, r) is)

€RelPower_Sym_thm› =
   Ù µ (D, r) is∑ Sym (D, r) ¥ Sym (RelPower (D, r) is)

€RelPower_Refl_thm› =
   Ù µ (D, r) is∑ Refl (D, r) ¥ Refl (RelPower (D, r) is)
=TEX

\ignore{
=SML
val RelPower_def = get_spec ¨RelPowerÆ;

set_goal([], ¨µ(D, r) is∑ Trans(D, r) ¥ Trans (RelPower (D, r) is)Æ);
a (REPEAT µ_tac THEN rewrite_tac [RelPower_def, trans_def]
	THEN REPEAT strip_tac
	THEN REPEAT (all_asm_ufc_tac[]));
val RelPower_Trans_thm = save_pop_thm "RelPower_Trans_thm";

set_goal([], ¨µ(D, r) is∑ Sym(D, r) ¥ Sym(RelPower (D, r) is)Æ);
a (REPEAT µ_tac THEN rewrite_tac [RelPower_def, sym_def]
	THEN REPEAT strip_tac
	THEN REPEAT (all_asm_ufc_tac[]));
val RelPower_Sym_thm = save_pop_thm "RelPower_Sym_thm";

set_goal([], ¨µ(D, r) is∑ Refl(D, r) ¥ Refl(RelPower (D, r) is)Æ);
a (REPEAT µ_tac THEN rewrite_tac [RelPower_def, refl_def]
	THEN REPEAT strip_tac
	THEN REPEAT (all_asm_ufc_tac[]));
val RelPower_Refl_thm = save_pop_thm "RelPower_Refl_thm";
=TEX
}%ignore

\section{Equivalence Relations}

=SML
declare_infix(230, "¶");
declare_infix(230, "¶âl");
declare_infix(230, "¶âr");
=TEX

It will be convenient to name an uncurried version of \emph{QuotientSet}:

πHOLCONST
‹ €EquivClasses› : ('a SET ∏ ('a ≠ 'a ≠ BOOL)) ≠ ('a SET SET)
˜¸¸¸¸¸¸
‹ EquivClasses = Uncurry QuotientSet
∞

=GFT
€EquivClasses_thm› =
   Ù EquivClasses (X, $¶) = {A|∂ x∑ x ç X ± A = EquivClass (X, $¶) x}

€EquivClasses_thm1› =
   Ù µ r∑ EquivClasses r = {A|∂ x∑ x ç Fst r ± A = EquivClass r x}
=TEX
\ignore{
=SML
push_pc "hol";

val EquivClasses_def = get_spec ¨EquivClassesÆ;

set_goal([], ¨µ(X, $¶)∑ EquivClasses (X, $¶) = {A|∂ x∑ x ç X ± A = EquivClass (X, $¶) x}Æ);
a (REPEAT strip_tac THEN rewrite_tac [quotient_set_def, EquivClasses_def]);
val EquivClasses_thm = save_pop_thm "EquivClasses_thm";

set_goal([], ¨µr∑ EquivClasses r = {A|∂ x∑ x ç Fst r ± A = EquivClass r x}Æ);
a (REPEAT µ_tac THEN split_pair_rewrite_tac [¨rÆ] [EquivClasses_thm]);
a (rewrite_tac[]);
val EquivClasses_thm1 = save_pop_thm "EquivClasses_thm1";
=TEX
}%ignore

=GFT
€EquivClasses_sub_thm› =
   Ù µ (D, $¶)∑ Equiv (D, $¶) ¥ (µ l∑ l ç EquivClasses (D, $¶) ¥ l Ä D)

€EquivClasses_sub_thm1› =
   Ù µ r∑ Equiv r ¥ (µ l∑ l ç EquivClasses r ¥ l Ä Fst r)
=TEX

\ignore{
=SML
set_goal([], ¨µ(D, $¶)∑ Equiv(D, $¶) ¥ µl∑ l ç EquivClasses (D, $¶) ¥ l Ä DÆ);
a (PC_T "hol1" (rewrite_tac [EquivClasses_thm, get_spec ¨EquivClassÆ] THEN REPEAT strip_tac));
a (all_asm_fc_tac[]);
val EquivClasses_sub_thm = save_pop_thm "EquivClasses_sub_thm";

set_goal([], ¨µr∑ Equiv r ¥ µl∑ l ç EquivClasses r ¥ l Ä Fst rÆ);
a (REPEAT µ_tac THEN split_pair_rewrite_tac [¨rÆ][]);
a (REPEAT strip_tac THEN all_asm_fc_tac [EquivClasses_sub_thm]);
a (asm_rewrite_tac[]);
val EquivClasses_sub_thm1 = save_pop_thm "EquivClasses_sub_thm1";
=TEX
}%ignore

\subsection{Products of Equivalence Relations}\label{PER}

I am providing an alternative way of lifting operators from some type to equivalence classes over the type.
The treatment of dyadic operators, which in {\Product} have to be curried if they are to be used infix, is done by uncurrying and then lifting as if a monadic function over the cartesian product.

This will lift to the product equivalence classes so we need a treatment of products of equivalence relations.

=GFT
€Equiv_RelProd_thm› =
   Ù µ (L, $¶âl) (R, $¶âr)∑
	Equiv (L, $¶âl) ± Equiv (R, $¶âr) ¥ Equiv ((L, $¶âl) RelProd (R, $¶âr))
=TEX

\ignore{
=SML
push_pc "hol1";

set_goal([], ¨µ(L, $¶âl) (R, $¶âr)∑ Equiv(L, $¶âl) ± Equiv(R, $¶âr) ¥ Equiv ((L, $¶âl) RelProd (R, $¶âr))Æ);
a (REPEAT strip_tac THEN fc_tac [equiv_def]);
a (split_pair_rewrite_tac [¨(L, $¶âl) RelProd (R, $¶âr)Æ] [equiv_def]);
a (rewrite_tac[] THEN REPEAT strip_tac);
a (all_fc_tac [Refl_RelProd_thm]);
a (all_fc_tac [Sym_RelProd_thm]);
a (all_fc_tac [Trans_RelProd_thm]);
val Equiv_RelProd_thm = save_pop_thm "Equiv_RelProd_thm";

pop_pc();
=TEX
}%ignore

\ignore{
=IGN
add_pc_thms "'rbjmisc" (map get_spec [] @ []);
set_merge_pcs ["basic_hol", "'sets_alg", "'Ø", "'rbjmisc"];
=TEX
}%ignore

=GFT
€EquivClass_RelProd_thm› =
   Ù µ (L, $¶âl) (R, $¶âr)∑ Equiv (L, $¶âl) ± Equiv (R, $¶âr)
         ¥ (µ xl xr yl yr∑ xl ç L ± xr ç R ± yl ç L ± yr ç R
             ¥ ((xl, xr) ç EquivClass ((L, $¶âl) RelProd (R, $¶âr)) (yl, yr)
               § xl ç EquivClass (L, $¶âl) yl
                 ± xr ç EquivClass (R, $¶âr) yr))
=TEX
=GFT
€EquivClass_RelProd_thm1› =
   Ù µ (L, $¶âl) (R, $¶âr)∑ Equiv (L, $¶âl) ± Equiv (R, $¶âr)
         ¥ (µ l r∑ l ç L ± r ç R
             ¥ EquivClass ((L, $¶âl) RelProd (R, $¶âr)) (l, r)
                = (EquivClass (L, $¶âl) l ∏ EquivClass (R, $¶âr) r))
=TEX

\ignore{
=SML
set_goal([], ¨µ(L, $¶âl) (R, $¶âr)∑ Equiv(L, $¶âl) ± Equiv(R, $¶âr) ¥ µxl xr yl yr∑ yl ç L ± yr ç R ¥ ((xl, xr) ç EquivClass ((L, $¶âl) RelProd (R, $¶âr)) (yl, yr)
	§ xl ç EquivClass (L, $¶âl) yl ± xr ç EquivClass (R, $¶âr) yr)Æ);
a (REPEAT µ_tac THEN strip_tac THEN rewrite_tac [RelProd_def, get_spec ¨EquivClassÆ] THEN REPEAT strip_tac
	THEN asm_rewrite_tac [rel_ç_in_clauses]);
val EquivClass_RelProd_thm = save_pop_thm "EquivClass_RelProd_thm";

set_goal([], ¨µ(L, $¶âl) (R, $¶âr)∑ Equiv(L, $¶âl) ± Equiv(R, $¶âr)
	¥ µl r∑ l ç L ± r ç R ¥ EquivClass ((L, $¶âl) RelProd (R, $¶âr)) (l, r) = ((EquivClass (L, $¶âl) l) ∏ (EquivClass (R, $¶âr) r))Æ);
a (REPEAT strip_tac
	THEN rewrite_tac [sets_ext_clauses]
	THEN strip_tac
	THEN split_pair_rewrite_tac [¨xÆ] [rel_ç_in_clauses]
	THEN REPEAT strip_tac
	THEN_TRY all_fc_tac [EquivClass_RelProd_thm]);
a (all_ufc_§_rewrite_tac [EquivClass_RelProd_thm] THEN contr_tac);
val EquivClass_RelProd_thm1 = save_pop_thm "EquivClass_RelProd_thm1";
=TEX
}%ignore

=GFT
€EquivClasses_RelProd_thm› =
   Ù µ (L, $¶âl) (R, $¶âr)∑ Equiv (L, $¶âl) ± Equiv (R, $¶âr) ¥ (µ l r∑
		(l ∏ r) ç EquivClasses ((L, $¶âl) RelProd (R, $¶âr))
		§ l ç EquivClasses (L, $¶âl) ± r ç EquivClasses (R, $¶âr))
=TEX
=GFT
€EquivClasses_RelProd_thm1› =
   Ù µ (L, $¶âl) (R, $¶âr)∑ Equiv (L, $¶âl) ± Equiv (R, $¶âr) ¥ (µ x∑
		x ç EquivClasses ((L, $¶âl) RelProd (R, $¶âr))
             § (∂ l r∑ x = (l ∏ r)
                 ± l ç EquivClasses (L, $¶âl)
                 ± r ç EquivClasses (R, $¶âr)))
=TEX
=GFT
€EquivClasses_RelProd_thm2› =
   Ù µ (L, $¶âl) (R, $¶âr)∑ Equiv (L, $¶âl) ± Equiv (R, $¶âr)
         ¥ EquivClasses ((L, $¶âl) RelProd (R, $¶âr))
           = EquivClasses (L, $¶âl) ∏âD EquivClasses (R, $¶âr)
=TEX

\ignore{
=SML
set_goal([], ¨µ(L, $¶âl) (R, $¶âr)∑ Equiv(L, $¶âl) ± Equiv(R, $¶âr) ¥ µl r∑ (l ∏ r) ç EquivClasses ((L, $¶âl) RelProd (R, $¶âr))
	         § l ç EquivClasses (L, $¶âl) ± r ç EquivClasses (R, $¶âr)Æ);
a (split_pair_rewrite_tac [¨(L, $¶âl) RelProd (R, $¶âr)Æ][EquivClasses_thm] THEN REPEAT_N 9 strip_tac);
a (rewrite_tac [ç_in_clauses]);
a (REPEAT strip_tac);
(* *** Goal "1" *** *)
a (DROP_NTH_ASM_T 2 ante_tac THEN rewrite_tac [RelProd_projections_thm]);
a (split_pair_rewrite_tac [¨xÆ][rel_ç_in_clauses] THEN strip_tac);
a (∂_tac ¨Fst xÆ THEN asm_rewrite_tac[]);
a (all_fc_tac [equiv_class_ç_thm]);
a (DROP_NTH_ASM_T 5 ante_tac);
a (split_pair_rewrite_tac [¨xÆ][]);
a (ALL_UFC_T rewrite_tac [EquivClass_RelProd_thm1]);
a (STRIP_T (asm_tac o eq_sym_rule) THEN all_fc_tac [cp_eq_thm1]);
a (asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a (DROP_NTH_ASM_T 2 ante_tac THEN rewrite_tac [RelProd_projections_thm]);
a (split_pair_rewrite_tac [¨xÆ][rel_ç_in_clauses] THEN strip_tac);
a (∂_tac ¨Snd xÆ THEN asm_rewrite_tac[]);
a (all_fc_tac [equiv_class_ç_thm]);
a (DROP_NTH_ASM_T 5 ante_tac);
a (split_pair_rewrite_tac [¨xÆ][]);
a (ALL_UFC_T rewrite_tac [EquivClass_RelProd_thm1]);
a (STRIP_T (asm_tac o eq_sym_rule) THEN all_fc_tac [cp_eq_thm1]);
a (asm_rewrite_tac[]);
(* *** Goal "3" *** *)
a (∂_tac ¨(x,x')Æ THEN asm_rewrite_tac[RelProd_projections_thm, rel_ç_in_clauses]);
a (ALL_FC_T rewrite_tac [EquivClass_RelProd_thm1]);
val EquivClasses_RelProd_thm = save_pop_thm "EquivClasses_RelProd_thm";

set_goal([], ¨µ(L, $¶âl) (R, $¶âr)∑ Equiv(L, $¶âl) ± Equiv(R, $¶âr) ¥ µx∑ x ç EquivClasses ((L, $¶âl) RelProd (R, $¶âr))
	         § ∂l r∑ x = (l ∏ r) ± l ç EquivClasses (L, $¶âl) ± r ç EquivClasses (R, $¶âr)Æ);
a (split_pair_rewrite_tac [¨(L, $¶âl) RelProd (R, $¶âr)Æ][EquivClasses_thm] THEN REPEAT_N 9 strip_tac);
a (rewrite_tac [ç_in_clauses]);
a (REPEAT strip_tac);
(* *** Goal "1" *** *)
a (DROP_NTH_ASM_T 2 ante_tac THEN rewrite_tac [RelProd_projections_thm]);
a (split_pair_rewrite_tac [¨x'Æ][rel_ç_in_clauses] THEN strip_tac);
a (∂_tac ¨EquivClass (L, $¶âl) (Fst x')Æ THEN ∂_tac ¨EquivClass (R, $¶âr) (Snd x')Æ THEN asm_rewrite_tac[]);
a (all_fc_tac [equiv_class_ç_thm]);
a (DROP_NTH_ASM_T 5 ante_tac);
a (split_pair_rewrite_tac [¨x'Æ][]);
a (ALL_UFC_T rewrite_tac [EquivClass_RelProd_thm1]);
a (STRIP_T (asm_tac o eq_sym_rule) THEN all_fc_tac [cp_eq_thm1]);
a (REPEAT strip_tac);
(* *** Goal "1.1" *** *)
a (∂_tac ¨Fst x'Æ THEN asm_rewrite_tac[]);
(* *** Goal "1.2" *** *)
a (∂_tac ¨Snd x'Æ THEN asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a (∂_tac ¨x', x''Æ THEN asm_rewrite_tac[RelProd_projections_thm]);
a (rewrite_tac [rel_ç_in_clauses] THEN REPEAT strip_tac);
a (ALL_UFC_T rewrite_tac [EquivClass_RelProd_thm1]);
val EquivClasses_RelProd_thm1 = save_pop_thm "EquivClasses_RelProd_thm1";

set_goal([], ¨µ(L, $¶âl) (R, $¶âr)∑ Equiv(L, $¶âl) ± Equiv(R, $¶âr) ¥ EquivClasses ((L, $¶âl) RelProd (R, $¶âr))
	         = (EquivClasses (L, $¶âl) ∏âD EquivClasses (R, $¶âr))Æ);
a (REPEAT strip_tac THEN rewrite_tac [sets_ext_clauses, ∏âD_ext_thm]);
a (REPEAT strip_tac);
(* *** Goal "1" *** *)
a (all_fc_tac [EquivClasses_RelProd_thm1]);
a (∂_tac ¨lÆ THEN ∂_tac ¨rÆ THEN asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a (all_ufc_§_rewrite_tac [EquivClasses_RelProd_thm1]);
a (∂_tac ¨leqÆ THEN ∂_tac ¨reqÆ THEN asm_rewrite_tac[sets_ext_clauses]);
val EquivClasses_RelProd_thm2 = save_pop_thm "EquivClasses_RelProd_thm2";
=TEX
}%ignore

=GFT
=TEX

\ignore{
=IGN
val QuotientClasses_RelProd_thm2 = rewrite_rule [EquivClasses_def, RelProd_projections_thm] EquivClasses_RelProd_thm2;

set_goal([])

=SML
pop_pc();
=TEX
}%ignore

\subsection{Powers of Equivalence Relations}

=GFT
€RelPower_Equiv_thm› =
   Ù µ (D, $¶) is∑ Equiv (D, $¶) ¥ Equiv (RelPower (D, $¶) is)
=TEX

\ignore{
=SML
set_goal([], ¨µ(D, $¶) is∑ Equiv(D, $¶) ¥ Equiv(RelPower (D, $¶) is)Æ);
a (REPEAT µ_tac THEN split_pair_rewrite_tac [¨RelPower (D, $¶) isÆ] [equiv_def] THEN strip_tac);
a (rewrite_tac [pair_clauses]);
a (all_fc_tac [RelPower_Trans_thm, RelPower_Sym_thm, RelPower_Refl_thm]
	THEN asm_rewrite_tac[]);
val RelPower_Equiv_thm = save_pop_thm "RelPower_Equiv_thm";

=IGN
set_goal([], ¨µ(D, $¶) is∑ Equiv(D, $¶) ¥ µf∑ (µi∑ i ç is ¥ f i ç D) 
	¥ EquivClass (RelPower (D, $¶) is) f = {g | µi∑ i ç is ¥ g i ç (EquivClass (D, $¶) (f i))}Æ);
a (REPEAT µ_tac THEN rewrite_tac [RelPower_def]);
=TEX
}%ignore

\subsection{Lifting Operators to Quotient Types}

The conditions for a function to be liftable from a type to a quotient of that type are now expressed.
This will be possible of the function ``respects'' the equivalence relations which determine the relevant quotient types.

The definition give here differs from {\it Respects} in theory {\it equiv\_rel} in expressing conditions for lifting both on the domain and the codomain relative to possibly distinct equivalence relation, and therefore requires that if two elements of the domain are equivalent under one relationship then the results of the function on these two elements will be equivalent under the other relationship.

=SML
declare_infix(200, "Respects1");
declare_infix(230, "¶âd");
declare_infix(230, "¶âc");
declare_infix(230, "¶âe");
declare_infix(230, "¶âf");
=TEX

πHOLCONST
‹ €$Respects1› : ('a ≠ 'b) ≠ (('a SET ∏ ('a ≠ 'a ≠ BOOL)) ∏ ('b SET ∏ ('b ≠ 'b ≠ BOOL))) ≠ BOOL
˜¸¸¸¸¸¸
‹ µ f $¶âc $¶âd C D∑ (f Respects1 ((D, $¶âd), (C, $¶âc)))
	§ µx y∑x ç D ± y ç D ± x ¶âd y ¥ f x ç C ± f y ç C ± f x ¶âc f y
∞

=GFT
€Respects1_Respects_thm› =
   Ù µ f $¶âd C D∑ f Respects1 ((D, $¶âd), Universe, $=) § (f Respects $¶âd) D 

€Respects1_Refines_thm› =
   Ù µ f $¶âd =âc $¶âe =âf D C∑
	f Respects1 ((D, $¶âd), C, $¶âc)
           ± ($¶âe Refines $¶âd) D
           ± ($¶âc Refines $¶âf) C
         ¥ f Respects1 ((D, $¶âe), C, $¶âf)
=TEX
=GFT
€eq_Refines_thm› =
   Ù µ $¶âd D∑ Equiv (D, $¶âd) ¥ ($= Refines $¶âd) D

€constant_img_thm1› =
   Ù µ f A a c∑ a ç A ± (µ x∑ x ç A ¥ f x = c)
	¥ (≈ y∑ ∂ x∑ x ç A ± y = f x) = c
=TEX

\ignore{
=SML
set_goal([], ¨µ f $¶âd D∑ (f Respects1 ((D, $¶âd), (Universe, $=))) § (f Respects $¶âd) DÆ);
a (REPEAT µ_tac THEN rewrite_tac (map get_spec [¨$Respects1Æ, ¨$RespectsÆ]) THEN REPEAT strip_tac
	THEN all_asm_ufc_tac[]);
val Respects1_Respects_thm = save_pop_thm "Respects1_Respects_thm";

set_goal([], ¨µ f $¶âd $=âc $¶âe $=âf D C∑ (f Respects1 ((D, $¶âd), (C, $¶âc))) ± ($¶âe Refines $¶âd) D ± ($¶âc Refines $¶âf) C
	¥ (f Respects1 ((D, $¶âe), (C, $¶âf)))Æ);
a (REPEAT µ_tac THEN rewrite_tac (map get_spec [¨$Respects1Æ, ¨$RefinesÆ]) THEN REPEAT strip_tac
	THEN all_asm_ufc_tac[] THEN REPEAT (all_asm_ufc_tac[]));
val Respects1_Refines_thm = save_pop_thm "Respects1_Refines_thm";

set_goal([], ¨µ $¶âd D∑ Equiv (D, $¶âd) ¥ ($= Refines $¶âd) DÆ);
a (REPEAT µ_tac THEN rewrite_tac (map get_spec [¨$RefinesÆ, ¨$EquivÆ, ¨$ReflÆ])
	THEN REPEAT strip_tac
	THEN REPEAT (all_asm_ufc_tac[])
	THEN asm_rewrite_tac[]);
val eq_Refines_thm = save_pop_thm "eq_Refines_thm";

set_goal([], ¨
	µf A a c∑
		a ç A ± (µx∑x ç A ¥ f x = c)
	¥	(≈y∑ ∂x∑ x ç A ± y = f x) = c
Æ);
a(REPEAT strip_tac);
a(≈_tac ¨≈ y∑ ∂ x∑ x ç A ± y = f xÆ);
(* *** Goal "1" *** *)
a(∂_tac¨cÆ THEN ∂_tac¨aÆ THEN REPEAT strip_tac);
a (asm_fc_tac[] THEN asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a (LEMMA_T ¨c = f xÆ asm_rewrite_thm_tac);
a (ASM_FC_T rewrite_tac []);
val €constant_img_thm1› = save_pop_thm "constant_img_thm1";
=TEX
}%ignore

The following operator lifts a function over a pair of equivalence relations respected by the function.
This definition allows that they domain and codomains are of different type, and will provide the basis for lifting monadic and dyadic operators in a single sorted theory.

=SML
declare_infix(200, "LiftOver");
=TEX

πHOLCONST
‹ €$LiftOver› : ('a ≠ 'b)
‹	≠ (('a SET ∏ ('a ≠ 'a ≠ BOOL)) ∏ ('b SET ∏ ('b ≠ 'b ≠ BOOL)))
‹	≠ ('a SET ≠ 'b SET)
˜¸¸¸¸¸¸
‹ µ f (D, $¶âd) (C, $¶âc)∑ (f LiftOver ((D, $¶âd), (C, $¶âc)))
‹	= Ãx∑ ≈y∑ ∂z∑ z ç x ± y = EquivClass (C, $¶âc) (f z)
∞

=GFT
€LiftOver_thm› =
   Ù µ f (D, $¶âd) (C, $¶âc) de ce∑
	     Equiv (D, $¶âd)
           ± Equiv (C, $¶âc)
           ± f Respects1 ((D, $¶âd), C, $¶âc)
           ± de ç D / $¶âd
           ± ce ç C / $¶âc
         ¥ ((f LiftOver ((D, $¶âd), C, $¶âc)) de = ce
           § (∂ d c∑ d ç D
               ± EquivClass (D, $¶âd) d = de
               ± EquivClass (C, $¶âc) c = ce
               ± c = f d))
=TEX

\ignore{
=SML
val Respects1_def= get_spec ¨$Respects1Æ;
val LiftOver_def= get_spec ¨$LiftOverÆ;

set_goal([], ¨
	µf (D, $¶âd) (C, $¶âc) de ce∑
		Equiv(D, $¶âd) ± Equiv(C, $¶âc)
	±	(f Respects1 ((D, $¶âd), (C, $¶âc)))
	±	de ç (D / $¶âd) ± ce ç (C / $¶âc)
	¥	((f LiftOver ((D, $¶âd), (C, $¶âc))) de = ce
		§ ∂d c∑ d ç D ± EquivClass (D, $¶âd) d = de ± EquivClass (C, $¶âc) c = ce
			± c = f d)
Æ);
a(rewrite_tac[Respects1_def, LiftOver_def] THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a (all_fc_tac [list_µ_elim [¨DÆ,¨$¶âdÆ] quotient_map_onto_thm]);
a (∂_tac ¨xÆ THEN ∂_tac ¨f xÆ THEN_TRY asm_rewrite_tac[]);
a (SYM_ASMS_T rewrite_tac);
a (≈_tac ¨(≈ y∑ ∂ z∑ z ç de ± y = EquivClass (C, $¶âc) (f z))Æ);
(* *** Goal "1.1" *** *)
a (lemma_tac ¨x ç deÆ THEN1 (all_fc_tac [equiv_class_ç_thm] THEN asm_rewrite_tac[]));
a (∂_tac ¨EquivClass (C, $¶âc) (f x)Æ THEN ∂_tac  ¨xÆ THEN_TRY asm_rewrite_tac[]);
(* *** Goal "1.2" *** *)
a (asm_rewrite_tac[]);
a (lemma_tac ¨z ç DÆ THEN1 all_fc_tac [all_µ_intro quotient_ç_thm]);
a (lemma_tac ¨x ¶âd zÆ);
(* *** Goal "1.2.1" *** *)
a (DROP_NTH_ASM_T 3 ante_tac THEN asm_rewrite_tac[get_spec ¨EquivClassÆ]);
(* *** Goal "1.2.2" *** *)
a (all_asm_fc_tac[]);
a (all_ufc_§_tac[equiv_class_eq_thm]);
(* *** Goal "2" *** *)
a (≈_tac ¨(≈ y∑ ∂ z∑ z ç de ± y = EquivClass (C, $¶âc) (f z))Æ);
(* *** Goal "2.1" *** *)
a (∂_tac ¨EquivClass (C, $¶âc) (f d)Æ THEN ∂_tac  ¨dÆ THEN_TRY asm_rewrite_tac[]);
a (SYM_ASMS_T rewrite_tac);
a (all_fc_tac[equiv_class_ç_thm]);
(* *** Goal "2.2" *** *)
a (asm_rewrite_tac[]);
a (lemma_tac ¨z ç DÆ THEN1 all_fc_tac [all_µ_intro quotient_ç_thm]);
a (lemma_tac ¨d ¶âd zÆ);
(* *** Goal "2.2.1" *** *)
a (DROP_NTH_ASM_T 3 ante_tac THEN SYM_ASMS_T rewrite_tac);
a (rewrite_tac[get_spec ¨EquivClassÆ]);
a (REPEAT strip_tac);
(* *** Goal "2.2.2" *** *)
a (all_asm_fc_tac[]);
a (LEMMA_T ¨ce = EquivClass (C, $¶âc) (f d)Æ rewrite_thm_tac THEN1 SYM_ASMS_T rewrite_tac);
a (ALL_UFC_§_T (rewrite_tac) [equiv_class_eq_thm]);
a (all_fc_tac [equiv_def]);
a (all_fc_tac [sym_def]);
val LiftOver_thm = save_pop_thm "LiftOver_thm";
=TEX
}%ignore

\subsection{Lifting Monadic Operators}

=SML
declare_infix(200, "MonOpRespects");
=TEX

πHOLCONST
‹ €$MonOpRespects› : ('a ≠ 'a) ≠ ('a SET ∏ ('a ≠ 'a ≠ BOOL)) ≠ BOOL
˜¸¸¸¸¸¸
‹ µ f eq∑ f MonOpRespects eq § f Respects1 (eq, eq)
∞

=GFT
€MonOpRespects_thm› =
   Ù µ f C $¶∑ f MonOpRespects (C, $¶) § (µ x y∑ x ç C ± y ç C ± x ¶ y ¥ f x ç C ± f y ç C ± f x ¶ f y)
=TEX

\ignore{
=SML
set_goal([], ¨µ f C $¶∑ f MonOpRespects (C, $¶) § µx y∑x ç C ± y ç C ± x ¶ y ¥ f x ç C ± f y ç C ± f x ¶ f yÆ);
a (REPEAT µ_tac THEN rewrite_tac [get_spec ¨$MonOpRespectsÆ, get_spec ¨$Respects1Æ]);
val MonOpRespects_thm = save_pop_thm "MonOpRespects_thm";
=TEX
}%ignore

The following operator lifts a monadic operator over an equivalence relations respected by the operator.

=SML
declare_infix(210, "MonOpLift");
=TEX

πHOLCONST
‹ €$MonOpLift› : ('a ≠ 'a)
‹	≠ ('a SET ∏ ('a ≠ 'a ≠ BOOL))
‹	≠ ('a SET ≠ 'a SET)
˜¸¸¸¸¸¸
‹ µ f (D, $¶âd)∑ f MonOpLift (D, $¶âd) = f LiftOver ((D, $¶âd), (D, $¶âd))
∞
=GFT
€MonOpLift_thm› =
   Ù µ f (D, $¶âd) de ce
     ∑ Equiv (D, $¶âd)
           ± f Respects1 ((D, $¶âd), D, $¶âd)
           ± de ç D / $¶âd
           ± ce ç D / $¶âd
         ¥ ((f MonOpLift (D, $¶âd)) de = ce
           § (∂ d c∑ d ç D
               ± EquivClass (D, $¶âd) d = de
               ± EquivClass (D, $¶âd) c = ce
               ± c = f d))
=TEX

\ignore{
=SML
val MonOpRespects_def= get_spec ¨$MonOpRespectsÆ;
val MonOpLift_def= get_spec ¨$MonOpLiftÆ;

push_pc "hol";

set_goal([], ¨
	µf (D, $¶âd) de ce∑
		Equiv(D, $¶âd)
	±	(f MonOpRespects (D, $¶âd))
	±	de ç (D / $¶âd) ± ce ç (D / $¶âd)
	¥	((f MonOpLift (D, $¶âd)) de = ce
		§ ∂d c∑ d ç D ± EquivClass (D, $¶âd) d = de ± EquivClass (D, $¶âd) c = ce
			± c = f d)
Æ);
a(rewrite_tac[MonOpLift_def, MonOpRespects_def] THEN REPEAT_N 7 strip_tac);
a (ALL_UFC_§_T (rewrite_tac) [LiftOver_thm]);
val MonOpLift_thm = save_pop_thm "MonOpLift_thm";
=TEX
}%ignore

\subsection{Lifting Dyadic Operators}

=SML
declare_infix(200, "DyOpRespects");
=TEX

πHOLCONST
‹ €$DyOpRespects› : ('a ≠ 'a ≠ 'a) ≠ ('a SET ∏ ('a ≠ 'a ≠ BOOL)) ≠ BOOL
˜¸¸¸¸¸¸
‹ µ f eq∑ f DyOpRespects eq § (Uncurry f) Respects1 (eq RelProd eq, eq)
∞

=GFT
€DyOpRespects_thm› =
   Ù µ f C $¶∑ f DyOpRespects (C, $¶)
         § (µ x1 y1 x2 y2∑ x1 ç C ± y1 ç C ± x2 ç C ± y2 ç C ± x1 ¶ x2 ± y1 ¶ y2
             ¥ f x1 y1 ç C ± f x2 y2 ç C ± f x1 y1 ¶ f x2 y2)
=TEX

\ignore{
=SML
set_goal([], ¨µ f C $¶∑ f DyOpRespects (C, $¶) § µx1 y1 x2 y2∑ x1 ç C ± y1 ç C ± x2 ç C ± y2 ç C ± x1 ¶ x2 ± y1 ¶ y2 ¥ f x1 y1 ç C ± f x2 y2 ç C ± f x1 y1 ¶ f x2 y2Æ);
a (REPEAT µ_tac THEN rewrite_tac [get_spec ¨$DyOpRespectsÆ, get_spec ¨$Respects1Æ, get_spec ¨UncurryÆ, get_spec ¨$RelProdÆ]);
a (REPEAT strip_tac);
(* *** Goal "1" *** *)
a (lemma_tac ¨(x1,y1) ç (C ∏ C) ± (x2,y2) ç (C ∏ C)Æ THEN1 asm_rewrite_tac[get_spec ¨$∏Æ]);
a (LIST_SPEC_NTH_ASM_T 9 [¨x1,y1Æ, ¨x2,y2Æ] (strip_asm_tac o (rewrite_rule[])));
(* *** Goal "2" *** *)
a (lemma_tac ¨(x1,y1) ç (C ∏ C) ± (x2,y2) ç (C ∏ C)Æ THEN1 asm_rewrite_tac[get_spec ¨$∏Æ]);
a (LIST_SPEC_NTH_ASM_T 9 [¨x1,y1Æ, ¨x2,y2Æ] (strip_asm_tac o (rewrite_rule[])));
(* *** Goal "3" *** *)
a (lemma_tac ¨(x1,y1) ç (C ∏ C) ± (x2,y2) ç (C ∏ C)Æ THEN1 asm_rewrite_tac[get_spec ¨$∏Æ]);
a (LIST_SPEC_NTH_ASM_T 9 [¨x1,y1Æ, ¨x2,y2Æ] (strip_asm_tac o (rewrite_rule[])));
(* *** Goal "4" *** *)
a (all_asm_ufc_tac[]);
(* *** Goal "5" *** *)
a (all_asm_ufc_tac[]);
(* *** Goal "6" *** *)
a (all_asm_ufc_tac[]);
val DyOpRespects_thm = save_pop_thm "DyOpRespects_thm";
=TEX
}%ignore

The following operator lifts a dyadic operator over an equivalence relations respected by the operator.

=SML
declare_infix(210, "DyOpLift");
=TEX

πHOLCONST
‹ €$DyOpLift› : ('a ≠ 'a ≠ 'a)
‹	≠ ('a SET ∏ ('a ≠ 'a ≠ BOOL))
‹	≠ ('a SET ≠ 'a SET ≠ 'a SET)
˜¸¸¸¸¸¸
‹ µ f (D, $¶âd)∑ f DyOpLift (D, $¶âd)
‹	= Ãx y∑((Uncurry f) LiftOver ((D, $¶âd) RelProd (D, $¶âd), (D, $¶âd))) (x ∏ y)
∞

=GFT
€DyOpLift_thm› =
   Ù µ f (D, $¶âd) l r c
     ∑ Equiv (D, $¶âd)
           ± f DyOpRespects (D, $¶âd)
           ± l ç D / $¶âd
           ± r ç D / $¶âd
           ± c ç D / $¶âd
         ¥ ((f DyOpLift (D, $¶âd)) l r = c
           § (∂ le re ce
           ∑ le ç D
               ± re ç D
               ± EquivClass (D, $¶âd) le = l
               ± EquivClass (D, $¶âd) re = r
               ± EquivClass (D, $¶âd) ce = c
               ± ce = f le re))
=TEX

\ignore{
=SML

push_pc "hol";

val DyOpRespects_def= get_spec ¨$DyOpRespectsÆ;
val DyOpLift_def= get_spec ¨$DyOpLiftÆ;

set_goal([], ¨
	µf (D, $¶âd) l r c∑
		Equiv(D, $¶âd)
	±	(f DyOpRespects (D, $¶âd))
	±	l ç (D / $¶âd) ± r ç (D / $¶âd) ± c ç (D / $¶âd)
	¥	((f DyOpLift (D, $¶âd)) l r = c
		§ ∂le re ce∑ le ç D ± re ç D ± EquivClass (D, $¶âd) le = l ± EquivClass (D, $¶âd) re = r ± EquivClass (D, $¶âd) ce = c
			± ce = f le re)
Æ);
a (rewrite_tac[DyOpLift_def, DyOpRespects_def] THEN REPEAT_N 8 strip_tac);
a (all_fc_tac [Equiv_RelProd_thm]);
a (lemma_tac ¨∂(D2, eD2)∑ (D, $¶âd) RelProd (D, $¶âd) = (D2, eD2)Æ THEN1 (∂_tac ¨(D, $¶âd) RelProd (D, $¶âd)Æ THEN rewrite_tac[]));
a (DROP_NTH_ASM_T 6 ante_tac THEN asm_rewrite_tac[] THEN strip_tac);
a (DROP_NTH_ASM_T 3 ante_tac THEN asm_rewrite_tac[] THEN strip_tac);
a (GET_NTH_ASM_T 3 (strip_asm_tac o (rewrite_rule [pair_clauses, RelProd_projections_thm]) o (eq_sym_rule)));
a (lemma_tac ¨(l ∏ r) ç  EquivClasses (D2, eD2)Æ);
(* *** Goal "1" *** *)
a (SYM_ASMS_T rewrite_tac);
a (all_ufc_§_rewrite_tac [EquivClasses_RelProd_thm]);
a (asm_rewrite_tac [EquivClasses_def]);
(* *** Goal "2" *** *)
a (POP_ASM_T (strip_asm_tac o (rewrite_rule [EquivClasses_def])));
a (all_fc_tac [quotient_map_onto_thm]);
a (ALL_UFC_§_T (rewrite_tac) [LiftOver_thm]);
a (REPEAT strip_tac);
(* *** Goal "2.1" *** *)
a (∂_tac ¨Fst dÆ THEN ∂_tac ¨Snd dÆ THEN ∂_tac ¨c'Æ THEN asm_rewrite_tac[]);
a (DROP_ASM_T ¨d ç D2Æ ante_tac THEN asm_rewrite_tac[]);
a (split_pair_rewrite_tac [¨dÆ][rel_ç_in_clauses]);
a (strip_tac THEN asm_rewrite_tac[]);
a (SYM_ASMS_T rewrite_tac);
a (DROP_NTH_ASM_T 5 ante_tac);
a (split_pair_rewrite_tac [¨dÆ] [eq_sym_rule (asm_rule  ¨(D, $¶âd) RelProd (D, $¶âd) = (D2, eD2)Æ)]);
a (ALL_FC_T rewrite_tac [EquivClass_RelProd_thm1]);
a (all_fc_tac [equiv_class_ç_thm]);
a (strip_tac);
a (all_ufc_§_tac [cp_eq_thm1]);
a (contr_tac);
(* *** Goal "2.2" *** *)
a (∂_tac ¨le,reÆ THEN ∂_tac ¨ceÆ THEN rewrite_tac[]);
a (rewrite_tac [asm_rule ¨D2 = (D ∏ D)Æ, rel_ç_in_clauses]);
a (REPEAT strip_tac);
a (SYM_ASMS_T rewrite_tac);
a (ALL_FC_T rewrite_tac [EquivClass_RelProd_thm1]);
val DyOpLift_thm = save_pop_thm "DyOpLift_thm";
=TEX
}%ignore

The following relation defines the relationship between a function which has been obtained by ``lifting'' a function over equvalence relations and the original.

=SML
declare_infix(200, "Lifts");
=TEX

πHOLCONST
‹ $€Lifts› : ('a SET ≠ 'b SET)
‹		≠	(('a SET ∏ ('a ≠ 'a ≠ BOOL))
‹			∏ ('a ≠ 'b)
‹			∏ ('b SET ∏ ('b ≠ 'b ≠ BOOL)))
‹		≠ BOOL
˜¸¸¸¸¸¸
‹ µ f D C ($¶âd, g, $¶âc)∑ f Lifts ((D, $¶âd), g, (C, $¶âc))
‹		§ (µx y∑ x ç (D / $¶âd) ± y ç x ¥ g y ç f x)
∞

=GFT

=TEX

\ignore{
=SML
set_goal([], ¨µf D C $¶âd $¶âc∑ g Respects1 ((D, $¶âd), (C, $¶âc)) ¥ ∂f∑ f Lifts ((D, $¶âd), g, (C, $¶âc))Æ);
a (REPEAT µ_tac THEN rewrite_tac (map get_spec [¨$Respects1Æ, ¨$LiftsÆ, ¨$QuotientSetÆ, ¨EquivClassÆ]) THEN REPEAT strip_tac);
a (∂_tac ¨(Ãe∑ EquivClass (C, $¶âc) (g e))õ-Æ);
a (REPEAT µ_tac THEN rewrite_tac (map get_spec [¨$Respects1Æ, ¨$LiftsÆ, ¨$QuotientSetÆ, ¨EquivClassÆ]) THEN REPEAT strip_tac);
a (rewrite_tac (map get_spec [¨$õ-Æ]));
a (lemma_tac ¨∂w∑{y|∂ x'∑ x' ç x ± y = EquivClass (C, $¶âc) (g x')} = {w}Æ THEN_TRY asm_rewrite_tac[get_spec ¨ContentsÆ]);
a (rewrite_tac (map get_spec [¨EquivClassÆ]));
a (var_elim_asm_tac ¨x = {y|y ç D ± x' ¶âd y}Æ);
a (all_asm_ufc_tac[]);
a (rewrite_tac (map get_spec [¨ContentsÆ]));
=TEX
}%ignore

\section{Lattices (I)}

The beginnings of a theory of lattices.
This version was done before the work on Univesal Algebra, and will be discarded if the later version conformant with that theory is found satisfactory.

=SML
set_merge_pcs ["hol", "'rbjmisc"] ;
=TEX

\subsection{Signature and Defining Property}

We will represent a lattice as a triple comprising a carrier set and two-argument join and meet functions.

πHOLLABPROD €LAT›¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	€CarâL›			: 'a SET;
‹	€JoinâL›			: 'a ≠ 'a ≠ 'a;
‹	€MeetâL›		: 'a ≠ 'a ≠ 'a
∞¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸

We will use L and M as variables for lattices and the following infixity declarations will be useful as names for the corresponding operations.

=SML
declare_infix (235, "≤âL");
declare_infix (235, "≤âM");
declare_infix (240, "±âL");
declare_infix (240, "±âM");
=TEX

πHOLCONST
‹ €IsLattice› : 'a LAT ≠ BOOL
˜¸¸¸¸¸¸
‹ µ L∑	IsLattice L § µ C $≤âL $±âL∑ MkLAT C $≤âL $±âL = L ¥ 
‹       (µx y∑ x ç C ± y ç C ¥
		x ≤âL y ç C ± x ±âL y ç C
	±	x ≤âL y = y ≤âL x ± x ±âL y = y ±âL x
	±	x ±âL (x ≤âL y) = x ± x ≤âL (x ±âL y) = x
        ± (µz∑ z ç C
		¥	(x ≤âL y) ≤âL z = x ≤âL (y ≤âL z)
		±	(x ±âL y) ±âL z = x ±âL (y ±âL z)))
∞

\subsection{Elementary Theorems}

=GFT
€±âL_idempot_thm› =
   Ù µ L
     ∑ IsLattice L ¥ (µ C $≤âL $±âL∑ MkLAT C $≤âL $±âL = L
        ¥ (µ x∑ x ç C ¥ x ±âL x = x))

€±âL_idempot_thm› =
   Ù µ L∑ IsLattice L ¥ (µ C $≤âL $±âL∑ MkLAT C $≤âL $±âL = L
	¥ (µ x∑ x ç C ¥ x ≤âL x = x))
=TEX

\ignore{
=SML
val lattice_def = get_spec ¨IsLatticeÆ;

set_goal([], ¨µL∑ IsLattice L ¥ µ C $≤âL $±âL∑ MkLAT C $≤âL $±âL = L ¥
	µx∑ x ç C ¥ x ±âL x = xÆ);
a (REPEAT strip_tac);
a (lemma_tac ¨x ±âL x ç CÆ THEN1 all_ufc_tac [lattice_def]);
a (lemma_tac ¨x ±âL (x ≤âL x ±âL x) = xÆ THEN1 all_ufc_tac [lattice_def]);
a (lemma_tac ¨x ≤âL x ±âL x = xÆ THEN1 all_ufc_tac [lattice_def]);
a (DROP_NTH_ASM_T 2 ante_tac THEN asm_rewrite_tac[]);
val ±âL_idempot_thm = save_pop_thm "±âL_idempot_thm";

set_goal([], ¨µL∑ IsLattice L ¥ µ C $≤âL $±âL∑ MkLAT C $≤âL $±âL = L ¥
	µx∑ x ç C ¥ x ≤âL x = xÆ);
a (REPEAT_N 8 strip_tac);
a (lemma_tac ¨x ≤âL x ç CÆ THEN1 all_ufc_tac [lattice_def]);
a (lemma_tac ¨x ≤âL (x ±âL (x ≤âL x)) = xÆ THEN1 all_ufc_tac [lattice_def]);
a (lemma_tac ¨x ±âL (x ≤âL x) = xÆ THEN1 all_ufc_tac [lattice_def]);
a (DROP_NTH_ASM_T 2 ante_tac THEN asm_rewrite_tac[]);
val ≤âL_idempot_thm = save_pop_thm "≤âL_idempot_thm";

=TEX
}%ignore

\subsection{Quotient Lattices}

The quotient of a lattice with respect to some equivalence relation over its elements is defined as follows:

πHOLCONST
‹ €QuotientLattice› : 'a LAT ≠ ('a ≠ 'a ≠ BOOL) ≠ 'a SET LAT
˜¸¸¸¸¸¸
‹ µ L $¶âd∑ QuotientLattice L $¶âd =
‹	let D = (CarâL L, $¶âd)
‹	in let $≤âL = (JoinâL L) DyOpLift D and $±âL = (MeetâL L) DyOpLift D
‹	   in MkLAT (EquivClasses D) $≤âL $±âL
∞

=SML
declare_alias ("/", ¨QuotientLatticeÆ);
=TEX

-GFT
=TEX

\ignore{
=IGN
val QuotientLattice_def = get_spec ¨QuotientLatticeÆ;

set_goal([], ¨µL $¶âd∑ IsLattice L ± Equiv (CarâL L, $¶âd) ¥ IsLattice (L / $¶âd)Æ);
a (REPEAT µ_tac THEN rewrite_tac [lattice_def, QuotientLattice_def, let_def] THEN REPEAT strip_tac);
=TEX
}%ignore

\section{Group Theory}

=SML
new_parent "group_egs";
set_merge_pcs ["basic_hol1", "'sets_alg", "'Ø", "'rbjmisc"];
=TEX

\subsection{Group Products}

πHOLCONST
‹ €GroupProduct› : 'a GROUP ≠ 'b GROUP ≠ ('a ∏ 'b) GROUP
˜¸¸¸¸¸¸
‹ µ G H∑ GroupProduct G H =
‹	let car = (Car G ∏ Car H)
‹	and prod	(la, lb) (ra, rb) = ((la.ra) G, (lb.rb) H)
‹	and unit = (Unit G, Unit H)
‹	and inv (a, b) = ((a õ~) G, (b õ~) H)
‹	in MkGROUP car prod unit inv
∞
=SML
declare_alias ("*", ¨GroupProductÆ);
=TEX
\ignore{
=SML
val €group_def› = get_spec¨GroupÆ;
val €group_unit_def› = get_spec¨UnitÆ;
val €gp_def› = get_spec¨GroupProductÆ;
=TEX
=SML
set_goal([], ¨µg:'a GROUP; h:'b GROUP∑
	g ç Group ± h ç Group ¥ g * h ç GroupÆ);
a(rewrite_tac [get_spec ¨GroupÆ,
	gp_def,
	group_unit_def,
	get_spec ¨$∏Æ,
	let_def]
	THEN REPEAT strip_tac
	THEN TRY (all_asm_fc_tac[])); (* ufc takes twice as long *)
val €group_product_thm› = save_pop_thm "group_product_thm";
=TEX
}%ignore

=GFT
group_product_thm = Ù µg:'a GROUP; h:'b GROUP∑
	g ç Group ± h ç Group ¥ g * h ç Group
=TEX

\subsection{Abelian Groups}

πHOLCONST
‹ €AbelianGroup› : 'a GROUP SET
˜¸¸¸¸¸¸
‹ µ G∑ G ç AbelianGroup § G ç Group
‹	± µ u v:'a∑ u ç Car G ± v ç Car G
‹	         ¥ (u.v) G = (v.u) G
∞

\ignore{
=SML
val €abelian_group_def› = get_spec¨AbelianGroupÆ;
set_goal([], ¨µg:'a GROUP; h:'b GROUP∑
	g ç AbelianGroup ± h ç AbelianGroup ±
	Car g = Universe ± Car h = Universe
	¥ Car (g * h) = UniverseÆ);
a(rewrite_tac [abelian_group_def,
	group_def,
	gp_def,
	group_unit_def,
	get_spec ¨$∏Æ,
	let_def]
	THEN REPEAT strip_tac
	THEN TRY (asm_rewrite_tac[sets_ext_clauses]));
val €abelian_group_product_lemma› = save_pop_thm "abelian_group_product_lemma";
=TEX

=SML
set_goal([], ¨µg:'a GROUP; h:'b GROUP∑
	g ç AbelianGroup ± h ç AbelianGroup 
	¥ (g * h) ç AbelianGroupÆ);
a (rewrite_tac [abelian_group_def]);
a (REPEAT strip_tac);
a (all_asm_ufc_tac[group_product_thm]);
a (REPEAT_N 2 (POP_ASM_T ante_tac));
a (asm_rewrite_tac [
	gp_def,
	let_def,
	group_unit_def,
	get_spec ¨$∏Æ]);
a (REPEAT strip_tac
	THEN all_asm_ufc_tac[]);
val €abelian_group_product_thm› = save_pop_thm "abelian_group_product_thm";
=TEX

=SML
set_goal([], ¨µG:'g GROUP; H:'h GROUP; x y:'g; v w:'h∑
	((x,v) . (y, w)) (G * H)
	= ((x . y)G, (v . w)H)Æ);
a (REPEAT strip_tac
	THEN rewrite_tac [gp_def, let_def, group_unit_def]
	THEN REPEAT strip_tac);
val group_prod_prod_thm = save_pop_thm "group_prod_prod_thm";
=TEX
=SML
set_goal([], ¨µG:'g GROUP; H:'h GROUP; x y:'g ∏ 'h∑
	(x . y) (G * H)
	= ((Fst x . Fst y)G, (Snd x . Snd y)H)Æ);
a (REPEAT strip_tac
	THEN rewrite_tac [gp_def, let_def, group_unit_def]
	THEN REPEAT strip_tac);
val group_prod_prod_thm1 = save_pop_thm "group_prod_prod_thm1";
=TEX

}%ignore

=GFT
abelian_group_product_thm = Ù µg:'a GROUP; h:'b GROUP∑
	g ç AbelianGroup ± h ç AbelianGroup ¥ (g * h) ç AbelianGroup
=TEX

\ignore{
=SML
set_goal([], ¨Ø_plus ç AbelianGroupÆ);
a (rewrite_tac [
	get_spec ¨AbelianGroupÆ,
	Ø_plus_ops_thm,
	Ø_plus_group_thm
	]);
val Ø_plus_abelian_thm = save_pop_thm "Ø_plus_abelian_thm";
=TEX
}%ignore

=GFT
Ø_plus_abelian_thm = Ù Ø_plus ç AbelianGroup
=TEX

\section{Topology}

=SML
new_parent "topology";
=TEX

\subsection{Bases etc.}

The following definitions belong properly in the theory ``topology''.

First we define the relationship between a $base$ and the topology of which it is a base.

=SML
declare_infix (300, "BaseOf");
=TEX

πHOLCONST
‹ $€BaseOf› :  'a SET SET ≠ 'a SET SET ≠ BOOL
˜¸¸¸¸¸¸
‹ µ base topology∑ base BaseOf topology §
‹	µs∑ s ç topology ¥ ∂ ss∑ ss Ä base ± s = ﬁ ss
∞

However, what we really need here is the construction of a topology from an arbitrary set of sets, which is done as follows:

πHOLCONST
‹ $€TopologyFrom› :  'a SET SET ≠ 'a SET SET
˜¸¸¸¸¸¸
‹ µ sets∑ TopologyFrom sets =
‹	• {topology | topology ç Topology ± sets Ä topology}
∞

\ignore{

Prove that $TopologyFrom$ yields a topology.

}%ignore

\section{Disjoint Unions (Sum)}

Two ways of constructing functions over disjoint unions.

πHOLCONST
‹ €Funâ+›: ('a ≠ 't) ≠ ('b≠ 'u) ≠ ('a + 'b ≠ 't + 'u)
˜¸¸¸¸¸¸
‹ µf:'a ≠ 't; g:'b ≠ 'u; ab:'a + 'b∑
‹	Funâ+ f g ab = if IsL ab then InL (f (OutL ab)) else InR (g (OutR ab))
∞

πHOLCONST
‹ €FunSum›: ('a ≠ 't) ≠ ('b≠ 't) ≠ ('a + 'b ≠ 't)
˜¸¸¸¸¸¸
‹ µf:'a ≠ 't; g:'b ≠ 't; ab:'a + 'b∑
‹	FunSum f g ab = if IsL ab then f (OutL ab) else g (OutR ab)
∞

=GFT
€IsL_IsR_lemma› =
	Ù µ x∑ IsR x § ≥ IsL x
=TEX

\ignore{
=SML
set_merge_pcs ["hol1", "'rbjmisc"];

set_goal([], ¨µx∑ IsR x § ≥ IsL xÆ);
a (µ_tac);
a (strip_asm_tac (µ_elim ¨xÆ sum_cases_thm) THEN asm_rewrite_tac[]);
val IsL_IsR_lemma = save_pop_thm "IsL_IsR_lemma";

add_pc_thms "'rbjmisc" (map get_spec [] @ [IsL_IsR_lemma]);
set_merge_pcs ["hol", "'rbjmisc"];
=TEX
}%ignore

\section{Indexed Sets}

=SML
declare_type_abbrev(€"IX"›, ["'a", "'b"], î'a ≠ 'b OPTÆ);
=TEX

πHOLCONST
‹ €IxVal› : ('b, 'a) IX ≠ 'b ≠ 'a
˜¸¸¸¸¸¸¸¸¸¸¸
‹ µis g∑ IxVal is g = ValueOf (is g)
∞

πHOLCONST
‹ €IxRan› : ('b, 'a) IX ≠ 'a SET
˜¸¸¸¸¸¸¸¸¸¸¸
‹ µis∑ IxRan is = {v | ∂¡∑ Value v = is ¡}
∞

πHOLCONST
‹ €IxDom› : ('b, 'a) IX ≠ 'b SET
˜¸¸¸¸¸¸¸¸¸¸¸
‹ µis∑ IxDom is = {i | IsDefined (is i)}
∞

=GFT
€ix_domran_lemma› =
   Ù µ x y∑ x ç IxDom y ¥ IxVal y x ç IxRan y

€ix_valueof_ran_lemma› =
   Ù µ x y∑ ≥ x y = Undefined ¥ ValueOf (x y) ç IxRan x
=TEX

\ignore{
=SML
val IxDom_def = get_spec ¨IxDomÆ;

set_goal ([], ¨µx y∑ x ç IxDom y ¥ IxVal y x ç IxRan yÆ);
a (REPEAT µ_tac THEN rewrite_tac [IxDom_def, get_spec ¨IxValÆ, get_spec ¨IxRanÆ]);
a (strip_tac THEN ∂_tac ¨xÆ);
a (strip_asm_tac (µ_elim ¨y xÆ opt_cases_thm) THEN asm_rewrite_tac[]);
val ix_domran_lemma = save_pop_thm "ix_domran_lemma";

set_goal ([], ¨µx y∑ ≥ x y = Undefined ¥ ValueOf (x y) ç IxRan xÆ);
a (REPEAT µ_tac THEN rewrite_tac [get_spec ¨IxRanÆ]
	THEN REPEAT strip_tac);
a (strip_asm_tac (µ_elim ¨x yÆ (±_right_elim (±_right_elim (get_spec ¨ValueÆ)))));
a (∂_tac ¨yÆ THEN asm_rewrite_tac[]);
val ix_valueof_ran_lemma = save_pop_thm "ix_valueof_ran_lemma";
=TEX
}%ignore

πHOLCONST
‹ €IxUd› : ('a, 'b) IX ≠ 'a SET
˜¸¸¸¸¸¸¸¸¸¸¸
‹ µis∑ IxUd is = {i | is i = Undefined}
∞

πHOLCONST
‹ €IxOverRide› : ('a, 'b) IX ≠ ('a, 'b) IX ≠ ('a, 'b) IX
˜¸¸¸¸¸¸¸¸¸¸¸
‹ µis1 is2∑ IxOverRide is1 is2 =
‹	Ãi∑ if ≥ i ç IxUd is2 then is2 i else is1 i 
∞

=GFT
€ixud_eq_iff_ixdom_eq_lemma› =
   Ù µ x y∑ IxUd x = IxUd y § IxDom x = IxDom y

€ixoverride_ixdom_lemma› =
   Ù µ x y∑ IxDom (IxOverRide x y) = IxDom x ¿ IxDom y

€ixoverride_ixud_lemma› =
   Ù µ x y∑ IxUd (IxOverRide x y) = IxUd x \ IxDom y

€ixoverride_ixran_lemma› =
   Ù µ x y∑ IxRan (IxOverRide x y) Ä IxRan x ¿ IxRan y
=TEX

\ignore{
=SML
set_goal ([], ¨µx y∑ IxUd x = IxUd y § IxDom x = IxDom yÆ);
a (REPEAT µ_tac THEN rewrite_tac [get_spec ¨IxDomÆ, get_spec ¨IxUdÆ]
	THEN PC_T1 "hol1" prove_tac[]);
val ixud_eq_iff_ixdom_eq_lemma = save_pop_thm "ixud_eq_iff_ixdom_eq_lemma";

set_goal ([], ¨µx y∑ IxDom (IxOverRide x y) = IxDom x ¿ IxDom yÆ);
a (REPEAT µ_tac
	THEN rewrite_tac [get_spec ¨IxDomÆ, get_spec ¨IxOverRideÆ]
	THEN PC_T "hol1" strip_tac
	THEN strip_tac THEN rewrite_tac[ç_in_clauses, get_spec ¨IxUdÆ]);
a (cases_tac ¨y x' = UndefinedÆ THEN asm_rewrite_tac[]);
val ixoverride_ixdom_lemma = save_pop_thm "ixoverride_ixdom_lemma";

set_goal ([], ¨µx y∑ IxRan (IxOverRide x y) Ä IxRan x ¿ IxRan yÆ);
a (REPEAT µ_tac
	THEN rewrite_tac [get_spec ¨IxRanÆ, get_spec ¨IxOverRideÆ]
	THEN PC_T "hol1" strip_tac
	THEN strip_tac THEN rewrite_tac[ç_in_clauses, get_spec ¨IxUdÆ]
	THEN strip_tac THEN POP_ASM_T ante_tac);
a (cases_tac ¨y ¡ = UndefinedÆ THEN asm_rewrite_tac[] THEN strip_tac);
(* *** Goal "1" *** *)
a (≤_left_tac THEN ∂_tac ¨¡Æ THEN asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a (≤_right_tac THEN ∂_tac ¨¡Æ THEN asm_rewrite_tac[]);
val ixoverride_ixran_lemma = save_pop_thm "ixoverride_ixran_lemma";

set_goal ([], ¨µx y∑ IxUd (IxOverRide x y) = IxUd x \ IxDom y Æ);
a (REPEAT µ_tac
	THEN rewrite_tac [get_spec ¨IxUdÆ, get_spec ¨IxDomÆ, get_spec ¨IxOverRideÆ]
	THEN PC_T "hol1" strip_tac
	THEN strip_tac THEN rewrite_tac[ç_in_clauses, get_spec ¨UndefinedÆ]);
a (cases_tac ¨y x' = UndefinedÆ THEN asm_rewrite_tac[]);
val ixoverride_ixud_lemma = save_pop_thm "ixoverride_ixud_lemma";

add_pc_thms "'rbjmisc" (map get_spec [] @ [ixud_eq_iff_ixdom_eq_lemma, ixoverride_ixdom_lemma, ixoverride_ixud_lemma]);
set_merge_pcs ["hol", "'rbjmisc"];
=TEX
}%ignore

πHOLCONST
‹ €IxCompIx› : ('a, 'b) IX ≠ ('b, 'c) IX ≠('a, 'c) IX
˜¸¸¸¸¸¸¸¸¸¸¸
‹ µix jx∑ IxCompIx ix jx = Ãx∑ if IsDefined (ix x) then jx (ValueOf (ix x)) else Undefined
∞

πHOLCONST
‹ €IxInc› : ('a, 'b) IX ≠ ('a, 'b) IX ≠ BOOL
˜¸¸¸¸¸¸¸¸¸¸¸
‹ µi j∑ IxInc i j § µx∑ IsDefined (i x) ¥ j x = i x 
∞

=SML
declare_alias("√", ¨IxIncÆ);
declare_infix(200, "√");
=TEX

=GFT
€IxInc_trans_thm› =
	Ù µ A B C∑ A √ B ± B √ C ¥ A √ C

€IxDom_√_thm› =
	Ù µ A B s∑ s ç IxDom A ± A √ B ¥ s ç IxDom B
=TEX

\ignore{
=SML
val IxCompIx_def = get_spec ¨IxCompIxÆ;
val IxInc_def = get_spec ¨IxIncÆ;

set_goal([], ¨µA B C:('a, 'b) IX∑ A √ B ± B √ C ¥ A √ CÆ);
a (REPEAT µ_tac THEN rewrite_tac[IxInc_def] THEN REPEAT strip_tac
	THEN (all_asm_fc_tac[]));
a (DROP_NTH_ASM_T 2 ante_tac THEN SYM_ASMS_T rewrite_tac
	THEN strip_tac THEN all_asm_fc_tac[]);
val IxInc_trans_thm = save_pop_thm "IxInc_trans_thm";

set_goal([], ¨µA B s∑ s ç IxDom A ± A √ B ¥ s ç IxDom BÆ);
a (REPEAT µ_tac THEN rewrite_tac[IxInc_def, IxDom_def] THEN REPEAT strip_tac
	THEN (all_asm_fc_tac[]) THEN asm_rewrite_tac[]);
val IxDom_√_thm = save_pop_thm "IxDom_√_thm";
=TEX
}%ignore

\section{Universal Algebra}

To make the operators fairly general within the constrainst imposed by the HOL type system we will have operators as functions over indexed sets of values.

The following labelled product is used as a general notion of ``structure'' independent of signature.
Of course any particular algebra will have a definite signature.

A signature is a string indexed set of arities, where an arity is a natural number.

=SML
declare_type_abbrev ("SIG", [], î(STRING, Ó) IXÆ);
=TEX

The operators over the algebra are represented by functions from indexed sets of operands to a single result value.
In this case we pack the arguments into a total function and ignore the values which do not correspond to the signature.
The signature (i.e. the arity of each operator) is explicit in this structure, otherwise the range of significance of the operators would not be known.

πHOLLABPROD €STRUCT›¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	€SCar›		: 'a SET;
‹	€SOps›		: (STRING, (Ó ∏ ((Ó ≠ 'a) ≠ 'a)))IX
∞¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸

The following function extracts the signature from a structure.

πHOLCONST
‹ €Sig› : ('a) STRUCT ≠ SIG
˜¸¸¸¸¸¸¸¸¸¸¸
‹ µs∑ Sig s = IxCompIx (SOps s) (Ãx∑ Value (Fst x)) 
∞

=GFT
€IxDom_Sig_thm› =
	Ù µ S∑ IxDom (Sig S) = IxDom (SOps S)

€ç_IxDom_Sig_thm› =
	Ù µ S x∑ x ç IxDom (Sig S) § x ç IxDom (SOps S)
=TEX

\ignore{
=SML
val Sig_def = get_spec ¨SigÆ;

set_goal ([], ¨µS∑ IxDom (Sig S) = IxDom (SOps S)Æ);
a (strip_tac THEN rewrite_tac[Sig_def, IxCompIx_def, IxDom_def, sets_ext_clauses]
	THEN REPEAT strip_tac THEN_TRY asm_rewrite_tac[]);
a (swap_nth_asm_concl_tac 1 THEN asm_rewrite_tac[]);
val IxDom_Sig_thm = save_pop_thm "IxDom_Sig_thm";

set_goal ([], ¨µS x∑ x ç IxDom (Sig S) § x ç IxDom (SOps S)Æ);
a (strip_tac THEN rewrite_tac[Sig_def, IxCompIx_def, IxDom_def, sets_ext_clauses]
	THEN REPEAT strip_tac THEN_TRY asm_rewrite_tac[]);
a (swap_nth_asm_concl_tac 1 THEN asm_rewrite_tac[]);
val ç_IxDom_Sig_thm = save_pop_thm "ç_IxDom_Sig_thm";
=TEX
}%ignore

\emph{IxInc} (aliased as $√$) is inclusion of indexed sets, and suffices for signature inclusion.

=GFT
€IxDom_Sig_SOps_thm› =
	Ù µ A∑ IxDom (Sig A) = IxDom (SOps A)

€SigInc_IxDom_Ä_thm› =
   Ù µ A B∑ Sig A √ Sig B ¥ IxDom (Sig A) Ä IxDom (Sig B)

€SigInc_IxDom_Sops_Ä_thm› =
   Ù µ A B∑ Sig A √ Sig B ¥ IxDom (SOps A) Ä IxDom (SOps B)
=TEX

\ignore{
=SML
set_goal([], ¨µA∑ IxDom (Sig A) = IxDom (SOps A)Æ);
a (REPEAT µ_tac THEN rewrite_tac[Sig_def, IxDom_def, sets_ext_clauses, IxCompIx_def] THEN strip_tac);
a (cond_cases_tac ¨SOps A x = UndefinedÆ);
val IxDom_Sig_SOps_thm = save_pop_thm "IxDom_Sig_SOps_thm";

set_goal([], ¨µA B∑ Sig A √ Sig B ¥ IxDom (Sig A) Ä IxDom (Sig B)Æ);
a (REPEAT µ_tac THEN rewrite_tac[IxInc_def, IxDom_def]);
a (PC_T "hol1" (REPEAT strip_tac) THEN asm_fc_tac[] THEN asm_rewrite_tac[]);
val SigInc_IxDom_Ä_thm = save_pop_thm "SigInc_IxDom_Ä_thm";

set_goal([], ¨µA B∑ Sig A √ Sig B ¥ IxDom (SOps A) Ä IxDom (SOps B)Æ);
a (REPEAT strip_tac THEN fc_tac[SigInc_IxDom_Ä_thm]);
a (asm_rewrite_tac [map_eq_sym_rule IxDom_Sig_SOps_thm]);
val SigInc_IxDom_Sops_Ä_thm = save_pop_thm "SigInc_IxDom_Sops_Ä_thm";
=TEX
}%ignore

This is probably too crude, it would probably be better to ignore the irrelevant behaviour of the operators (i.e. values off sig or out of domain).

πHOLCONST
‹ €StructInc› : ('a) STRUCT ≠ ('a) STRUCT ≠ BOOL
˜¸¸¸¸¸¸¸¸¸¸¸
‹ µs t∑ StructInc s t § SCar s = SCar t ± IxInc (SOps s) (SOps t) 
∞

=SML
declare_alias("√", ¨StructIncÆ);
=TEX

There is a general requirement on structures that the operators are closed on the domain of the structure.

πHOLCONST
‹ €ClosedOp› : 'a SET ≠ (Ó ∏ ((Ó ≠ 'a) ≠ 'a)) ≠ BOOL
˜¸¸¸¸¸¸¸¸¸¸¸
‹ µs p∑ ClosedOp s p = µf∑ (µi∑ i < Fst p ¥ f i ç s) ¥ Snd p f ç s
∞

πHOLCONST
‹ €ClosedStruct› : ('a) STRUCT ≠ BOOL
˜¸¸¸¸¸¸¸¸¸¸¸
‹ µs∑ ClosedStruct s § µp∑ p ç IxRan (SOps s) ¥ ClosedOp (SCar s) p
∞

\subsection{Packing Functions}

The form of the operators is not idea for talking about the structures, so we define some functions which will make more convenient forms readily obtainable.

There are two things we need to be able to do.
The first is to convert 0-ary 1-ary and 2-ary operations in their usual convenient representation to the representation in which the arguments are collected into an indexed set.
The second is to collect the operators into a name-indexed set.

Note that the two kinds of indexed set are represented differently (not that they are different in kind).

πHOLCONST
‹ €pack0op› : 'a ≠ (Ó ∏ ((Ó ≠ 'a) ≠ 'a))
˜¸¸¸¸¸¸¸¸¸¸¸
‹ µc∑ pack0op c = (0, Ãis∑ c)
∞

πHOLCONST
‹ €pack1op› : ('a ≠ 'a) ≠ (Ó ∏ ((Ó ≠ 'a) ≠ 'a))
˜¸¸¸¸¸¸¸¸¸¸¸
‹ µf∑ pack1op f = (1, Ãis∑ f (is 0))
∞

πHOLCONST
‹ €pack2op› : ('a ≠ 'a ≠ 'a) ≠ (Ó ∏ ((Ó ≠ 'a) ≠ 'a))
˜¸¸¸¸¸¸¸¸¸¸¸
‹ µf∑ pack2op f = (2, Ãis∑ f (is 0) (is 1))
∞

πHOLCONST
‹ €packops› : (STRING ∏ (Ó ∏ ((Ó ≠ 'a) ≠ 'a)))LIST ≠ (STRING, (Ó ∏ ((Ó ≠ 'a) ≠ 'a)))IX
˜¸¸¸¸¸¸¸¸¸¸¸
‹         packops [] = (Ãis∑ Undefined)
‹ ± µh t∑ packops (Cons h t) = Ãis∑
		if Fst h = is then Value (Snd h) else packops t is
∞

\subsection{Homomorphisms}

Now we can define the notion of homomorphism.

First we define the requirement on the homomorphism to map the domain of the source into the domain of the target.

πHOLCONST
‹ €FunClosed› : ('b)STRUCT  ∏ ('b ≠ 'c) ∏ ('c) STRUCT ≠ BOOL
˜¸¸¸¸¸¸
‹ µ A f B∑ FunClosed (A, f, B) § µ x∑ x ç SCar A ¥ f x ç SCar B
∞

=GFT
€FunClosed_trans_thm› = Ù µ A f B g C∑
	FunClosed (A, f, B) ± FunClosed (B, g, C) ¥ FunClosed (A, g o f, C)
=TEX

\ignore{
=SML
val FunClosed_def = get_spec ¨FunClosedÆ;

set_goal([], ¨µ A f B g C∑ FunClosed (A, f, B) ± FunClosed (B, g, C) ¥ FunClosed (A, g o f, C)Æ);
a (REPEAT µ_tac THEN rewrite_tac [FunClosed_def] THEN REPEAT strip_tac THEN REPEAT (all_asm_ufc_tac[]));
val FunClosed_trans_thm = save_pop_thm "FunClosed_trans_thm";
=TEX
}%ignore

Then the requirement that the function respects an operator

πHOLCONST
‹ €HomOp› : ('b)STRUCT  ∏ ('b ≠ 'c) ∏ ('c) STRUCT ≠ BOOL
˜¸¸¸¸¸¸
‹ µ A B f∑ HomOp (A, f, B) § Sig A √ Sig B ± FunClosed (A, f, B) ±
	µs∑ s ç IxDom (SOps A) ¥
		let (is1, f1) = ValueOf (SOps A s)
		and (is2, f2) = ValueOf (SOps B s)
        	and d = SCar A
		in µg∑ FunImage g {i | i < is1} Ä d
			¥ f (f1 g) = f2 (Ãx∑ f (g x))
∞

=GFT
=TEX

\ignore{
=SML
val HomOp_def = get_spec ¨HomOpÆ;

set_goal([], ¨µ A f B g C∑ HomOp (A, f, B) ± HomOp (B, g, C) ¥ HomOp (A, g o f, C)Æ);
a (REPEAT µ_tac THEN rewrite_tac [HomOp_def, let_def] THEN strip_tac);
a (all_fc_tac [FunClosed_trans_thm] THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a (all_fc_tac [IxInc_trans_thm]);
(* *** Goal "2" *** *)
a (ALL_ASM_FC_T rewrite_tac []);
a (rule_nth_asm_tac 2 (rewrite_rule[map_eq_sym_rule IxDom_Sig_thm]));
a (all_asm_fc_tac [IxDom_√_thm]);
a (rule_nth_asm_tac 1 (rewrite_rule[IxDom_Sig_thm]));
a (lemma_tac ¨FunImage (f o g') {i|i < Fst (ValueOf (SOps B s))} Ä SCar BÆ);
(* *** Goal "2.1" *** *)
a (lemma_tac ¨Fst (ValueOf (SOps B s)) = Fst (ValueOf (SOps A s))Æ);
(* *** Goal "2.1.1" *** *)
a (fc_tac [SigInc_IxDom_Sops_Ä_thm]);

(* *** Goal "2.2" *** *)
set_labelled_goal "2.2";
a (ALL_ASM_FC_T (rewrite_tac o (map(rewrite_rule[
			prove_rule [get_spec ¨$o:(('a≠'c)≠(('b≠'a)≠('b≠'c)))Æ, ext_thm] ¨(f o g') = (Ã x∑ f (g' x))Æ
			]))) []);
=IGN
val HomClosed_comp_thm = save_pop_thm "HomClosed_comp_thm";
=TEX
}%ignore


πHOLCONST
‹ €AlgHom› : ('b)STRUCT  ∏ ('b ≠ 'c) ∏ ('c) STRUCT ≠ BOOL
˜¸¸¸¸¸¸
‹ µ A f B∑ AlgHom (A, f, B) §
‹	Sig A √ Sig B ± FunClosed (A, f, B) ± HomOp (A, f, B)
∞

\subsection{Algebraic Equations}

Algebraic equations in an algebra are preserved under homomorphism.

To prove this general claim we must first define the concept of an algebraic equation, which will be done inductively.
We need to be able to talk about the same algebraic equation over two distinct algebras so the notion will be parameterised by an algebra.

We will represent an expression over an algebra by a function from a valuation of variables to a value.
We generate the expressions for a specific ``signature''.
The signature is just a triple giving the number of 0-ary, 1-ary and 2-ary operations in the algebra.

=SML
declare_type_abbrev("EXPR", ["'a"], î('a) STRUCT ≠ ((Ó ≠ 'a) ≠ 'a)Æ);
=TEX

There is no syntax in this account of polynomials, so the list is a list of the values of the variables.

An equation is a pair of polynomials.

To define the set of polynomials we first define the ways in which new polynomials can be constucted from a set already to hand.
This is by the use of any of the operations in the algebra, and the operation involved is functional composition.

πHOLCONST
‹ €VExpr› : Ó ≠ 'a EXPR
˜¸¸¸¸¸¸
‹ µn∑ VExpr n = Ãa va∑ va n
∞

πHOLCONST
‹ €VExprs› : Ó ≠ 'a EXPR SET
˜¸¸¸¸¸¸
‹ µn∑ VExprs n = {p | ∂m∑ m < n ± p = VExpr m}
∞

πHOLCONST
‹ €CExprs› : SIG ≠ 'a EXPR SET ≠ 'a EXPR SET
˜¸¸¸¸¸¸
‹ µsig es∑ CExprs sig es = {e | ∂name arity am∑
‹		name ç IxDom sig ± sig name = Value arity
‹	±	(µi∑ i < arity ¥ am i ç es)
‹	±	e = Ãstruct va∑  (Snd (ValueOf (SOps struct name))) (Ãi∑ am i struct va)}
∞

Now we define closure under the above operators.

πHOLCONST
‹ €ExprClosed› : SIG ≠ 'a EXPR SET ≠ BOOL
˜¸¸¸¸¸¸
‹ µs es∑ ExprClosed s es § CExprs s es Ä es
∞

πHOLCONST
‹ €Exprs› : SIG ≠ Ó ≠ 'a EXPR SET
˜¸¸¸¸¸¸
‹ µs n∑ Exprs s n = •{ps | ExprClosed s ps ± VExprs n Ä ps}
∞

\ignore{

\subsection{Quotient Algebras}

 πHOLCONST
‹ €QuotientStruct› : ('b, 'a) STRUCT ≠ ('b ≠ 'b ≠ BOOL) ≠ ('b SET, 'a) ALG
 ˜¸¸¸¸¸¸
‹ µ A $¶âd∑ QuotientStruct A $¶âd = 
‹	let (C, ops) = ≈(C, ops)∑ (MkSTRUCT C ops = A)
‹	in let D = (C, $¶âd)
‹	in MkSTRUCT (EquivClasses D) (Map (Ãop∑ op MonOpLift D) mops) 
 ∞

}%ignore

\section{Lattices (II)}

The beginnings of a theory of lattices.
This version was done using Universal Algebra, the previous version will be discarded if this version conformant with the approach to universal algebra is found satisfactory.

=SML
set_merge_pcs ["hol", "'rbjmisc"] ;
=TEX

\subsection{Signature and Defining Property}

We will use the general structure type \emph{STRUCT} to represent lattice structures.

We will use L and M as variables for lattices and the following infixity declarations will be useful as names for the corresponding operations.

πHOLCONST
‹ €MkLat› : 'a SET ≠ ('a ≠ 'a ≠ 'a) ≠ ('a ≠ 'a ≠ 'a) ≠ ('a) STRUCT
˜¸¸¸¸¸¸
‹ µd j m∑ MkLat d j m = MkSTRUCT d (packops [("≤âL" , pack2op j); ("≤âL" , pack2op m)])
∞

=SML
declare_infix (235, "≤âL");
declare_infix (235, "≤âM");
declare_infix (240, "±âL");
declare_infix (240, "±âM");
=TEX


πHOLCONST
‹ €IsLat› : ('a) STRUCT ≠ BOOL
˜¸¸¸¸¸¸
‹ µ L∑	IsLat L § µ C $≤âL $±âL∑ StructInc (MkLat C $≤âL $±âL) L ¥ 
‹       (µx y∑ x ç C ± y ç C ¥
		x ≤âL y ç C ± x ±âL y ç C
	±	x ≤âL y = y ≤âL x ± x ±âL y = y ±âL x
	±	x ±âL (x ≤âL y) = x ± x ≤âL (x ±âL y) = x
        ± (µz∑ z ç C
		¥	(x ≤âL y) ≤âL z = x ≤âL (y ≤âL z)
		±	(x ±âL y) ±âL z = x ±âL (y ±âL z)))
∞

\subsection{Elementary Theorems}

=GFT
€±âL_idempot_thm› =
   Ù µ L∑ IsLat L ¥ (µ C $≤âL $±âL∑ MkLat C $≤âL $±âL Äâs L
	¥ (µ x∑ x ç C ¥ x ±âL x = x))

€≤âL_idempot_thm› =
   Ù µ L∑ IsLat L ¥ (µ C $≤âL $±âL∑ MkLat C $≤âL $±âL Äâs L
	¥ (µ x∑ x ç C ¥ x ≤âL x = x))
=TEX

\ignore{
=SML
val lat_def = get_spec ¨IsLatÆ;

set_goal([], ¨µL∑ IsLat L ¥ µ C $≤âL $±âL∑ StructInc (MkLat C $≤âL $±âL) L ¥
	µx∑ x ç C ¥ x ±âL x = xÆ);
a (REPEAT strip_tac);
a (lemma_tac ¨x ±âL x ç CÆ THEN1 all_ufc_tac [lat_def]);
a (lemma_tac ¨x ±âL (x ≤âL x ±âL x) = xÆ THEN1 all_ufc_tac [lat_def]);
a (lemma_tac ¨x ≤âL x ±âL x = xÆ THEN1 all_ufc_tac [lat_def]);
a (DROP_NTH_ASM_T 2 ante_tac THEN asm_rewrite_tac[]);
val ±âL_idempot_thm1 = save_pop_thm "±âL_idempot_thm1";

set_goal([], ¨µL∑ IsLat L ¥ µ C $≤âL $±âL∑ StructInc (MkLat C $≤âL $±âL) L ¥
	µx∑ x ç C ¥ x ≤âL x = xÆ);
a (REPEAT_N 8 strip_tac);
a (lemma_tac ¨x ≤âL x ç CÆ THEN1 all_ufc_tac [lat_def]);
a (lemma_tac ¨x ≤âL (x ±âL (x ≤âL x)) = xÆ THEN1 all_ufc_tac [lat_def]);
a (lemma_tac ¨x ±âL (x ≤âL x) = xÆ THEN1 all_ufc_tac [lat_def]);
a (DROP_NTH_ASM_T 2 ante_tac THEN asm_rewrite_tac[]);
val ≤âL_idempot_thm1 = save_pop_thm "≤âL_idempot_thm1";
=TEX
}%ignore

=SML
commit_pc "'rbjmisc";

force_new_pc "€rbjmisc›";
merge_pcs ["hol", "'rbjmisc"] "rbjmisc";
commit_pc "rbjmisc";

force_new_pc "€rbjmisc1›";
merge_pcs ["'rbjmisc", "hol1"] "rbjmisc1";
commit_pc "rbjmisc1";
=TEX


{\let\Section\section
\def\section#1{\Section{#1}\label{TheoryListing}}
\include{rbjmisc.th}
}  %\let

\twocolumn[\section{INDEX}\label{INDEX}]
{\small\printindex}

\end{document}
=SML
set_flag ("pp_use_alias", true);
output_theory{out_file="rbjmisc.th.doc", theory="rbjmisc"};
=TEX