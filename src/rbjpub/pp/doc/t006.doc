=IGN
$Id: t006.doc,v 1.12 2007/12/01 15:53:40 rbj01 Exp $
=TEX
\documentclass[11pt,a4paper]{article}
\usepackage{latexsym}
\usepackage{ProofPower}
\ftlinepenalty=9999
\tabstop=0.25in
\usepackage{A4}

\def\Hide#1{\relax}
\newcommand{\ignore}[1]{}

\title{Miscellanea}
\author{Roger Bishop Jones}
\date{\ }

\usepackage[unicode,pdftex]{hyperref}
\hypersetup{pdfauthor={Roger Bishop Jones}}
\hypersetup{colorlinks=true, urlcolor=black, citecolor=black, filecolor=black, linkcolor=black}

\makeindex
\begin{document}
\vfill
\maketitle
\begin{abstract}
This document contains things used by my other theories which do not particularly belong in them.
Definitions or theorems which arguably belong in a theory already produced by someone else.
\end{abstract}
\vfill
\begin{centering}
{\footnotesize

Date Created 2004/07/15

Last Changed $ $Date: 2007/12/01 15:53:40 $ $

\href{http://www.rbjones.com/rbjpub/pp/doc/t006.pdf}
{http://www.rbjones.com/rbjpub/pp/doc/t006.pdf}

$ $Id: t006.doc,v 1.12 2007/12/01 15:53:40 rbj01 Exp $ $

\copyright\ Roger Bishop Jones; Licenced under Gnu LGPL

}%footnotesize
\end{centering}

\newpage

{\setcounter{tocdepth}{4}
\parskip=0pt\tableofcontents}

%%%%

{\raggedright
\bibliographystyle{fmu}
\bibliography{rbj,fmu}
} %\raggedright

\section{The Theory rbjmisc}

For context and motivation see \cite{rbjt000}.

All the theorems are placed in the one temporary location, which therefore must have as ancestors all the theories which are being extended.

There is one section in this document, following this one, for each theory to which an addition is being made so new parents may be added in those sections, or new proof contexts used.

=SML
open PreConsisProof;
=TEX

=SML
open_theory "cache'rbjhol";
force_new_theory "rbjmisc";
new_parent "analysis";
set_merge_pcs["basic_hol1", "'sets_alg", "'¯", "'savedthm_cs_¶_proof"];
open UnifyForwardChain; open RbjTactics1;
=TEX

\ignore{
 ¹HOLLABPROD EIGHTTUPLEüüüüüüüüüüüüüüüüü
Ü	aaaa bbbb cccc dddd eeee ffff gggg hhhh: 'a
 °üüüüüüüüüüüüüüüüüüüüüüüüü
}%ignore



\section{Sets}

Here is a definition of ``Pairwise disjoint''.

¹HOLCONST
Ü $ÛPDisjİ: 'a  SET SET ­ BOOL
÷üüüüüü
Ü µss· PDisj ss ¤ ³ ¶t u· {t; u} € ss ± ³ t = u ± ³ t ¡ u = {} 
°

=GFT
Û€_trans_thmİ = ô µ A B C· A € B ± B € C ´ A € C
=TEX

\ignore{
=SML
val €_trans_thm = save_thm ("€_trans_thm", pc_rule1 "hol1" prove_rule []
	¬µA B C· A € B ± B € C ´ A € C®);
=TEX
}%ignore

¹HOLCONST
Ü ÛFunImageİ: ('a ­ 'b) ­ 'a SET ­ 'b SET
÷üüüüüü
Ü µf A· FunImage f A = {b | ¶a· a  A ± f a = b}
°

\section{Lists}

\subsection{List Membership}

=SML
declare_infix(300, "‰L");
=TEX

¹HOLCONST
Ü $Û‰Lİ: 'a ­ 'a  LIST ­ BOOL
÷üüüüüü
Ü µ a b al· (a ‰L [] ¤ F)
Ü	± (a ‰L (Cons b al) ¤ a = b ² a ‰L al)
°

\subsection{Quantification}

¹HOLCONST
Ü Ûµ‰Lİ: BOOL LIST ­ BOOL
÷üüüüüü
Ü µ bl· µ‰L bl = Fold $± bl T
°

¹HOLCONST
Ü Û¶‰Lİ: BOOL LIST ­ BOOL
÷üüüüüü
Ü µ bl· ¶‰L bl = Fold $² bl F
°

\subsection{Mapping Constructors}

The idea here is to facilitate the construction of a list of objects of some kind (typically a HOL labelled product), given a curried constructor and lists of the operands.
We will need a different one for each arity of constructor, so I will use a numeric suffix.

¹HOLCONST
Ü ÛMapCf‰2İ: ('a ­ 'b ­ 'c) ­ 'a LIST ­ 'b LIST ­ 'c LIST
÷üüüüüü
Ü µ cf al bl·  MapCf‰2 cf al bl = Map (Uncurry cf) (Combine al bl)
°

¹HOLCONST
Ü ÛMapCf‰3İ: ('a ­ 'b ­ 'c ­ 'd) ­ 'a LIST ­ 'b LIST ­ 'c LIST ­ 'd LIST
÷üüüüüü
Ü µ cf al bl cl·  MapCf‰3 cf al bl cl =
	Map (Uncurry (Uncurry cf)) (Combine (Combine al bl) cl)
°

\section{Real Numbers and Analysis}

\subsection{Products}
=GFT
¯_prod_sign_iff_clauses 
ô (µ x y· î¯ 0 <R x *‰R y		¤ î¯ 0 <‰R x ± î¯ 0 <‰R y ² x <‰R î¯ 0 ± y <‰R î¯ 0)
± (µ x y· x *‰R y <‰R î¯ 0		¤ î¯ 0 <‰R x ± y <‰R î¯ 0 ² x <‰R î¯ 0 ± î¯ 0 <‰R y)
± (µ x y· î¯ 0 ¼‰R x *‰R y		¤ î¯ 0 ¼‰R x ± î¯ 0 ¼‰R y ² x ¼‰R î¯ 0 ± y ¼‰R î¯ 0)
± (µ x y· x *‰R y ¼‰R î¯ 0		¤ î¯ 0 ¼‰R x ± y ¼‰R î¯ 0 ² x ¼‰R î¯ 0 ± î¯ 0 ¼‰R y)
± (µ x y· x *‰R y = î¯ 0		¤ x = î¯ 0 ² y = î¯ 0)
± (µ x y· î¯ 0 = x *‰R y		¤ x = î¯ 0 ² y = î¯ 0)
=TEX

\ignore{
=SML
set_goal([], ¬µ x y·
	(î¯ 0 <‰R x ± î¯ 0 <‰R y ´ î¯ 0 <‰R x *‰R y)
	± (x <‰R î¯ 0 ± y <‰R î¯ 0 ´ î¯ 0 <‰R x *‰R y)
	± (x <‰R î¯ 0 ± î¯ 0 <‰R y ´ x *‰R y <‰R î¯ 0)
	± (î¯ 0 <‰R x ± y <‰R î¯ 0 ´ x *‰R y <‰R î¯ 0)
	± (x = î¯ 0 ² y = î¯ 0 ´ x *‰R y = î¯ 0)
®);
a (REPEAT strip_tac
	THEN TRY (asm_rewrite_tac[]));
(* *** Goal "1" *** *)
a (all_asm_ufc_tac [¯_0_less_0_less_times_thm]);
(* *** Goal "2" *** *)
a (all_asm_ufc_tac [¯_less_0_less_thm]);
a (LEMMA_T ¬î¯ 0 <‰R (~‰R x) *‰R (~‰R y)® ante_tac
	THEN1 all_asm_ufc_tac [¯_0_less_0_less_times_thm]);
a (rewrite_tac[¯_times_minus_thm]);
(* *** Goal "3" *** *)
a (once_rewrite_tac [¯_less_0_less_thm]);
a (rewrite_tac[]);
a (lemma_tac ¬î¯ 0 <‰R (~‰R x)®
	THEN1 (ALL_ASM_FC_T (MAP_EVERY ante_tac) [¯_less_0_less_thm]
		THEN rewrite_tac[]
		THEN REPEAT strip_tac));
a (all_asm_ufc_tac [¯_0_less_0_less_times_thm]);
a (lemma_tac ¬~‰R (x *‰R y) = ~‰R x *‰R y®
	THEN1 (PC_T1 "¯_lin_arith" prove_tac[]));
a (asm_rewrite_tac[]);
(* *** Goal "4" *** *)
a (once_rewrite_tac [¯_less_0_less_thm]);
a (rewrite_tac[]);
a (lemma_tac ¬î¯ 0 <‰R (~‰R y)®
	THEN1 (ALL_ASM_FC_T (MAP_EVERY ante_tac) [¯_less_0_less_thm]
		THEN rewrite_tac[]
		THEN REPEAT strip_tac));
a (all_asm_ufc_tac [¯_0_less_0_less_times_thm]);
a (lemma_tac ¬~‰R (x *‰R y) = x *‰R ~‰R y®
	THEN1 (PC_T1 "¯_lin_arith" prove_tac[]));
a (asm_rewrite_tac[]);
val ¯_product_sign_lemma = pop_thm ();
=TEX
=SML
set_goal([], ¬µ x y·
	(î¯ 0 <‰R x *‰R y ´ î¯ 0 <‰R x ± î¯ 0 <‰R y ² x <‰R î¯ 0 ± y <‰R î¯ 0)
	± (x *‰R y <‰R î¯ 0 ´ î¯ 0 <‰R x ± y <‰R î¯ 0 ² î¯ 0 <‰R y ± x <‰R î¯ 0)
	± (x *‰R y = î¯ 0 ´ x = î¯ 0 ² y = î¯ 0)
®);
a contr_tac;
(* *** Goal "1" *** *)
a (strip_asm_tac (list_µ_elim [¬x®, ¬î¯ 0®] ¯_less_cases_thm));
a (DROP_NTH_ASM_T 4 ante_tac THEN asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a (strip_asm_tac (list_µ_elim [¬x®, ¬î¯ 0®] ¯_less_cases_thm));
(* *** Goal "2.1" *** *)
a (strip_asm_tac (list_µ_elim [¬y®, ¬î¯ 0®] ¯_less_cases_thm));
(* *** Goal "2.1.1" *** *)
a (DROP_NTH_ASM_T 5 ante_tac THEN asm_rewrite_tac[]);
(* *** Goal "2.1.2" *** *)
a (all_asm_ufc_tac[¯_product_sign_lemma]);
a (all_asm_ufc_tac[¯_less_trans_thm]);
(* *** Goal "2.2" *** *)
a (DROP_NTH_ASM_T 4 ante_tac THEN asm_rewrite_tac[]);
(* *** Goal "3" *** *)
a (strip_asm_tac (list_µ_elim [¬y®, ¬î¯ 0®] ¯_less_cases_thm));
(* *** Goal "3.1" *** *)
a (strip_asm_tac (list_µ_elim [¬x®, ¬î¯ 0®] ¯_less_cases_thm));
(* *** Goal "3.1.1" *** *)
a (DROP_NTH_ASM_T 5 ante_tac THEN asm_rewrite_tac[]);
(* *** Goal "3.1.2" *** *)
a (all_asm_ufc_tac[¯_product_sign_lemma]);
a (all_asm_ufc_tac[¯_less_trans_thm]);
(* *** Goal "3.2" *** *)
a (DROP_NTH_ASM_T 4 ante_tac THEN asm_rewrite_tac[]);
(* *** Goal "4" *** *)
a (strip_asm_tac (list_µ_elim [¬y®, ¬î¯ 0®] ¯_less_cases_thm));
a (DROP_NTH_ASM_T 4 ante_tac THEN asm_rewrite_tac[]);
(* *** Goal "5" *** *)
a (strip_asm_tac (list_µ_elim [¬x®, ¬î¯ 0®] ¯_less_cases_thm));
(* *** Goal "5.1" *** *)
a (strip_asm_tac (list_µ_elim [¬y®, ¬î¯ 0®] ¯_less_cases_thm));
(* *** Goal "5.1.1" *** *)
a (all_asm_ufc_tac[¯_product_sign_lemma]);
a (all_asm_ufc_tac[¯_less_trans_thm]);
(* *** Goal "5.1.2" *** *)
a (DROP_NTH_ASM_T 5 ante_tac THEN asm_rewrite_tac[]);
(* *** Goal "5.2" *** *)
a (DROP_NTH_ASM_T 4 ante_tac THEN asm_rewrite_tac[]);
(* *** Goal "6" *** *)
a (strip_asm_tac (list_µ_elim [¬x®, ¬î¯ 0®] ¯_less_cases_thm));
a (DROP_NTH_ASM_T 4 ante_tac THEN asm_rewrite_tac[]);
(* *** Goal "7" *** *)
a (strip_asm_tac (list_µ_elim [¬y®, ¬î¯ 0®] ¯_less_cases_thm));
a (DROP_NTH_ASM_T 4 ante_tac THEN asm_rewrite_tac[]);
(* *** Goal "8" *** *)
a (strip_asm_tac (list_µ_elim [¬y®, ¬î¯ 0®] ¯_less_cases_thm));
(* *** Goal "8.1" *** *)
a (strip_asm_tac (list_µ_elim [¬x®, ¬î¯ 0®] ¯_less_cases_thm));
(* *** Goal "8.1.1" *** *)
a (DROP_NTH_ASM_T 5 ante_tac THEN asm_rewrite_tac[]);
(* *** Goal "8.1.2" *** *)
a (DROP_NTH_ASM_T 5 ante_tac THEN asm_rewrite_tac[]);
(* *** Goal "8.2" *** *)
a (strip_asm_tac (list_µ_elim [¬x®, ¬î¯ 0®] ¯_less_cases_thm));
(* *** Goal "8.2.1" *** *)
a (DROP_NTH_ASM_T 5 ante_tac THEN asm_rewrite_tac[]);
(* *** Goal "8.2.2" *** *)
a (all_asm_ufc_tac[¯_product_sign_lemma]);
a (all_asm_ufc_tac[¯_less_trans_thm]);
(* *** Goal "9" *** *)
a (strip_asm_tac (list_µ_elim [¬x®, ¬î¯ 0®] ¯_less_cases_thm));
(* *** Goal "9.1" *** *)
a (strip_asm_tac (list_µ_elim [¬y®, ¬î¯ 0®] ¯_less_cases_thm));
(* *** Goal "9.1.1" *** *)
a (all_asm_ufc_tac[¯_product_sign_lemma]);
a (DROP_NTH_ASM_T 5 ante_tac THEN asm_rewrite_tac[]);
(* *** Goal "9.1.2" *** *)
a (all_asm_ufc_tac[¯_product_sign_lemma]);
a (DROP_NTH_ASM_T 5 ante_tac THEN asm_rewrite_tac[]);
(* *** Goal "9.2" *** *)
a (strip_asm_tac (list_µ_elim [¬y®, ¬î¯ 0®] ¯_less_cases_thm));
(* *** Goal "9.2.1" *** *)
a (all_asm_ufc_tac[¯_product_sign_lemma]);
a (DROP_NTH_ASM_T 5 ante_tac THEN asm_rewrite_tac[]);
(* *** Goal "9.2.2" *** *)
a (all_asm_ufc_tac[¯_product_sign_lemma]);
a (DROP_NTH_ASM_T 5 ante_tac THEN asm_rewrite_tac[]);
val ¯_product_sign_cp_lemma = pop_thm ();
=TEX
=SML
set_goal([], ¬(µ x y· î¯ 0 <‰R x *‰R y ¤ î¯ 0 <‰R x ± î¯ 0 <‰R y
		² x <‰R î¯ 0 ± y <‰R î¯ 0)
	± (µ x y· x *‰R y <‰R î¯ 0 ¤ î¯ 0 <‰R x ± y <‰R î¯ 0
		² x <‰R î¯ 0 ± î¯ 0 <‰R y)
	± (µ x y· x *‰R y = î¯ 0 ¤ x = î¯ 0 ² y = î¯ 0)
	± (µ x y· î¯ 0 = x *‰R y ¤ x = î¯ 0 ² y = î¯ 0)®);
a (REPEAT strip_tac
	THEN TRY (asm_rewrite_tac [])
	THEN TRY (all_ufc_tac [¯_product_sign_lemma,
	¯_product_sign_cp_lemma]));
a (DROP_NTH_ASM_T 2 (asm_tac o (conv_rule eq_sym_conv))
	THEN ufc_tac [¯_product_sign_cp_lemma]
	THEN asm_rewrite_tac[]);
val ¯_prod_sign_iff_lemma = pop_thm ();
=TEX
=SML
set_goal([], ¬(µ x y· î¯ 0 ¼‰R x *‰R y ¤ î¯ 0 ¼‰R x ± î¯ 0 ¼‰R y
		² x ¼‰R î¯ 0 ± y ¼‰R î¯ 0)
	± (µ x y· x *‰R y ¼‰R î¯ 0 ¤ î¯ 0 ¼‰R x ± y ¼‰R î¯ 0
		² x ¼‰R î¯ 0 ± î¯ 0 ¼‰R y)
	± (µ x y· x *‰R y = î¯ 0 ¤ x = î¯ 0 ² y = î¯ 0)
	± (µ x y· î¯ 0 = x *‰R y ¤ x = î¯ 0 ² y = î¯ 0)®);
a (rewrite_tac [get_spec ¬$¼‰R®, ¯_prod_sign_iff_lemma]);
a (REPEAT_N 6 strip_tac THEN TRY (asm_rewrite_tac[])
	THEN (PC_T1 "¯_lin_arith" prove_tac[]));
val ¯_prod_sign_iff_lemma2 = pop_thm ();
=TEX
=SML
set_goal([], ¬(µ x y· î¯ 0 <‰R x *‰R y ¤ î¯ 0 <‰R x ± î¯ 0 <‰R y
		² x <‰R î¯ 0 ± y <‰R î¯ 0)
	± (µ x y· x *‰R y <‰R î¯ 0 ¤ î¯ 0 <‰R x ± y <‰R î¯ 0
		² x <‰R î¯ 0 ± î¯ 0 <‰R y)
	± (µ x y· î¯ 0 ¼‰R x *‰R y ¤ î¯ 0 ¼‰R x ± î¯ 0 ¼‰R y
		² x ¼‰R î¯ 0 ± y ¼‰R î¯ 0)
	± (µ x y· x *‰R y ¼‰R î¯ 0 ¤ î¯ 0 ¼‰R x ± y ¼‰R î¯ 0
		² x ¼‰R î¯ 0 ± î¯ 0 ¼‰R y)
	± (µ x y· x *‰R y = î¯ 0 ¤ x = î¯ 0 ² y = î¯ 0)
	± (µ x y· î¯ 0 = x *‰R y ¤ x = î¯ 0 ² y = î¯ 0)®);
a (rewrite_tac [¯_prod_sign_iff_lemma, ¯_prod_sign_iff_lemma2]
	THEN (PC_T1 "¯_lin_arith" prove_tac[]));
val ¯_prod_sign_iff_clauses = save_pop_thm "¯_prod_sign_iff_clauses";
=TEX
}%ignore

\ignore{

=SML
set_goal([], ¬µ x y z· î¯ 0 <‰R x ± y <‰R z ´ y *‰R x <‰R z *‰R x®);
a (REPEAT strip_tac);
a (all_ufc_tac [¯_times_mono_thm]);
a (PC_T1 "¯_lin_arith" asm_prove_tac[]);
val ¯_times_mono_thm1 = save_pop_thm "¯_times_mono_thm1";
=TEX

=SML

set_goal([], ¬µ x y z· î¯ 0 ¼‰R x ± y ¼‰R z ´ x *‰R y ¼‰R x *‰R z®);
a (rewrite_tac [get_spec ¬$¼‰R®]
	THEN REPEAT strip_tac
	THEN TRY (asm_rewrite_tac[])
	THEN TRY (SYM_ASMS_T rewrite_tac)
	THEN TRY (all_ufc_tac
	[¯_times_mono_thm, ¯_times_mono_thm1, ¯_less_trans_thm]));
val ¯_times_mono_thm2 = save_pop_thm "¯_times_mono_thm2";

set_goal([], ¬µ x y z· î¯ 0 ¼‰R x ± y ¼‰R z ´ y *‰R x ¼‰R z *‰R x®);
a (rewrite_tac [get_spec ¬$¼‰R®]
	THEN REPEAT strip_tac
	THEN TRY (asm_rewrite_tac[])
	THEN TRY (SYM_ASMS_T rewrite_tac)
	THEN TRY (all_ufc_tac
	[¯_times_mono_thm, ¯_times_mono_thm1, ¯_less_trans_thm]));
val ¯_times_mono_thm3 = save_pop_thm "¯_times_mono_thm3";
=TEX

=SML
set_goal([], ¬µ w x y z· î¯ 0 <‰R w ± î¯ 0 <‰R y ± w <‰R x ± y <‰R z ´ w *‰R y <‰R x *‰R z®);
a (REPEAT strip_tac);
a (lemma_tac ¬î¯ 0 <‰R z ± î¯ 0 <‰R x®
	THEN1 (all_asm_ufc_tac[¯_less_trans_thm])
	THEN REPEAT strip_tac);
a (lemma_tac ¬w *‰R y <‰R w *‰R z®
	THEN1 (all_asm_ufc_tac[¯_times_mono_thm, ¯_times_mono_thm1, ¯_less_trans_thm]));
a (lemma_tac ¬w *‰R z <‰R x *‰R z®
	THEN1 (strip_asm_tac (list_µ_elim [¬z®, ¬w®, ¬x®] ¯_times_mono_thm1)));
a (strip_asm_tac (list_µ_elim [¬w *‰R y®, ¬w *‰R z®, ¬x *‰R z®] ¯_less_trans_thm));
val ¯_times_mono_thm4 = save_pop_thm "¯_times_mono_thm4";
=TEX

=SML
set_goal([], ¬µ w x y z· î¯ 0 ¼‰R w ± î¯ 0 ¼‰R y ± w ¼‰R x ± y ¼‰R z ´ w *‰R y ¼‰R x *‰R z®);
a (REPEAT strip_tac);
a (lemma_tac ¬î¯ 0 ¼‰R z ± î¯ 0 ¼‰R x®
	THEN1 (all_asm_ufc_tac[¯_¼_trans_thm])
	THEN REPEAT strip_tac);
a (lemma_tac ¬w *‰R y ¼‰R w *‰R z®
	THEN1 (all_asm_ufc_tac[¯_times_mono_thm2, ¯_times_mono_thm3, ¯_¼_trans_thm]));
a (lemma_tac ¬w *‰R z ¼‰R x *‰R z®
	THEN1 (strip_asm_tac (list_µ_elim [¬z®, ¬w®, ¬x®] ¯_times_mono_thm3)));
a (strip_asm_tac (list_µ_elim [¬w *‰R y®, ¬w *‰R z®, ¬x *‰R z®] ¯_¼_trans_thm));
val ¯_times_mono_thm5 = save_pop_thm "¯_times_mono_thm5";
=TEX
}%ignore

\subsection{Squares}

\ignore{
=SML
set_goal([], ¬µ x y· î¯ 0 <‰R x ± x <‰R y ´ x *‰R x <‰R y *‰R y®);
a (REPEAT strip_tac);
a (all_asm_ufc_tac [¯_less_trans_thm]);
a (strip_asm_tac (list_µ_elim [¬x®, ¬y®, ¬x®, ¬y®] ¯_times_mono_thm4));
val ¯_square_mono_thm = save_pop_thm "¯_square_mono_thm";
=TEX

=SML
set_goal([], ¬µ x y· î¯ 0 ¼‰R x ± x ¼‰R y ´ x *‰R x ¼‰R y *‰R y®);
a (REPEAT strip_tac);
a (all_asm_ufc_tac [¯_¼_trans_thm]);
a (strip_asm_tac (list_µ_elim [¬x®, ¬y®, ¬x®, ¬y®] ¯_times_mono_thm5));
val ¯_square_mono_thm1 = save_pop_thm "¯_square_mono_thm1";
=TEX

=SML
set_goal([], ¬µ x y z· î¯ 0 <‰R x ± î¯ 0 <‰R y ± x *‰R x <‰R y *‰R y ´ x <‰R y®);
a (REPEAT strip_tac);
a (strip_asm_tac (all_µ_elim ¯_less_cases_thm));
(* *** Goal "1" *** *)
a (DROP_ASM_T ¬x *‰R x <‰R y *‰R y® ante_tac
	THEN asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a (strip_asm_tac (list_µ_elim [¬y®, ¬x®] ¯_square_mono_thm));
a (all_ufc_tac [¯_less_antisym_thm]);
val ¯_square_less_less_thm = save_pop_thm "¯_square_less_less_thm";
=TEX

-SML
set_goal([], ¬µ x y· î¯ 0 <‰R x ± î¯ 0 <‰R y ´ (x *‰R x <‰R y *‰R y ¤ x <‰R y)®);
a (REPEAT strip_tac);
(* *** Goal "1" *** *)
a (all_ufc_tac [¯_square_less_less_thm]);
(* *** Goal "2" *** *)
a (all_ufc_tac [¯_square_mono_thm]);
val ¯_square_less_iff_less_thm = save_pop_thm "¯_square_less_iff_less_thm";
=TEX

-SML
set_goal([], ¬µ x y· î¯ 0 ¼‰R x ± î¯ 0 ¼‰R y ´ (x *‰R x ¼‰R y *‰R y ¤ x ¼‰R y)®);
a (REPEAT strip_tac);
(* *** Goal "1" *** *)
a (all_ufc_tac [¯_square_¼_¼_thm]);
(* *** Goal "2" *** *)
a (all_ufc_tac [¯_square_mono_thm1]);
val ¯_square_¼_iff_¼_thm = save_pop_thm "¯_square_¼_iff_¼_thm";
=TEX

=SML
set_goal([], ¬µx y:¯· î¯ 0 <‰R x ± î¯ 0 <‰R y ± y *‰R y = x *‰R x ´ x = y®);
a (REPEAT strip_tac);
a (strip_asm_tac (all_µ_elim ¯_less_cases_thm)
	THEN (ufc_tac [¯_times_mono_thm]));
(* *** Goal "1" *** *)
a (lemma_tac ¬x *‰R x <‰R x *‰R y®
	THEN1 asm_ufc_tac []);
a (lemma_tac ¬x *‰R y <‰R y *‰R y®
	THEN1 all_ufc_tac [list_µ_elim [¬y®, ¬x®, ¬y®] ¯_times_mono_thm1]);
a (ALL_FC_T (MAP_EVERY ante_tac) [¯_less_trans_thm]
	THEN asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a (lemma_tac ¬x *‰R y <‰R x *‰R x®
	THEN1 asm_ufc_tac []);
a (lemma_tac ¬y *‰R y <‰R x *‰R y®
	THEN1 all_ufc_tac [list_µ_elim [¬y®, ¬y®, ¬x®] ¯_times_mono_thm1]);
a (ALL_FC_T (MAP_EVERY ante_tac) [¯_less_trans_thm]
	THEN asm_rewrite_tac[]);
val ¯_square_eq_thm1 = save_pop_thm "¯_square_eq_thm1";
=TEX

=SML
set_goal([], ¬µx y:¯· î¯ 0 ¼‰R x ± î¯ 0 ¼‰R y ± y *‰R y = x *‰R x ´ x = y®);
a (rewrite_tac[get_spec ¬$¼‰R®]);
a (rewrite_tac (map eq_sym_conv [¬î¯ 0 = x®, ¬î¯ 0 = y®])
	THEN REPEAT strip_tac
	THEN TRY (asm_rewrite_tac[]));
(* *** Goal "1" *** *)
a (all_ufc_tac [¯_square_eq_thm1]);
(* *** Goal "2" *** *)
a (POP_ASM_T ante_tac THEN asm_rewrite_tac[¯_prod_sign_iff_clauses]);
(* *** Goal "3" *** *)
a (POP_ASM_T ante_tac
	THEN asm_rewrite_tac[¯_prod_sign_iff_clauses]
	THEN STRIP_T rewrite_thm_tac);
val ¯_square_eq_thm2 = save_pop_thm "¯_square_eq_thm2";
=TEX

=SML
set_goal([], ¬µ x y· î¯ 0 <‰R x ± î¯ 0 <‰R y ´ (x *‰R x = y *‰R y ¤ x = y)®);
a (REPEAT strip_tac
	THEN TRY (asm_rewrite_tac[]));
a (strip_asm_tac (all_µ_elim ¯_less_cases_thm)
	THEN (ALL_FC_T (MAP_EVERY ante_tac) [¯_square_mono_thm])
	THEN TRY (asm_rewrite_tac[]));
a (strip_asm_tac (list_µ_elim [¬y®, ¬x®] ¯_square_mono_thm)
	THEN POP_ASM_T ante_tac
	THEN TRY (asm_rewrite_tac[]));
val ¯_square_eq_eq_thm = save_pop_thm "¯_square_eq_eq_thm";
=TEX

=SML
set_goal([], ¬µ x y· î¯ 0 ¼‰R x ± î¯ 0 ¼‰R y ´ (x *‰R x = y *‰R y ¤ x = y)®);
a (rewrite_tac[get_spec ¬$¼‰R®]
	THEN REPEAT strip_tac
	THEN TRY (SYM_ASMS_T rewrite_tac));
(* *** Goal "1" *** *)
a (all_ufc_tac [¯_square_eq_eq_thm]);
(* *** Goal "2" *** *)
a (POP_ASM_T ante_tac
	THEN SYM_ASMS_T rewrite_tac
	THEN rewrite_tac [¯_prod_sign_iff_clauses]);
(* *** Goal "3" *** *)
a (POP_ASM_T ante_tac
	THEN SYM_ASMS_T rewrite_tac
	THEN rewrite_tac [¯_prod_sign_iff_clauses]
	THEN strip_tac
	THEN asm_rewrite_tac[]);
val ¯_square_eq_eq_thm2 = save_pop_thm "¯_square_eq_eq_thm2";
=TEX

=SML
set_goal([], ¬µ x y· î¯ 0 ¼‰R x ± î¯ 0 ¼‰R y ± x *‰R x ¼‰R y *‰R y ´ x ¼‰R y®);
a (REPEAT strip_tac);
a (strip_asm_tac (all_µ_elim ¯_less_cases_thm));
(* *** Goal "1" *** *)
a (asm_rewrite_tac[get_spec ¬$¼‰R®]);
(* *** Goal "2" *** *)
a (DROP_ASM_T ¬x *‰R x ¼‰R y *‰R y® ante_tac
	THEN asm_rewrite_tac[]);
(* *** Goal "3" *** *)
a (strip_asm_tac (list_µ_elim [¬y®, ¬x®] ¯_square_mono_thm1));
(* *** Goal "3.1" *** *)
a (POP_ASM_T ante_tac THEN asm_rewrite_tac[get_spec ¬$¼‰R®]);
(* *** Goal "3.2" *** *)
a (all_ufc_tac [pc_rule1 "¯_lin_arith"
	prove_rule [] ¬µx y:¯· x ¼‰R y ± y ¼‰R x ´ x = y®]);
a (all_ufc_tac [¯_square_eq_eq_thm2]);
a (all_var_elim_asm_tac);
val ¯_square_¼_¼_thm = save_pop_thm "¯_square_¼_¼_thm";
=TEX

=SML
set_goal([], ¬µ x y· x *‰R x = y *‰R y ¤ Abs x = Abs y®);
a (REPEAT µ_tac
	THEN rewrite_tac [get_spec ¬Abs‰R®]
	THEN cases_tac ¬î¯ 0 ¼‰R x®
	THEN cases_tac ¬î¯ 0 ¼‰R y®
	THEN TRY (asm_rewrite_tac[])
	);
(* *** Goal "1" *** *)
a (all_ufc_¤_rewrite_tac [¯_square_eq_eq_thm2]); 
(* *** Goal "2" *** *)
a (all_asm_ante_tac
	THEN lemma_tac ¬¶ z· y = ~‰R z®
	THEN1 (¶_tac ¬~‰R y®
		THEN rewrite_tac[])
	THEN asm_rewrite_tac [¯_times_minus_thm]
	THEN REPEAT strip_tac);
(* *** Goal "2.1" *** *)
a (lemma_tac ¬î¯ 0 ¼‰R z®
	THEN1 (PC_T1 "¯_lin_arith" asm_prove_tac []));
a (all_ufc_tac [¯_square_eq_eq_thm2]); 
(* *** Goal "2.2" *** *)
a (lemma_tac ¬î¯ 0 ¼‰R z®
	THEN1 (PC_T1 "¯_lin_arith" asm_prove_tac []));
a (asm_prove_tac [¯_square_eq_eq_thm2]);
(* *** Goal "3" *** *)
a (all_asm_ante_tac
	THEN lemma_tac ¬¶ z· x = ~‰R z®
	THEN1 (¶_tac ¬~‰R x®
		THEN rewrite_tac[])
	THEN asm_rewrite_tac [¯_times_minus_thm]);
a (strip_tac THEN strip_tac);
a (lemma_tac ¬î¯ 0 ¼‰R z®
	THEN1 (PC_T1 "¯_lin_arith" asm_prove_tac []));
a (all_ufc_¤_rewrite_tac [¯_square_eq_eq_thm2]); 
(* *** Goal "4" *** *)
a (all_asm_ante_tac
	THEN lemma_tac ¬¶ z· x = ~‰R z®
	THEN1 (¶_tac ¬~‰R x®
		THEN rewrite_tac[])
	THEN lemma_tac ¬¶ v· y = ~‰R v®
	THEN1 (¶_tac ¬~‰R y®
		THEN rewrite_tac[])
	THEN asm_rewrite_tac[]
	THEN strip_tac THEN strip_tac);
a (lemma_tac ¬î¯ 0 ¼‰R z®
	THEN1 (PC_T1 "¯_lin_arith" asm_prove_tac []));
a (lemma_tac ¬î¯ 0 ¼‰R v®
	THEN1 (PC_T1 "¯_lin_arith" asm_prove_tac []));
a (rewrite_tac [¯_times_minus_thm]);
a (all_ufc_¤_rewrite_tac [¯_square_eq_eq_thm2]);
val ¯_square_eq_iff_abs_eq_thm = save_pop_thm "¯_square_eq_iff_abs_eq_thm";
=TEX

=SML
set_goal([], ¬µx:¯· î¯ 0 ¼ x ^ 2®);
a (rewrite_tac [¯_î_exp_square_thm, ¯_prod_sign_iff_clauses]);
a (PC_T1 "¯_lin_arith" prove_tac[]);
val ¯_square_pos_thm = save_pop_thm "¯_square_pos_thm";
=TEX
}%ignore

\subsection{Sums}

\ignore{
=SML
set_goal([], ¬µx y:¯· î¯ 0 ¼ x ± î¯ 0 ¼ y ´ î¯ 0 ¼ x + y®);
a (PC_T1 "¯_lin_arith" prove_tac[]);
val ¯_sum_pos_thm = save_pop_thm "¯_sum_pos_thm";
=TEX

=SML
set_goal([], ¬µ x y:¯· î¯ 0 ¼ x ^‰N 2 +‰R y ^‰N 2®);
a (REPEAT µ_tac);
a (lemma_tac ¬î¯ 0 ¼ x ^ 2 ± î¯ 0 ¼ y ^ 2®
	THEN1 rewrite_tac [¯_square_pos_thm]);
a (all_ufc_tac [¯_sum_pos_thm]);
val ¯_sum_square_pos_thm = save_pop_thm "¯_sum_square_pos_thm";
=TEX

=SML
set_goal([], ¬µx y: ¯· x^2 + y^2 = î¯ 0 ¤ x = î¯ 0 ± y = î¯ 0®);
a (REPEAT_N 5 strip_tac THEN TRY (asm_rewrite_tac[]));
a (lemma_tac ¬î¯ 0 ¼ x ^ 2 ± î¯ 0 ¼ y ^ 2®
	THEN1 rewrite_tac [¯_square_pos_thm]);
a (ALL_FC_T (MAP_EVERY (asm_tac o (rewrite_rule [¯_î_exp_square_thm, ¯_prod_sign_iff_clauses])))
	[pc_rule1 "¯_lin_arith" prove_rule []
	¬µx y: ¯·î¯ 0 ¼ x ± î¯ 0 ¼ y ´ x + y = î¯ 0 ´ x = î¯ 0 ± y = î¯ 0®]
	THEN asm_rewrite_tac[]);
val ¯_sum_square_zero_thm = save_pop_thm "¯_sum_square_zero_thm";
=TEX

=SML
set_goal([], ¬µx y:¯· î¯ 0 ¼ x ± î¯ 0 ¼ y
	´ (x + y = î¯ 0 ¤ x = î¯ 0 ± y = î¯ 0)®);
a (PC_T1 "¯_lin_arith" prove_tac[]);
val ¯_sum_zero_thm = save_pop_thm "¯_sum_zero_thm";
=TEX

=SML
set_goal([], ¬µ x y:¯· Abs (x ^‰N 2 +‰R y ^‰N 2) = x ^‰N 2 +‰R y ^‰N 2®);
a (REPEAT µ_tac);
a (asm_rewrite_tac [get_spec ¬Abs‰R®, ¯_sum_square_pos_thm]);
val ¯_abs_sum_square_thm = save_pop_thm "¯_abs_sum_square_thm";
=TEX


=SML
val ¯_plus_mono_thm = save_thm ("¯_plus_mono_thm", pc_rule1 "¯_lin_arith" prove_rule []
	¬µu v x y· u ¼‰R v ± x ¼‰R y ´ u +‰R x ¼‰R v +‰R y®);
=TEX
}%ignore

\subsection{Abs}

The following arithmetic results are obtained for reasoning about norms on real vector spaces, in particular to prove that $Abs$ is a norm over the reals and that the defined product operation over norms yields a norm.

=GFT
¯_Abs_Norm_clauses 
ô (µ v· î¯ 0 ¼‰R Abs‰R v)
± (µ v· (Abs‰R v = î¯ 0) ¤ v = î¯ 0)
± (µ x v· Abs‰R (x *‰R v) = Abs‰R x *‰R Abs‰R v)
± (µ v w· Abs‰R (v +‰R w) ¼‰R Abs‰R v +‰R Abs‰R w)
=TEX

\ignore{
=SML
set_goal([], ¬(µ v· î¯ 0 ¼‰R Abs‰R v)
             ± (µ v· (Abs‰R v = î¯ 0) = v = î¯ 0)
             ± (µ x v· Abs‰R (x *‰R v) = Abs‰R x *‰R Abs‰R v)
             ± (µ v w· Abs‰R (v +‰R w) ¼‰R Abs‰R v +‰R Abs‰R w)®);
a (rewrite_tac [get_spec ¬Abs‰R®, get_spec ¬$¼‰R®, ¯_prod_sign_iff_clauses]);
a (REPEAT ±_tac THEN REPEAT µ_tac);
(* *** Goal "1" *** *)
a (CASES_T ¬î¯ 0 < v ² î¯ 0 = v® asm_tac
	THEN TRY (asm_rewrite_tac[]));
a (PC_T1 "¯_lin_arith" asm_prove_tac[]);
(* *** Goal "2" *** *)
a (CASES_T ¬î¯ 0 < v ² î¯ 0 = v® asm_tac
	THEN TRY (asm_rewrite_tac[])
	THEN TRY (PC_T1 "¯_lin_arith" asm_prove_tac[]));
(* *** Goal "3" *** *)
a (strip_asm_tac (list_µ_elim [¬x®, ¬î¯ 0®] ¯_less_cases_thm)
	THEN asm_rewrite_tac[]
	THEN (strip_asm_tac (list_µ_elim [¬v®, ¬î¯ 0®] ¯_less_cases_thm))
	THEN asm_rewrite_tac[]);
(* *** Goal "3.1" *** *)
a (LEMMA_T ¬³(î¯ 0 < x ² î¯ 0 = x)® asm_tac
	THEN1 PC_T1 "¯_lin_arith" asm_prove_tac[]);
a (LEMMA_T ¬³(î¯ 0 < v ² î¯ 0 = v)® asm_tac
	THEN1 PC_T1 "¯_lin_arith" asm_prove_tac[]);
a (asm_rewrite_tac[¯_times_minus_thm]);
(* *** Goal "3.2" *** *)
a (LEMMA_T ¬³(î¯ 0 < x ² î¯ 0 = x)® asm_tac
	THEN1 PC_T1 "¯_lin_arith" asm_prove_tac[]);
a (LEMMA_T ¬³(v < î¯ 0 ² x = î¯ 0 ² v = î¯ 0)® asm_tac
	THEN1 PC_T1 "¯_lin_arith" asm_prove_tac[]);
a (asm_rewrite_tac[¯_times_minus_thm]);
(* *** Goal "3.3" *** *)
a (LEMMA_T ¬³(î¯ 0 < v ² î¯ 0 = v)® asm_tac
	THEN1 PC_T1 "¯_lin_arith" asm_prove_tac[]);
a (asm_rewrite_tac[¯_times_minus_thm]);
a (LEMMA_T ¬³(x < î¯ 0 ² x = î¯ 0 ² v = î¯ 0)® asm_tac
	THEN1 PC_T1 "¯_lin_arith" asm_prove_tac[]);
a (asm_rewrite_tac[¯_times_minus_thm]);
(* *** Goal "4" *** *)
a (strip_asm_tac (list_µ_elim [¬w®, ¬î¯ 0®] ¯_less_cases_thm)
	THEN TRY (asm_rewrite_tac[])
	THEN (strip_asm_tac (list_µ_elim [¬v®, ¬î¯ 0®] ¯_less_cases_thm))
	THEN TRY (asm_rewrite_tac[]));
(* *** Goal "4.1" *** *)
a (LEMMA_T ¬³(î¯ 0 <‰R v ² î¯ 0 = v)® rewrite_thm_tac
	THEN1 PC_T1 "¯_lin_arith" asm_prove_tac[]);
a (LEMMA_T ¬³(î¯ 0 <‰R w ² î¯ 0 = w)® rewrite_thm_tac
	THEN1 PC_T1 "¯_lin_arith" asm_prove_tac[]);
a (LEMMA_T ¬³(î¯ 0 <‰R v +‰R w ² î¯ 0 = v +‰R w)® rewrite_thm_tac
	THEN1 PC_T1 "¯_lin_arith" asm_prove_tac[]);
(* *** Goal "4.2" *** *)
a (LEMMA_T ¬³(î¯ 0 <‰R w ² î¯ 0 = w)® rewrite_thm_tac
	THEN1 PC_T1 "¯_lin_arith" asm_prove_tac[]);
a (CASES_T ¬î¯ 0 <‰R v +‰R w ² î¯ 0 = v +‰R w® rewrite_thm_tac
	THEN TRY (PC_T1 "¯_lin_arith" asm_prove_tac[]));
(* *** Goal "4.3" *** *)
a (LEMMA_T ¬³(î¯ 0 <‰R v ² î¯ 0 = v)® rewrite_thm_tac
	THEN1 PC_T1 "¯_lin_arith" asm_prove_tac[]);
a (CASES_T ¬î¯ 0 <‰R v +‰R w ² î¯ 0 = v +‰R w® rewrite_thm_tac
	THEN TRY (PC_T1 "¯_lin_arith" asm_prove_tac[]));
(* *** Goal "4.4" *** *)
a (CASES_T ¬î¯ 0 <‰R v +‰R w ² î¯ 0 = v +‰R w® rewrite_thm_tac
	THEN TRY (PC_T1 "¯_lin_arith" asm_prove_tac[]));
val ¯_Abs_Norm_clauses = save_pop_thm "¯_Abs_Norm_clauses";
=TEX

=SML
set_goal([], ¬µx:¯· x ¼‰R Abs x®);
a (REPEAT strip_tac
	THEN rewrite_tac [get_spec ¬Abs‰R®]
	THEN cases_tac ¬î¯ 0 ¼‰R x®
	THEN asm_rewrite_tac[]
	THEN PC_T1 "¯_lin_arith" asm_prove_tac[]);
val ¯_¼_abs_thm = save_pop_thm "¯_¼_abs_thm";
=TEX

=SML
set_goal([], ¬µx:¯· î¯ 0 ¼‰R x ´ Abs x = x®);
a (REPEAT strip_tac
	THEN rewrite_tac [get_spec ¬Abs‰R®]
	THEN asm_rewrite_tac []);
val ¯_abs_pos_id_thm = save_pop_thm "¯_abs_pos_id_thm";
=TEX

=SML
set_goal([], ¬µx y:¯· î¯ 0 ¼‰R x ± x ¼‰R y ´ Abs x ¼‰R Abs y®);
a (REPEAT strip_tac
	THEN rewrite_tac [get_spec ¬Abs‰R®]
	THEN cases_tac ¬î¯ 0 ¼‰R x®
	THEN cases_tac ¬î¯ 0 ¼‰R y®
	THEN asm_rewrite_tac[]
	THEN PC_T1 "¯_lin_arith" asm_prove_tac[]);
val ¯_abs_mono_thm = save_pop_thm "¯_abs_mono_thm";
=TEX

=SML
set_goal([], ¬µx y:¯· x ^ 2 = y ^ 2 ´ Abs x = Abs y®);
a (rewrite_tac [¯_î_exp_square_thm, get_spec ¬Abs‰R®]
	THEN REPEAT strip_tac);
a (cases_tac ¬î¯ 0 ¼‰R x®
	THEN asm_rewrite_tac[]);
(* *** Goal "1" *** *)
a (cases_tac ¬î¯ 0 ¼‰R y®
	THEN asm_rewrite_tac[]);
(* *** Goal "1.1" *** *)
a (all_asm_ufc_tac [¯_square_eq_thm2] THEN asm_rewrite_tac[]);
(* *** Goal "1.2" *** *)
a (all_asm_ante_tac);
a (lemma_tac ¬¶z· y = ~‰R z®
	THEN1 (¶_tac ¬~‰R y® THEN rewrite_tac[])
	THEN asm_rewrite_tac[¯_times_minus_thm]
	THEN REPEAT strip_tac);
a (lemma_tac ¬î¯ 0 ¼‰R z®
	THEN1 (PC_T1 "¯_lin_arith" asm_prove_tac[]));
a (all_ufc_tac [¯_square_eq_thm2]
	THEN asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a (all_asm_ante_tac);
a (lemma_tac ¬¶z· x = ~‰R z®
	THEN1 (¶_tac ¬~‰R x® THEN rewrite_tac[])
	THEN asm_rewrite_tac[¯_times_minus_thm]
	THEN REPEAT strip_tac);
a (lemma_tac ¬î¯ 0 ¼‰R z®
	THEN1 (PC_T1 "¯_lin_arith" asm_prove_tac[]));
a (cases_tac ¬î¯ 0 ¼‰R y®
	THEN asm_rewrite_tac[]);
(* *** Goal "2.1" *** *)
a (all_asm_ufc_tac [¯_square_eq_thm2] THEN asm_rewrite_tac[]);
(* *** Goal "2.2" *** *)
a (all_asm_ante_tac);
a (lemma_tac ¬¶v· y = ~‰R v®
	THEN1 (¶_tac ¬~‰R y® THEN rewrite_tac[])
	THEN asm_rewrite_tac[¯_times_minus_thm]
	THEN REPEAT strip_tac);
a (lemma_tac ¬î¯ 0 ¼‰R v®
	THEN1 (PC_T1 "¯_lin_arith" asm_prove_tac[]));
a (all_asm_ufc_tac [¯_square_eq_thm2] THEN asm_rewrite_tac[]);
val ¯_square_eq_abs_thm = pop_thm ();
=TEX

=SML
set_goal([], ¬µx y:¯· Abs x = Abs y ´ x ^ 2 = y ^ 2®);
a (REPEAT µ_tac
	THEN rewrite_tac [get_spec ¬Abs‰R®]
	THEN cases_tac ¬î¯ 0 ¼‰R x®
	THEN cases_tac ¬î¯ 0 ¼‰R y®
	THEN asm_rewrite_tac[]
	THEN strip_tac
	THEN TRY (asm_rewrite_tac[¯_î_exp_square_thm, ¯_times_minus_thm]));
(* *** Goal "1" *** *)
a (POP_ASM_T (rewrite_thm_tac o eq_sym_rule));
a (asm_rewrite_tac[¯_times_minus_thm]);
(* *** Goal "2" *** *)
a (LEMMA_T ¬~‰R (~‰R x) = ~‰R (~‰R y)® (asm_tac o (rewrite_rule[]))
	THEN1 (pure_asm_rewrite_tac[]
		THEN rewrite_tac[])
	THEN asm_rewrite_tac[]);
val ¯_abs_eq_square_thm = pop_thm ();
=TEX

=SML
set_goal([], ¬µx y:¯· x ^ 2 = y ^ 2 ¤ Abs x = Abs y®);
a (REPEAT strip_tac
	THEN all_ufc_tac [¯_square_eq_abs_thm, ¯_abs_eq_square_thm]
	THEN asm_rewrite_tac[]);
val ¯_square_eq_abs_thm = save_pop_thm "¯_square_eq_abs_thm";
=TEX

=SML
set_goal([], ¬µx:¯· Abs (x *‰R x) = x *‰R x®);
a (REPEAT strip_tac
	THEN rewrite_tac [get_spec ¬Abs‰R®]);
a (LEMMA_T ¬î¯ 0 ¼‰R x *‰R x® rewrite_thm_tac
	THEN1 (rewrite_tac [¯_prod_sign_iff_clauses]
		THEN PC_T1 "¯_lin_arith" prove_tac[]));
val ¯_abs_square_thm1 = save_pop_thm "¯_abs_square_thm1";
=TEX

=SML
set_goal([], ¬µ x y· x *‰R x ¼‰R y *‰R y ´ Abs x ¼‰R Abs y®);
a (REPEAT strip_tac
	THEN bc_tac [¯_square_¼_¼_thm]
	THEN TRY (rewrite_tac [¯_Abs_Norm_clauses]));
a (asm_rewrite_tac [map_eq_sym_rule ¯_Abs_Norm_clauses,
	¯_abs_square_thm1]);
val ¯_square_¼_abs_¼_thm = save_pop_thm "¯_square_¼_abs_¼_thm";
=TEX

=SML
set_goal([], ¬µ x y· Abs x ¼‰R Abs y ´ x *‰R x ¼‰R y *‰R y®);
a (REPEAT strip_tac);
a (lemma_tac ¬î¯ 0 ¼‰R Abs x®
	THEN1 rewrite_tac [¯_Abs_Norm_clauses]);
a (ALL_FC_T (MAP_EVERY ante_tac) [¯_square_mono_thm1]);
a (rewrite_tac [map_eq_sym_rule ¯_Abs_Norm_clauses,
	¯_abs_square_thm1]);
val ¯_abs_¼_square_¼_thm = save_pop_thm "¯_abs_¼_square_¼_thm";
=TEX

=SML
set_goal([], ¬µ x y· x *‰R x ¼‰R y *‰R y ¤ Abs x ¼‰R Abs y®);
a (REPEAT µ_tac THEN strip_tac
	THEN rewrite_tac [¯_abs_¼_square_¼_thm, ¯_square_¼_abs_¼_thm]);
val ¯_square_¼_iff_abs_¼_thm = save_pop_thm "¯_square_¼_iff_abs_¼_thm";
=TEX

=SML
set_goal([], ¬µ x y· x *‰R x <‰R y *‰R y ¤ Abs x <‰R Abs y®);
a (REPEAT strip_tac);
(* *** Goal "1" *** *)
a (lemma_tac ¬Abs‰R x ¼‰R Abs‰R y®);
(* *** Goal "1.1" *** *)
a (lemma_tac ¬x *‰R x ¼‰R y *‰R y®
	THEN1 asm_rewrite_tac [get_spec ¬$¼‰R®]);
a (bc_tac [¯_square_¼_iff_abs_¼_thm] THEN strip_tac);
(* *** Goal "1.2" *** *)
a (POP_ASM_T ante_tac
	THEN rewrite_tac [get_spec ¬$¼‰R®]
	THEN REPEAT strip_tac);
a (DROP_NTH_ASM_T 2 ante_tac
	THEN LEMMA_T ¬x *‰R x = y *‰R y® rewrite_thm_tac
	THEN1 asm_rewrite_tac [¯_square_eq_iff_abs_eq_thm]);
(* *** Goal "2" *** *)
a (lemma_tac ¬x *‰R x ¼‰R y *‰R y®);
a (lemma_tac ¬Abs x ¼‰R Abs y®
	THEN1 asm_rewrite_tac [get_spec ¬$¼‰R®]);
a (bc_tac [¯_abs_¼_square_¼_thm] THEN strip_tac);
(* *** Goal "2.2" *** *)
a (POP_ASM_T ante_tac
	THEN rewrite_tac [get_spec ¬$¼‰R®]
	THEN REPEAT strip_tac);
a (DROP_NTH_ASM_T 2 ante_tac
	THEN LEMMA_T ¬Abs x = Abs y® rewrite_thm_tac
	THEN1 asm_rewrite_tac [map_eq_sym_rule ¯_square_eq_iff_abs_eq_thm]);
val ¯_square_less_iff_abs_less_thm = save_pop_thm "¯_square_less_iff_abs_less_thm";
=TEX

=SML
set_goal([], ¬µx:¯· Abs (x ^‰N 2) = x ^‰N 2®);
a (rewrite_tac [¯_î_exp_square_thm, ¯_abs_square_thm1]);
val ¯_abs_square_thm2 = save_pop_thm "¯_abs_square_thm2";
=TEX

=SML
set_goal([], ¬µx y:¯· Abs (x *‰R y) = (Abs x) *‰R (Abs y)®);
a (REPEAT strip_tac
	THEN rewrite_tac [get_spec ¬Abs‰R®]);
a (cases_tac ¬î¯ 0 ¼‰R x® THEN cases_tac ¬î¯ 0 ¼‰R y®
	THEN TRY (asm_rewrite_tac[]));
(* *** Goal "1" *** *)
a (lemma_tac ¬î¯ 0 ¼‰R x *‰R y®
	THEN1 (rewrite_tac [¯_prod_sign_iff_clauses]
		THEN contr_tac)
	THEN asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a (cases_tac ¬x = î¯ 0® THEN TRY (asm_rewrite_tac[]));
a (lemma_tac ¬³ î¯ 0 ¼‰R x *‰R y®
	THEN1 (rewrite_tac [¯_prod_sign_iff_clauses]
		THEN REPEAT strip_tac
		THEN TRY (PC_T1 "¯_lin_arith" asm_prove_tac[]))
	THEN asm_rewrite_tac[¯_times_minus_thm]);
(* *** Goal "3" *** *)
a (cases_tac ¬y = î¯ 0® THEN TRY (asm_rewrite_tac[]));
a (lemma_tac ¬³ î¯ 0 ¼‰R x *‰R y®
	THEN1 (rewrite_tac [¯_prod_sign_iff_clauses]
		THEN REPEAT strip_tac
		THEN TRY (PC_T1 "¯_lin_arith" asm_prove_tac[]))
	THEN asm_rewrite_tac[¯_times_minus_thm]);
(* *** Goal "4" *** *)
a (lemma_tac ¬î¯ 0 ¼‰R x *‰R y®
	THEN1 (rewrite_tac [¯_prod_sign_iff_clauses]
		THEN (PC_T1 "¯_lin_arith" asm_prove_tac[]))
	THEN asm_rewrite_tac[¯_times_minus_thm]);
val ¯_abs_prod_thm = save_pop_thm "¯_abs_prod_thm";
=TEX

}%ignore

\subsection{Square Root}

\ignore{
=SML
push_goal ([], ¬¶SqrtA· µ x· î¯ 0 ¼ SqrtA x ± (SqrtA x)^2 = Abs x®);
a(prove_¶_tac THEN strip_tac);
a (lemma_tac ¬î¯ 0 ¼ Abs x'®
	THEN1 (rewrite_tac [¯_0_¼_abs_thm]));
a (all_ufc_tac [square_root_thm1]);
a(¶_tac ¬y® THEN asm_rewrite_tac[]);
val _ = save_cs_¶_thm (pop_thm());
=TEX
}%\ignore

¹HOLCONST
Ü ÛSqrtAİ :¯ ­ ¯
÷üüüüüü
Ü µ x· î¯ 0 ¼ SqrtA x 
Ü ± (SqrtA x)^2 = Abs x
°

\ignore{

=SML
set_goal([], ¬µx y:¯· SqrtA x = SqrtA y ´ Abs x = Abs y®);
a (REPEAT strip_tac);
a (LEMMA_T ¬(SqrtA x) ^‰N 2 = (SqrtA y) ^‰N 2® ante_tac
	THEN1 asm_rewrite_tac[]);
a (rewrite_tac [get_spec ¬SqrtA®]);
val ¯_sqrt_abs_thm1 = pop_thm ();
=TEX

=SML
set_goal([], ¬µx:¯· SqrtA x = î¯ 0 ¤ x = î¯ 0®);
a (REPEAT strip_tac THEN TRY (asm_rewrite_tac[]));
a (contr_tac THEN lemma_tac ¬î¯ 0 <‰R SqrtA x ^‰N 2®
	THEN1 rewrite_tac[get_spec ¬SqrtA®,
	get_spec ¬Abs‰R®,
	get_spec ¬$¼‰R®]);
(* *** Goal "1.1" *** *)
a (cases_tac ¬î¯ 0 <‰R x ² î¯ 0 = x®
	THEN asm_rewrite_tac[]
	THEN PC_T1 "¯_lin_arith" asm_prove_tac[]);
(* *** Goal "1.2" *** *)
a (POP_ASM_T ante_tac
	THEN asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a (strip_asm_tac (rewrite_rule [¯_î_exp_square_thm, ¯_prod_sign_iff_clauses]
	(µ_elim ¬î¯ 0® (get_spec ¬SqrtA®))));
val sqrt_thm1 = save_pop_thm "sqrt_thm1";
=TEX

=SML
set_goal([], ¬µx y:¯· SqrtA (x ^ 2 + y ^ 2) = î¯ 0 ¤ x = î¯ 0 ± y = î¯ 0®);
a (REPEAT µ_tac THEN rewrite_tac [sqrt_thm1]);
a (lemma_tac ¬î¯ 0 ¼ x ^ 2 ± î¯ 0 ¼ y ^ 2®
	THEN1 (rewrite_tac [¯_square_pos_thm]));
a (lemma_tac ¬î¯ 0 ¼ x ^ 2 + y ^ 2®
	THEN1 (all_ufc_tac [¯_sum_pos_thm]));
a (LEMMA_T ¬(x ^‰N 2 + y ^‰N 2 = î¯ 0)
		= (x ^‰N 2 = î¯ 0 ± y ^‰N 2 = î¯ 0)®
	rewrite_thm_tac
	THEN1 (ALL_FC_T1 fc_¤_canon rewrite_tac [¯_sum_zero_thm]));
a (rewrite_tac[¯_î_exp_square_thm, ¯_prod_sign_iff_clauses]);
val sqrt_square_thm = save_pop_thm "sqrt_square_thm";
=TEX
}%\ignore

\ignore{

=SML
set_goal([], ¬µx:¯· Abs(SqrtA x) = SqrtA x
	± Abs (Abs x) = Abs x
	± Abs (î¯ 0) = î¯ 0
	± Abs (~‰R  x) = Abs x®);
a (REPEAT strip_tac
	THEN TRY (rewrite_tac [get_spec ¬Abs‰R®, get_spec ¬SqrtA®]));
(* *** Goal "1" *** *)
a (cases_tac ¬î¯ 0 ¼‰R x®
	THEN asm_rewrite_tac[]);
a (lemma_tac ¬î¯ 0 ¼‰R ~‰R x®
	THEN1 (PC_T1 "¯_lin_arith" asm_prove_tac[]));
a (asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a (rewrite_tac [get_spec ¬$¼‰R®]);
a (strip_asm_tac (list_µ_elim [¬î¯ 0®, ¬x®] ¯_less_cases_thm)
	THEN TRY (asm_rewrite_tac[]));
(* *** Goal "2.1" *** *)
a (LEMMA_T ¬³ (î¯ 0 <‰R ~‰R x ² î¯ 0 = ~‰R x)® rewrite_thm_tac
	THEN1 (PC_T1 "¯_lin_arith" asm_prove_tac[]));
(* *** Goal "2.2" *** *)
a (LEMMA_T ¬x = î¯ 0® rewrite_thm_tac
	THEN1 (PC_T1 "¯_lin_arith" asm_prove_tac[]));
(* *** Goal "2.3" *** *)
a (LEMMA_T ¬î¯ 0 <‰R ~‰R x® rewrite_thm_tac
	THEN1 (PC_T1 "¯_lin_arith" asm_prove_tac[]));
a (LEMMA_T ¬³ (î¯ 0 <‰R x ² î¯ 0 = x)® rewrite_thm_tac
	THEN1 (PC_T1 "¯_lin_arith" asm_prove_tac[]));
val ¯_abs_clauses1 = pop_thm ();
=TEX

=SML
set_goal([], ¬µx:¯· SqrtA (~‰R x) = SqrtA x®);
a (strip_tac);
a (lemma_tac ¬SqrtA (~‰R x) ^‰N 2 = Abs‰R x®
	THEN1 (strip_asm_tac (µ_elim ¬~‰R x® (get_spec ¬SqrtA®))
		THEN asm_rewrite_tac[¯_abs_clauses1]));
a (lemma_tac ¬(SqrtA x) ^‰N 2 = Abs‰R x®
	THEN1 (strip_asm_tac (µ_elim ¬x® (get_spec ¬SqrtA®))
		THEN asm_rewrite_tac[¯_abs_clauses1]));
a (lemma_tac ¬SqrtA (~‰R x) ^‰N 2 = SqrtA x ^‰N 2®
	THEN1 asm_rewrite_tac[]);
a (ALL_FC_T (MAP_EVERY ante_tac) [¯_square_eq_abs_thm]
	THEN rewrite_tac [¯_abs_clauses1]
	THEN strip_tac);
val ¯_sqrt_minus_thm = save_pop_thm "¯_sqrt_minus_thm";
=TEX

=SML
set_goal([], ¬µx:¯· SqrtA(Abs x) = SqrtA x®);
a (REPEAT strip_tac
	THEN TRY (rewrite_tac [get_spec ¬Abs‰R®, get_spec ¬SqrtA®]));
a (cases_tac ¬î¯ 0 ¼‰R x®
	THEN asm_rewrite_tac[¯_sqrt_minus_thm]);
val ¯_sqrt_abs_thm = pop_thm ();
=TEX

=SML
set_goal([], ¬µx:¯· SqrtA(Abs x) = SqrtA x
	± Abs(SqrtA x) = SqrtA x
	± Abs (Abs x) = Abs x
	± Abs (î¯ 0) = î¯ 0
	± Abs (~‰R  x) = Abs x®);
a (rewrite_tac[¯_abs_clauses1, ¯_sqrt_abs_thm]);
val ¯_abs_clauses = save_pop_thm "¯_abs_clauses";
=TEX

=SML
set_goal([], ¬µx y:¯· Abs x = Abs y ´ SqrtA x = SqrtA y®);
a (REPEAT µ_tac THEN rewrite_tac [get_spec ¬Abs‰R®]);
a (cases_tac ¬î¯ 0 ¼‰R x®
	THEN asm_rewrite_tac[]);
(* *** Goal "1" *** *)
a (cases_tac ¬î¯ 0 ¼‰R y®
	THEN REPEAT strip_tac
	THEN asm_rewrite_tac[¯_sqrt_minus_thm]);
(* *** Goal "2" *** *)
a (cases_tac ¬î¯ 0 ¼‰R y®
	THEN (asm_rewrite_tac[])
	THEN REPEAT strip_tac
	THEN TRY (asm_rewrite_tac[¯_sqrt_minus_thm]));
(* *** Goal "2.1" *** *)
a (LEMMA_T ¬y = ~‰R x® rewrite_thm_tac
	THEN1 asm_rewrite_tac[]);
a (rewrite_tac[¯_sqrt_minus_thm]);
(* *** Goal "2.2" *** *)
a (LEMMA_T ¬x = y® rewrite_thm_tac
	THEN1 (PC_T1 "¯_lin_arith" asm_prove_tac[]));
val ¯_sqrt_abs_thm2 = pop_thm ();
=TEX

=SML
set_goal([], ¬µx y:¯· SqrtA x = SqrtA y ¤ Abs x = Abs y®);
a (REPEAT strip_tac THEN all_ufc_tac [¯_sqrt_abs_thm1, ¯_sqrt_abs_thm2]);
val ¯_sqrt_abs_thm = save_pop_thm "¯_sqrt_abs_thm";
=TEX

=SML
set_goal([], ¬µx y:¯· î¯ 0 ¼‰R x ± x ¼‰R y ´ SqrtA x ¼‰R SqrtA y®);
a (REPEAT strip_tac
	THEN bc_tac [¯_square_¼_¼_thm]
	THEN TRY (rewrite_tac [rewrite_rule [¯_î_exp_square_thm] (get_spec ¬SqrtA®)])
	THEN all_ufc_tac [¯_abs_mono_thm]);
val ¯_sqrt_mono_thm = save_pop_thm "¯_sqrt_mono_thm";
=TEX

=SML
set_goal([], ¬µx:¯· SqrtA (x * x) = Abs x®);
a (strip_tac
	THEN lemma_tac ¬SqrtA (x *‰R x) ^‰N 2 = (Abs‰R x) ^‰N 2®
	THEN1 (rewrite_tac [rewrite_conv [¯_î_exp_square_thm] ¬(Abs‰R x) ^‰N 2®,
		get_spec ¬SqrtA®, get_spec ¬Abs‰R®, ¯_abs_square_thm1]
		THEN cases_tac ¬î¯ 0 ¼‰R x®
		THEN asm_rewrite_tac[¯_times_minus_thm]));
a (ALL_ASM_FC_T
	(MAP_EVERY (strip_asm_tac o (rewrite_rule [¯_abs_clauses1])))
	[¯_square_eq_abs_thm]);
val ¯_sqrt_square_thm1 = save_pop_thm "¯_sqrt_square_thm1";
=TEX

=SML
set_goal([], ¬µx:¯· SqrtA (x ^ 2) = Abs x®);
a (REPEAT strip_tac
	THEN rewrite_tac [¯_sqrt_square_thm1, ¯_î_exp_square_thm]);
val ¯_sqrt_square_thm2 = save_pop_thm "¯_sqrt_square_thm2";
=TEX

=SML
set_goal([], ¬µx y:¯· SqrtA (x * y) = SqrtA x * SqrtA y®);
a (REPEAT strip_tac
	THEN lemma_tac ¬(SqrtA x *‰R SqrtA y) *‰R (SqrtA x *‰R SqrtA y)
	 = (SqrtA x *‰R SqrtA x) *‰R (SqrtA y *‰R SqrtA y)®
	THEN1 rewrite_tac [µ_elim ¬SqrtA x® ¯_times_order_thm]);
a (lemma_tac ¬SqrtA x *‰R SqrtA x = Abs‰R x®
	THEN1 (rewrite_tac [rewrite_rule [¯_î_exp_square_thm]
			(µ_elim ¬x® (get_spec ¬SqrtA®))]));
a (lemma_tac ¬SqrtA y *‰R SqrtA y = Abs‰R y®
	THEN1 (rewrite_tac [rewrite_rule [¯_î_exp_square_thm]
			(µ_elim ¬y® (get_spec ¬SqrtA®))]));
a (DROP_NTH_ASM_T 3 ante_tac);
a (once_asm_rewrite_tac[]);
a (rewrite_tac[eq_sym_rule(rewrite_rule [¯_Abs_Norm_clauses, ¯_î_exp_square_thm]
	((±_right_elim o (µ_elim ¬x *‰R y®)) (get_spec ¬SqrtA®))),
	rewrite_rule [¯_î_exp_square_thm] ¯_square_eq_abs_thm,
	¯_abs_clauses]);
a (once_rewrite_tac [eq_sym_conv ¬Abs‰R (SqrtA x *‰R SqrtA y) = SqrtA (x *‰R y)®]
	THEN STRIP_T rewrite_thm_tac);
a (rewrite_tac [¯_abs_clauses, ¯_Abs_Norm_clauses]);
val ¯_sqrt_prod_thm = save_pop_thm "¯_sqrt_prod_thm";
=TEX

=SML
set_goal([], ¬µx y:¯· SqrtA(x + y) ¼ (SqrtA x) +‰R (SqrtA y)®);
a (REPEAT strip_tac);
a (LEMMA_T ¬SqrtA(x + y) = Abs (SqrtA(x + y))
	± (SqrtA x) +‰R (SqrtA y) = Abs((SqrtA x) +‰R (SqrtA y))®
	once_rewrite_thm_tac);
(* *** Goal "1" *** *)
a (lemma_tac ¬î¯ 0 ¼‰R SqrtA (x +‰R y) ± î¯ 0 ¼‰R SqrtA x +‰R SqrtA y®
	THEN1 (rewrite_tac [get_spec ¬SqrtA®]
		THEN bc_tac [¯_sum_pos_thm]
		THEN rewrite_tac [get_spec ¬SqrtA®])
	THEN ALL_FC_T rewrite_tac [¯_abs_pos_id_thm]);
(* *** Goal "2" *** *)
a (bc_tac [¯_square_¼_abs_¼_thm]);
a (rewrite_tac[rewrite_rule [¯_î_exp_square_thm] (get_spec ¬SqrtA®),
	¯_times_plus_distrib_thm]);
a (¯_top_anf_tac);
a (lemma_tac ¬Abs‰R (x +‰R y) ¼‰R (Abs‰R x) +‰R (Abs‰R y)®
	THEN1 rewrite_tac [¯_Abs_Norm_clauses]);
a (LEMMA_T ¬(Abs‰R x) +‰R (Abs‰R y) ¼‰R Abs‰R x +‰R Abs‰R y +‰R î¯ 2 *‰R SqrtA x *‰R SqrtA y®
	asm_tac
	THEN1 rewrite_tac [¯_prod_sign_iff_clauses, get_spec ¬SqrtA®]);
a (all_ufc_tac [¯_¼_trans_thm]);
val sqrt_plus_thm = save_pop_thm "sqrt_plus_thm"; 
=TEX

}%ignore

\subsection{Sums of Countable Collections of Reals}

In evaluating the cosmological consequences of Newton's Laws it is desirable to formulate them as cosmological theories in ways which do not prejudge such questions as whether the cardinality of the universe is finite.
To do this it is necessary to be able, where possible, to form the sum of an infinite set of reals, possibly even an uncountably infinite set of real numbers.

For the most general formulations it seems possible that the use of non-standard reals might be needed.
We are concerned here with what can be done with standard reals, i.e. with formalising the notion that some collection of real numbers has a finite sum.

The following definition gives the sum of a possibly finite or countable collection of real numbers.

=SML
declare_infix (300, ">");
=TEX
¹HOLCONST
Ü $Û>İ : ('a ­ ¯ + ONE) ­ ¯ ­ BOOL
÷üüüüüü
Ü µc r· c > r ¤
Ü	¶s· (µ a n m· IsL (c a) ´ s n = s m ´ n = m)
Ü	´ (Series (Ìn· if IsR (c (s n)) then 0‰R else OutL (c (s n)))) -> r
°

\section{Group Theory}

=SML
new_parent "group_egs";
=TEX

\subsection{Group Products}

¹HOLCONST
Ü ÛGroupProductİ : 'a GROUP ­ 'b GROUP ­ ('a ¸ 'b) GROUP
÷üüüüüü
Ü µ G H· GroupProduct G H =
Ü	let car = (Car G ¸ Car H)
Ü	and prod	(la, lb) (ra, rb) = ((la.ra) G, (lb.rb) H)
Ü	and unit = (Unit G, Unit H)
Ü	and inv (a, b) = ((a ›~) G, (b ›~) H)
Ü	in MkGROUP car prod unit inv
°
=SML
declare_alias ("*", ¬GroupProduct®);
=TEX
\ignore{
=SML
val Ûgroup_defİ = get_spec¬Group®;
val Ûgroup_unit_defİ = get_spec¬Unit®;
val Ûgp_defİ = get_spec¬GroupProduct®;
=TEX
=SML
set_goal([], ¬µg:'a GROUP; h:'b GROUP·
	g  Group ± h  Group ´ g * h  Group®);
a(rewrite_tac [get_spec ¬Group®,
	gp_def,
	group_unit_def,
	get_spec ¬$¸®,
	let_def]
	THEN REPEAT strip_tac
	THEN TRY (all_asm_fc_tac[])); (* ufc takes twice as long *)
val Ûgroup_product_thmİ = save_pop_thm "group_product_thm";
=TEX
}%ignore

=GFT
group_product_thm = ô µg:'a GROUP; h:'b GROUP·
	g  Group ± h  Group ´ g * h  Group
=TEX

\subsection{Abelian Groups}

¹HOLCONST
Ü ÛAbelianGroupİ : 'a GROUP SET
÷üüüüüü
Ü µ G· G  AbelianGroup ¤ G  Group
Ü	± µ u v:'a· u  Car G ± v  Car G
Ü	         ´ (u.v) G = (v.u) G
°

\ignore{
=SML
val Ûabelian_group_defİ = get_spec¬AbelianGroup®;
set_goal([], ¬µg:'a GROUP; h:'b GROUP·
	g  AbelianGroup ± h  AbelianGroup ±
	Car g = Universe ± Car h = Universe
	´ Car (g * h) = Universe®);
a(rewrite_tac [abelian_group_def,
	group_def,
	gp_def,
	group_unit_def,
	get_spec ¬$¸®,
	let_def]
	THEN REPEAT strip_tac
	THEN TRY (asm_rewrite_tac[sets_ext_clauses]));
val Ûabelian_group_product_lemmaİ = save_pop_thm "abelian_group_product_lemma";
=TEX

=SML
set_goal([], ¬µg:'a GROUP; h:'b GROUP·
	g  AbelianGroup ± h  AbelianGroup 
	´ (g * h)  AbelianGroup®);
a (rewrite_tac [abelian_group_def]);
a (REPEAT strip_tac);
a (all_asm_ufc_tac[group_product_thm]);
a (REPEAT_N 2 (POP_ASM_T ante_tac));
a (asm_rewrite_tac [
	gp_def,
	let_def,
	group_unit_def,
	get_spec ¬$¸®]);
a (REPEAT strip_tac
	THEN all_asm_ufc_tac[]);
val Ûabelian_group_product_thmİ = save_pop_thm "abelian_group_product_thm";
=TEX

=SML
set_goal([], ¬µG:'g GROUP; H:'h GROUP; x y:'g; v w:'h·
	((x,v) . (y, w)) (G * H)
	= ((x . y)G, (v . w)H)®);
a (REPEAT strip_tac
	THEN rewrite_tac [gp_def, let_def, group_unit_def]
	THEN REPEAT strip_tac);
val group_prod_prod_thm = save_pop_thm "group_prod_prod_thm";
=TEX
=SML
set_goal([], ¬µG:'g GROUP; H:'h GROUP; x y:'g ¸ 'h·
	(x . y) (G * H)
	= ((Fst x . Fst y)G, (Snd x . Snd y)H)®);
a (REPEAT strip_tac
	THEN rewrite_tac [gp_def, let_def, group_unit_def]
	THEN REPEAT strip_tac);
val group_prod_prod_thm1 = save_pop_thm "group_prod_prod_thm1";
=TEX

}%ignore

=GFT
abelian_group_product_thm = ô µg:'a GROUP; h:'b GROUP·
	g  AbelianGroup ± h  AbelianGroup ´ (g * h)  AbelianGroup
=TEX

\ignore{
=SML
set_goal([], ¬¯_plus  AbelianGroup®);
a (rewrite_tac [
	get_spec ¬AbelianGroup®,
	¯_plus_ops_thm,
	¯_plus_group_thm
	]);
val ¯_plus_abelian_thm = save_pop_thm "¯_plus_abelian_thm";
=TEX
} %ignore

=GFT
¯_plus_abelian_thm = ô ¯_plus  AbelianGroup
=TEX

\section{Topology}

=SML
new_parent "topology";
=TEX

\subsection{Bases etc.}

The following definitions belong properly in the theory ``topology''.

First we define the relationship between a $base$ and the topology of which it is a base.

=SML
declare_infix (300, "BaseOf");
=TEX

¹HOLCONST
Ü $ÛBaseOfİ :  'a SET SET ­ 'a SET SET ­ BOOL
÷üüüüüü
Ü µ base topology· base BaseOf topology ¤
Ü	µs· s  topology ´ ¶ ss· ss € base ± s = Ş ss
°

However, what we really need here is the construction of a topology from an arbitrary set of sets, which is done as follows:

¹HOLCONST
Ü $ÛTopologyFromİ :  'a SET SET ­ 'a SET SET
÷üüüüüü
Ü µ sets· TopologyFrom sets =
Ü	¥ {topology | topology  Topology ± sets € topology}
°

\ignore{

Prove that $TopologyFrom$ yields a topology.

}%ignore

\section{For Inductive and Coinductive Definitions}

These have been moved from \cite{rbjt007}, pro-tem into this new section, to be merged in later.

\subsection{Some Useful Constant Specifications}

which probably don't belong here and will in due course be moved elsewhere.

The identity function.

¹HOLCONST
Ü ÛIİ: 'a ­ 'a
÷üüüüüü
Ü I = Ìx·x
°

Two ways of constructing functions over disjoint unions.

¹HOLCONST
Ü ÛFun‰+İ: ('a ­ 't) ­ ('b­ 'u) ­ ('a + 'b ­ 't + 'u)
÷üüüüüü
Ü µf:'a ­ 't; g:'b ­ 'u; ab:'a + 'b·
Ü	Fun‰+ f g ab = if IsL ab then InL (f (OutL ab)) else InR (g (OutR ab))
°

¹HOLCONST
Ü ÛFunSumİ: ('a ­ 't) ­ ('b­ 't) ­ ('a + 'b ­ 't)
÷üüüüüü
Ü µf:'a ­ 't; g:'b ­ 't; ab:'a + 'b·
Ü	FunSum f g ab = if IsL ab then f (OutL ab) else g (OutR ab)
°

A function for making a list of ascending integers.

=SML
declare_infix (300, "..‰L");
=TEX
¹HOLCONST
Ü $Û..‰Lİ: î ­ î ­ î LIST
÷üüüüüü
Ü µ x y· x ..‰L 0 = []
Ü ± x ..‰L (y + 1) = if x ¼ y then (x ..‰L y) @ [y+1] else []
°

{\let\Section\section
\def\section#1{\Section{#1}\label{TheoryListing}}
\include{rbjmisc.th}
}  %\let

\twocolumn[\section{INDEX}\label{INDEX}]
{\small\printindex}

\end{document}
=SML
set_flag ("pp_use_alias", true);
output_theory{out_file="rbjmisc.th.doc", theory="rbjmisc"};
=TEX