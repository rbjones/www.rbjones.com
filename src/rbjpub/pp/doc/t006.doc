=IGN
$Id: t006.doc,v 1.1 2004/07/15 14:40:31 rbj Exp $
=TEX
\documentclass[11pt,a4paper]{article}
\usepackage{latexsym}
\usepackage{ProofPower}
\ftlinepenalty=9999
\tabstop=0.25in
\usepackage{A4}
\def\N{\mathbb{N}}
\def\D{\mathbb{D}}
\def\B{\mathbb{B}}
\def\R{\mathbb{R}}
\def\Z{\mathbb{Z}}
\def\Q{\mathbb{Q}}

\def\Hide#1{\relax}
\newcommand{\ignore}[1]{}

\title{Miscellaneous SML}
\author{Roger Bishop Jones}
\makeindex
\begin{document}
\vfill
\maketitle
\begin{abstract}
This document contains things used by my other theories which do not particularly belong in them.
Some are bits of SML not associated with a theory.
Some are definitions or theorems which arguably belong in a theory already produced by someone else.
\end{abstract}
\vfill
\newpage
\tableofcontents
\newpage
%%%%

{\raggedright
\bibliographystyle{fmu}
\bibliography{fmu}
} %\raggedright

\section{Some SML procedures}

\subsection{Force New Theory}

This is just to save the exception handling which otherwise has to appear at the top of every document which creates a \Product theory.

First for deleting the old theory (from your previous build) and starting the theory afresh.

=SML
fun Ûforce_new_theoryÝ name =
  let val _ = force_delete_theory name handle _ => ();
  in new_theory name
end;
=TEX

Then something similar for an associated proof context.

=SML
fun Ûforce_new_pcÝ name =
  let val _ = delete_pc name handle _ => ();
  in new_pc name
end;
=TEX

=IGN
fun add_pc_thms pc thms =
		(add_rw_thms thms pc;
		add_sc_thms thms pc;
 		add_st_thms thms pc);
=TEX

\subsection{Doing Consistency Proofs before Axiomatic Descriptions}

To avoid getting theory listings in which the definitions of some constants are given using $ConstSpec$ I like to do any necessary consistency proofs before introducing the definition which needs them.
For this to do any good, the automatic consistency prover has to know that I done it.

I therefore introduce a new value of type $ref THM$ called $xl\_consistency\_result$.
When I do a consistency proof, I store the resulting theorem in this location.

=SML
val xl_consistency_result = ref t_thm;
=TEX

When I do a consistency proof, I store the resulting theorem in this location.
I use the following function to do that, to hide the implementation details.

=SML
fun xl_set_cs_¶_thm thm = (xl_consistency_result := thm);
=TEX

I also have a special partial proof context with a consistency prover which knows to look for the consistency proof in this special place.
This is the consistency prover:

=SML
open_theory "basic_hol";
set_pc "basic_hol";

local fun eq_refl_conv t = prove_rule [] (mk_eq (t,t))
in 
 fun xl_cs_¶_conv x =
	if x =$ (concl(!xl_consistency_result))
	then (¤_t_intro (!xl_consistency_result)) handle _ => eq_refl_conv x
	else eq_refl_conv x
end;
=TEX

and here's the proof context containing it:

=SML
force_new_pc "xl_cs_¶_conv";
set_cs_¶_convs [xl_cs_¶_conv] "xl_cs_¶_conv";
set_pr_conv basic_prove_conv "xl_cs_¶_conv";
set_pr_tac basic_prove_tac "xl_cs_¶_conv";
commit_pc "xl_cs_¶_conv";
=TEX

Then we go back to the $hol$ theory.

=SML
open_theory "hol";
set_pc "hol";
=TEX

\subsection{Tacticals etc.}

Some functions which turn round equations before using them.

=SML
fun list_eq_sym_rule thms = map (fn th => eq_sym_rule th handle _=> th) thms;
fun SYM_ASMS_T tltt = GET_ASMS_T (tltt o list_eq_sym_rule);

fun top_eq_sym_rule thm = conv_rule (ONCE_MAP_C eq_sym_conv) thm;
=TEX

Some functions for chaining with equivalence theorems.

=SML
fun ALL_FC_¤_T tt = ALL_FC_T1 fc_¤_canon tt;
fun FC_¤_T tt = FC_T1 fc_¤_canon tt;
fun all_fc_¤_tac thms = ALL_FC_¤_T (MAP_EVERY strip_asm_tac) thms;
fun fc_¤_tac thms = FC_¤_T (MAP_EVERY strip_asm_tac) thms;
=TEX

A (rather crude) function for stripping theorems for backward chaining.
Beware, the result is closed.

=SML
fun list_concat l = foldr (op @) [] l;

fun (rule_canon: (THM -> THM) -> CANON) rule thm = [rule thm];
fun (nail_canon:CANON) thm =
	if is_´ ((snd o strip_µ) (concl thm))
	then [thm]
	else [´_intro ¬T® thm];
val (all_´_intro_canon:CANON) = rule_canon all_´_intro;
val bc_canon =
	REPEAT_CAN (
		simple_µ_rewrite_canon
		ORELSE_CAN (rule_canon undisch_rule)
		ORELSE_CAN ±_rewrite_canon)
	THEN_CAN all_´_intro_canon
	THEN_CAN nail_canon
	THEN_CAN (rule_canon all_µ_intro);
fun abc_tac thml =
	let val thms = list_concat (map bc_canon thml)
	in REPEAT (accept_tac t_thm ORELSE (bc_tac thms))
	end;
=TEX

A tactic for normal form conversion of real expressions.
=SML
val ¯_anf_tac = conv_tac (TOP_MAP_C ¯_anf_conv);
=TEX

=IGN
strip_´_rule;
strip_±_rule;
all_µ_elim;
THEN_CAN;
ORELSE_CAN;
REPEAT_CAN;
=TEX
Normal form conversion tactic for real expressions:

=SML
val ¯_top_anf_tac = conv_tac (TOP_MAP_C ¯_anf_conv);
=TEX

\subsection{Trawling for Useful Theorems}

The following functions search the ancestors of the current theory for theorems which do something with the current goal, i.e. which rewrite the conclusion, backward chain from it, or forward chain from the assumptions.

I will supply some details here if I ever get these into a state fit for anyone else.

\ignore{
=IGN
set_goal([¬x ¼ y:î®], ¬µx y· Suc x > x + y®);
=SML
val avoid_theories = ref ["min", "log", "misc", "sets", "combin", "pair", "list"];
val avoid_constants = ref [""];
val avoid_specs: string list ref = ref [""];

datatype THMDET =
		Spec of TERM
	|	Thm of (string * string);

fun is_defined_constant s =
	let val theoryname = get_const_theory s;
	    val defn = get_defn theoryname s
	in true
	end
	handle _ => false;

fun defined_consts t =
	let val consts = term_consts t
	in filter
		(fn x => not ((fst x) mem !avoid_constants)
		andalso is_defined_constant (fst x))
	   consts
	end;

fun defined_const_names t = map fst (defined_consts t);

fun on_conc f = f (snd (top_goal()));

fun on_asms f =
	let val (asms, concl) = top_goal()
	in f asms
	end;

fun on_goal f =
	let val (asms, concl) = top_goal()
	in  list_concat(map f (concl :: asms))
	end;

fun term_const_specs t =
	let fun gs (s,t) =
		let val c = mk_const (s,t)
		in (if	s mem !avoid_specs orelse
			(get_const_theory s) mem !avoid_theories
		   then []
		   else [(Spec c, get_spec c)]) handle _ => []
		end
	in list_concat (map gs (term_consts t))
	end;

fun const_theories t = list_cup (map (fn x => [get_const_theory x]) (defined_const_names t));

fun ancestor_theories t = filter (fn x => not (x mem !avoid_theories)) (get_ancestors t);

fun thy_thms t = map (fn (s,thm) => (Thm(t, hd s), thm)) (get_thms t);

fun const_thms t = list_concat(map thy_thms (const_theories t));

fun ancestor_thms t = list_concat(map thy_thms (ancestor_theories t));

fun rewriting_thm t thm =
	let val t' = pure_once_rewrite_conv [thm] t
	in true
	end handle _ => false;

fun srewriting_thm t thm = rewriting_thm t (top_eq_sym_rule thm) handle _ => false;

fun fc_thm ts thm =
	let val thms = fc_rule (fc_canon thm) (map asm_rule ts)
	in (fn [] => false | _ => true) thms
	end handle _ => false;

fun all_fc_thm ts thm =
	let val (gl, pr) = all_fc_tac [thm] (ts, ¬F®)
	in if length gl = 1 andalso length (fst (hd gl)) = length ts
		then false else true
	end handle _ => false;

fun bc_thm c thm =
	let val (gl, pr) = bc_tac [thm] ([], c)
	in if length gl = 1 andalso (snd (hd gl)) =$ c
		then false else true
	end handle _ => false;

fun numthms n [] = []
|   numthms n ((thmdets, thm)::t) = ((n, thmdets), thm):: (numthms (n+1) t);

fun rew_specs t =
	let val thms = term_const_specs t
	in numthms 1 (filter ((rewriting_thm t) o snd) thms)
	end;

fun terml_const_specs tl = list_concat (map term_const_specs tl);

fun fc_specs ts =
	let val thms = terml_const_specs ts
	in numthms 1 (filter ((fc_thm ts) o snd) thms)
	end;

fun bc_specs t =
	let val thms = term_const_specs t
	in numthms 1 (filter ((bc_thm t) o snd) thms)
	end;

fun rew_thms t =
	let val thms = (ancestor_thms "-") @ (term_const_specs t)
	in numthms 1 (filter ((rewriting_thm t) o snd) thms)
	end;

fun srew_thms t =
	let val thms = (ancestor_thms "-") @ (term_const_specs t)
	in numthms 1 (filter ((srewriting_thm t) o snd) thms)
	end;

fun fc_thms tl =
	let val thms = (ancestor_thms "-") @ (terml_const_specs tl)
	in numthms 1 (filter ((fc_thm tl) o snd) thms)
	end;

fun all_fc_thms tl =
	let val thms = (ancestor_thms "-") @ (terml_const_specs tl)
	in numthms 1 (filter ((all_fc_thm tl) o snd) thms)
	end;

fun bc_thms t =
	let val thms = (ancestor_thms "-") @ (term_const_specs t)
	in numthms 1 (filter ((bc_thm t) o snd) thms)
	end;

fun rew_thms2 t =
	let val thms = (ancestor_thms "-") @ (term_const_specs t)
	in numthms 1 (list_concat (map (fn (sl, th) =>
		[(sl, (th, (snd o dest_eq)(concl (pure_once_rewrite_conv [th] t))))]
		handle _ => []) thms))
	end;

fun rew_thms3 t =
	let val thms = (ancestor_thms "-") @ (term_const_specs t)
	in numthms 1 (list_concat (map (fn (sl, th) =>
		[(sl, (snd o dest_eq)(concl (pure_once_rewrite_conv [th] t)))]
		handle _ => []) thms))
	end;

fun const_rewrite_conv t =
	let val thms = map snd (rew_thms t)
	in rewrite_conv thms t
	end;

fun with_conc_thms f =
	let fun ff t = f (map snd (rew_thms t))
	in on_conc ff
	end;

fun with_conc_specs f =
	let fun ff t = f (map snd (rew_specs t))
	in on_conc ff
	end;

fun td_thm (Thm (thyn, thmn)) = get_thm thyn thmn
|   td_thm (Spec s) = get_spec s;

fun td_thml tdl = map td_thm tdl;

fun numl2tdl tdsl nl =
 map (fn chose => (snd o fst o chose) tdsl) (map (fn n=> nth (n-1)) nl);

fun todo () =
	let val rw = length (on_conc rew_thms)
	    val bc = length (on_conc bc_thms)
	    val fc = length (on_asms fc_thms)
	in {rw = rw, bc = bc, fc = fc}
	end;
=TEX
}%ignore

\section{The Theory rbjmisc}

All the theorems are placed in the one temporary location, which therefore must have as ancestors all the theories which are being extended.

There is one section in this document, following this one, for each theory to which an addition is being made so new parents may be added in those sections, or new proof contexts used.

=SML
open_theory "hol";
force_new_theory "rbjmisc";
=TEX

\section{Real numbers and Analysis}

=SML
new_parent"analysis";
set_merge_pcs["basic_hol1", "'sets_alg", "'¯", "xl_cs_¶_conv"];
=TEX

\subsection{Products}

=GFT
¯_prod_sign_iff_clauses 
ô (µ x y· î¯ 0 <R x *R y		¤ î¯ 0 <R x ± î¯ 0 <R y ² x <R î¯ 0 ± y <R î¯ 0)
± (µ x y· x *R y <R î¯ 0		¤ î¯ 0 <R x ± y <R î¯ 0 ² x <R î¯ 0 ± î¯ 0 <R y)
± (µ x y· î¯ 0 ¼R x *R y		¤ î¯ 0 ¼R x ± î¯ 0 ¼R y ² x ¼R î¯ 0 ± y ¼R î¯ 0)
± (µ x y· x *R y ¼R î¯ 0		¤ î¯ 0 ¼R x ± y ¼R î¯ 0 ² x ¼R î¯ 0 ± î¯ 0 ¼R y)
± (µ x y· x *R y = î¯ 0		¤ x = î¯ 0 ² y = î¯ 0)
± (µ x y· î¯ 0 = x *R y		¤ x = î¯ 0 ² y = î¯ 0)
=TEX

\ignore{
=SML
set_goal([], ¬µ x y·
	(î¯ 0 <R x ± î¯ 0 <R y ´ î¯ 0 <R x *R y)
	± (x <R î¯ 0 ± y <R î¯ 0 ´ î¯ 0 <R x *R y)
	± (x <R î¯ 0 ± î¯ 0 <R y ´ x *R y <R î¯ 0)
	± (î¯ 0 <R x ± y <R î¯ 0 ´ x *R y <R î¯ 0)
	± (x = î¯ 0 ² y = î¯ 0 ´ x *R y = î¯ 0)
®);
a (REPEAT strip_tac
	THEN TRY (asm_rewrite_tac[]));
(* *** Goal "1" *** *)
a (all_asm_fc_tac [¯_0_less_0_less_times_thm]);
(* *** Goal "2" *** *)
a (all_asm_fc_tac [¯_less_0_less_thm]);
a (LEMMA_T ¬î¯ 0 <R (~R x) *R (~R y)® ante_tac
	THEN1 all_asm_fc_tac [¯_0_less_0_less_times_thm]);
a (rewrite_tac(td_thml[Thm ("\175", "\175_times_minus_thm")]));
(* *** Goal "3" *** *)
a (once_rewrite_tac [¯_less_0_less_thm]);
a (rewrite_tac[]);
a (lemma_tac ¬î¯ 0 <R (~R x)®
	THEN1 (ALL_ASM_FC_T (MAP_EVERY ante_tac) [¯_less_0_less_thm]
		THEN rewrite_tac[]
		THEN REPEAT strip_tac));
a (all_asm_fc_tac [¯_0_less_0_less_times_thm]);
a (lemma_tac ¬~R (x *R y) = ~R x *R y®
	THEN1 (PC_T1 "¯_lin_arith" prove_tac[]));
a (asm_rewrite_tac[]);
(* *** Goal "4" *** *)
a (once_rewrite_tac [¯_less_0_less_thm]);
a (rewrite_tac[]);
a (lemma_tac ¬î¯ 0 <R (~R y)®
	THEN1 (ALL_ASM_FC_T (MAP_EVERY ante_tac) [¯_less_0_less_thm]
		THEN rewrite_tac[]
		THEN REPEAT strip_tac));
a (all_asm_fc_tac [¯_0_less_0_less_times_thm]);
a (lemma_tac ¬~R (x *R y) = x *R ~R y®
	THEN1 (PC_T1 "¯_lin_arith" prove_tac[]));
a (asm_rewrite_tac[]);
val ¯_product_sign_lemma = pop_thm ();
=TEX
=SML
set_goal([], ¬µ x y·
	(î¯ 0 <R x *R y ´ î¯ 0 <R x ± î¯ 0 <R y ² x <R î¯ 0 ± y <R î¯ 0)
	± (x *R y <R î¯ 0 ´ î¯ 0 <R x ± y <R î¯ 0 ² î¯ 0 <R y ± x <R î¯ 0)
	± (x *R y = î¯ 0 ´ x = î¯ 0 ² y = î¯ 0)
®);
a contr_tac;
(* *** Goal "1" *** *)
a (strip_asm_tac (list_µ_elim [¬x®, ¬î¯ 0®] ¯_less_cases_thm));
a (DROP_NTH_ASM_T 4 ante_tac THEN asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a (strip_asm_tac (list_µ_elim [¬x®, ¬î¯ 0®] ¯_less_cases_thm));
(* *** Goal "2.1" *** *)
a (strip_asm_tac (list_µ_elim [¬y®, ¬î¯ 0®] ¯_less_cases_thm));
(* *** Goal "2.1.1" *** *)
a (DROP_NTH_ASM_T 5 ante_tac THEN asm_rewrite_tac[]);
(* *** Goal "2.1.2" *** *)
a (all_asm_fc_tac[¯_product_sign_lemma]);
a (all_asm_fc_tac[¯_less_trans_thm]);
(* *** Goal "2.2" *** *)
a (DROP_NTH_ASM_T 4 ante_tac THEN asm_rewrite_tac[]);
(* *** Goal "3" *** *)
a (strip_asm_tac (list_µ_elim [¬y®, ¬î¯ 0®] ¯_less_cases_thm));
(* *** Goal "3.1" *** *)
a (strip_asm_tac (list_µ_elim [¬x®, ¬î¯ 0®] ¯_less_cases_thm));
(* *** Goal "3.1.1" *** *)
a (DROP_NTH_ASM_T 5 ante_tac THEN asm_rewrite_tac[]);
(* *** Goal "3.1.2" *** *)
a (all_asm_fc_tac[¯_product_sign_lemma]);
a (all_asm_fc_tac[¯_less_trans_thm]);
(* *** Goal "3.2" *** *)
a (DROP_NTH_ASM_T 4 ante_tac THEN asm_rewrite_tac[]);
(* *** Goal "4" *** *)
a (strip_asm_tac (list_µ_elim [¬y®, ¬î¯ 0®] ¯_less_cases_thm));
a (DROP_NTH_ASM_T 4 ante_tac THEN asm_rewrite_tac[]);
(* *** Goal "5" *** *)
a (strip_asm_tac (list_µ_elim [¬x®, ¬î¯ 0®] ¯_less_cases_thm));
(* *** Goal "5.1" *** *)
a (strip_asm_tac (list_µ_elim [¬y®, ¬î¯ 0®] ¯_less_cases_thm));
(* *** Goal "5.1.1" *** *)
a (all_asm_fc_tac[¯_product_sign_lemma]);
a (all_asm_fc_tac[¯_less_trans_thm]);
(* *** Goal "5.1.2" *** *)
a (DROP_NTH_ASM_T 5 ante_tac THEN asm_rewrite_tac[]);
(* *** Goal "5.2" *** *)
a (DROP_NTH_ASM_T 4 ante_tac THEN asm_rewrite_tac[]);
(* *** Goal "6" *** *)
a (strip_asm_tac (list_µ_elim [¬x®, ¬î¯ 0®] ¯_less_cases_thm));
a (DROP_NTH_ASM_T 4 ante_tac THEN asm_rewrite_tac[]);
(* *** Goal "7" *** *)
a (strip_asm_tac (list_µ_elim [¬y®, ¬î¯ 0®] ¯_less_cases_thm));
a (DROP_NTH_ASM_T 4 ante_tac THEN asm_rewrite_tac[]);
(* *** Goal "8" *** *)
a (strip_asm_tac (list_µ_elim [¬y®, ¬î¯ 0®] ¯_less_cases_thm));
(* *** Goal "8.1" *** *)
a (strip_asm_tac (list_µ_elim [¬x®, ¬î¯ 0®] ¯_less_cases_thm));
(* *** Goal "8.1.1" *** *)
a (DROP_NTH_ASM_T 5 ante_tac THEN asm_rewrite_tac[]);
(* *** Goal "8.1.2" *** *)
a (DROP_NTH_ASM_T 5 ante_tac THEN asm_rewrite_tac[]);
(* *** Goal "8.2" *** *)
a (strip_asm_tac (list_µ_elim [¬x®, ¬î¯ 0®] ¯_less_cases_thm));
(* *** Goal "8.2.1" *** *)
a (DROP_NTH_ASM_T 5 ante_tac THEN asm_rewrite_tac[]);
(* *** Goal "8.2.2" *** *)
a (all_asm_fc_tac[¯_product_sign_lemma]);
a (all_asm_fc_tac[¯_less_trans_thm]);
(* *** Goal "9" *** *)
a (strip_asm_tac (list_µ_elim [¬x®, ¬î¯ 0®] ¯_less_cases_thm));
(* *** Goal "9.1" *** *)
a (strip_asm_tac (list_µ_elim [¬y®, ¬î¯ 0®] ¯_less_cases_thm));
(* *** Goal "9.1.1" *** *)
a (all_asm_fc_tac[¯_product_sign_lemma]);
a (DROP_NTH_ASM_T 4 ante_tac THEN asm_rewrite_tac[]);
(* *** Goal "9.1.2" *** *)
a (all_asm_fc_tac[¯_product_sign_lemma]);
a (DROP_NTH_ASM_T 4 ante_tac THEN asm_rewrite_tac[]);
(* *** Goal "9.2" *** *)
a (strip_asm_tac (list_µ_elim [¬y®, ¬î¯ 0®] ¯_less_cases_thm));
(* *** Goal "9.2.1" *** *)
a (all_asm_fc_tac[¯_product_sign_lemma]);
a (DROP_NTH_ASM_T 4 ante_tac THEN asm_rewrite_tac[]);
(* *** Goal "9.2.2" *** *)
a (all_asm_fc_tac[¯_product_sign_lemma]);
a (DROP_NTH_ASM_T 4 ante_tac THEN asm_rewrite_tac[]);
val ¯_product_sign_cp_lemma = pop_thm ();
=TEX
=SML
set_goal([], ¬(µ x y· î¯ 0 <R x *R y ¤ î¯ 0 <R x ± î¯ 0 <R y
		² x <R î¯ 0 ± y <R î¯ 0)
	± (µ x y· x *R y <R î¯ 0 ¤ î¯ 0 <R x ± y <R î¯ 0
		² x <R î¯ 0 ± î¯ 0 <R y)
	± (µ x y· x *R y = î¯ 0 ¤ x = î¯ 0 ² y = î¯ 0)
	± (µ x y· î¯ 0 = x *R y ¤ x = î¯ 0 ² y = î¯ 0)®);
a (REPEAT strip_tac
	THEN TRY (asm_rewrite_tac [])
	THEN TRY (all_fc_tac [¯_product_sign_lemma,
	¯_product_sign_cp_lemma]));
a (DROP_NTH_ASM_T 2 (asm_tac o (conv_rule eq_sym_conv))
	THEN fc_tac [¯_product_sign_cp_lemma]
	THEN asm_rewrite_tac[]);
val ¯_prod_sign_iff_lemma = pop_thm ();
=TEX
=SML
set_goal([], ¬(µ x y· î¯ 0 ¼R x *R y ¤ î¯ 0 ¼R x ± î¯ 0 ¼R y
		² x ¼R î¯ 0 ± y ¼R î¯ 0)
	± (µ x y· x *R y ¼R î¯ 0 ¤ î¯ 0 ¼R x ± y ¼R î¯ 0
		² x ¼R î¯ 0 ± î¯ 0 ¼R y)
	± (µ x y· x *R y = î¯ 0 ¤ x = î¯ 0 ² y = î¯ 0)
	± (µ x y· î¯ 0 = x *R y ¤ x = î¯ 0 ² y = î¯ 0)®);
a (rewrite_tac [get_spec ¬$¼R®, ¯_prod_sign_iff_lemma]
	THEN (PC_T1 "¯_lin_arith" prove_tac[]));
val ¯_prod_sign_iff_lemma2 = pop_thm ();
=TEX
=SML
set_goal([], ¬(µ x y· î¯ 0 <R x *R y ¤ î¯ 0 <R x ± î¯ 0 <R y
		² x <R î¯ 0 ± y <R î¯ 0)
	± (µ x y· x *R y <R î¯ 0 ¤ î¯ 0 <R x ± y <R î¯ 0
		² x <R î¯ 0 ± î¯ 0 <R y)
	± (µ x y· î¯ 0 ¼R x *R y ¤ î¯ 0 ¼R x ± î¯ 0 ¼R y
		² x ¼R î¯ 0 ± y ¼R î¯ 0)
	± (µ x y· x *R y ¼R î¯ 0 ¤ î¯ 0 ¼R x ± y ¼R î¯ 0
		² x ¼R î¯ 0 ± î¯ 0 ¼R y)
	± (µ x y· x *R y = î¯ 0 ¤ x = î¯ 0 ² y = î¯ 0)
	± (µ x y· î¯ 0 = x *R y ¤ x = î¯ 0 ² y = î¯ 0)®);
a (rewrite_tac [¯_prod_sign_iff_lemma, ¯_prod_sign_iff_lemma2]
	THEN (PC_T1 "¯_lin_arith" prove_tac[]));
val ¯_prod_sign_iff_clauses = save_pop_thm "¯_prod_sign_iff_clauses";
=TEX
}%ignore

\ignore{

=SML
set_goal([], ¬µ x y z· î¯ 0 <R x ± y <R z ´ y *R x <R z *R x®);
a (REPEAT strip_tac);
a (all_fc_tac [¯_times_mono_thm]);
a (PC_T1 "¯_lin_arith" asm_prove_tac[]);
val ¯_times_mono_thm1 = save_pop_thm "¯_times_mono_thm1";
=TEX

=SML

set_goal([], ¬µ x y z· î¯ 0 ¼R x ± y ¼R z ´ x *R y ¼R x *R z®);
a (rewrite_tac [get_spec ¬$¼R®]
	THEN REPEAT strip_tac
	THEN TRY (asm_rewrite_tac[])
	THEN TRY (SYM_ASMS_T rewrite_tac)
	THEN TRY (all_fc_tac
	[¯_times_mono_thm, ¯_times_mono_thm1, ¯_less_trans_thm]));
val ¯_times_mono_thm2 = save_pop_thm "¯_times_mono_thm2";

set_goal([], ¬µ x y z· î¯ 0 ¼R x ± y ¼R z ´ y *R x ¼R z *R x®);
a (rewrite_tac [get_spec ¬$¼R®]
	THEN REPEAT strip_tac
	THEN TRY (asm_rewrite_tac[])
	THEN TRY (SYM_ASMS_T rewrite_tac)
	THEN TRY (all_fc_tac
	[¯_times_mono_thm, ¯_times_mono_thm1, ¯_less_trans_thm]));
val ¯_times_mono_thm3 = save_pop_thm "¯_times_mono_thm3";
=TEX

=SML
set_goal([], ¬µ w x y z· î¯ 0 <R w ± î¯ 0 <R y ± w <R x ± y <R z ´ w *R y <R x *R z®);
a (REPEAT strip_tac);
a (lemma_tac ¬î¯ 0 <R z ± î¯ 0 <R x®
	THEN1 (all_asm_fc_tac[¯_less_trans_thm])
	THEN REPEAT strip_tac);
a (lemma_tac ¬w *R y <R w *R z®
	THEN1 (all_asm_fc_tac[¯_times_mono_thm, ¯_times_mono_thm1, ¯_less_trans_thm]));
a (lemma_tac ¬w *R z <R x *R z®
	THEN1 (strip_asm_tac (list_µ_elim [¬z®, ¬w®, ¬x®] ¯_times_mono_thm1)));
a (strip_asm_tac (list_µ_elim [¬w *R y®, ¬w *R z®, ¬x *R z®] ¯_less_trans_thm));
val ¯_times_mono_thm4 = save_pop_thm "¯_times_mono_thm4";
=TEX

=SML
set_goal([], ¬µ w x y z· î¯ 0 ¼R w ± î¯ 0 ¼R y ± w ¼R x ± y ¼R z ´ w *R y ¼R x *R z®);
a (REPEAT strip_tac);
a (lemma_tac ¬î¯ 0 ¼R z ± î¯ 0 ¼R x®
	THEN1 (all_asm_fc_tac[¯_¼_trans_thm])
	THEN REPEAT strip_tac);
a (lemma_tac ¬w *R y ¼R w *R z®
	THEN1 (all_asm_fc_tac[¯_times_mono_thm2, ¯_times_mono_thm3, ¯_¼_trans_thm]));
a (lemma_tac ¬w *R z ¼R x *R z®
	THEN1 (strip_asm_tac (list_µ_elim [¬z®, ¬w®, ¬x®] ¯_times_mono_thm3)));
a (strip_asm_tac (list_µ_elim [¬w *R y®, ¬w *R z®, ¬x *R z®] ¯_¼_trans_thm));
val ¯_times_mono_thm5 = save_pop_thm "¯_times_mono_thm5";
=TEX
}%ignore

\subsection{Squares}

\ignore{
=SML
set_goal([], ¬µ x y· î¯ 0 <R x ± x <R y ´ x *R x <R y *R y®);
a (REPEAT strip_tac);
a (all_asm_fc_tac [¯_less_trans_thm]);
a (strip_asm_tac (list_µ_elim [¬x®, ¬y®, ¬x®, ¬y®] ¯_times_mono_thm4));
val ¯_square_mono_thm = save_pop_thm "¯_square_mono_thm";
=TEX

=SML
set_goal([], ¬µ x y· î¯ 0 ¼R x ± x ¼R y ´ x *R x ¼R y *R y®);
a (REPEAT strip_tac);
a (all_asm_fc_tac [¯_¼_trans_thm]);
a (strip_asm_tac (list_µ_elim [¬x®, ¬y®, ¬x®, ¬y®] ¯_times_mono_thm5));
val ¯_square_mono_thm1 = save_pop_thm "¯_square_mono_thm1";
=TEX

=SML
set_goal([], ¬µ x y z· î¯ 0 <R x ± î¯ 0 <R y ± x *R x <R y *R y ´ x <R y®);
a (REPEAT strip_tac);
a (strip_asm_tac (all_µ_elim ¯_less_cases_thm));
(* *** Goal "1" *** *)
a (DROP_ASM_T ¬x *R x <R y *R y® ante_tac
	THEN asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a (strip_asm_tac (list_µ_elim [¬y®, ¬x®] ¯_square_mono_thm));
a (all_fc_tac [¯_less_antisym_thm]);
val ¯_square_less_less_thm = save_pop_thm "¯_square_less_less_thm";
=TEX

-SML
set_goal([], ¬µ x y· î¯ 0 <R x ± î¯ 0 <R y ´ (x *R x <R y *R y ¤ x <R y)®);
a (REPEAT strip_tac);
(* *** Goal "1" *** *)
a (all_fc_tac [¯_square_less_less_thm]);
(* *** Goal "2" *** *)
a (all_fc_tac [¯_square_mono_thm]);
val ¯_square_less_iff_less_thm = save_pop_thm "¯_square_less_iff_less_thm";
=TEX

-SML
set_goal([], ¬µ x y· î¯ 0 ¼R x ± î¯ 0 ¼R y ´ (x *R x ¼R y *R y ¤ x ¼R y)®);
a (REPEAT strip_tac);
(* *** Goal "1" *** *)
a (all_fc_tac [¯_square_¼_¼_thm]);
(* *** Goal "2" *** *)
a (all_fc_tac [¯_square_mono_thm1]);
val ¯_square_¼_iff_¼_thm = save_pop_thm "¯_square_¼_iff_¼_thm";
=TEX

=SML
set_goal([], ¬µx y:¯· î¯ 0 <R x ± î¯ 0 <R y ± y *R y = x *R x ´ x = y®);
a (REPEAT strip_tac);
a (strip_asm_tac (all_µ_elim ¯_less_cases_thm)
	THEN (fc_tac [¯_times_mono_thm]));
(* *** Goal "1" *** *)
a (lemma_tac ¬x *R x <R x *R y®
	THEN1 asm_fc_tac []);
a (lemma_tac ¬x *R y <R y *R y®
	THEN1 all_fc_tac [list_µ_elim [¬y®, ¬x®, ¬y®] ¯_times_mono_thm1]);
a (ALL_FC_T (MAP_EVERY ante_tac) [¯_less_trans_thm]
	THEN asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a (lemma_tac ¬x *R y <R x *R x®
	THEN1 asm_fc_tac []);
a (lemma_tac ¬y *R y <R x *R y®
	THEN1 all_fc_tac [list_µ_elim [¬y®, ¬y®, ¬x®] ¯_times_mono_thm1]);
a (ALL_FC_T (MAP_EVERY ante_tac) [¯_less_trans_thm]
	THEN asm_rewrite_tac[]);
val ¯_square_eq_thm1 = save_pop_thm "¯_square_eq_thm1";
=TEX

=SML
set_goal([], ¬µx y:¯· î¯ 0 ¼R x ± î¯ 0 ¼R y ± y *R y = x *R x ´ x = y®);
a (rewrite_tac[get_spec ¬$¼R®]);
a (rewrite_tac (map eq_sym_conv [¬î¯ 0 = x®, ¬î¯ 0 = y®])
	THEN REPEAT strip_tac
	THEN TRY (asm_rewrite_tac[]));
(* *** Goal "1" *** *)
a (all_fc_tac [¯_square_eq_thm1]);
(* *** Goal "2" *** *)
a (POP_ASM_T ante_tac THEN asm_rewrite_tac[¯_prod_sign_iff_clauses]);
(* *** Goal "3" *** *)
a (POP_ASM_T ante_tac
	THEN asm_rewrite_tac[¯_prod_sign_iff_clauses]
	THEN STRIP_T rewrite_thm_tac);
val ¯_square_eq_thm2 = save_pop_thm "¯_square_eq_thm2";
=TEX

=SML
set_goal([], ¬µ x y· î¯ 0 <R x ± î¯ 0 <R y ´ (x *R x = y *R y ¤ x = y)®);
a (REPEAT strip_tac
	THEN TRY (asm_rewrite_tac[]));
a (strip_asm_tac (all_µ_elim ¯_less_cases_thm)
	THEN (ALL_FC_T (MAP_EVERY ante_tac) [¯_square_mono_thm])
	THEN TRY (asm_rewrite_tac[]));
a (strip_asm_tac (list_µ_elim [¬y®, ¬x®] ¯_square_mono_thm)
	THEN POP_ASM_T ante_tac
	THEN TRY (asm_rewrite_tac[]));
val ¯_square_eq_eq_thm = save_pop_thm "¯_square_eq_eq_thm";
=TEX

=SML
set_goal([], ¬µ x y· î¯ 0 ¼R x ± î¯ 0 ¼R y ´ (x *R x = y *R y ¤ x = y)®);
a (rewrite_tac[get_spec ¬$¼R®]
	THEN REPEAT strip_tac
	THEN TRY (SYM_ASMS_T rewrite_tac));
(* *** Goal "1" *** *)
a (all_fc_tac [¯_square_eq_eq_thm]);
(* *** Goal "2" *** *)
a (POP_ASM_T ante_tac
	THEN SYM_ASMS_T rewrite_tac
	THEN rewrite_tac [¯_prod_sign_iff_clauses]);
(* *** Goal "3" *** *)
a (POP_ASM_T ante_tac
	THEN SYM_ASMS_T rewrite_tac
	THEN rewrite_tac [¯_prod_sign_iff_clauses]
	THEN strip_tac
	THEN asm_rewrite_tac[]);
val ¯_square_eq_eq_thm2 = save_pop_thm "¯_square_eq_eq_thm2";
=TEX

=SML
set_goal([], ¬µ x y· î¯ 0 ¼R x ± î¯ 0 ¼R y ± x *R x ¼R y *R y ´ x ¼R y®);
a (REPEAT strip_tac);
a (strip_asm_tac (all_µ_elim ¯_less_cases_thm));
(* *** Goal "1" *** *)
a (asm_rewrite_tac[get_spec ¬$¼R®]);
(* *** Goal "2" *** *)
a (DROP_ASM_T ¬x *R x ¼R y *R y® ante_tac
	THEN asm_rewrite_tac[]);
(* *** Goal "3" *** *)
a (strip_asm_tac (list_µ_elim [¬y®, ¬x®] ¯_square_mono_thm1));
(* *** Goal "3.1" *** *)
a (POP_ASM_T ante_tac THEN asm_rewrite_tac[get_spec ¬$¼R®]);
(* *** Goal "3.2" *** *)
a (all_fc_tac [pc_rule1 "¯_lin_arith"
	prove_rule [] ¬µx y:¯· x ¼R y ± y ¼R x ´ x = y®]);
a (all_fc_tac [¯_square_eq_eq_thm2]);
a (asm_rewrite_tac [get_spec ¬$¼R®]);
val ¯_square_¼_¼_thm = save_pop_thm "¯_square_¼_¼_thm";
=TEX

=SML
set_goal([], ¬µ x y· x *R x = y *R y ¤ Abs x = Abs y®);
a (REPEAT µ_tac
	THEN rewrite_tac [get_spec ¬AbsR®]
	THEN cases_tac ¬î¯ 0 ¼R x®
	THEN cases_tac ¬î¯ 0 ¼R y®
	THEN TRY (asm_rewrite_tac[])
	);
(* *** Goal "1" *** *)
a (strip_asm_tac (all_µ_elim ¯_square_eq_eq_thm2)
	THEN TRY (asm_rewrite_tac[]));
(* *** Goal "2" *** *)
a (all_asm_ante_tac
	THEN lemma_tac ¬¶ z· y = ~R z®
	THEN1 (¶_tac ¬~R y®
		THEN rewrite_tac[])
	THEN asm_rewrite_tac [¯_times_minus_thm]
	THEN REPEAT strip_tac);
(* *** Goal "2.1" *** *)
a (lemma_tac ¬î¯ 0 ¼R z®
	THEN1 (PC_T1 "¯_lin_arith" asm_prove_tac []));
a (strip_asm_tac (list_µ_elim [¬x®, ¬z®] ¯_square_eq_eq_thm2)
	THEN TRY (asm_rewrite_tac[]));
(* *** Goal "2.2" *** *)
a (lemma_tac ¬î¯ 0 ¼R z®
	THEN1 (PC_T1 "¯_lin_arith" asm_prove_tac []));
a (strip_asm_tac (list_µ_elim [¬x®, ¬z®] ¯_square_eq_eq_thm2)
	THEN TRY (asm_rewrite_tac[]));
(* *** Goal "3" *** *)
a (all_asm_ante_tac
	THEN lemma_tac ¬¶ z· x = ~R z®
	THEN1 (¶_tac ¬~R x®
		THEN rewrite_tac[])
	THEN asm_rewrite_tac [¯_times_minus_thm]);
a (strip_tac THEN strip_tac);
a (lemma_tac ¬î¯ 0 ¼R z®
	THEN1 (PC_T1 "¯_lin_arith" asm_prove_tac []));
a (strip_asm_tac (list_µ_elim [¬z®, ¬y®] ¯_square_eq_eq_thm2)
	THEN TRY (asm_rewrite_tac[]));
(* *** Goal "4" *** *)
a (all_asm_ante_tac
	THEN lemma_tac ¬¶ z· x = ~R z®
	THEN1 (¶_tac ¬~R x®
		THEN rewrite_tac[])
	THEN lemma_tac ¬¶ v· y = ~R v®
	THEN1 (¶_tac ¬~R y®
		THEN rewrite_tac[])
	THEN asm_rewrite_tac[]
	THEN strip_tac THEN strip_tac);
a (lemma_tac ¬î¯ 0 ¼R z®
	THEN1 (PC_T1 "¯_lin_arith" asm_prove_tac []));
a (lemma_tac ¬î¯ 0 ¼R v®
	THEN1 (PC_T1 "¯_lin_arith" asm_prove_tac []));
a (strip_asm_tac (list_µ_elim [¬z®, ¬v®] ¯_square_eq_eq_thm2)
	THEN TRY (asm_rewrite_tac[¯_times_minus_thm]));
val ¯_square_eq_iff_abs_eq_thm = save_pop_thm "¯_square_eq_iff_abs_eq_thm";
=TEX

=SML
set_goal([], ¬µx:¯· î¯ 0 ¼ x ^ 2®);
a (rewrite_tac [¯_î_exp_square_thm, ¯_prod_sign_iff_clauses]);
a (PC_T1 "¯_lin_arith" prove_tac[]);
val ¯_square_pos_thm = save_pop_thm "¯_square_pos_thm";
=TEX
}%ignore

\subsection{Sums}

\ignore{
=SML
set_goal([], ¬µx y:¯· î¯ 0 ¼ x ± î¯ 0 ¼ y ´ î¯ 0 ¼ x + y®);
a (PC_T1 "¯_lin_arith" prove_tac[]);
val ¯_sum_pos_thm = save_pop_thm "¯_sum_pos_thm";
=TEX

=SML
set_goal([], ¬µ x y:¯· î¯ 0 ¼ x ^N 2 +R y ^N 2®);
a (REPEAT µ_tac);
a (lemma_tac ¬î¯ 0 ¼ x ^ 2 ± î¯ 0 ¼ y ^ 2®
	THEN1 rewrite_tac [¯_square_pos_thm]);
a (all_fc_tac [¯_sum_pos_thm]);
val ¯_sum_square_pos_thm = save_pop_thm "¯_sum_square_pos_thm";
=TEX

=SML
set_goal([], ¬µx y: ¯· x^2 + y^2 = î¯ 0 ¤ x = î¯ 0 ± y = î¯ 0®);
a (REPEAT_N 5 strip_tac THEN TRY (asm_rewrite_tac[]));
a (lemma_tac ¬î¯ 0 ¼ x ^ 2 ± î¯ 0 ¼ y ^ 2®
	THEN1 rewrite_tac [¯_square_pos_thm]);
a (ALL_FC_T (MAP_EVERY (asm_tac o (rewrite_rule [¯_î_exp_square_thm, ¯_prod_sign_iff_clauses])))
	[pc_rule1 "¯_lin_arith" prove_rule []
	¬µx y: ¯·î¯ 0 ¼ x ± î¯ 0 ¼ y ´ x + y = î¯ 0 ´ x = î¯ 0 ± y = î¯ 0®]
	THEN asm_rewrite_tac[]);
val ¯_sum_square_zero_thm = save_pop_thm "¯_sum_square_zero_thm";
=TEX

=SML
set_goal([], ¬µx y:¯· î¯ 0 ¼ x ± î¯ 0 ¼ y
	´ (x + y = î¯ 0 ¤ x = î¯ 0 ± y = î¯ 0)®);
a (PC_T1 "¯_lin_arith" prove_tac[]);
val ¯_sum_zero_thm = save_pop_thm "¯_sum_zero_thm";
=TEX

=SML
set_goal([], ¬µ x y:¯· Abs (x ^N 2 +R y ^N 2) = x ^N 2 +R y ^N 2®);
a (REPEAT µ_tac);
a (asm_rewrite_tac [get_spec ¬AbsR®, ¯_sum_square_pos_thm]);
val ¯_abs_sum_square_thm = save_pop_thm "¯_abs_sum_square_thm";
=TEX


=SML
val ¯_plus_mono_thm = save_thm ("¯_plus_mono_thm", pc_rule1 "¯_lin_arith" prove_rule []
	¬µu v x y· u ¼R v ± x ¼R y ´ u +R x ¼R v +R y®);
=TEX

}%ignore

\subsection{Abs}

The following arithmetic results are obtained for reasoning about norms on real vector spaces, in particular to prove that $Abs$ is a norm over the reals and that the defined product operation over norms yields a norm.

=GFT
¯_Abs_Norm_clauses 
ô (µ v· î¯ 0 ¼R AbsR v)
± (µ v· (AbsR v = î¯ 0) ¤ v = î¯ 0)
± (µ x v· AbsR (x *R v) = AbsR x *R AbsR v)
± (µ v w· AbsR (v +R w) ¼R AbsR v +R AbsR w)
=TEX

\ignore{
=SML
set_goal([], ¬(µ v· î¯ 0 ¼R AbsR v)
             ± (µ v· (AbsR v = î¯ 0) = v = î¯ 0)
             ± (µ x v· AbsR (x *R v) = AbsR x *R AbsR v)
             ± (µ v w· AbsR (v +R w) ¼R AbsR v +R AbsR w)®);
a (rewrite_tac [get_spec ¬AbsR®, get_spec ¬$¼R®, ¯_prod_sign_iff_clauses]);
a (REPEAT ±_tac THEN REPEAT µ_tac);
(* *** Goal "1" *** *)
a (CASES_T ¬î¯ 0 < v ² î¯ 0 = v® asm_tac
	THEN TRY (asm_rewrite_tac[]));
a (PC_T1 "¯_lin_arith" asm_prove_tac[]);
(* *** Goal "2" *** *)
a (CASES_T ¬î¯ 0 < v ² î¯ 0 = v® asm_tac
	THEN TRY (asm_rewrite_tac[])
	THEN TRY (PC_T1 "¯_lin_arith" asm_prove_tac[]));
(* *** Goal "3" *** *)
a (strip_asm_tac (list_µ_elim [¬x®, ¬î¯ 0®] ¯_less_cases_thm)
	THEN asm_rewrite_tac[]
	THEN (strip_asm_tac (list_µ_elim [¬v®, ¬î¯ 0®] ¯_less_cases_thm))
	THEN asm_rewrite_tac[]);
(* *** Goal "3.1" *** *)
a (LEMMA_T ¬³(î¯ 0 < x ² î¯ 0 = x)® asm_tac
	THEN1 PC_T1 "¯_lin_arith" asm_prove_tac[]);
a (LEMMA_T ¬³(î¯ 0 < v ² î¯ 0 = v)® asm_tac
	THEN1 PC_T1 "¯_lin_arith" asm_prove_tac[]);
a (asm_rewrite_tac[¯_times_minus_thm]);
(* *** Goal "3.2" *** *)
a (LEMMA_T ¬³(î¯ 0 < x ² î¯ 0 = x)® asm_tac
	THEN1 PC_T1 "¯_lin_arith" asm_prove_tac[]);
a (LEMMA_T ¬³(v < î¯ 0 ² x = î¯ 0 ² v = î¯ 0)® asm_tac
	THEN1 PC_T1 "¯_lin_arith" asm_prove_tac[]);
a (asm_rewrite_tac[¯_times_minus_thm]);
(* *** Goal "3.3" *** *)
a (LEMMA_T ¬³(î¯ 0 < v ² î¯ 0 = v)® asm_tac
	THEN1 PC_T1 "¯_lin_arith" asm_prove_tac[]);
a (asm_rewrite_tac[¯_times_minus_thm]);
a (LEMMA_T ¬³(x < î¯ 0 ² x = î¯ 0 ² v = î¯ 0)® asm_tac
	THEN1 PC_T1 "¯_lin_arith" asm_prove_tac[]);
a (asm_rewrite_tac[¯_times_minus_thm]);
(* *** Goal "4" *** *)
a (strip_asm_tac (list_µ_elim [¬w®, ¬î¯ 0®] ¯_less_cases_thm)
	THEN TRY (asm_rewrite_tac[])
	THEN (strip_asm_tac (list_µ_elim [¬v®, ¬î¯ 0®] ¯_less_cases_thm))
	THEN TRY (asm_rewrite_tac[]));
(* *** Goal "4.1" *** *)
a (LEMMA_T ¬³(î¯ 0 <R v ² î¯ 0 = v)® rewrite_thm_tac
	THEN1 PC_T1 "¯_lin_arith" asm_prove_tac[]);
a (LEMMA_T ¬³(î¯ 0 <R w ² î¯ 0 = w)® rewrite_thm_tac
	THEN1 PC_T1 "¯_lin_arith" asm_prove_tac[]);
a (LEMMA_T ¬³(î¯ 0 <R v +R w ² î¯ 0 = v +R w)® rewrite_thm_tac
	THEN1 PC_T1 "¯_lin_arith" asm_prove_tac[]);
(* *** Goal "4.2" *** *)
a (LEMMA_T ¬³(î¯ 0 <R w ² î¯ 0 = w)® rewrite_thm_tac
	THEN1 PC_T1 "¯_lin_arith" asm_prove_tac[]);
a (CASES_T ¬î¯ 0 <R v +R w ² î¯ 0 = v +R w® rewrite_thm_tac
	THEN TRY (PC_T1 "¯_lin_arith" asm_prove_tac[]));
(* *** Goal "4.3" *** *)
a (LEMMA_T ¬³(î¯ 0 <R v ² î¯ 0 = v)® rewrite_thm_tac
	THEN1 PC_T1 "¯_lin_arith" asm_prove_tac[]);
a (CASES_T ¬î¯ 0 <R v +R w ² î¯ 0 = v +R w® rewrite_thm_tac
	THEN TRY (PC_T1 "¯_lin_arith" asm_prove_tac[]));
(* *** Goal "4.4" *** *)
a (CASES_T ¬î¯ 0 <R v +R w ² î¯ 0 = v +R w® rewrite_thm_tac
	THEN TRY (PC_T1 "¯_lin_arith" asm_prove_tac[]));
val ¯_Abs_Norm_clauses = save_pop_thm "¯_Abs_Norm_clauses";
=TEX

=SML
set_goal([], ¬µx:¯· x ¼R Abs x®);
a (REPEAT strip_tac
	THEN rewrite_tac [get_spec ¬AbsR®]
	THEN cases_tac ¬î¯ 0 ¼R x®
	THEN asm_rewrite_tac[]
	THEN PC_T1 "¯_lin_arith" asm_prove_tac[]);
val ¯_¼_abs_thm = save_pop_thm "¯_¼_abs_thm";
=TEX

=SML
set_goal([], ¬µx:¯· î¯ 0 ¼R x ´ Abs x = x®);
a (REPEAT strip_tac
	THEN rewrite_tac [get_spec ¬AbsR®]
	THEN asm_rewrite_tac []);
val ¯_abs_pos_id_thm = save_pop_thm "¯_abs_pos_id_thm";
=TEX

=SML
set_goal([], ¬µx y:¯· î¯ 0 ¼R x ± x ¼R y ´ Abs x ¼R Abs y®);
a (REPEAT strip_tac
	THEN rewrite_tac [get_spec ¬AbsR®]
	THEN cases_tac ¬î¯ 0 ¼R x®
	THEN cases_tac ¬î¯ 0 ¼R y®
	THEN asm_rewrite_tac[]
	THEN PC_T1 "¯_lin_arith" asm_prove_tac[]);
val ¯_abs_mono_thm = save_pop_thm "¯_abs_mono_thm";
=TEX

=SML
set_goal([], ¬µx y:¯· x ^ 2 = y ^ 2 ´ Abs x = Abs y®);
a (rewrite_tac [¯_î_exp_square_thm, get_spec ¬AbsR®]
	THEN REPEAT strip_tac);
a (cases_tac ¬î¯ 0 ¼R x®
	THEN asm_rewrite_tac[]);
(* *** Goal "1" *** *)
a (cases_tac ¬î¯ 0 ¼R y®
	THEN asm_rewrite_tac[]);
(* *** Goal "1.1" *** *)
a (strip_asm_tac (list_µ_elim [¬y®, ¬x®] ¯_square_eq_thm2)
	THEN asm_rewrite_tac[]);
(* *** Goal "1.2" *** *)
a (all_asm_ante_tac);
a (lemma_tac ¬¶z· y = ~R z®
	THEN1 (¶_tac ¬~R y® THEN rewrite_tac[])
	THEN asm_rewrite_tac[¯_times_minus_thm]
	THEN REPEAT strip_tac);
a (lemma_tac ¬î¯ 0 ¼R z®
	THEN1 (PC_T1 "¯_lin_arith" asm_prove_tac[]));
a (all_fc_tac [¯_square_eq_thm2]
	THEN asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a (all_asm_ante_tac);
a (lemma_tac ¬¶z· x = ~R z®
	THEN1 (¶_tac ¬~R x® THEN rewrite_tac[])
	THEN asm_rewrite_tac[¯_times_minus_thm]
	THEN REPEAT strip_tac);
a (lemma_tac ¬î¯ 0 ¼R z®
	THEN1 (PC_T1 "¯_lin_arith" asm_prove_tac[]));
a (cases_tac ¬î¯ 0 ¼R y®
	THEN asm_rewrite_tac[]);
(* *** Goal "2.1" *** *)
a (strip_asm_tac (list_µ_elim [¬y®, ¬z®] ¯_square_eq_thm2)
	THEN asm_rewrite_tac[]);
(* *** Goal "2.2" *** *)
a (all_asm_ante_tac);
a (lemma_tac ¬¶v· y = ~R v®
	THEN1 (¶_tac ¬~R y® THEN rewrite_tac[])
	THEN asm_rewrite_tac[¯_times_minus_thm]
	THEN REPEAT strip_tac);
a (lemma_tac ¬î¯ 0 ¼R v®
	THEN1 (PC_T1 "¯_lin_arith" asm_prove_tac[]));
a (strip_asm_tac (list_µ_elim [¬v®, ¬z®] ¯_square_eq_thm2)
	THEN asm_rewrite_tac[]);
val ¯_square_eq_abs_thm = pop_thm ();
=TEX

=SML
set_goal([], ¬µx y:¯· Abs x = Abs y ´ x ^ 2 = y ^ 2®);
a (REPEAT µ_tac
	THEN rewrite_tac [get_spec ¬AbsR®]
	THEN cases_tac ¬î¯ 0 ¼R x®
	THEN cases_tac ¬î¯ 0 ¼R y®
	THEN asm_rewrite_tac[]
	THEN strip_tac
	THEN TRY (asm_rewrite_tac[¯_î_exp_square_thm, ¯_times_minus_thm]));
(* *** Goal "1" *** *)
a (POP_ASM_T (rewrite_thm_tac o eq_sym_rule));
a (asm_rewrite_tac[¯_times_minus_thm]);
(* *** Goal "2" *** *)
a (LEMMA_T ¬~R (~R x) = ~R (~R y)® (asm_tac o (rewrite_rule[]))
	THEN1 (pure_asm_rewrite_tac[]
		THEN rewrite_tac[])
	THEN asm_rewrite_tac[]);
val ¯_abs_eq_square_thm = pop_thm ();
=TEX

=SML
set_goal([], ¬µx y:¯· x ^ 2 = y ^ 2 ¤ Abs x = Abs y®);
a (REPEAT strip_tac
	THEN all_fc_tac [¯_square_eq_abs_thm, ¯_abs_eq_square_thm]
	THEN asm_rewrite_tac[]);
val ¯_square_eq_abs_thm = save_pop_thm "¯_square_eq_abs_thm";
=TEX

=SML
set_goal([], ¬µx:¯· Abs (x *R x) = x *R x®);
a (REPEAT strip_tac
	THEN rewrite_tac [get_spec ¬AbsR®]);
a (LEMMA_T ¬î¯ 0 ¼R x *R x® rewrite_thm_tac
	THEN1 (rewrite_tac [¯_prod_sign_iff_clauses]
		THEN PC_T1 "¯_lin_arith" prove_tac[]));
val ¯_abs_square_thm1 = save_pop_thm "¯_abs_square_thm1";
=TEX

=SML
set_goal([], ¬µ x y· x *R x ¼R y *R y ´ Abs x ¼R Abs y®);
a (REPEAT strip_tac
	THEN bc_tac [¯_square_¼_¼_thm]
	THEN TRY (rewrite_tac [¯_Abs_Norm_clauses]));
a (asm_rewrite_tac [top_eq_sym_rule ¯_Abs_Norm_clauses,
	¯_abs_square_thm1]);
val ¯_square_¼_abs_¼_thm = save_pop_thm "¯_square_¼_abs_¼_thm";
=TEX

=SML
set_goal([], ¬µ x y· Abs x ¼R Abs y ´ x *R x ¼R y *R y®);
a (REPEAT strip_tac);
a (lemma_tac ¬î¯ 0 ¼R Abs x®
	THEN1 rewrite_tac [¯_Abs_Norm_clauses]);
a (ALL_FC_T (MAP_EVERY ante_tac) [¯_square_mono_thm1]);
a (rewrite_tac [top_eq_sym_rule ¯_Abs_Norm_clauses,
	¯_abs_square_thm1]);
val ¯_abs_¼_square_¼_thm = save_pop_thm "¯_abs_¼_square_¼_thm";
=TEX

=SML
set_goal([], ¬µ x y· x *R x ¼R y *R y ¤ Abs x ¼R Abs y®);
a (REPEAT µ_tac THEN strip_tac
	THEN rewrite_tac [¯_abs_¼_square_¼_thm, ¯_square_¼_abs_¼_thm]);
val ¯_square_¼_iff_abs_¼_thm = save_pop_thm "¯_square_¼_iff_abs_¼_thm";
=TEX

=SML
set_goal([], ¬µ x y· x *R x <R y *R y ¤ Abs x <R Abs y®);
a (REPEAT strip_tac);
(* *** Goal "1" *** *)
a (lemma_tac ¬AbsR x ¼R AbsR y®);
(* *** Goal "1.1" *** *)
a (lemma_tac ¬x *R x ¼R y *R y®
	THEN1 asm_rewrite_tac [get_spec ¬$¼R®]);
a (bc_tac [¯_square_¼_iff_abs_¼_thm] THEN strip_tac);
(* *** Goal "1.2" *** *)
a (POP_ASM_T ante_tac
	THEN rewrite_tac [get_spec ¬$¼R®]
	THEN REPEAT strip_tac);
a (DROP_NTH_ASM_T 2 ante_tac
	THEN LEMMA_T ¬x *R x = y *R y® rewrite_thm_tac
	THEN1 asm_rewrite_tac [¯_square_eq_iff_abs_eq_thm]);
(* *** Goal "2" *** *)
a (lemma_tac ¬x *R x ¼R y *R y®);
a (lemma_tac ¬Abs x ¼R Abs y®
	THEN1 asm_rewrite_tac [get_spec ¬$¼R®]);
a (bc_tac [¯_abs_¼_square_¼_thm] THEN strip_tac);
(* *** Goal "2.2" *** *)
a (POP_ASM_T ante_tac
	THEN rewrite_tac [get_spec ¬$¼R®]
	THEN REPEAT strip_tac);
a (DROP_NTH_ASM_T 2 ante_tac
	THEN LEMMA_T ¬Abs x = Abs y® rewrite_thm_tac
	THEN1 asm_rewrite_tac [top_eq_sym_rule ¯_square_eq_iff_abs_eq_thm]);
val ¯_square_less_iff_abs_less_thm = save_pop_thm "¯_square_less_iff_abs_less_thm";
=TEX

=SML
set_goal([], ¬µx:¯· Abs (x ^N 2) = x ^N 2®);
a (rewrite_tac [¯_î_exp_square_thm, ¯_abs_square_thm1]);
val ¯_abs_square_thm2 = save_pop_thm "¯_abs_square_thm2";
=TEX

=SML
set_goal([], ¬µx y:¯· Abs (x *R y) = (Abs x) *R (Abs y)®);
a (REPEAT strip_tac
	THEN rewrite_tac [get_spec ¬AbsR®]);
a (cases_tac ¬î¯ 0 ¼R x® THEN cases_tac ¬î¯ 0 ¼R y®
	THEN TRY (asm_rewrite_tac[]));
(* *** Goal "1" *** *)
a (lemma_tac ¬î¯ 0 ¼R x *R y®
	THEN1 (rewrite_tac [¯_prod_sign_iff_clauses]
		THEN contr_tac)
	THEN asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a (cases_tac ¬x = î¯ 0® THEN TRY (asm_rewrite_tac[]));
a (lemma_tac ¬³ î¯ 0 ¼R x *R y®
	THEN1 (rewrite_tac [¯_prod_sign_iff_clauses]
		THEN REPEAT strip_tac
		THEN TRY (PC_T1 "¯_lin_arith" asm_prove_tac[]))
	THEN asm_rewrite_tac[¯_times_minus_thm]);
(* *** Goal "3" *** *)
a (cases_tac ¬y = î¯ 0® THEN TRY (asm_rewrite_tac[]));
a (lemma_tac ¬³ î¯ 0 ¼R x *R y®
	THEN1 (rewrite_tac [¯_prod_sign_iff_clauses]
		THEN REPEAT strip_tac
		THEN TRY (PC_T1 "¯_lin_arith" asm_prove_tac[]))
	THEN asm_rewrite_tac[¯_times_minus_thm]);
(* *** Goal "4" *** *)
a (lemma_tac ¬î¯ 0 ¼R x *R y®
	THEN1 (rewrite_tac [¯_prod_sign_iff_clauses]
		THEN (PC_T1 "¯_lin_arith" asm_prove_tac[]))
	THEN asm_rewrite_tac[¯_times_minus_thm]);
val ¯_abs_prod_thm = save_pop_thm "¯_abs_prod_thm";
=TEX

}%ignore

\subsection{Square Root}

\ignore{
=SML
push_goal ([], ¬¶Sqrt· µ x· î¯ 0 ¼ Sqrt x ± (Sqrt x)^2 = Abs x®);
a(prove_¶_tac THEN strip_tac);
a (lemma_tac ¬î¯ 0 ¼ Abs x'®
	THEN1 (rewrite_tac [¯_0_¼_abs_thm]));
a (all_fc_tac [square_root_thm1]);
a(¶_tac ¬y® THEN asm_rewrite_tac[]);
val _ = xl_set_cs_¶_thm (pop_thm());
=TEX
}%\ignore

¹HOLCONST
Ü ÛSqrtÝ :¯ ­ ¯
÷üüüüüü
Ü µ x· î¯ 0 ¼ Sqrt x 
Ü ± (Sqrt x)^2 = Abs x
°

\ignore{

=SML
set_goal([], ¬µx y:¯· Sqrt x = Sqrt y ´ Abs x = Abs y®);
a (REPEAT strip_tac);
a (LEMMA_T ¬(Sqrt x) ^N 2 = (Sqrt y) ^N 2® ante_tac
	THEN1 asm_rewrite_tac[]);
a (rewrite_tac [get_spec ¬Sqrt®]);
val ¯_sqrt_abs_thm1 = pop_thm ();
=TEX

=SML
set_goal([], ¬µx:¯· Sqrt x = î¯ 0 ¤ x = î¯ 0®);
a (REPEAT strip_tac THEN TRY (asm_rewrite_tac[]));
a (contr_tac THEN lemma_tac ¬î¯ 0 <R Sqrt x ^N 2®
	THEN1 rewrite_tac[get_spec ¬Sqrt®,
	get_spec ¬AbsR®,
	get_spec ¬$¼R®]);
(* *** Goal "1.1" *** *)
a (cases_tac ¬î¯ 0 <R x ² î¯ 0 = x®
	THEN asm_rewrite_tac[]
	THEN PC_T1 "¯_lin_arith" asm_prove_tac[]);
(* *** Goal "1.2" *** *)
a (POP_ASM_T ante_tac
	THEN asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a (strip_asm_tac (rewrite_rule [¯_î_exp_square_thm, ¯_prod_sign_iff_clauses]
	(µ_elim ¬î¯ 0® (get_spec ¬Sqrt®))));
val sqrt_thm1 = save_pop_thm "sqrt_thm1";
=TEX

=SML
set_goal([], ¬µx y:¯· Sqrt (x ^ 2 + y ^ 2) = î¯ 0 ¤ x = î¯ 0 ± y = î¯ 0®);
a (REPEAT µ_tac THEN rewrite_tac [sqrt_thm1]);
a (lemma_tac ¬î¯ 0 ¼ x ^ 2 ± î¯ 0 ¼ y ^ 2®
	THEN1 (rewrite_tac [¯_square_pos_thm]));
a (lemma_tac ¬î¯ 0 ¼ x ^ 2 + y ^ 2®
	THEN1 (all_fc_tac [¯_sum_pos_thm]));
a (LEMMA_T ¬(x ^N 2 + y ^N 2 = î¯ 0)
		= (x ^N 2 = î¯ 0 ± y ^N 2 = î¯ 0)®
	rewrite_thm_tac
	THEN1 (ALL_FC_T1 fc_¤_canon rewrite_tac [¯_sum_zero_thm]));
a (rewrite_tac[¯_î_exp_square_thm, ¯_prod_sign_iff_clauses]);
val sqrt_square_thm = save_pop_thm "sqrt_square_thm";
=TEX
}%\ignore

\ignore{

=SML
set_goal([], ¬µx:¯· Abs(Sqrt x) = Sqrt x
	± Abs (Abs x) = Abs x
	± Abs (î¯ 0) = î¯ 0
	± Abs (~R  x) = Abs x®);
a (REPEAT strip_tac
	THEN TRY (rewrite_tac [get_spec ¬AbsR®, get_spec ¬Sqrt®]));
(* *** Goal "1" *** *)
a (cases_tac ¬î¯ 0 ¼R x®
	THEN asm_rewrite_tac[]);
a (lemma_tac ¬î¯ 0 ¼R ~R x®
	THEN1 (PC_T1 "¯_lin_arith" asm_prove_tac[]));
a (asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a (rewrite_tac [get_spec ¬$¼R®]);
a (strip_asm_tac (list_µ_elim [¬î¯ 0®, ¬x®] ¯_less_cases_thm)
	THEN TRY (asm_rewrite_tac[]));
(* *** Goal "2.1" *** *)
a (LEMMA_T ¬³ (î¯ 0 <R ~R x ² î¯ 0 = ~R x)® rewrite_thm_tac
	THEN1 (PC_T1 "¯_lin_arith" asm_prove_tac[]));
(* *** Goal "2.2" *** *)
a (LEMMA_T ¬x = î¯ 0® rewrite_thm_tac
	THEN1 (PC_T1 "¯_lin_arith" asm_prove_tac[]));
(* *** Goal "2.3" *** *)
a (LEMMA_T ¬î¯ 0 <R ~R x® rewrite_thm_tac
	THEN1 (PC_T1 "¯_lin_arith" asm_prove_tac[]));
a (LEMMA_T ¬³ (î¯ 0 <R x ² î¯ 0 = x)® rewrite_thm_tac
	THEN1 (PC_T1 "¯_lin_arith" asm_prove_tac[]));
val ¯_abs_clauses1 = pop_thm ();
=TEX

=SML
set_goal([], ¬µx:¯· Sqrt (~R x) = Sqrt x®);
a (strip_tac);
a (lemma_tac ¬Sqrt (~R x) ^N 2 = AbsR x®
	THEN1 (strip_asm_tac (µ_elim ¬~R x® (get_spec ¬Sqrt®))
		THEN asm_rewrite_tac[¯_abs_clauses1]));
a (lemma_tac ¬(Sqrt x) ^N 2 = AbsR x®
	THEN1 (strip_asm_tac (µ_elim ¬x® (get_spec ¬Sqrt®))
		THEN asm_rewrite_tac[¯_abs_clauses1]));
a (lemma_tac ¬Sqrt (~R x) ^N 2 = Sqrt x ^N 2®
	THEN1 asm_rewrite_tac[]);
a (ALL_FC_T (MAP_EVERY ante_tac) [¯_square_eq_abs_thm]
	THEN rewrite_tac [¯_abs_clauses1]
	THEN strip_tac);
val ¯_sqrt_minus_thm = save_pop_thm "¯_sqrt_minus_thm";
=TEX

=SML
set_goal([], ¬µx:¯· Sqrt(Abs x) = Sqrt x®);
a (REPEAT strip_tac
	THEN TRY (rewrite_tac [get_spec ¬AbsR®, get_spec ¬Sqrt®]));
a (cases_tac ¬î¯ 0 ¼R x®
	THEN asm_rewrite_tac[¯_sqrt_minus_thm]);
val ¯_sqrt_abs_thm = pop_thm ();
=TEX

=SML
set_goal([], ¬µx:¯· Sqrt(Abs x) = Sqrt x
	± Abs(Sqrt x) = Sqrt x
	± Abs (Abs x) = Abs x
	± Abs (î¯ 0) = î¯ 0
	± Abs (~R  x) = Abs x®);
a (rewrite_tac[¯_abs_clauses1, ¯_sqrt_abs_thm]);
val ¯_abs_clauses = save_pop_thm "¯_abs_clauses";
=TEX

=SML
set_goal([], ¬µx y:¯· Abs x = Abs y ´ Sqrt x = Sqrt y®);
a (REPEAT µ_tac THEN rewrite_tac [get_spec ¬AbsR®]);
a (cases_tac ¬î¯ 0 ¼R x®
	THEN asm_rewrite_tac[]);
(* *** Goal "1" *** *)
a (cases_tac ¬î¯ 0 ¼R y®
	THEN REPEAT strip_tac
	THEN asm_rewrite_tac[¯_sqrt_minus_thm]);
(* *** Goal "2" *** *)
a (cases_tac ¬î¯ 0 ¼R y®
	THEN (asm_rewrite_tac[])
	THEN REPEAT strip_tac
	THEN TRY (asm_rewrite_tac[¯_sqrt_minus_thm]));
(* *** Goal "2.1" *** *)
a (LEMMA_T ¬y = ~R x® rewrite_thm_tac
	THEN1 asm_rewrite_tac[]);
a (rewrite_tac[¯_sqrt_minus_thm]);
(* *** Goal "2.2" *** *)
a (LEMMA_T ¬x = y® rewrite_thm_tac
	THEN1 (PC_T1 "¯_lin_arith" asm_prove_tac[]));
val ¯_sqrt_abs_thm2 = pop_thm ();
=TEX

=SML
set_goal([], ¬µx y:¯· Sqrt x = Sqrt y ¤ Abs x = Abs y®);
a (REPEAT strip_tac THEN all_fc_tac [¯_sqrt_abs_thm1, ¯_sqrt_abs_thm2]);
val ¯_sqrt_abs_thm = save_pop_thm "¯_sqrt_abs_thm";
=TEX

=SML
set_goal([], ¬µx y:¯· î¯ 0 ¼R x ± x ¼R y ´ Sqrt x ¼R Sqrt y®);
a (REPEAT strip_tac
	THEN bc_tac [¯_square_¼_¼_thm]
	THEN TRY (rewrite_tac [rewrite_rule [¯_î_exp_square_thm] (get_spec ¬Sqrt®)])
	THEN all_fc_tac [¯_abs_mono_thm]);
val ¯_sqrt_mono_thm = save_pop_thm "¯_sqrt_mono_thm";
=TEX

=SML
set_goal([], ¬µx:¯· Sqrt (x * x) = Abs x®);
a (strip_tac
	THEN lemma_tac ¬Sqrt (x *R x) ^N 2 = (AbsR x) ^N 2®
	THEN1 (rewrite_tac [rewrite_conv [¯_î_exp_square_thm] ¬(AbsR x) ^N 2®,
		get_spec ¬Sqrt®, get_spec ¬AbsR®, ¯_abs_square_thm1]
		THEN cases_tac ¬î¯ 0 ¼R x®
		THEN asm_rewrite_tac[¯_times_minus_thm]));
a (ALL_ASM_FC_T
	(MAP_EVERY (strip_asm_tac o (rewrite_rule [¯_abs_clauses1])))
	[¯_square_eq_abs_thm]);
val ¯_sqrt_square_thm1 = save_pop_thm "¯_sqrt_square_thm1";
=TEX

=SML
set_goal([], ¬µx:¯· Sqrt (x ^ 2) = Abs x®);
a (REPEAT strip_tac
	THEN rewrite_tac [¯_sqrt_square_thm1, ¯_î_exp_square_thm]);
val ¯_sqrt_square_thm2 = save_pop_thm "¯_sqrt_square_thm2";
=TEX

=SML
set_goal([], ¬µx y:¯· Sqrt (x * y) = Sqrt x * Sqrt y®);
a (REPEAT strip_tac
	THEN lemma_tac ¬(Sqrt x *R Sqrt y) *R (Sqrt x *R Sqrt y)
	 = (Sqrt x *R Sqrt x) *R (Sqrt y *R Sqrt y)®
	THEN1 rewrite_tac [µ_elim ¬Sqrt x® ¯_times_order_thm]);
a (lemma_tac ¬Sqrt x *R Sqrt x = AbsR x®
	THEN1 (rewrite_tac [rewrite_rule [¯_î_exp_square_thm]
			(µ_elim ¬x® (get_spec ¬Sqrt®))]));
a (lemma_tac ¬Sqrt y *R Sqrt y = AbsR y®
	THEN1 (rewrite_tac [rewrite_rule [¯_î_exp_square_thm]
			(µ_elim ¬y® (get_spec ¬Sqrt®))]));
a (DROP_NTH_ASM_T 3 ante_tac);
a (once_asm_rewrite_tac[]);
a (rewrite_tac[eq_sym_rule(rewrite_rule [¯_Abs_Norm_clauses, ¯_î_exp_square_thm]
	((±_right_elim o (µ_elim ¬x *R y®)) (get_spec ¬Sqrt®))),
	rewrite_rule [¯_î_exp_square_thm] ¯_square_eq_abs_thm,
	¯_abs_clauses]);
a (once_rewrite_tac [eq_sym_conv ¬AbsR (Sqrt x *R Sqrt y) = Sqrt (x *R y)®]
	THEN STRIP_T rewrite_thm_tac);
a (rewrite_tac [¯_abs_clauses, ¯_Abs_Norm_clauses]);
val ¯_sqrt_prod_thm = save_pop_thm "¯_sqrt_prod_thm";
=TEX

=SML
set_goal([], ¬µx y:¯· Sqrt(x + y) ¼ (Sqrt x) +R (Sqrt y)®);
a (REPEAT strip_tac);
a (LEMMA_T ¬Sqrt(x + y) = Abs (Sqrt(x + y))
	± (Sqrt x) +R (Sqrt y) = Abs((Sqrt x) +R (Sqrt y))®
	once_rewrite_thm_tac);
(* *** Goal "1" *** *)
a (lemma_tac ¬î¯ 0 ¼R Sqrt (x +R y) ± î¯ 0 ¼R Sqrt x +R Sqrt y®
	THEN1 (rewrite_tac [get_spec ¬Sqrt®]
		THEN bc_tac [¯_sum_pos_thm]
		THEN rewrite_tac [get_spec ¬Sqrt®])
	THEN ALL_FC_T rewrite_tac [¯_abs_pos_id_thm]);
(* *** Goal "2" *** *)
a (bc_tac [¯_square_¼_abs_¼_thm]);
a (rewrite_tac[rewrite_rule [¯_î_exp_square_thm] (get_spec ¬Sqrt®),
	¯_times_plus_distrib_thm]);
a (¯_anf_tac);
a (lemma_tac ¬AbsR (x +R y) ¼R (AbsR x) +R (AbsR y)®
	THEN1 rewrite_tac [¯_Abs_Norm_clauses]);
a (LEMMA_T ¬(AbsR x) +R (AbsR y) ¼R AbsR x +R AbsR y +R î¯ 2 *R Sqrt x *R Sqrt y®
	asm_tac
	THEN1 rewrite_tac [¯_prod_sign_iff_clauses, get_spec ¬Sqrt®]);
a (all_fc_tac [¯_¼_trans_thm]);
val sqrt_plus_thm = save_pop_thm "sqrt_plus_thm"; 
=TEX

}% \ignore

\subsection{List Membership}

=SML
declare_infix(300, "L");
=TEX
¹HOLCONST
Ü $ÛLÝ: 'a ­ 'a  LIST ­ BOOL
÷üüüüüü
Ü µ a b al· (a L [] ¤ F)
Ü	± (a L (Cons b al) ¤ a = b ² a L al)
°
=SML
declare_alias("", ¬$L®);
=TEX

\subsection{Sums of Countable Collections of Reals}

In evaluating the cosmological consequences of Newton's Laws it is desirable to formulate them as cosmological theories in ways which do not prejudge such questions as whether the cardinality of the universe is finite.
To do this it is necessary to be able, where possible, to form the sum of an infinite set of reals, possibly even an uncountably infinite set of real numbers.

For the most general formulations it seems possible that the use of non-standard reals might be needed.
We are concerned here with what can be done with standard reals, i.e. with formalising the notion that some collection of real numbers has a finite sum.

The following definition gives the sum of a possibly finite or countable collection of real numbers.

=SML
declare_infix (300, ">");
=TEX
¹HOLCONST
Ü $Û>Ý : ('a ­ ¯ + ONE) ­ ¯ ­ BOOL
÷üüüüüü
Ü µc r· c > r ¤
Ü	¶s· (µ a n m· IsL (c a) ´ s n = s m ´ n = m)
Ü	´ (Series (Ìn· if IsR (c (s n)) then 0R else OutL (c (s n)))) -> r
°

\section{Group Theory}

=SML
new_parent "group_egs";
=TEX

\subsection{Group Products}

¹HOLCONST
Ü ÛGroupProductÝ : 'a GROUP ­ 'b GROUP ­ ('a ¸ 'b) GROUP
÷üüüüüü
Ü µ G H· GroupProduct G H =
Ü	let car = (Car G ¸ Car H)
Ü	and prod	(la, lb) (ra, rb) = ((la.ra) G, (lb.rb) H)
Ü	and unit = (Unit G, Unit H)
Ü	and inv (a, b) = ((a ~) G, (b ~) H)
Ü	in (car, prod, unit, inv)
°
=SML
declare_alias ("*", ¬GroupProduct®);
=TEX
\ignore{
=SML
val Ûgroup_defÝ = get_spec¬Group®;
val Ûgroup_unit_defÝ = get_spec¬Unit®;
val Ûgp_defÝ = get_spec¬GroupProduct®;
=TEX
=SML
set_goal([], ¬µg:'a GROUP; h:'b GROUP·
	g  Group ± h  Group ´ g * h  Group®);
a(rewrite_tac [get_spec ¬Group®,
	gp_def,
	group_unit_def,
	get_spec ¬$¸®,
	let_def]
	THEN REPEAT strip_tac
	THEN TRY (all_asm_fc_tac[]));
val Ûgroup_product_thmÝ = save_pop_thm "group_product_thm";
=TEX
}%ignore

=GFT
group_product_thm = ô µg:'a GROUP; h:'b GROUP·
	g  Group ± h  Group ´ g * h  Group
=TEX

\subsection{Abelian Groups}

¹HOLCONST
Ü ÛAbelianGroupÝ : 'a GROUP SET
÷üüüüüü
Ü µ G· G  AbelianGroup ¤ G  Group
Ü	± µ u v:'a· u  Car G ± v  Car G
Ü	         ´ (u.v) G = (v.u) G
°

\ignore{
=SML
val Ûabelian_group_defÝ = get_spec¬AbelianGroup®;
set_goal([], ¬µg:'a GROUP; h:'b GROUP·
	g  AbelianGroup ± h  AbelianGroup ±
	Car g = Universe ± Car h = Universe
	´ Car (g * h) = Universe®);
a(rewrite_tac [abelian_group_def,
	group_def,
	gp_def,
	group_unit_def,
	get_spec ¬$¸®,
	let_def]
	THEN REPEAT strip_tac
	THEN TRY (asm_rewrite_tac[sets_ext_clauses]));
val Ûabelian_group_product_lemmaÝ = save_pop_thm "abelian_group_product_lemma";
=TEX

=SML
set_goal([], ¬µg:'a GROUP; h:'b GROUP·
	g  AbelianGroup ± h  AbelianGroup 
	´ (g * h)  AbelianGroup®);
a (rewrite_tac [abelian_group_def]);
a (REPEAT strip_tac);
a (all_asm_fc_tac[group_product_thm]);
a (REPEAT_N 2 (POP_ASM_T ante_tac));
a (asm_rewrite_tac [
	gp_def,
	let_def,
	group_unit_def,
	get_spec ¬$¸®]);
a (REPEAT strip_tac
	THEN all_asm_fc_tac[]);
val Ûabelian_group_product_thmÝ = save_pop_thm "abelian_group_product_thm";
=TEX

=SML
set_goal([], ¬µG:'g GROUP; H:'h GROUP; x y:'g; v w:'h·
	((x,v) . (y, w)) (G * H)
	= ((x . y)G, (v . w)H)®);
a (REPEAT strip_tac
	THEN rewrite_tac [gp_def, let_def, group_unit_def]
	THEN REPEAT strip_tac);
val group_prod_prod_thm = save_pop_thm "group_prod_prod_thm";
=TEX
=SML
set_goal([], ¬µG:'g GROUP; H:'h GROUP; x y:'g ¸ 'h·
	(x . y) (G * H)
	= ((Fst x . Fst y)G, (Snd x . Snd y)H)®);
a (REPEAT strip_tac
	THEN rewrite_tac [gp_def, let_def, group_unit_def]
	THEN REPEAT strip_tac);
val group_prod_prod_thm1 = save_pop_thm "group_prod_prod_thm1";
=TEX

}%ignore

=GFT
abelian_group_product_thm = ô µg:'a GROUP; h:'b GROUP·
	g  AbelianGroup ± h  AbelianGroup ´ (g * h)  AbelianGroup
=TEX

\ignore{
=SML
set_goal([], ¬¯_plus  AbelianGroup®);
a (rewrite_tac [
	get_spec ¬AbelianGroup®,
	¯_plus_ops_thm,
	¯_plus_group_thm
	]);
val ¯_plus_abelian_thm = save_pop_thm "¯_plus_abelian_thm";
=TEX
} %\ignore

=GFT
¯_plus_abelian_thm = ô ¯_plus  AbelianGroup
=TEX

\section{Topology}

=SML
new_parent "topology";
=TEX

\subsection{Bases etc.}

The following definitions belong properly in the theory ``topology''.

First we define the relationship between a $base$ and the topology of which it is a base.

=SML
declare_infix (300, "BaseOf");
=TEX

¹HOLCONST
Ü $ÛBaseOfÝ :  'a SET SET ­ 'a SET SET ­ BOOL
÷üüüüüü
Ü µ base topology· base BaseOf topology ¤
Ü	µs· s  topology ´ ¶ ss· ss  base ± s = Þ ss
°

However, what we really need here is the construction of a topology from an arbitrary set of sets, which is done as follows:

¹HOLCONST
Ü $ÛTopologyFromÝ :  'a SET SET ­ 'a SET SET
÷üüüüüü
Ü µ sets· TopologyFrom sets =
Ü	¥ {topology | topology  Topology ± sets  topology}
°

\ignore{

Prove that $TopologyFrom$ yields a topology.

}%ignore

{\let\Section\section
\def\section#1{\Section{#1}\label{TheoryListing}}
\include{rbjmisc.th}
}  %\let

\twocolumn[\section{INDEX}\label{INDEX}]
{\small\printindex}

\end{document}
=SML
set_flag ("pp_use_alias", true);
output_theory{out_file="rbjmisc.th.doc", theory="rbjmisc"};
set_flag ("pp_use_alias", false);
=TEX