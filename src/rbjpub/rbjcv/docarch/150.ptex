\showboxbreadth=999 \showboxdepth=999
\documentstyle[FM,hol]{article}
\pagestyle{FM}
\setcounter{section}{-1}
\FMtitle{HOL in HOL}
\FMidentity{DS/FMU/RBJ/150}
\FMissue{0.1}
\FMclass{}
\FMdate{\today}
\FMauthor{Roger Bishop Jones}
\FMstatus{Draft}
\FMtype{}
\FMauthority{}
\FMsummary{ }
\FMdistribution{}
\begin{document}
\makeFMfrontpage
\section{Document control}
\subsection{Contents list}
\tableofcontents
\subsection{Document cross references}

\subsection{Changes history}  % to get section number `0.3'

First version.

\subsection{Changes forecast}

Under development, highly incomplete, totally volatile.

\subsection{Abbreviations and notation}
\begin{tabular}{ll}
HOL & Higher Order Logic\\
\end{tabular}
\section{INTRODUCTION}
\subsection{}
\subsection{Introducing the new theory}
Û
extend_theory`ppf150`;;
map loadf [`TAUT`;`infra`];;
lemmas_on := false;;
Ê
We first introduce a new theory with Zermelo Fraenkel (pf137) as a parent.
Definitions theorems and axioms from various ancestors are loaded and bound to ML variable names.
Â
new_theory`ppf150`;;
map new_parent [`string`; `infra`];;
map loadf [`infra`];;
lemmas_on := false;;
Ê
\section{INTRODUCING THE NEW TYPE HOLSYN}
\subsection{The type definition}
Â
new_type 0 `TYPE`;;
new_constant (`mk_vartype`,":string ã TYPE");;
new_constant (`mk_type`,":string â TYPE list ã TYPE");;
let TYPE_axiom = new_axiom(`TYPE_axiom`,"
	É(f0:string ã *) (f1: string â TYPE list ã * list ã *)é
        ¿ (fn:TYPE ã *)é
         (Ésé fn(mk_vartype s) = f0 s) Ä
         (És tlé fn(mk_type (s,tl)) = f1 (s, tl) (map fn tl))
");;
Ê


Â
new_type 0 `FTERM`;;
new_constant (`mk_fvar`,":string â TYPE ã FTERM");;
new_constant (`mk_fconst`,":string â TYPE ã FTERM");;
new_constant (`mk_fcomb`,":FTERM â FTERM  ã FTERM");;
new_constant (`mk_fabs`,":string â TYPE â FTERM  ã FTERM");;

let FTERM_axiom = new_axiom(`FTERM_axiom`,"
	É
	(f0:string â TYPE ã *)
	(f1:string â TYPE ã *)
	(f2: FTERM â FTERM ã * â * ã *)
	(f3: string â TYPE â FTERM ã * ã *)é
        ¿ (fn:FTERM ã *)é
         (És tyé	fn (mk_fvar (s, ty))
			= f0 (s, ty))
	Ä  (És tyé	fn(mk_fconst (s, ty))
			= f1 (s, ty))
	Ä  (Éf aé	fn(mk_fcomb (f, a))
			= f2 (f, a) (fn f, fn a))
	Ä  (Év ty bé	fn(mk_fabs (v, ty, b))
			= f3 (v, ty, b) (fn b))
");;
Ê

»
	dest_fvar: FTERM ã string â TYPE
…
		dest_fvar o mk_fvar = I
À
»
	dest_fconst: FTERM ã string â TYPE
…
		dest_fconst o mk_fconst = I
À
»
	dest_fcomb: FTERM ã FTERM â FTERM
…
		dest_fcomb o mk_fcomb = I
À
»
	dest_fabs: FTERM ã string â TYPE â FTERM
…
		dest_fabs o mk_fabs = I
À
\section{WELL FORMED TERMS}
»
	consistent_vartypes: (string â TYPE ã bool) ã bool
…
	consistent_vartypes sts =
		É(s,t)(s',t')é sts (s,t) Ä sts (s',t') Ä (s = s')
			ä (t = t')
À
»
	freevars_fset: FTERM ã (string â TYPE ã bool)
…
	É(s : string) (t : TYPE) (f : FTERM)
	(a : FTERM) (v : string) (b : FTERM) é
	(freevars_fset (mk_fvar(s,t)) = çxé x = (s,t))
Ä	(freevars_fset (mk_fconst(s,t)) = çxé F)
Ä	(freevars_fset (mk_fcomb(f, a)) =
			(freevars_fset f) ° (freevars_fset a))
Ä	(freevars_fset (mk_fabs(v, t, b)) =
			(freevars_fset b) ƒ çxé x = (v,t))
À
»
	type_of_term: FTERM ã TYPE ã bool
…
	É(s : string) (t : TYPE) (ty: TYPE)
	 (f : FTERM) (a : FTERM) (v : string)
	 (b : FTERM) é
	(type_of_term (mk_fvar(s,t)) ty = (t = ty))
Ä	(type_of_term (mk_fconst(s,t)) ty = (t = ty))
Ä	(type_of_term (mk_fcomb(f, a)) ty = 
		Ñ(t1 : TYPE)é
			(type_of_term f (mk_type(`ã`, [t1; ty])))
		Ä	(type_of_term a t1)
		Ä	((consistent_vartypes o freevars_fset) (mk_fcomb(f, a))))
Ä	(type_of_term (mk_fabs(v, t, b)) ty = 
		Ñ(t1 : TYPE)é
			(type_of_term b t1)
		Ä	(mk_type(`ã`, [t; t1]) = ty)
		Ä	(consistent_vartypes ((freevars_fset b) ° (çxé x = (v,t)))))
À
For comparison, we give a constructive version of
the above (omitting the checks for type consistency of free variables).
The relation {\it type\_of\_term} is actually
a partial function. We use the following gadgets
to define partial functions.
Â
new_type_abbrev(`FAIL`, ":one");;
Ê

»
	FAIL : FAIL
…
	FAIL = one
À

We need the {\it dest\_type} function.
»
	dest_type : TYPE ã (string â TYPE list) + FAIL
…
	(dest_type(mk_vartype s) = INR FAIL)
Ä	(dest_type(mk_type(s, tl)) = INL (s, tl))
À

»
	ctype_of_term: FTERM ã TYPE + FAIL
… 
	É(s : string) (t : TYPE) (ty: TYPE)
	 (f : FTERM) (a : FTERM) (v : FTERM)
	 (b : FTERM) é
	(ctype_of_term (mk_fvar(s,t)) = INL t)
Ä	(ctype_of_term (mk_fconst(s,t)) = INL t)
Ä	(ctype_of_term (mk_fcomb(f, a)) = 
		let tf = ctype_of_term f in
                let ta = ctype_of_term a in
		if ((ISL tf) Ä (ISL ta))
		then (
		let s_tl = dest_type (OUTL tf) in
			if ((ISL s_tl)
			Ä  (FST (OUTL s_tl) = `ã`)
			Ä  (length (SND (OUTL s_tl)) = 2)
			Ä  (HD (SND (OUTL s_tl)) = (OUTL ta)))
			then (INL (HD (TL (SND (OUTL s_tl)))))
			else (INR FAIL))
		else (INR FAIL))
Ä	(ctype_of_term (mk_abs(v, t, b)) =
		let tb =  (ctype_of_term b) in
		if (ISL tb)
		then (INL (mk_type(`ã`, [t; OUTL tb])))
		else (INR FAIL))
À

»
	is_wf_term : FTERM ã bool
…
	Éterm:FTERMé
	is_wf_term term = Ñtype:TYPEé type_of_term term type
À

Â
sim_type_def `TERM` ("x:FTERM, is_wf_term x");;
%let TERM_AXIOM = new_type_definition(`TERM`,
	"p_or_choice is_wf_term",
	TAC_PROOF(([],
	"Ñx:FTERMé (p_or_choice is_wf_term) x"),
	REWRITE_TAC[EXISTS_p_or_choice]));;
let EQ_IMP thm = DISCH_ALL (EQ_MP thm (ASSUME ((lhs o concl) thm)));;
let new_type_lemmas type_axiom =
	let [a1;a2;a3;a4;a5;a6] = prove_new_type_lemmas type_axiom
in	LIST_CONJ [a1;a5;a3; GEN_ALL (EQ_IMP (SPEC_ALL a6));a2;a4];;
let TERM_LEMMAS = save_thm(`TERM_LEMMAS`,new_type_lemmas TERM_AXIOM);;%
Ê
»
	freevars_set : TERM ã (string â TYPE ã bool)
…
	freevars_set = freevars_fset o REP_TERM 
À
»
	mk_var : string â TYPE ã TERM
…
	mk_var = ABS_TERM o mk_fvar 
À
»
	mk_const : string â TYPE ã TERM
…
	mk_const = ABS_TERM o mk_fconst 
À
»
	mk_comb : TERM â TERM ã TERM
…
	mk_comb = (ABS_TERM o mk_fcomb) o ç(x,y)é (REP_TERM x, REP_TERM y)
À
»
	dest_var: TERM ã string â TYPE
…
		dest_var o mk_var = I
À
»
	mk_abs : TERM â TERM ã TERM
…
	mk_abs = (ABS_TERM o mk_fabs) o
			ç(x,y)é (	FST(dest_var x),
					SND(dest_var x),
					REP_TERM y)
À
»
	dest_const: TERM ã string â TYPE
…
		dest_const o mk_const = I
À
»
	dest_comb: TERM ã TERM â TERM
…
		dest_comb o mk_comb = I
À
»
	dest_abs: TERM ã TERM â TERM
…
		dest_abs o mk_abs = I
À

\section{FREE VARIABLES}
»
	type_tyvars :  TYPE ã (string ã bool)
…
		(És:stringé  type_tyvars (mk_vartype s) = çxéx=s)
	Ä	(És tlé type_tyvars (mk_type(s, tl)) =
			£ çxé x ≈ (map term_tyvars tl))
À
»
	term_types :  TERM ã (TYPE ã bool)
…
		(És té term_types (mk_var (s,t)) = çxéx=t)
	Ä	(És té term_types (mk_const (s,t)) = çxéx=t)
	Ä	(Éf aé term_types (mk_comb (f,a)) =
			(term_types f) ° (term_types a))
	Ä	(Év bé term_types (mk_abs(v,b)) =
			(term_types v) ° (term_types b))
À

»
›	image :  (* ã **) ã (* ã bool) ã (** ã bool)
…
›	Éfunction seté image function set = 
›		çx:**é Ñy:*é (x = f y) Ä y ù set
À

»
›	types_tyvars :  (TYPE ã bool) ã (string ã bool)
…
›	Étypesé types_tyvars types =
		£ ((image:  (TYPE ã (string ã bool)) ã (TYPE ã bool) ã ((string ã bool) ã bool))
		type_tvars types)
›		
À

»
	term_tyvars :  TERM ã (string ã bool)
…
	term_tyvars = types_tyvars o term_types
À
»
	terms_tyvars :  (TERM ã bool) ã (string ã bool)
…
	É terms:(TERM ã bool)é
	terms_tyvars terms =
	£ ((image:(TERM ã (string ã bool)) ã (TERM ã bool) ã ((string ã bool) ã bool))
	term_tvars terms)
À
»
	l_t_s :  (* list) ã (* ã bool)
…
	l_t_s s e = e ≈ s
À

\section{TYPE INSTANTIATION}
\subsection{Of Types}
»
	inst_typef : (string ã TYPE) ã TYPE ã TYPE
…
	É(f: string ã TYPE) é
		(Ésé  inst_typef f (mk_vartype s) = f s)
	Ä	(És tléinst_typef f (mk_type(s, tl)) =
			mk_type(s, map (inst_typef f) tl))
À
\subsection{Of Terms}
The problem here is to rename variables in such a way as to prevent identification of previously distinct variables and prevent seperation of previously identical ones.
.LP
This is definitely not trivial, and I havn't yet figured out how to do it.

\ftlinepenalty=1000
»	ran : (* â ** ã bool) ã (** ã bool)
…
	ran f e = Ñxé f (x, e)
À

»
	inst_termf :
		(string ã TYPE)
		% instantiations required %
	ã	(	(string â TYPE ã bool)
		% free variables to avoid clashing with %
		â	((string â TYPE) â (string â TYPE) ã bool)
		% substitutions already done and still relevant %
		â	TERM)
	ã	(	(string â TYPE ã bool)
		â	((string â TYPE) â (string â TYPE) ã bool)
		â 	TERM)
…
	É	(tsubs :string ã TYPE)
		(fvars :string â TYPE ã bool)
		(vsubs :(string â TYPE) â (string â TYPE) ã bool)é
	(És té	
		inst_termf tsubs (fvars, vsubs, (mk_var (s,t)))
		=
		(Ñv'é vsubs ((s,t), v')) =>
			(fvars,
			vsubs,
			mk_var v')
		| (inst_typef tsubs t = t) =>
			((s,t) ù (ran vsubs) =>
			  (let	nn = s % rename it %
			  in		fvars,
			  		(vsubs ° (l_t_s [(s,t),(nn,t)])),
			  		mk_var(nn,t))
			| fvars ° (l_t_s [s,t]),
			  vsubs,
			  mk_var(s,t))
		| 	let nn =
				((s, inst_typef tsubs t) ù (fvars ° (ran vsubs))
				=> s % change to new name for variable %
				| s)
			in	(fvars,
				vsubs ° (l_t_s[(s,t), (nn,inst_typef tsubs t)]),
				mk_var(nn,inst_typef tsubs t)
				)
	)
Ä	(És té	
		inst_termf tsubs (fvars, vsubs, (mk_const (s,t)))
		= 	(fvars,
			vsubs,
			mk_const(s, inst_typef tsubs t)))
Ä	(Éf aé	
		inst_termf tsubs (fvars, vsubs, (mk_comb (f,a)))
		= 	let lr = inst_termf tsubs (fvars, vsubs, f)
			in
			let rr = inst_termf tsubs (FST lr, FST(SND lr), a)
			in
			(FST rr,
			FST(SND rr),
			mk_comb(SND(SND lr),SND(SND rr))))
Ä	(Év bé	
		inst_termf tsubs (fvars, vsubs, (mk_abs (v,b)))
		= 	let lr = inst_termf tsubs (fvars, vsubs, v)
			in
			let rr = inst_termf tsubs (FST lr, FST(SND lr), v)
			in
			(FST rr ƒ ((FST lr) ƒ fvars),
			FST(SND rr),
			mk_abs(SND(SND lr),SND(SND rr))))
À
\section{SUBSTITUTION}

We will give a rather unconstructive formulation of the
notion of substitution.
First we need to define renaming:
{\it rename (v, ty) w e} is the result of changing
all instances of the
variable with name {\it v} and type {\it ty} in the
term {\it e} to have name {\it w}.

»
	rename : (string â TYPE) ã string ã FTERM ã FTERM
…
	É
	(v : string) (ty : TYPE) (w: string)
	(vv :string) (tty : TYPE) (cc : string)
	(ff : FTERM) (aa : FTERM) (bb : FTERM)
	é
	(rename (v, ty) w (mk_fvar(vv, tty)) =
		((v = vv) Ä (ty = tty)) =>
			mk_fvar(w, ty) | mk_fvar(vv, tty))
	Ä
	(rename (v, ty) w (mk_fconst(cc, tty)) =
		mk_fconst(cc, tty))
	Ä
	(rename (v, ty) w (mk_fcomb(ff, aa)) =
		mk_fcomb(rename (v, ty) w ff, rename (v, ty) w aa))
	Ä
	(rename (v, ty) w (mk_fabs(vv, tty, bb)) =
		((v = vv) Ä (ty = tty)) =>
			mk_fabs(vv, tty, bb) | mk_fabs(vv, tty, rename (v, ty) w bb))
À

We will need to  test when two terms are
$\alpha$-convertible:

»
	aconv : FTERM ã FTERM ã bool
…
	É(t1 : FTERM) (t2 : FTERM)é
	aconv t1 t2 =
		(t1 = t2)
	Å	(Ñt1f t1a t2f t2aé
			(t1 = mk_fcomb(t1f, t1a))
		Ä	(t2 = mk_fcomb(t2f, t2a))
		Ä	(aconv t1f t2f Ä aconv t1a t2a))
	Å	(Ñv1 v2 ty b1 b2é
			(t1 = mk_fabs(v1, ty, b1))
		Ä	(t2 = mk_fabs(v2, ty, b2))
		Ä	aconv t1 (mk_fabs(v1, ty, rename (v2, ty) v1 b2)))

À

We will need to choose new variable names:
»
	new_var : TYPE ã (string â TYPE ã bool) ã string
…
	É ty vs é (new_var ty vs, ty) ì vs 
À

Now we can define {\it subst}. {\it subst F t1} gives the
term resulting from replacing every free variable
in {\it t1} by its ``image under {\it F}'' with bound
variables renamed as necessary to avoid capture.
Variables which are not to be changed correspond
to pairs $(s, t)$ with $\it F (s, t) =  mk\_fvar (s, t)$.


»

	subst : (string â TYPE ã FTERM) ã FTERM ã FTERM
…
	É
	(v : string) (ty : TYPE) (c : string)
	(f : FTERM) (a : FTERM) (b : FTERM)
	é
	(subst R (mk_fvar(v, ty)) = R (v,ty))
	Ä
	(subst R (mk_fconst(c, ty)) = mk_fconst(c, ty))
	Ä
	(subst R (mk_fcomb(f, a)) =
		mk_fcomb(subst R f, subst R a))
	Ä
	(subst R (mk_fabs(v, ty, b)) =
		let RR = çxé (x = (v, ty)) => (mk_fvar x) | R x
		in 	if( Ñwé
				(w à (v, ty))
			Ä	((v, ty) ù freevars_fset (RR w))
			Ä	(w ù freevars_fset b)
			)then(	let new_frees =
	£(image (freevars_fset o RR) (freevars_fset b))
				in let v' = new_var ty new_frees
				in let RRR = çxé (x = (v', ty)) => (mk_fvar x) | RR x
				in
	mk_fabs(v', ty, subst RRR (rename (v, ty) v' b))
			)else(
	mk_fabs(v, ty, subst RR b)))
À

The inference rule {\tt SUBST} may readily be
defined in terms of the above function.

\section{SEQUENTS}
Â
new_type_abbrev(`SEQ`, ":(TERM) list â TERM");;
Ê
\section{PROOFS}
Â
new_type 0 `FPROOF`;;
new_constant (`mk_fAXp`,":SEQ ã FPROOF");;
new_constant (`mk_fASSUMEp`,":TERM ã FPROOF");;
new_constant (`mk_fREFLp`,":TERM ã FPROOF");;
new_constant (`mk_fBETA_CONVp`,":TERM ã FPROOF");;
new_constant (`mk_fSUBSTp`,
	":(FPROOF â TERM)list ã TERM ã FPROOF ã FPROOF");;
new_constant (`mk_fABSp`,":TERM ã FPROOF ã FPROOF");;
new_constant (`mk_fINST_TYPEp`,
	":(TYPE â TYPE)list ã FPROOF ã FPROOF");;
new_constant (`mk_fDISCHp`,":TERM ã FPROOF ã FPROOF");;
new_constant (`mk_fMPp`,":FPROOF ã FPROOF ã FPROOF");;

let FPROOF_axiom = new_axiom(`FPROOF_axiom`,"
	É
	(fAXf:SEQ ã *)
	(fASSUMEf:TERM ã *)
	(fREFLf:TERM ã *)
	(fBETA_CONVf:TERM ã *)
	(fSUBSTf:(FPROOF â TERM)list ã TERM ã FPROOF ã (*)list ã * ã *)
	(fABSf:TERM ã FPROOF ã * ã *)
	(fINST_TYPEf:(TYPE â TYPE)list ã FPROOF ã * ã *)
	(fDISCHf:TERM ã FPROOF ã * ã *)
	(fMPf:FPROOF ã FPROOF ã * ã * ã *)é
        ¿ (fn:FPROOF ã *)é
         (Éseqé	fn (mk_fAXp seq)
			= fAXf s)
	Ä  (Étermé	fn(mk_fASSUMEp term)
			= fASSUMEf term)
	Ä  (Étermé	fn(mk_fREFLp term)
			= fREFLf term)
	Ä  (Étermé	fn(mk_fBETA_CONVp term)
			= fBETA_CONVf term)
	Ä  (Éfptl term fproofé
		fn(mk_fSUBSTp fptl term fproof)
			= fSUBSTf fptl term fproof
				(map (fn o FST) fptl) (fn fproof))
	Ä  (Éterm fproofé
		fn(mk_fABSp term fproof)
			= fABSf term fproof (fn fproof))
	Ä  (Éttl fproofé
		fn(mk_fINST_TYPEp ttl fproof)
			= fINST_TYPEf ttl fproof (fn fproof))
	Ä  (Éterm fproofé
		fn(mk_fDISCHp term fproof)
			= fDISCHf term fproof (fn fproof))
	Ä  (Éfproof1 fproof2é
		fn(mk_fMPp fproof1 fproof2)
			= fMPf fproof1 fproof2 (fn fproof1) (fn fproof2))
");;
Ê

\section{THEORIES}

We have already defined the type environment part of
a theory. A theory also has both a constant environment
and a bunch  of axioms:

Â
new_type_abbrev(`TY_ENV`, ":string ã num ã bool");;

new_type_abbrev(`CON_ENV`, ":string ã TYPE ã bool");;

new_type_abbrev(`SEQS`, ":SEQ ã bool");;
Ê

«Õ`THEORY``T`ÕÕÕÕÕÕÕÕÕÕﬂ
›name		:string,
›parents	:string ã bool,
›ty_env	:TY_ENV,
›con_env	:CON_ENV,
›extensions	:SEQS,
›axioms	:SEQS,
›theorems	:SEQS
…ÕÕÕÕÕÕÕÕÕÕÕÕ
›T
 ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕ‡
Â
new_type_abbrev(`FTHEORIES`, ":THEORY list");;
Ê
\section{THE THEORY}
\section{SEMANTIC DOMAINS}
\begin{enumerate}
\item{}
Mono-types are sets (objects of type SET).
\item{}
A type variable assignment is a map from strings to Mono-types (SETS).
\item{}
A type constant assignment is a map from (string X SET list) to SET.
\item{}
Monomorphic individuals are elements of SET.
\item{}
Polmorphic values are maps from type variable assignments to Monomorphic values.
\item{}
A variable assignment is a map from string to polymorphic value.
\item{}
A constant assignment is a map from string to polymorphic value.
\end{enumerate}

\section{ISSUES}
\subsection{Changes to the Language}
I am strongly tempted to make some adjustments to the language.
The strongest temptation I have is to outlaw overloading of variable names.
Some but not all of the above specs are written on that assumption.
I am also tempted to have term formation rules which are independent of the theory environment (i.e. allow constants to be used before declaration).
Also to allow overloading of constants.
(rules for conservative extension permitting sets of constant definitions provided the types used are pairwise non-unifiable).
\subsection{Formalisation}
I would like to avoid having FAILure results on all functions which are not certain to succeed, but am not sure whether they can be avoided.
The reason is to keep the specification simple.
Where a function is normally used in circumstances when its arguments are known to be satisfactory, I think it is better to use a version which does not have failure codes in it.
To make this possible as consistently as possible I think functions with failure results should be used only where absolutely necessary.
This corresponds to programming in ML by checking with "is\_?" before doing "dest\_?" instead of going ahead regardless and then trapping the exception.
Trapping exceptions is easier in ML but more complicated in HOL.

\begin{FT}{}
% \input{/escher/usr2/rbj/ppf/ppf150.th.prt}
\end{FT}
\end{document}
