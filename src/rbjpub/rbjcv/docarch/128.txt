.nr PS 11
.nr VS 14
.so /escher/usr2/projects/infra/msmacros/roff.defs
.so /escher/usr2/projects/infra/msmacros/roff2.defs
.RP
.TL
Pure function theory part 2
.AU
Roger Bishop Jones
.AI
ICL Defence Systems
.AB
.LP
This document consists of the second part of a pure theory of (partial) functions.
.AE
.ds LH 
.ds CH PF in HOL part 2
.ds RH \*(DY Page \\n(PN
.ds LF DBC/FMU/RBJ/128   Issue 0.1
.ds CF PF in HOL part 2
.ds RF Page \\n(PN
.ig cx
extend_theory`pf128`;;
loadf`/escher/usr2/projects/infra/pholfiles/TAUT`;;
map load_definitions [`zf120`;`zf122`;`pf123`;`pf128`];;
map load_theorems [`zf120`;`zf122`;`pf123`;`pf128`];;
map load_axioms [`zf120`;`zf122`;`pf123`;`pf128`];;
map delete_cache [`zf120`;`zf122`;`pf123`;`pf128`];;
let NOT_FORALL_TAC = REWRITE_TAC[NOT_FORALL] THEN BETA_TAC;;
let PURE_NOT_FORALL_TAC = PURE_REWRITE_TAC[NOT_FORALL] THEN BETA_TAC;;
let NOT_EXISTS_TAC = REWRITE_TAC[NOT_EXISTS] THEN BETA_TAC;;
let PURE_NOT_EXISTS_TAC = PURE_REWRITE_TAC[NOT_EXISTS] THEN BETA_TAC;;
let NEW_GOAL_TAC t = RMP_TAC t THENL [STRIP_TAC; ALL_TAC];;
let new_goal t = expand (NEW_GOAL_TAC t);;
let NEW_GOAL_PROOF_TAC t p = RMP_TAC t THENL [STRIP_TAC THEN p; ALL_TAC];;
let new_goal_proof t p = expand (NEW_GOAL_PROOF_TAC t p);;
let MASSUMP = map ASSUMP;;
let OREWRITE_TAC t = REWRITE_TAC[t];;
.cx
.LP
.KS
.NH
INTRODUCTION
.LP
.hd
new_theory`pf128`;;
new_parent`pf123`;;
loadf`/escher/usr2/projects/infra/pholfiles/TAUT`;;
map load_definitions [`zf120`;`zf122`;`pf123`];;
map load_theorems [`zf120`;`zf122`;`pf123`];;
map load_axioms [`zf120`;`zf122`;`pf123`];;
map delete_cache [`zf120`;`zf122`;`pf123`];;
let NOT_FORALL_TAC = REWRITE_TAC[NOT_FORALL] THEN BETA_TAC;;
let PURE_NOT_FORALL_TAC = PURE_REWRITE_TAC[NOT_FORALL] THEN BETA_TAC;;
let NOT_EXISTS_TAC = REWRITE_TAC[NOT_EXISTS] THEN BETA_TAC;;
let PURE_NOT_EXISTS_TAC = PURE_REWRITE_TAC[NOT_EXISTS] THEN BETA_TAC;;
let NEW_GOAL_TAC t = RMP_TAC t THENL [STRIP_TAC; ALL_TAC];;
let new_goal t = expand (NEW_GOAL_TAC t);;
let NEW_GOAL_PROOF_TAC t p = RMP_TAC t THENL [STRIP_TAC THEN p; ALL_TAC];;
let new_goal_proof t p = expand (NEW_GOAL_PROOF_TAC t p);;
let MASSUMP = map ASSUMP;;
let OREWRITE_TAC t = REWRITE_TAC[t];;
.he
.KE
.NH
FUNCTIONAL ABSTRACTION
.LP
.hd
let fabs_DEF = new_definition(`fabs_DEF`,"(fabs:SETã(SETãSET)ãSET) d val =
		áx:SETé Éy:SETé
	y ù x = Ñ(v:SET)(w:SET)é (w à ¥) Ä (y = v ó w) Ä (w = val v) Ä (v ù d)
");;
.he
.hd
let ptptsts_DEF = new_definition(`ptptsts_DEF`,"
	(ptptsts:(PFãPF)ã(SETãSET)) val = çs:SETé REP_PF (val (ABS_PF s))
");;
.he
.hd
let sabs_DEF = new_definition(`sabs_DEF`,"
	(sabs:PFã(PFãPF)ãSET) d val = fabs (domain (REP_PF d)) (ptptsts val)
");;
.he
.hd
let abs_DEF = new_definition(`abs_DEF`,"
	(abs:PFã(PFãPF)ãPF) d val =	ABS_PF (sabs d val)
");;
.he
.LP
.hd
set_goal([],"
	É(x:SET)(d:SET)(val:SETãSET)é (x = fabs d val) =
		Éy:SETé
	y ù x = Ñ(v:SET)(w:SET)é (w à ¥) Ä (y = v ó w) Ä (w = val v) Ä (v ù d)
");;
expand (REPEAT GEN_TAC);;
lemma "Ñ(x:SET)é Éy:SETé
	y ù x = Ñ(v:SET)(w:SET)é (w à ¥) Ä (y = v ó w) Ä (w = val v) Ä (v ù d)";;
  lemma_proof "Ñ(x:SET)é É(y:SET)é y ù x = Ñ(z:SET)é z ù d Ä (y = val z)"
		[REWRITE_TAC [ZF_thm26]];;
  expand (EXISTS_TAC "sep (d ™ s) ç(y:SET)é
	Ñ(v:SET)(w:SET)é (w à ¥) Ä (y = v ó w) Ä (w = val v) Ä (v ù d)");;
  expand (GEN_TAC THEN ASM_REWRITE_TAC [ZF2] THEN BETA_TAC);;
  expand (TAUT_REWRITE_TAC "(a Ä b = b) = b ä a" THEN STRIP_TAC);;
  expand (ASM_REWRITE_TAC [ZF2_thm27]);;
  expand (EXISTS_TAC "v:SET" THEN EXISTS_TAC "(val:SETãSET) v"
		THEN ASM_REWRITE_TAC[]);;
  expand (EXISTS_TAC "v:SET" THEN ASM_REWRITE_TAC[]);;
expand (ASM_REWRITE_TAC[fabs_DEF]);;
expand (IMP_RES_TAC (BETA_RULE (SPEC "ç(x:SET)é Éyé
     y ù x =
     (Ñv wé w à ¥ Ä (y = v ó w) Ä (w = val v) Ä v ù d)"
	(INST_TYPE [":SET",":*"] SELECT_AX))));;
expand (ASM_REWRITE_TAC [ZF_le1]);;
let PFB01 = save_top_thm `PFB01`;;
.he
.hd
set_goal([],"
	É(x:SET)(d:SET)(val:SET ã SET)é x ù (fabs d val)
		= Ñv wé w à ¥ Ä (x = v ó w) Ä (w = val v) Ä v ù d
");;
expand (REWRITE_TAC [REWRITE_RULE []
		(SPECL["fabs d val";"d:SET";"val:SET ã SET"] PFB01)]);;
let PFB02 = save_top_thm `PFB02`;;
.he
.hd
set_goal([],"
	É(d:SET)(val:SET ã SET)é function (fabs d val)
");;
expand (REWRITE_TAC [function] THEN REPEAT STRIP_TAC);;
expand (REWRITE_TAC [relation; PFB02] THEN REPEAT STRIP_TAC);;
expand (EVERY (map EXISTS_TAC ["v:SET";"w:SET"]) THEN ASM_REWRITE_TAC[]);;
lemma_proof "(Ñv w'é
        w' à ¥ Ä
        (y ó w = v ó w') Ä
        (w' = val v) Ä
        v ù d) Ä
	(Ñv wé w à ¥ Ä (y ó z = v ó w) Ä (w = val v) Ä v ù d)"
	[DEF_RES_TAC PFB02;	ASM_REWRITE_TAC[]];;
expand (DEF_RES_TAC ZF2_thm3 THEN ASM_REWRITE_TAC []);;
expand (REWRITE_TAC (map (SYM o ASSUMP) ["y = v'";"y = v"]));;
let PFB03 = save_top_thm `PFB03`;;
.he
.hd
set_goal([],"
	É(d:SET)(val:SET ã SET)é ¥ ì (image (fabs d val))
");;
expand (REWRITE_TAC [image_DEF; ì_DEF; ZF2; ZF6; PFB02; NE_DEF; ZF2_thm3]);;
expand BETA_TAC;;
expand (TAUT_REWRITE_TAC "å(a Ä b) = åa Å åb" THEN REPEAT STRIP_TAC);;
expand (EVERY[DISJ2_TAC; REPEAT (CHANGED_TAC NOT_EXISTS_TAC)]);;
expand (TAUT_REWRITE_TAC "å(åa Ä (b Ä c) Ä d Ä e) = b Ä c Ä d Ä e ä a"
	THEN REPEAT STRIP_TAC THEN ASM_REWRITE_TAC[]);;
let PFB04 = save_top_thm `PFB04`;;
.he
.hd
set_goal([],"
	É(d:PF)(val:PF ã PF)é ¥ ì (image (sabs d val))
");;
expand (REWRITE_TAC [sabs_DEF; PFB04]);;
let PFB05 = save_top_thm `PFB05`;;
.he
.LP
Prove that sabs yields a function.
.hd
set_goal([],"
	É(d:PF)(val:PF ã PF)é function (sabs d val)
");;
expand (REWRITE_TAC [sabs_DEF; PFB03]);;
let PFB06 = save_top_thm `PFB06`;;
.he
.hd
set_goal([],"
	É(x:SET)(d:SET)(val:SETãSET)é x ù d ä
		((val x à ¥) = (x ù (domain(fabs d val))))
");;
expand (REWRITE_TAC [domain_DEF; PFB02; ZF2; ZF6]);;
expand (BETA_TAC THEN REPEAT STRIP_TAC);;
expand (EQ_TAC THEN REPEAT STRIP_TAC);;

expand (EXISTS_TAC "pair x ((val:SET ãSET) x)");;
expand (ASM_REWRITE_TAC [ZF5]);;
expand (EXISTS_TAC "x ó ((val:SET ãSET) x)");;
expand (REWRITE_TAC [ZF_le5]);;
expand (EXISTS_TAC "x:SET" THEN EXISTS_TAC "(val:SET ãSET) x"
	THEN ASM_REWRITE_TAC[]);;

expand (EVERY (map EXISTS_TAC
		["(val:SET ãSET) x"; "x:SET"; "(val:SET ãSET) x"])
	THEN ASM_REWRITE_TAC[]);;

expand (DEF_RES_TAC ZF2_thm3);;
expand (ASM_REWRITE_TAC []);;
expand (REWRITE_TAC [SYM (ASSUMP "w' = (val:SET ãSET) v'")]);;
expand (ASM_REWRITE_TAC[]);;

let PFB07 = save_top_thm `PFB07`;;
.he
.hd
set_goal([],"
	É(d:SET)(val:SETãSET)(x:SET)é x ù d ä
		(function_application (fabs d val) x = val x)
");;
expand (REPEAT STRIP_TAC);;
expand (ASM_CASES_TAC "x ù domain (fabs d val)");;
expand (ASSUME_TAC (SPEC_ALL PFB03) THEN IMP_RES_TAC
		(SPECL ["fabs d val";"x:SET";"(val:SETãSET) x"] PF_t13));;
expand (ASM_REWRITE_TAC[PFB02]);;
expand (EVERY (map EXISTS_TAC ["x:SET";"(val:SETãSET) x"]) THEN ASM_REWRITE_TAC[]);;
expand (IMP_RES_TAC PFB07 THEN ASM_REWRITE_TAC[]);;
expand (IMP_RES_TAC PFB07 THEN ASM_REWRITE_TAC[function_application_DEF]);;
expand (REWRITE_TAC [REWRITE_RULE
	[NE_DEF; SYM (ASSUMP "(val x) à ¥ = x ù (domain(fabs d val))")]
	(ASSUMP "åx ù (domain(fabs d val))")]);;
let PFB08 = save_top_thm `PFB08`;;
.he
.hd
set_goal([],"
	É(x:SET)(y:SET)é pure_function x Ä pure_function y ä
		((ABS_PF x = ABS_PF y) = (x = y))
");;
expand (REPEAT STRIP_TAC);;
lemma_proof "Ñv:PFé x = REP_PF v"
	[DEF_RES_TAC (CONJUNCT2 DEF_PF)];;
lemma_proof "Ñw:PFé y = REP_PF w"
	[DEF_RES_TAC (CONJUNCT2 DEF_PF)];;
expand (ASM_REWRITE_TAC[PF_t11; PF_t09]);;
let PFB09 = save_top_thm `PFB09`;;
.he
.hd
set_goal([],"
	É(d:PF)(z:PF)é (d ≤ z) à ¥≤ ä
		Ñ(w:SET)é pure_function w Ä (((REP_PF z) ó w) ù (REP_PF d))
");;
expand (REWRITE_TAC [NE_DEF; ≤_DEF; lift_binop_DEF; PF_t26] THEN BETA_TAC);;
.he
.sv "HOL output"
"Éd zé
  å(ABS_PF(function_application(REP_PF d)(REP_PF z)) = ABS_PF ¥) ä
  (Ñwé pure_function w Ä ((REP_PF z) ó w) ù (REP_PF d))"
.sw
.hd
new_goal "Éd zé
  å(function_application(REP_PF d)(REP_PF z) = ¥) ä
  (Ñwé pure_function w Ä ((REP_PF z) ó w) ù (REP_PF d))";;

  lemma "É(d:PF)(z:PF)é(ABS_PF(function_application(REP_PF d)(REP_PF z))
				= ABS_PF ¥)
	= (function_application(REP_PF d)(REP_PF z) = ¥)";;

    expand (REPEAT STRIP_TAC);;
    lemma "pure_function (function_application(REP_PF d)(REP_PF z))
		Ä pure_function ¥";;
      expand (REWRITE_TAC [PF_t17]);;
	lemma_proof "pure_function (REP_PF d) Ä pure_function (REP_PF z)"
			[REWRITE_TAC [PF_t19]];;
      expand (IMP_RES_TAC PF_t18);;
    expand (IMP_RES_TAC PFB09);;
  expand (ASM_REWRITE_TAC[]);;
.he
.sv "HOL output"
"Éd zé
  å(function_application(REP_PF d)(REP_PF z) = ¥) ä
  (Ñwé pure_function w Ä ((REP_PF z) ó w) ù (REP_PF d))"
.sw
.hd
expand (REPEAT STRIP_TAC);;
lemma "(REP_PF z) ù domain (REP_PF d)";;
  lemma "É(x:SET)(y:SET)éå(function_application x y = ¥) ä y ù domain x";;
    expand (TAUT_REWRITE_TAC "åa ä b = åb ä a"
		THEN REWRITE_TAC [PF_t24]);;
  expand RES_TAC;;
  lemma "Ñq:SETé ((REP_PF z) ó q) ù (REP_PF d)";;
  expand (ACCEPT_TAC (REWRITE_RULE [ZF2_thm11]
		(ASSUMP "(REP_PF z) ù (domain(REP_PF d))")));;
expand (EXISTS_TAC "q:SET" THEN ASM_REWRITE_TAC []);;
.he
.sv "HOL output"
"pure_function q"
    [ "å(function_application(REP_PF d)(REP_PF z) = ¥)" ]
    [ "(REP_PF z) ù (domain(REP_PF d))" ]
    [ "((REP_PF z) ó q) ù (REP_PF d)" ]
.sw
.hd
lemma "pure_function (REP_PF d) Ä q ù field (REP_PF d)";;

  expand (STRIP_TAC THEN REWRITE_TAC [PF_t19]);;
  expand (EVERY [	REWRITE_TAC [field_DEF; ZF_thm10];
			DISJ2_TAC;
			REWRITE_TAC [ZF2_thm13];
			EXISTS_TAC "REP_PF z"; 
			ASM_REWRITE_TAC[]]);;
expand (IMP_RES_TAC PF_t06);;
let PFB10 = save_top_thm `PFB10`;;
.he
.hd
set_goal([],"
	É(d:PF)(y:PF)é ((d ≤ y) à ¥≤) ä (REP_PF y) ù domain (REP_PF d)
");;
expand (REPEAT STRIP_TAC);;
lemma_proof "Ñwé pure_function w Ä ((REP_PF y) ó w) ù (REP_PF d)"
		[IMP_RES_TAC PFB10];;
expand (REWRITE_TAC [domain_DEF; ZF2; ZF6]);;
expand (BETA_TAC THEN STRIP_TAC);;
expand (EXISTS_TAC "unit (REP_PF y)" THEN STRIP_TAC);;
expand (EXISTS_TAC "(REP_PF y) ó w");;
expand (ASM_REWRITE_TAC [] THEN REWRITE_TAC [ó_DEF; ZF_le4]);;
expand (REWRITE_TAC [ZF_thm9]);;
expand (EXISTS_TAC "w:SET" THEN ASM_REWRITE_TAC[]);;
let PFB11 = save_top_thm `PFB11`;;
.he
.hd
set_goal([],"
	É(x:PF)(y:PF)(z:PF)é ((x ≤ y) à ¥≤) ä
		(((x ≤ y) = z) = ((REP_PF y) ó (REP_PF z)) ù (REP_PF x))
");;
expand (REPEAT STRIP_TAC);;
expand (IMP_RES_TAC PFB11);;
expand (REWRITE_TAC [≤_DEF; lift_binop_DEF]);;
expand BETA_TAC;;
expand (ONCE_REWRITE_TAC [PF_t09]);;
lemma "pure_function (function_application(REP_PF x)(REP_PF y))";;
  lemma_proof "pure_function (REP_PF x) Ä pure_function(REP_PF y)"
		[REWRITE_TAC [PF_t19]];;
  expand (IMP_RES_TAC PF_t18);;
expand (IMP_RES_THEN OREWRITE_TAC PF_t10);;
lemma_proof "pure_function (REP_PF x)" [REWRITE_TAC [PF_t19]];;
expand (IMP_RES_THEN OREWRITE_TAC PF_t14);;
let PFB12 = save_top_thm `PFB12`;;
.he
.hd
set_goal([],"
	É(d:PF)(e:PF)(f:PF)é
	(ABS_PF(function_application(REP_PF d)(REP_PF e)) = f)
	= (function_application(REP_PF d)(REP_PF e) = REP_PF f)
");;
expand (REWRITE_TAC [PF_t09] THEN REPEAT GEN_TAC);;
lemma "pure_function (function_application(REP_PF d)(REP_PF e))";;
  lemma_proof "pure_function (REP_PF d) Ä pure_function (REP_PF e)"
		[REWRITE_TAC [PF_t19]];;
  expand (IMP_RES_TAC PF_t18);;
expand (IMP_RES_THEN OREWRITE_TAC PF_t10);;
let PFB13 = save_top_thm `PFB13`;;
.he
.hd
set_goal([],"
	É(d:PF)(e:PF)(f:SET)é pure_function f ä
	((ABS_PF(function_application(REP_PF d)(REP_PF e)) = ABS_PF f)
	= (function_application(REP_PF d)(REP_PF e) = f))
");;
expand (REPEAT STRIP_TAC THEN REWRITE_TAC [PFB13]);;
expand (IMP_RES_THEN OREWRITE_TAC PF_t10);;
let PFB14 = save_top_thm `PFB14`;;
.he
.hd
set_goal([],"
	É(x:SET)(d:PF)(val:PF ã PF)é x ù (sabs d val) ä
		(d ≤ (ABS_PF (fst x))) à ¥≤
");;
expand (REWRITE_TAC [sabs_DEF; PFB02; ptptsts_DEF; domain_DEF;
	ZF2; ZF6; NE_DEF; ≤_DEF; PF_t26; lift_binop_DEF]);;
expand (BETA_TAC THEN REPEAT GEN_TAC THEN STRIP_TAC);;
expand (ASSUME_TAC PF_t17 THEN IMP_RES_THEN OREWRITE_TAC PFB14);;
.he
.hd
lemma "function_application(REP_PF d)(REP_PF(ABS_PF(fst x))) = z''";;
  expand (ASM_REWRITE_TAC[ZF2_thm1]);;
  lemma_proof "pure_function (REP_PF d)" [REWRITE_TAC[PF_t19]];;
  lemma "v ù (domain (REP_PF d))";;
    expand (REWRITE_TAC [domain_DEF; ZF2; ZF6]);;
    expand (BETA_TAC THEN STRIP_TAC);;
    expand (EXISTS_TAC "z:SET" THEN ASM_REWRITE_TAC[]);;
    expand (EXISTS_TAC "z':SET" THEN ASM_REWRITE_TAC[]);;
    expand (EXISTS_TAC "z'':SET" THEN ASM_REWRITE_TAC[]);;
.he
.hd
  lemma "pure_function v";;
    lemma "v ù (field (REP_PF d))";;
	expand (REWRITE_TAC[field_DEF; domain_DEF; ZF2; ZF6; ZF_thm10]);;
	expand (DISJ1_TAC THEN BETA_TAC THEN STRIP_TAC);;
	expand (EXISTS_TAC "z:SET" THEN ASM_REWRITE_TAC[]);;
	expand (EXISTS_TAC "z':SET" THEN ASM_REWRITE_TAC[]);;
	expand (EXISTS_TAC "z'':SET" THEN ASM_REWRITE_TAC[]);;
    expand (IMP_RES_TAC PF_t06);;
  expand (IMP_RES_THEN OREWRITE_TAC PF_t10);;
  expand (IMP_RES_THEN OREWRITE_TAC PF_t14);;
  expand (ASM_REWRITE_TAC[]);;
.he
.hd
expand (ASM_REWRITE_TAC[]);;
lemma_proof "pure_function (REP_PF d)" [REWRITE_TAC[PF_t19]];;
lemma_proof "¥ ì (image (REP_PF d))" [IMP_RES_TAC PF_t05];;
lemma "z'' ù (image (REP_PF d))";;
  expand (REWRITE_TAC [image_DEF; ZF2; ZF6]);;
  expand (BETA_TAC THEN STRIP_TAC);;
  expand (EXISTS_TAC "pair (v:SET) (z'':SET)" THEN REWRITE_TAC[ZF_le4]);;
  expand (EXISTS_TAC "(v:SET) ó (z'':SET)"
		THEN ASM_REWRITE_TAC[ó_DEF;ZF_le4]);;
  expand (EXISTS_TAC "v:SET" THEN ASM_REWRITE_TAC[]);;
.he
.hd
expand STRIP_TAC;;
expand (UNDISCH_TAC "¥ ì (image(REP_PF d))" THEN REWRITE_TAC [ì_DEF]);;
expand (ACCEPT_TAC (REWRITE_RULE [ASSUMP "z'' = ¥"]
		(ASSUMP "z'' ù (image(REP_PF d))")));;
let PFB15 = save_top_thm `PFB15`;;
.he
.hd
set_goal([],"
	É(x:SET)(d:PF)(val:PF ã PF)é x ù (sabs d val) ä
		(ABS_PF (snd x)) à ¥≤
");;
expand (REWRITE_TAC [sabs_DEF; PFB02; ptptsts_DEF; domain_DEF;
	ZF2; ZF6; NE_DEF; ≤_DEF; PF_t26; lift_binop_DEF]);;
expand (BETA_TAC THEN REPEAT GEN_TAC THEN STRIP_TAC);;
lemma_proof "pure_function w Ä pure_function ¥"
	[ASM_REWRITE_TAC[PF_t19; PF_t17]];;
lemma_proof "snd x = w" [ASM_REWRITE_TAC [ZF2_thm2]];;
expand (REWRITE_TAC[ASSUMP "snd x = w"]
		THEN IMP_RES_THEN OREWRITE_TAC PFB09);;
expand (ACCEPT_TAC (ASSUMP "å(w = ¥)"));;
let PFB16 = save_top_thm `PFB16`;;
.he
.hd
set_goal([],"
	É(x:SET)(d:PF)(val:PF ã PF)é x ù (sabs d val) ä
		(unit x = REP_PF (ABS_PF(fst x) ó≤ ABS_PF(snd x)))
");;
expand (REWRITE_TAC [sabs_DEF; PFB02; ptptsts_DEF; domain_DEF;
	ZF2; ZF6; NE_DEF; ≤_DEF; PF_t26; lift_binop_DEF]);;
expand (BETA_TAC THEN REPEAT STRIP_TAC);;
expand (ASM_REWRITE_TAC[ZF2_thm1; ZF2_thm2; ó≤_DEF;
		lift_binop_DEF; unit_map_DEF]);;
expand (BETA_TAC);;
lemma_proof "pure_function (REP_PF (val (ABS_PF v)))"
		[REWRITE_TAC [PF_t19]];;
expand (IMP_RES_THEN OREWRITE_TAC PF_t10);;
expand (REWRITE_TAC [SYM (ASSUMP "w = REP_PF(val(ABS_PF v))");
		ASSUMP "å(w = ¥)"]);;
.he
.hd
lemma "pure_function v";;
  lemma_proof "pure_function (REP_PF d)" [REWRITE_TAC [PF_t19]];;
  expand (IMP_RES_TAC PF_t06);;
  lemma "v ù field (REP_PF d)";;
    expand (ASM_REWRITE_TAC
		[field_DEF; domain_DEF; ZF2; ZF6; ZF_thm10]);;
    expand (EVERY[DISJ1_TAC; BETA_TAC; STRIP_TAC]);;
    expand (EXISTS_TAC "z:SET" THEN ASM_REWRITE_TAC[ZF6]);;
    expand (EXISTS_TAC "z':SET" THEN ASM_REWRITE_TAC[ZF6]);;
    expand (EXISTS_TAC "z'':SET" THEN ASM_REWRITE_TAC[ZF6]);;
  expand RES_TAC;;
.he
.sv "HOL output"
"unit(v ó w) = REP_PF(ABS_PF(unit((REP_PF(ABS_PF v)) ó w)))"
    [ "å(w = ¥)" ]
    [ "x = v ó w" ]
    [ "w = REP_PF(val(ABS_PF v))" ]
    [ "z' ù (REP_PF d)" ]
    [ "z ù z'" ]
    [ "v ù z" ]
    [ "(v ó z'') ù (REP_PF d)" ]
    [ "pure_function(REP_PF(val(ABS_PF v)))" ]
    [ "pure_function v" ]
.sw
.hd
expand (IMP_RES_THEN OREWRITE_TAC PF_t10);;
lemma_proof "pure_function w" [ASM_REWRITE_TAC[]];;
lemma_proof "pure_function (unit_map v w)" [IMP_RES_TAC PF_t23];;
expand (REWRITE_TAC [REWRITE_RULE [unit_map_DEF]
		(ASSUMP "pure_function(unit_map v w)")]);;
lemma "pure_function (unit (v ó w))";;
  lemma_proof "w à ¥"
	[REWRITE_TAC [NE_DEF] THEN ACCEPT_TAC (ASSUMP "å(w = ¥)")];;
  expand (IMP_RES_TAC PF_t16);;
lemma_proof "REP_PF(ABS_PF(unit(v ó w))) = unit(v ó w)"
			[IMP_RES_TAC PF_t10];;
expand (ASM_REWRITE_TAC[]);;
let PFB17 = save_top_thm `PFB17`;;
.he
.hd
set_goal([],"
	É(x:SET)(d:PF)(val:PF ã PF)é x ù (sabs d val) ä
		(ABS_PF (snd x) = val (ABS_PF (fst x)))
");;
expand (REWRITE_TAC [sabs_DEF; PFB02; ptptsts_DEF; domain_DEF;
	ZF2; ZF6; NE_DEF; ≤_DEF; PF_t26; lift_binop_DEF]);;
expand (BETA_TAC THEN REPEAT STRIP_TAC);;
expand (ASM_REWRITE_TAC [ZF2_thm1; ZF2_thm2]);;
expand (REWRITE_TAC [PF_t11]);;
let PFB18 = save_top_thm `PFB18`;;
.he
.hd
set_goal([],"
	É(x:SET)(d:PF)(val:PF ã PF)é(x ù (sabs d val) ä
	Ñ(y:PF)(z:PF)é z à ¥≤ Ä (unit x = REP_PF (y ó≤ z))
		Ä (z = val y) Ä ((d ≤ y) à ¥≤)) 
");;
expand (EVERY([REPEAT STRIP_TAC;
		EXISTS_TAC "ABS_PF (fst x)";
		EXISTS_TAC "ABS_PF (snd x)"] @
		(map (IMP_RES_THEN OREWRITE_TAC)
			[PFB15; PFB16; PFB17; PFB18])));;
let PFB19 = save_top_thm `PFB19`;;
.he
.hd
set_goal([],"
	É(x:SET)(d:PF)(val:PF ã PF)é
	(Ñ(y:PF)(z:PF)é z à ¥≤ Ä (unit x = REP_PF (y ó≤ z))
		Ä (z = val y) Ä ((d ≤ y) à ¥≤))
	ä	x ù (sabs d val)
");;
expand (REWRITE_TAC [sabs_DEF; PFB02; ptptsts_DEF; domain_DEF;
	ZF2; ZF6; NE_DEF]);;
expand (EVERY[BETA_TAC; REPEAT STRIP_TAC]);;
expand (EXISTS_TAC "REP_PF y" THEN EXISTS_TAC "REP_PF z"
	THEN ASM_REWRITE_TAC[PF_t11] THEN REPEAT STRIP_TAC);;
.he
.hd
expand (UNDISCH_TAC "å(z = ¥≤)"
	THEN ASM_REWRITE_TAC [PF_t26]);;
expand (REWRITE_TAC [PF_t11; SYM (ASSUMP "REP_PF(val y) = ¥")]);;
.he
.hd
expand (UNDISCH_TAC "unit x = REP_PF(y ó≤ z)"
		THEN REWRITE_TAC [ó≤_DEF; lift_binop_DEF; unit_map_DEF]);;
expand (BETA_TAC);;
lemma "å(REP_PF z = ¥)";;
  expand (UNDISCH_TAC "å(z = ¥≤)" THEN REWRITE_TAC [PF_t26]);;
  expand (TAUT_REWRITE_TAC "åa ä åb = b ä a" THEN STRIP_TAC);;
  expand (REWRITE_TAC [SYM (ASSUMP "REP_PF z = ¥"); PF_t11]);;
expand (ASM_REWRITE_TAC[]);;
.he
.hd
lemma "pure_function (unit((REP_PF y) ó (REP_PF(val y))))";;
  lemma_proof "pure_function (REP_PF y) Ä pure_function (REP_PF(val y))"
	[REWRITE_TAC [PF_t19]];;
  lemma "(REP_PF(val y)) à ¥";;
    expand (REWRITE_TAC [NE_DEF; SYM (ASSUMP "z = val y")]);;
    expand (UNDISCH_TAC "å(z = ¥≤)"
		THEN REWRITE_TAC [PF_t26]);;
    expand (TAUT_REWRITE_TAC "å a ä å b = b ä a"
		THEN STRIP_TAC
		THEN REWRITE_TAC [SYM (ASSUME "REP_PF z = ¥"); PF_t11]);;
  expand (IMP_RES_TAC PF_t16);;
.he
.hd
expand (IMP_RES_THEN OREWRITE_TAC PF_t10);;
expand (REWRITE_TAC [ZF_le13]);;
.he
.hd
lemma_proof "(d ≤ y) à ¥≤" [ASM_REWRITE_TAC[NE_DEF]];;
lemma_proof "Ñwé pure_function w Ä ((REP_PF y) ó w) ù (REP_PF d)"
	[IMP_RES_TAC PFB10];;
expand (EXISTS_TAC "pair (REP_PF y) w" THEN REWRITE_TAC [ZF_le4]);;
expand (EXISTS_TAC "(REP_PF y) ó w" THEN ASM_REWRITE_TAC [ZF_le5]);;
.he
.hd
lemma_proof "(d ≤ y) à ¥≤" [ASM_REWRITE_TAC[NE_DEF]];;
lemma_proof "Ñwé pure_function w Ä ((REP_PF y) ó w) ù (REP_PF d)"
	[IMP_RES_TAC PFB10];;
expand (EXISTS_TAC "w:SET" THEN ASM_REWRITE_TAC[]);;
let PFB20 = save_top_thm `PFB20`;;
.he
.hd
set_goal([],"
		É(x:SET)(d:PF)(val:PF ã PF)é(x ù (sabs d val) =
	Ñ(y:PF)(z:PF)é z à ¥≤ Ä (unit x = REP_PF (y ó≤ z))
		Ä (z = val y) Ä ((d ≤ y) à ¥≤)) 
");;
expand (REPEAT GEN_TAC THEN EQ_TAC THEN REWRITE_TAC[PFB19; PFB20]);;
let PFB21 = save_top_thm `PFB21`;;
.he
.hd
set_goal([],"
	É(z:PF)(d:PF)(f:PFãPF)é (REP_PF z) ù domain(sabs d f)
	ä (function_application(sabs d f)(REP_PF z) = REP_PF(f z))
");;
expand (REPEAT STRIP_TAC);;
lemma_proof "function (sabs d f)" [REWRITE_TAC [PFB06]];;
expand (IMP_RES_THEN OREWRITE_TAC PF_t13);;
.he
.sv "HOL output"
"((REP_PF z) ó (REP_PF(f z))) ù (sabs d f)"
    [ "(REP_PF z) ù (domain(sabs d f))" ]
    [ "function(sabs d f)" ]
.sw
.hd
expand (UNDISCH_TAC "(REP_PF z) ù (domain(sabs d f))"
	THEN REWRITE_TAC [domain_DEF; ZF2; ZF6; PFB21]
	THEN BETA_TAC THEN REPEAT STRIP_TAC);;
.he
.sv "HOL output"
"Ñy z'é
  z' à ¥≤ Ä
  (unit((REP_PF z) ó (REP_PF(f z))) = REP_PF(y ó≤ z')) Ä
  (z' = f y) Ä
  (d ≤ y) à ¥≤"
    [ "function(sabs d f)" ]
    [ "z' à ¥≤" ]
    [ "unit z'' = REP_PF(y ó≤ z')" ]
    [ "z' = f y" ]
    [ "(d ≤ y) à ¥≤" ]
    [ "z' ù z''" ]
    [ "(REP_PF z) ù z'" ]
    [ "z'''' à ¥≤" ]
    [ "unit((REP_PF z) ó z''') = REP_PF(y' ó≤ z'''')" ]
    [ "z'''' = f y'" ]
    [ "(d ≤ y') à ¥≤" ]
.sw
.hd
expand (EXISTS_TAC "y':PF" THEN ASM_REWRITE_TAC[]);;
expand (EXISTS_TAC "z'''':PF" THEN ASM_REWRITE_TAC[]);;
.he
.sv "HOL output"
"unit((REP_PF z) ó (REP_PF(f z))) = REP_PF(y' ó≤ (f y'))"
    [ "function(sabs d f)" ]
    [ "z' à ¥≤" ]
    [ "unit z'' = REP_PF(y ó≤ z')" ]
    [ "z' = f y" ]
    [ "(d ≤ y) à ¥≤" ]
    [ "z' ù z''" ]
    [ "(REP_PF z) ù z'" ]
    [ "z'''' à ¥≤" ]
    [ "unit((REP_PF z) ó z''') = REP_PF(y' ó≤ z'''')" ]
    [ "z'''' = f y'" ]
    [ "(d ≤ y') à ¥≤" ]
.sw
.hd
lemma "(z:PF) = y'";;
  expand (UNDISCH_TAC "unit((REP_PF z) ó z''') = REP_PF(y' ó≤ z'''')"
	THEN ASM_REWRITE_TAC[]);;
  expand (REWRITE_TAC[ó≤_DEF; unit_map_DEF; lift_binop_DEF]);;
  expand BETA_TAC;;
  lemma "å(REP_PF(f y') = ¥)";;
    expand (REWRITE_TAC [SYM  (ASSUMP "z'''' = f y'")]);;
    expand (MP_TAC (REWRITE_RULE [NE_DEF; PF_t26](ASSUMP "z'''' à ¥≤")));;
    expand (TAUT_REWRITE_TAC "åa ä åb = b ä a" THEN STRIP_TAC
	THEN REWRITE_TAC [SYM (ASSUME "REP_PF z'''' = ¥"); PF_t11]);;
  expand (ASM_REWRITE_TAC[]);;
.he
.sv "HOL output"
"(unit((REP_PF z) ó z''') =
  REP_PF(ABS_PF(unit((REP_PF y') ó (REP_PF(f y')))))) ä
 (z = y')"
    [ "function(sabs d f)" ]
    [ "z' à ¥≤" ]
    [ "unit z'' = REP_PF(y ó≤ z')" ]
    [ "z' = f y" ]
    [ "(d ≤ y) à ¥≤" ]
    [ "z' ù z''" ]
    [ "(REP_PF z) ù z'" ]
    [ "z'''' à ¥≤" ]
    [ "z'''' = f y'" ]
    [ "(d ≤ y') à ¥≤" ]
    [ "å(REP_PF(f y') = ¥)" ]
.sw
.hd
lemma "pure_function (unit((REP_PF y') ó (REP_PF(f y'))))";;
  lemma_proof "pure_function (REP_PF y')
		Ä pure_function (REP_PF ((f:PFãPF) y'))"
	[REWRITE_TAC [PF_t19]];;
  lemma "(REP_PF ((f:PFãPF) y')) à ¥";;
    expand (REWRITE_TAC[NE_DEF]);;
    expand (REWRITE_TAC [SYM  (ASSUMP "z'''' = f y'")]);;
    expand (MP_TAC (REWRITE_RULE [NE_DEF; PF_t26](ASSUMP "z'''' à ¥≤")));;
    expand (TAUT_REWRITE_TAC "åa ä åb = b ä a" THEN STRIP_TAC
	THEN REWRITE_TAC [SYM (ASSUME "REP_PF z'''' = ¥"); PF_t11]);;
  expand (IMP_RES_TAC PF_t16);;
.he
.hd
expand (IMP_RES_THEN OREWRITE_TAC PF_t10);;
expand (REWRITE_TAC [ZF_le13; ZF2_thm3; PF_t09] THEN TAUT_TAC);;
.he
.sv "HOL output"
"unit((REP_PF z) ó (REP_PF(f z))) = REP_PF(y' ó≤ (f y'))"
    [ "function(sabs d f)" ]
    [ "z' à ¥≤" ]
    [ "unit z'' = REP_PF(y ó≤ z')" ]
    [ "z' = f y" ]
    [ "(d ≤ y) à ¥≤" ]
    [ "z' ù z''" ]
    [ "(REP_PF z) ù z'" ]
    [ "z'''' à ¥≤" ]
    [ "unit((REP_PF z) ó z''') = REP_PF(y' ó≤ z'''')" ]
    [ "z'''' = f y'" ]
    [ "(d ≤ y') à ¥≤" ]
    [ "z = y'" ]
.sw
.hd
expand (ASM_REWRITE_TAC[ó≤_DEF; lift_binop_DEF; unit_map_DEF]);;
expand (BETA_TAC);;
lemma "å(REP_PF(f y') = ¥)";;
  expand (REWRITE_TAC [SYM  (ASSUMP "z'''' = f y'")]);;
  expand (MP_TAC (REWRITE_RULE [NE_DEF; PF_t26](ASSUMP "z'''' à ¥≤")));;
  expand (TAUT_REWRITE_TAC "åa ä åb = b ä a" THEN STRIP_TAC
	THEN REWRITE_TAC [SYM (ASSUME "REP_PF z'''' = ¥"); PF_t11]);;
expand (ASM_REWRITE_TAC[]);;
lemma "pure_function (unit((REP_PF y') ó (REP_PF(f y'))))";;
  lemma_proof "pure_function (REP_PF y')
		Ä pure_function (REP_PF ((f:PFãPF) y'))"
	[REWRITE_TAC [PF_t19]];;
  lemma "(REP_PF ((f:PFãPF) y')) à ¥";;
    expand (REWRITE_TAC[NE_DEF]);;
    expand (REWRITE_TAC [SYM  (ASSUMP "z'''' = f y'")]);;
    expand (MP_TAC (REWRITE_RULE [NE_DEF; PF_t26](ASSUMP "z'''' à ¥≤")));;
    expand (TAUT_REWRITE_TAC "åa ä åb = b ä a" THEN STRIP_TAC
	THEN REWRITE_TAC [SYM (ASSUME "REP_PF z'''' = ¥"); PF_t11]);;
  expand (IMP_RES_TAC PF_t16);;
.he
.hd
expand (IMP_RES_THEN OREWRITE_TAC PF_t10);;
let PFB22 = save_top_thm `PFB22`;;
.he
.LP
We now prove that sabs yields a pure function.
.hd
set_goal([],"
	É(d:PF)(val:PF ã PF)é pure_function (sabs d val)
");;
expand (REPEAT GEN_TAC THEN TMP_TAC (SPEC "sabs d val"
	(REWRITE_RULE [function_hereditary_DEF] PF_t01)));;
expand (REWRITE_TAC [PFB06; PFB05]);;
expand (REWRITE_TAC [field_DEF; ZF_thm10; domain_DEF;
		image_DEF; ZF2; ZF6]);;
expand (BETA_TAC THEN REPEAT STRIP_TAC);;
.he
.hd
lemma_proof "Ñy zé
        z à ¥≤ Ä
        (unit(x ó z'') = REP_PF(y ó≤ z)) Ä
        (z = val y) Ä
        (d ≤ y) à ¥≤" [DEF_RES_TAC PFB21];;
lemma "x = REP_PF y";;
  expand (UNDISCH_TAC "unit(x ó z'') = REP_PF(y ó≤ z''')"
		THEN REWRITE_TAC [ó≤_DEF; unit_map_DEF; lift_binop_DEF]);;
  expand BETA_TAC;;
  lemma "å(REP_PF z''' = ¥)";;
    expand (UNDISCH_TAC "z''' à ¥≤" THEN REWRITE_TAC [NE_DEF; PF_t26]
		THEN TAUT_REWRITE_TAC "åa ä åb = b ä a"
		THEN STRIP_TAC);;
    expand (REWRITE_TAC [SYM (ASSUMP "REP_PF z''' = ¥"); PF_t11]);;
  expand (ASM_REWRITE_TAC[]);;
.he
.hd
  lemma "pure_function (unit((REP_PF y) ó (REP_PF(val y))))";;
    lemma_proof "pure_function (REP_PF y) Ä pure_function (REP_PF(val y))"
		[REWRITE_TAC [PF_t19]];;
    lemma "(REP_PF(val y)) à ¥";;
      expand (REWRITE_TAC [NE_DEF; SYM (ASSUMP "z''' = val y")]);;
      expand (UNDISCH_TAC "(z''' à ¥≤)"
		THEN REWRITE_TAC [NE_DEF; PF_t26]);;
      expand (TAUT_REWRITE_TAC "å a ä å b = b ä a"
		THEN STRIP_TAC
		THEN REWRITE_TAC [SYM (ASSUME "REP_PF z''' = ¥"); PF_t11]);;
    expand (IMP_RES_TAC PF_t16);;
.he
.hd
  expand (IMP_RES_THEN OREWRITE_TAC PF_t10);;
  expand (REWRITE_TAC [ZF_le13; ZF2_thm3]);;
  expand TAUT_TAC;;
expand (ASM_REWRITE_TAC [PF_t19]);;
.he
.hd
lemma_proof "Ñy zé
        z à ¥≤ Ä
        (unit(z'' ó x) = REP_PF(y ó≤ z)) Ä
        (z = val y) Ä
        (d ≤ y) à ¥≤" [DEF_RES_TAC PFB21];;
lemma "x = REP_PF z'''";;
  expand (UNDISCH_TAC "unit(z'' ó x) = REP_PF(y ó≤ z''')"
		THEN REWRITE_TAC [ó≤_DEF; unit_map_DEF; lift_binop_DEF]);;
  expand BETA_TAC;;
  lemma "å(REP_PF z''' = ¥)";;
    expand (UNDISCH_TAC "z''' à ¥≤" THEN REWRITE_TAC [NE_DEF; PF_t26]
		THEN TAUT_REWRITE_TAC "åa ä åb = b ä a"
		THEN STRIP_TAC);;
    expand (REWRITE_TAC [SYM (ASSUMP "REP_PF z''' = ¥"); PF_t11]);;
  expand (ASM_REWRITE_TAC[]);;
.he
.hd
  lemma "pure_function (unit((REP_PF y) ó (REP_PF(val y))))";;
    lemma_proof "pure_function (REP_PF y) Ä pure_function (REP_PF(val y))"
		[REWRITE_TAC [PF_t19]];;
    lemma "(REP_PF(val y)) à ¥";;
      expand (REWRITE_TAC [NE_DEF; SYM (ASSUMP "z''' = val y")]);;
      expand (UNDISCH_TAC "(z''' à ¥≤)"
		THEN REWRITE_TAC [NE_DEF; PF_t26]);;
      expand (TAUT_REWRITE_TAC "å a ä å b = b ä a"
		THEN STRIP_TAC
		THEN REWRITE_TAC [SYM (ASSUME "REP_PF z''' = ¥"); PF_t11]);;
    expand (IMP_RES_TAC PF_t16);;
.he
.hd
  expand (IMP_RES_THEN OREWRITE_TAC PF_t10);;
  expand (REWRITE_TAC [ZF_le13; ZF2_thm3]);;
  expand TAUT_TAC;;
expand (ASM_REWRITE_TAC [PF_t19]);;
.he
.hd
let PFB23 = save_top_thm `PFB23`;;
.he
.NH 2
Lemmas for proving beta reduction
.LP
.NH 2
Beta reduction
.LP
The most important property of abstraction is the validity of beta-reduction:
.hd
set_goal([],"
	É(d:PF)(z:PF)é
	(d ≤ z) à ¥≤ = (REP_PF z) ù (domain (REP_PF d))
");;
expand (REPEAT STRIP_TAC THEN EQ_TAC);;
expand (REWRITE_TAC [PFB11]);;
expand (REWRITE_TAC[domain_DEF; ZF2; ZF6; NE_DEF; PF_t26;
		≤_DEF; lift_binop_DEF]);;
expand (BETA_TAC THEN STRIP_TAC);;
.he
.sv "HOL output"
"å(ABS_PF(function_application(REP_PF d)(REP_PF z)) = ABS_PF ¥)"
    [ "z'' ù (REP_PF d)" ]
    [ "z' ù z''" ]
    [ "(REP_PF z) ù z'" ]
    [ "((REP_PF z) ó z''') ù (REP_PF d)" ]
.sw
.hd
lemma "pure_function (function_application(REP_PF d)(REP_PF z))";;
  lemma_proof "pure_function (REP_PF d) Ä pure_function (REP_PF z)"
		[REWRITE_TAC [PF_t19]];;
  expand (IMP_RES_TAC PF_t18);;
expand (ASSUME_TAC PF_t17 THEN IMP_RES_THEN OREWRITE_TAC PFB09);;
.he
.sv "HOL output"
"å(function_application(REP_PF d)(REP_PF z) = ¥)"
    [ "z'' ù (REP_PF d)" ]
    [ "z' ù z''" ]
    [ "(REP_PF z) ù z'" ]
    [ "((REP_PF z) ó z''') ù (REP_PF d)" ]
    [ "pure_function(function_application(REP_PF d)(REP_PF z))" ]
    [ "pure_function ¥" ]
.sw
.hd
lemma_proof "pure_function (REP_PF d)" [REWRITE_TAC [PF_t19]];;
expand (IMP_RES_THEN (OREWRITE_TAC o SYM o (REWRITE_RULE [NE_DEF]))
	PF_t12);;
expand (REWRITE_TAC [domain_DEF; ZF2; ZF6]);;
expand (BETA_TAC THEN STRIP_TAC);;
expand (EXISTS_TAC "z':SET" THEN ASM_REWRITE_TAC[]);;
expand (EXISTS_TAC "z'':SET" THEN ASM_REWRITE_TAC[]);;
expand (EXISTS_TAC "z''':SET" THEN ASM_REWRITE_TAC[]);;
let PFB24 = save_top_thm `PFB24`;;
.he
.hd
set_goal([],"
	É(d:PF)(f:PFãPF)(z:PF)é
		(REP_PF z) ù (domain (sabs d f)) =
			(REP_PF z) ù (domain (REP_PF d)) Ä ((f z) à ¥≤)
");;
expand (REPEAT GEN_TAC THEN REWRITE_TAC [SYM (SPEC_ALL PFB24)]);;
expand (REWRITE_TAC [NE_DEF; domain_DEF; ZF2; ZF6; PF_t26; PFB21]
	THEN BETA_TAC);;
expand (REPEAT STRIP_TAC THEN EQ_TAC THEN REPEAT STRIP_TAC);;
.he
.sv "HOL output"
.sw
.hd
expand (UNDISCH_TAC "å(d ≤ y' = ABS_PF ¥)");;
lemma "(y':PF) = z";;
  expand (UNDISCH_TAC "unit((REP_PF z) ó z''') = REP_PF(y' ó≤ z'''')");;
  expand (REWRITE_TAC [ó≤_DEF; lift_binop_DEF; unit_map_DEF]
	THEN BETA_TAC);;
  lemma "å (REP_PF z'''' = ¥)";;
    expand (UNDISCH_TAC "å(z'''' = ABS_PF ¥)"
		THEN TAUT_REWRITE_TAC "åa ä åb = b ä a"
		THEN STRIP_TAC
		THEN REWRITE_TAC [SYM (ASSUME "REP_PF z'''' = ¥"); PF_t11]);;
  expand (ASM_REWRITE_TAC[]);;
  lemma "pure_function (unit((REP_PF y') ó (REP_PF((f:PF ã PF) y'))))";;
    lemma_proof "pure_function (REP_PF y')
	Ä pure_function (REP_PF ((f:PF ã PF) y'))"
		[REWRITE_TAC [PF_t19]];;
    lemma "(REP_PF((f:PF ã PF) y') à ¥)";;
      expand (REWRITE_TAC
	  [NE_DEF;
	  SYM (ASSUMP "z'''' = (f:PF ã PF) y'")]);;
      expand (UNDISCH_TAC "å(z'''' = ABS_PF ¥)"
		THEN TAUT_REWRITE_TAC "åa ä åb = b ä a"
		THEN STRIP_TAC
		THEN REWRITE_TAC [SYM (ASSUME "REP_PF z'''' = ¥"); PF_t11]);;
    expand (IMP_RES_TAC PF_t16);;
  expand (IMP_RES_THEN OREWRITE_TAC PF_t10);;
  expand (REWRITE_TAC[ZF_le13; ZF2_thm3]);;
  expand (REWRITE_TAC[GEN_ALL (SYM (SPEC_ALL PF_t09))]);;
  expand (REPEAT STRIP_TAC THEN ASM_REWRITE_TAC[]);;
expand (ASM_REWRITE_TAC[]);;
.he
.sv "HOL output"
"F"
    [ "å(z' = ABS_PF ¥)" ]
    [ "unit z'' = REP_PF(y ó≤ z')" ]
    [ "z' = (f:PF ã PF) y" ]
    [ "å(d ≤ y = ABS_PF ¥)" ]
    [ "z' ù z''" ]
    [ "(REP_PF z) ù z'" ]
    [ "å(z'''' = ABS_PF ¥)" ]
    [ "unit((REP_PF z) ó z''') = REP_PF(y' ó≤ z'''')" ]
    [ "z'''' = (f:PF ã PF) y'" ]
    [ "å(d ≤ y' = ABS_PF ¥)" ]
    [ "(f:PF ã PF) z = ABS_PF ¥" ]
.sw
.hd
lemma "(y':PF) = z";;
  expand (UNDISCH_TAC "unit((REP_PF z) ó z''') = REP_PF(y' ó≤ z'''')");;
  expand (REWRITE_TAC [ó≤_DEF; lift_binop_DEF; unit_map_DEF]
	THEN BETA_TAC);;
  lemma "å (REP_PF z'''' = ¥)";;
    expand (UNDISCH_TAC "å(z'''' = ABS_PF ¥)"
		THEN TAUT_REWRITE_TAC "åa ä åb = b ä a"
		THEN STRIP_TAC
		THEN REWRITE_TAC [SYM (ASSUME "REP_PF z'''' = ¥"); PF_t11]);;
  expand (ASM_REWRITE_TAC[]);;
  lemma "pure_function (unit((REP_PF y') ó (REP_PF((f:PF ã PF) y'))))";;
    lemma_proof "pure_function (REP_PF y')
	Ä pure_function (REP_PF ((f:PF ã PF) y'))"
		[REWRITE_TAC [PF_t19]];;
    lemma "(REP_PF((f:PF ã PF) y') à ¥)";;
      expand (REWRITE_TAC
	  [NE_DEF;
	  SYM (ASSUMP "z'''' = (f:PF ã PF) y'")]);;
      expand (UNDISCH_TAC "å(z'''' = ABS_PF ¥)"
		THEN TAUT_REWRITE_TAC "åa ä åb = b ä a"
		THEN STRIP_TAC
		THEN REWRITE_TAC [SYM (ASSUME "REP_PF z'''' = ¥"); PF_t11]);;
    expand (IMP_RES_TAC PF_t16);;
  expand (IMP_RES_THEN OREWRITE_TAC PF_t10);;
  expand (REWRITE_TAC[ZF_le13; ZF2_thm3]);;
  expand (REWRITE_TAC[GEN_ALL (SYM (SPEC_ALL PF_t09))]);;
  expand (REPEAT STRIP_TAC THEN ASM_REWRITE_TAC[]);;
expand (UNDISCH_TAC "å(z'''' = ABS_PF ¥)"
	THEN ASM_REWRITE_TAC[]);;
.he
.sv "HOL output"
"Ñz:SETé
  (Ñz':SETé
    (Ñy:PF z:PFé
      å(z = ABS_PF ¥) Ä
      (unit z' = REP_PF(y ó≤ z)) Ä
      (z = (f:PF ã PF) y) Ä
      å(d ≤ y = ABS_PF ¥)) Ä
    z ù z') Ä
  (REP_PF z) ù z"
    [ "å(d ≤ z = ABS_PF ¥)" ]
    [ "å((f:PF ã PF) z = ABS_PF ¥)" ]
.sw
.hd
expand (EXISTS_TAC "pair (REP_PF z) (REP_PF ((f:PF ã PF) z))"
	THEN REWRITE_TAC [ZF_le4]);;
expand (EXISTS_TAC "(REP_PF z) ó (REP_PF ((f:PF ã PF) z))"
	THEN REWRITE_TAC [ZF_le5]);;
expand (EXISTS_TAC "z:PF" THEN ASM_REWRITE_TAC[]);;
expand (EXISTS_TAC "(f:PFãPF) z" THEN ASM_REWRITE_TAC[]);;
expand (REWRITE_TAC [ó≤_DEF; lift_binop_DEF; unit_map_DEF]
	THEN BETA_TAC);;
lemma "å (REP_PF((f:PF ã PF) z) = ¥)";;
  expand (UNDISCH_TAC "å((f:PF ã PF) z = ABS_PF ¥)"
	THEN TAUT_REWRITE_TAC "åa ä åb = b ä a"
	THEN STRIP_TAC
	THEN REWRITE_TAC [SYM (ASSUME "REP_PF((f:PF ã PF) z) = ¥")]);;
  expand (REWRITE_TAC [PF_t11]);;
expand (ASM_REWRITE_TAC[]);;
lemma "pure_function (unit((REP_PF z) ó (REP_PF((f:PF ã PF) z))))";;
  lemma_proof "pure_function (REP_PF z)
	Ä pure_function (REP_PF ((f:PF ã PF) z))"
		[REWRITE_TAC [PF_t19]];;
  lemma "(REP_PF((f:PF ã PF) z) à ¥)";;
    expand (ASM_REWRITE_TAC  [NE_DEF]);;
  expand (IMP_RES_TAC PF_t16);;
expand (IMP_RES_THEN OREWRITE_TAC PF_t10);;
.he
.sv "HOL output"
"Ñz:SET y:PF z':PFé
  å(z' = ABS_PF ¥) Ä
  (unit((REP_PF z) ó z) = REP_PF(y ó≤ z')) Ä
  (z' = (f:PF ã PF) y) Ä
  å(d ≤ y = ABS_PF ¥)"
    [ "å(d ≤ z = ABS_PF ¥)" ]
    [ "å((f:PF ã PF) z = ABS_PF ¥)" ]
.sw
.hd
expand (EXISTS_TAC "REP_PF ((f:PF ã PF) z)"
	THEN EXISTS_TAC "z:PF"
	THEN EXISTS_TAC "(f:PF ã PF) z"
	THEN ASM_REWRITE_TAC[ó≤_DEF; unit_map_DEF; lift_binop_DEF]
	THEN BETA_TAC);;
lemma "å(REP_PF((f:PF ã PF) z) = ¥)";;
  expand (UNDISCH_TAC "å((f:PF ã PF) z = ABS_PF ¥)"
	THEN TAUT_REWRITE_TAC "åa ä åb = b ä a"
	THEN STRIP_TAC
	THEN REWRITE_TAC[SYM (ASSUME "REP_PF((f:PF ã PF) z) = ¥");
				PF_t11]);;
expand (ASM_REWRITE_TAC[]);;
.he
.hd
lemma "pure_function (unit((REP_PF z) ó (REP_PF((f:PF ã PF) z))))";;
  lemma_proof "pure_function (REP_PF z)
	Ä pure_function (REP_PF ((f:PF ã PF) z))"
		[REWRITE_TAC [PF_t19]];;
  lemma "(REP_PF((f:PF ã PF) z) à ¥)";;
    expand (ASM_REWRITE_TAC  [NE_DEF]);;
  expand (IMP_RES_TAC PF_t16);;
expand (IMP_RES_THEN OREWRITE_TAC PF_t10);;
let PFB25 = save_top_thm `PFB25`;;
.he
.hd
set_goal([],"
	É(d:PF)(f:PFãPF)(z:PF)é (f z = ¥≤) ä
		((abs d f) ≤ z = f z)
");;
expand (REWRITE_TAC [abs_DEF; ≤_DEF; lift_binop_DEF; NE_DEF; PF_t26]);;
expand (BETA_TAC THEN REPEAT GEN_TAC);;
expand (STRIP_TAC THEN ASM_REWRITE_TAC[]);;
lemma_proof "pure_function (sabs d f)" [REWRITE_TAC [PFB23]];;
expand (IMP_RES_THEN OREWRITE_TAC PF_t10);;
lemma "pure_function (function_application(sabs d f)(REP_PF z))
	Ä pure_function ¥";;
  lemma_proof "pure_function (REP_PF z)" [REWRITE_TAC[PF_t19]];;
  expand (IMP_RES_TAC PF_t18 THEN ASM_REWRITE_TAC [PF_t17]);;
expand (IMP_RES_THEN OREWRITE_TAC PFB09);;
lemma "(function_application(sabs d f)(REP_PF z) = ¥)
	= å((REP_PF z) ù (domain(sabs d f)))";;
  expand (IMP_RES_TAC (SPECL ["sabs d f";"REP_PF z"] PF_t12));;
  expand (ASM_REWRITE_TAC[NE_DEF]);;
expand (ASM_REWRITE_TAC[]);;
.he
.sv "HOL output"
"å(REP_PF z) ù (domain(sabs d f))"
    [ "(f:PF ã PF) z = ABS_PF ¥" ]
    [ "pure_function(sabs d f)" ]
    [ "pure_function(function_application(sabs d f)(REP_PF z))" ]
    [ "pure_function ¥" ]
    [ "(function_application(sabs d f)(REP_PF z) = ¥) =
       å(REP_PF z) ù (domain(sabs d f))" ]
.sw
.hd
expand (REWRITE_TAC [domain_DEF; ZF2; ZF6]
	THEN BETA_TAC
	THEN REWRITE_TAC [PFB21]);;
expand (UNDISCH_TAC "(f:PF ã PF) z = ABS_PF ¥"
	THEN TAUT_REWRITE_TAC "a ä åb = b ä åa"
	THEN REPEAT STRIP_TAC);;
.he
.sv "HOL output"
"F"
    [ "pure_function(sabs d f)" ]
    [ "pure_function(function_application(sabs d f)(REP_PF z))" ]
    [ "pure_function ¥" ]
    [ "(function_application(sabs d f)(REP_PF z) = ¥) =
       å(REP_PF z) ù (domain(sabs d f))" ]
    [ "((z':PF) à ¥≤):bool" ]
    [ "unit z'' = REP_PF(y ó≤ z')" ]
    [ "z' = (f:PF ã PF) y" ]
    [ "((d ≤ y) à ¥≤):bool" ]
    [ "z' ù z''" ]
    [ "(REP_PF z) ù z'" ]
    [ "((z'''':PF) à ¥≤):bool" ]
    [ "unit((REP_PF z) ó z''') = REP_PF(y' ó≤ z'''')" ]
    [ "z'''' = (f:PF ã PF) y'" ]
    [ "((d ≤ y') à ¥≤):bool" ]
    [ "(f:PF ã PF) z = ABS_PF ¥" ]
.sw
.hd
lemma "(y':PF) = z";;
  expand (UNDISCH_TAC "unit((REP_PF z) ó z''') = REP_PF(y' ó≤ z'''')");;
  expand (REWRITE_TAC [ó≤_DEF; lift_binop_DEF; unit_map_DEF]
	THEN BETA_TAC);;
  lemma "å (REP_PF z'''' = ¥)";;
    expand (UNDISCH_TAC "(z'''' à ¥≤)"
		THEN REWRITE_TAC [NE_DEF; PF_t26]
		THEN TAUT_REWRITE_TAC "åa ä åb = b ä a"
		THEN STRIP_TAC
		THEN REWRITE_TAC [SYM (ASSUME "REP_PF z'''' = ¥"); PF_t11]);;
  expand (ASM_REWRITE_TAC[]);;
  lemma "pure_function (unit((REP_PF y') ó (REP_PF((f:PF ã PF) y'))))";;
    lemma_proof "pure_function (REP_PF y')
	Ä pure_function (REP_PF ((f:PF ã PF) y'))"
		[REWRITE_TAC [PF_t19]];;
    lemma "(REP_PF((f:PF ã PF) y') à ¥)";;
      expand (REWRITE_TAC
	  [NE_DEF;
	  SYM (ASSUMP "z'''' = (f:PF ã PF) y'")]);;
	expand (UNDISCH_TAC "(z'''' à ¥≤)"
		THEN REWRITE_TAC [NE_DEF; PF_t26]
		THEN TAUT_REWRITE_TAC "åa ä åb = b ä a"
		THEN STRIP_TAC
		THEN REWRITE_TAC [SYM (ASSUME "REP_PF z'''' = ¥"); PF_t11]);;
    expand (IMP_RES_TAC PF_t16);;
  expand (IMP_RES_THEN OREWRITE_TAC PF_t10);;
  expand (REWRITE_TAC[ZF_le13; ZF2_thm3]);;
  expand (REWRITE_TAC[GEN_ALL (SYM (SPEC_ALL PF_t09))]);;
  expand (REPEAT STRIP_TAC THEN ASM_REWRITE_TAC[]);;
expand (UNDISCH_TAC "(z'''' à ¥≤)"
	THEN ASM_REWRITE_TAC[NE_DEF; PF_t26]);;
let PFB26 = save_top_thm `PFB26`;;
.he
.hd
set_goal([],"
	É(d:PF)(f:PFãPF)(z:PF)é
		(d ≤ z) à ¥≤ ä (abs d f ≤ z = f z)
");;
expand (REPEAT GEN_TAC THEN STRIP_TAC);;
lemma "(REP_PF z) ù (domain(sabs d f)) Å (((f:PF ã PF) z) = ¥≤)";;
  expand (IMP_RES_TAC PFB11);;
  expand (ASSUME_TAC (SPEC_ALL (REWRITE_RULE [NE_DEF] PFB25))
	THEN IMP_RES_TAC (GEN_ALL (TAUT_RULE
				"(a = b Ä c) ä (b ä a Å åc)"))
	THEN ASM_REWRITE_TAC[]);;
  expand (UNDISCH_TAC "åå((f:PF ã PF) z = ¥≤)"
		THEN TAUT_TAC);;
.he
.sv "HOL output"
2 subgoals
"(abs d f) ≤ z = (f:PF ã PF) z"
    [ "((d ≤ z) à ¥≤):bool" ]
    [ "(f:PF ã PF) z = ¥≤" ]

"(abs d f) ≤ z = (f:PF ã PF) z"
    [ "((d ≤ z) à ¥≤):bool" ]
    [ "(REP_PF z) ù (domain(sabs d f))" ]
.sw
.hd
expand (UNDISCH_TAC "((d ≤ z) à ¥≤):bool");;
expand (REWRITE_TAC [abs_DEF; ≤_DEF; lift_binop_DEF; NE_DEF; PF_t26]);;
expand (BETA_TAC THEN REPEAT GEN_TAC);;
lemma "pure_function (function_application(REP_PF d)(REP_PF z))
	Ä pure_function ¥";;
  lemma_proof "pure_function (REP_PF d) Ä pure_function (REP_PF z)"
	[REWRITE_TAC [PF_t19]];;
  expand (IMP_RES_THEN OREWRITE_TAC PF_t18);;
  expand (ACCEPT_TAC PF_t17);;
expand (IMP_RES_THEN OREWRITE_TAC PFB09);;
.he
.sv "HOL output"
"å(function_application(REP_PF d)(REP_PF z) = ¥) ä
 (ABS_PF(function_application(REP_PF(ABS_PF(sabs d f)))(REP_PF z)) =
  f z)"
    [ "pure_function(function_application(REP_PF d)(REP_PF z))" ]
    [ "pure_function ¥" ]
.sw
.hd
lemma_proof "pure_function (REP_PF d)" [REWRITE_TAC[PF_t19]];;
lemma "å((function_application(REP_PF d)(REP_PF z)) = ¥)
		= ((REP_PF z) ù (domain(REP_PF d)))";;
  lemma_proof "(REP_PF z) ù (domain(REP_PF d)) =
       (function_application(REP_PF d)(REP_PF z)) à ¥"
	[IMP_RES_TAC (SPECL ["(REP_PF d)";"(REP_PF z)"] PF_t12)];;
  expand (UNDISCH_TAC "(REP_PF z) ù (domain(REP_PF d)) =
       (function_application(REP_PF d)(REP_PF z)) à ¥"
	THEN REWRITE_TAC [NE_DEF] THEN TAUT_TAC);;
expand (ASM_REWRITE_TAC[]);;
.he
.sv "HOL output"
"(REP_PF z) ù (domain(REP_PF d)) ä
 (ABS_PF(function_application(REP_PF(ABS_PF(sabs d f)))(REP_PF z)) =
  f z)"
    [ "pure_function(function_application(REP_PF d)(REP_PF z))" ]
    [ "pure_function ¥" ]
    [ "pure_function(REP_PF d)" ]
    [ "å(function_application(REP_PF d)(REP_PF z) = ¥) =
       (REP_PF z) ù (domain(REP_PF d))" ]
.sw
.hd
expand (REWRITE_TAC [domain_DEF; ZF2; ZF6]);;
expand (BETA_TAC THEN REPEAT STRIP_TAC);;
expand (ONCE_REWRITE_TAC [SYM(SPEC "(f:PFãPF) z" PF_t11)]);;
lemma "pure_function (function_application(REP_PF(ABS_PF(sabs d f)))
	(REP_PF z))
	Ä pure_function (REP_PF(f z))";;
  expand (REWRITE_TAC [PF_t19]);;
  lemma "pure_function (REP_PF(ABS_PF(sabs d f)))
	Ä pure_function (REP_PF z)";;
    expand (REWRITE_TAC [PF_t19]);;
  expand (IMP_RES_THEN OREWRITE_TAC PF_t18);;
expand (IMP_RES_THEN OREWRITE_TAC PFB09);;
lemma_proof "pure_function (sabs d f)" [REWRITE_TAC [PFB23]];;
lemma_proof "function (sabs d f)" [IMP_RES_TAC PF_t05];;
expand (IMP_RES_THEN OREWRITE_TAC PF_t10);;
.he
.sv "HOL output"
"function_application(sabs d f)(REP_PF z) = REP_PF(f z)"
    [ "pure_function(function_application(REP_PF d)(REP_PF z))" ]
    [ "pure_function ¥" ]
    [ "pure_function(REP_PF d)" ]
    [ "å(function_application(REP_PF d)(REP_PF z) = ¥) =
       (REP_PF z) ù (domain(REP_PF d))" ]
    [ "z'' ù (REP_PF d)" ]
    [ "z' ù z''" ]
    [ "(REP_PF z) ù z'" ]
    [ "((REP_PF z) ó z''') ù (REP_PF d)" ]
    [ "pure_function
       (function_application(REP_PF(ABS_PF(sabs d f)))(REP_PF z))" ]
    [ "pure_function(REP_PF(f z))" ]
    [ "pure_function(sabs d f)" ]
    [ "function(sabs d f)" ]
.sw
.hd
expand (IMP_RES_TAC PFB22);;
.he
.sv "HOL output"
"(abs d f) ≤ z = (f:PF ã PF) z"
    [ "((d ≤ z) à ¥≤):bool" ]
    [ "(f:PF ã PF) z = ¥≤" ]
.sw
.hd
expand (IMP_RES_TAC PFB26);;
let PFB27 = save_top_thm `PFB27`;;
.he
.NH
FUNCTIONAL OVERRIDE
.LP
.hd
set_goal([],"
	É(x:SET)(y:SET)é pure_function x Ä y ù field x ä
		pure_function y
");;
.he
.hd
set_goal([],"
	É(w:SET)(y:SET)é pure_function w Ä pure_function y ä
		pure_function (w ï y)
");;
expand (REPEAT STRIP_TAC THEN REWRITE_TAC [pure_function_DEF]);;
expand (REPEAT STRIP_TAC);;
expand (DEF_RES_TAC function_hereditary_DEF);;
.he
.hd
lemma "function (w ï y) Ä
        ¥ ì (image (w ï y)) Ä
        (Éxé x ù (field (w ï y)) ä p x)";;
	expand (REPEAT STRIP_TAC);;

		expand (IMP_RES_TAC PF_t05);;
		expand (IMP_RES_TAC ZF2_thm10);;
.he
.hd
		expand (IMP_RES_TAC PF_t05);;
		lemma "¥ ì (image y) Ä  ¥ ì (image w) ä ¥ ì (image(w ï y))";;
			expand (EVERY[REWRITE_TAC [ì_DEF];
			TAUT_REWRITE_TAC "åa Ä åb ä åc = c ä a Å b"]);;
			expand (STRIP_TAC THEN
				IMP_RES_TAC (REWRITE_RULE [•_DEF; ZF_thm10] ZF2_thm14)
				THEN ASM_REWRITE_TAC[]);;
		expand RES_TAC;;
.he
.hd
	lemma "x ù field w Å x ù field y";;
		expand (IMP_RES_TAC PF_t05);;
		expand (IMP_RES_TAC ZF2_thm26);;
		expand (IMP_RES_THEN (çxéREWRITE_TAC[x])
			(REWRITE_RULE [•_DEF; ZF_thm10]
			(ASSUMP "(field(w ï y)) • ((field w) ° (field y))")));;
.he
.hd
	expand (IMP_RES_TAC PF_t06);;
	expand (IMP_RES_TAC PF_t02);;

	expand (IMP_RES_TAC PF_t06);;
	expand (IMP_RES_TAC PF_t02);;
expand RES_TAC;;
let PFB28 = save_top_thm `PFB28`;;
.he
.hd
let ï≤_DEF = new_infix_definition(`ï≤_DEF`,"
	ï≤ = lift_binop $ï
");;
.he
.hd
set_goal([],"
	É(x:SET)(y:SET)(z:SET)é
	pure_function x Ä pure_function y Ä pure_function z
	ä	(function_application (x ï y) z = 
			((function_application y z = ¥)
			=> function_application x z
			| function_application y z))
");;
expand (REWRITE_TAC [function_application_DEF] THEN REPEAT STRIP_TAC);;
.he
.hd
lemma_proof "function x Ä function y"
		[IMP_RES_TAC PF_t05; ASM_REWRITE_TAC[]];;
expand (IMP_RES_THEN (çxéPURE_REWRITE_TAC[x]) ZF2_thm16);;
expand (IMP_RES_THEN (çxéPURE_REWRITE_TAC[x]) ZF2_thm19);;
expand (EVERY[
	ASM_CASES_TAC "z ù domain x";
	ASM_CASES_TAC "z ù domain y";
	ASM_REWRITE_TAC[]]);;
.he
.hd
expand (IMP_RES_THEN DEF_RES_TAC (SPECL ["y:SET";"z:SET"] PF_t12));;
expand (REWRITE_TAC [REWRITE_RULE
	[NE_DEF; function_application_DEF; ASSUMP "z ù (domain y)"]
	(ASSUMP "(function_application y z) à ¥")]);;
.he
.hd
expand (ASM_CASES_TAC "y © z = ¥" THEN ASM_REWRITE_TAC[]);;

let PFB29 = save_top_thm `PFB29`;;
.he
.hd
set_goal([],"
	É(x:PF)(y:PF)(z:PF)é (x ï≤ y) ≤ z = ((y ≤ z = ¥≤) => x ≤ z | y ≤ z)
");;
expand (PURE_REWRITE_TAC [ï≤_DEF; ≤_DEF; lift_binop_DEF] THEN BETA_TAC);;
expand (REPEAT STRIP_TAC);;
lemma_proof "pure_function (REP_PF x)"
		[REWRITE_TAC [DEF_PF]; EXISTS_TAC "x"; REFL_TAC];;
lemma_proof "pure_function (REP_PF y)"
		[REWRITE_TAC [DEF_PF]; EXISTS_TAC "y"; REFL_TAC];;
lemma_proof "pure_function (REP_PF z)"
		[REWRITE_TAC [DEF_PF]; EXISTS_TAC "z"; REFL_TAC];;
lemma_proof "pure_function((REP_PF x) ï (REP_PF y))"
		[IMP_RES_TAC PFB28];;
expand (IMP_RES_THEN (çxéPURE_REWRITE_TAC[x]) PF_t10);;
lemma_proof "pure_function (function_application((REP_PF x) ï
		(REP_PF y))	(REP_PF z))"
		[IMP_RES_TAC PF_t18];;
expand (ASM_CASES_TAC
		"ABS_PF(function_application(REP_PF y)(REP_PF z)) = ¥≤"
	THEN ASM_REWRITE_TAC[]);;
.he
.sv "HOL output"
2 subgoals
"ABS_PF(function_application((REP_PF x) ï (REP_PF y))(REP_PF z)) =
 ABS_PF(function_application(REP_PF y)(REP_PF z))"
    [ "pure_function(REP_PF x)" ]
    [ "pure_function(REP_PF y)" ]
    [ "pure_function(REP_PF z)" ]
    [ "pure_function((REP_PF x) ï (REP_PF y))" ]
    [ "pure_function
       (function_application((REP_PF x) ï (REP_PF y))(REP_PF z))" ]
    [ "å(ABS_PF(function_application(REP_PF y)(REP_PF z)) = ¥≤)" ]

"ABS_PF(function_application((REP_PF x) ï (REP_PF y))(REP_PF z)) =
 ABS_PF(function_application(REP_PF x)(REP_PF z))"
    [ "pure_function(REP_PF x)" ]
    [ "pure_function(REP_PF y)" ]
    [ "pure_function(REP_PF z)" ]
    [ "pure_function((REP_PF x) ï (REP_PF y))" ]
    [ "pure_function
       (function_application((REP_PF x) ï (REP_PF y))(REP_PF z))" ]
    [ "ABS_PF(function_application(REP_PF y)(REP_PF z)) = ¥≤" ]
.sw
.hd
lemma_proof "pure_function(function_application(REP_PF x)(REP_PF z))"			[IMP_RES_TAC PF_t18];;
lemma_proof "(ABS_PF
        (function_application((REP_PF x) ï (REP_PF y))(REP_PF z)) =
        ABS_PF(function_application(REP_PF x)(REP_PF z))) =
       (function_application((REP_PF x) ï (REP_PF y))(REP_PF z) =
        function_application(REP_PF x)(REP_PF z))"
		[IMP_RES_TAC PFB09; ASM_REWRITE_TAC[]];;

expand (ASM_REWRITE_TAC[]);;
.he
.hd
lemma_proof "function_application((REP_PF x) ï (REP_PF y))(REP_PF z) =
     ((function_application (REP_PF y)(REP_PF z) = ¥) => 
      function_application (REP_PF x) (REP_PF z) | 
      function_application (REP_PF y) (REP_PF z))"
	[IMP_RES_TAC (SPECL ["REP_PF x";"REP_PF y";"REP_PF z"] PFB29)];;

expand (ASM_REWRITE_TAC[]);;
.he
.hd
lemma "function_application (REP_PF y)(REP_PF z) = ¥";;
expand (MP_TAC (ASSUMP
	"ABS_PF(function_application(REP_PF y)(REP_PF z)) = ¥≤"));;
expand (REWRITE_TAC [PF_t26]);;
expand (ASSUME_TAC PF_t17);; 
lemma_proof "pure_function (function_application(REP_PF y)(REP_PF z))"
		[IMP_RES_TAC PF_t18];;
expand (IMP_RES_TAC PFB09);;
expand (REWRITE_TAC [ASSUMP
	"(ABS_PF(function_application(REP_PF y)(REP_PF z)) = ABS_PF ¥) =
	(function_application(REP_PF y)(REP_PF z) = ¥)"]);;

expand (REWRITE_TAC [ASSUMP
	"function_application(REP_PF y)(REP_PF z) = ¥"]);;
.he
.hd
lemma_proof "pure_function(function_application(REP_PF y)(REP_PF z))"			[IMP_RES_TAC PF_t18];;
lemma_proof "(ABS_PF
        (function_application((REP_PF x) ï (REP_PF y))(REP_PF z)) =
        ABS_PF(function_application(REP_PF y)(REP_PF z))) =
       (function_application((REP_PF x) ï (REP_PF y))(REP_PF z) =
        function_application(REP_PF y)(REP_PF z))"
		[IMP_RES_TAC PFB09; ASM_REWRITE_TAC[]];;

expand (ASM_REWRITE_TAC[]);;

lemma_proof "function_application((REP_PF x) ï (REP_PF y))(REP_PF z) =
     ((function_application (REP_PF y)(REP_PF z) = ¥) => 
      function_application (REP_PF x) (REP_PF z) | 
      function_application (REP_PF y) (REP_PF z))"
	[IMP_RES_TAC (SPECL ["REP_PF x";"REP_PF y";"REP_PF z"] PFB29)];;

expand (ASM_REWRITE_TAC[]);;

lemma "å (function_application (REP_PF y)(REP_PF z) = ¥)";;
	expand (MP_TAC (ASSUMP
	"å(ABS_PF(function_application(REP_PF y)(REP_PF z)) = ¥≤)"));;
expand (REWRITE_TAC [PF_t26]);;
expand (ASSUME_TAC PF_t17);; 
lemma_proof "pure_function (function_application(REP_PF y)(REP_PF z))"
		[IMP_RES_TAC PF_t18];;
expand (IMP_RES_TAC PFB09);;
expand (REWRITE_TAC [ASSUMP
	"(ABS_PF(function_application(REP_PF y)(REP_PF z)) = ABS_PF ¥) =
	(function_application(REP_PF y)(REP_PF z) = ¥)"]);;

expand (REWRITE_TAC [ASSUMP
	"å(function_application(REP_PF y)(REP_PF z) = ¥)"]);;
.he
.hd
let PFB30 = save_top_thm `PFB30`;;
.he
let 
.NH
DEPENDENT FUNCTION SPACE
.LP
.hd
let dependent_function_space_DEF = new_definition(`dependent_function_space_DEF`,"
	(dependent_function_space:SETãSET) f =
	(sep (ë (ë ((domain f) ™ (domain (£ (image f))))))
	(çx:SETé function x Ä (domain x • domain f) Ä
	É(y:SET)é (y ù (domain x)) ä
		(function_application
			(function_application f y)
			(function_application x y))
		à ¥) 
		) ™ unit truef
");;
.he
.hd
let ˙_DEF = new_definition(`˙_DEF`,"
	(˙:PFãPF) = lift_monop dependent_function_space
");;
.he
.NH
DISJOINT UNION
.LP
.hd
%
let disjoint_union_DEF = new_definition(`disjoint_union_DEF`,"
	(disjoint_union:SETãSET) f =
	(sep (ë (ë ((domain f) ™ (£ (image f)))))
		(çx:SETé function x Ä (domain x • domain f) Ä
			É(y:SET)é (y ù x) ä (x © y) ù (f © y)
		)) ™ (unit truef)
");;
%
.he
.hd
%
let ˚_DEF = new_definition(`˚_DEF`,"
	˚ = lift_monop disjoint_union
");;
%
.he
.NH
THE END
.hd
close_theory`pf128`;;
.he
.KS
.NH
THE THEORY PF2
.LP
.DS L
 The Theory PF2
Parents --  PF     PF     
Constants --
  fabs ":SET ã ((SET ã SET) ã SET)"
  ptptsts ":(PF ã PF) ã (SET ã SET)"
  sabs ":PF ã ((PF ã PF) ã SET)"
  abs ":PF ã ((PF ã PF) ã PF)"
  dependent_function_space ":SET ã SET"     ˙ ":PF ã PF"     
Curried Infixes --  ï≤ ":PF ã (PF ã PF)"     
Definitions --
  fabs_DEF
    Ö fabs d val =
       (áxé
         Éyé
          y ù x =
          (Ñv wé
            w à ¥ Ä (y = v ó w) Ä (w = val v) Ä v ù d))
  ptptsts_DEF  Ö ptptsts val = (çsé REP_PF(val(ABS_PF s)))
  sabs_DEF  Ö sabs d val = fabs(domain(REP_PF d))(ptptsts val)
  abs_DEF  Ö abs d val = ABS_PF(sabs d val)
  ï≤_DEF  Ö $ï≤ = lift_binop $ï
  dependent_function_space_DEF
    Ö dependent_function_space f =
       (sep
        (ë(ë((domain f) ™ (domain(£(image f))))))
        (çxé
          function x Ä
          (domain x) • (domain f) Ä
          (Éyé
            y ù (domain x) ä
            (function_application
             (function_application f y)
             (function_application x y)) à
            ¥))) ™
       (unit truef)
  ˙_DEF  Ö ˙ = lift_monop dependent_function_space
  
Theorems --
  PFB01
    Ö Éx d valé
        (x = fabs d val) =
        (Éyé
          y ù x =
          (Ñv wé
            w à ¥ Ä (y = v ó w) Ä (w = val v) Ä v ù d))
  PFB02
    Ö Éx d valé
        x ù (fabs d val) =
        (Ñv wé w à ¥ Ä (x = v ó w) Ä (w = val v) Ä v ù d)
  PFB03  Ö Éd valé function(fabs d val)
  PFB04  Ö Éd valé ¥ ì (image(fabs d val))
  PFB05  Ö Éd valé ¥ ì (image(sabs d val))
  PFB06  Ö Éd valé function(sabs d val)
  PFB07
    Ö Éx d valé
        x ù d ä ((val x) à ¥ = x ù (domain(fabs d val)))
  PFB08
    Ö Éd val xé
        x ù d ä (function_application(fabs d val)x = val x)
  PFB09
    Ö Éx yé
        pure_function x Ä pure_function y ä
        ((ABS_PF x = ABS_PF y) = (x = y))
  PFB10
    Ö Éd zé
        (d ≤ z) à ¥≤ ä
        (Ñwé pure_function w Ä ((REP_PF z) ó w) ù (REP_PF d))
  PFB11
    Ö Éd yé
        (d ≤ y) à ¥≤ ä (REP_PF y) ù (domain(REP_PF d))
  PFB12
    Ö Éx y zé
        (x ≤ y) à ¥≤ ä
        ((x ≤ y = z) = ((REP_PF y) ó (REP_PF z)) ù (REP_PF x))
  PFB13
    Ö Éd e fé
        (ABS_PF(function_application(REP_PF d)(REP_PF e)) = f) =
        (function_application(REP_PF d)(REP_PF e) = REP_PF f)
  PFB14
    Ö Éd e fé
        pure_function f ä
        ((ABS_PF(function_application(REP_PF d)(REP_PF e)) = ABS_PF f) =
         (function_application(REP_PF d)(REP_PF e) = f))
  PFB15
    Ö Éx d valé
        x ù (sabs d val) ä (d ≤ (ABS_PF(fst x))) à ¥≤
  PFB16
    Ö Éx d valé x ù (sabs d val) ä (ABS_PF(snd x)) à ¥≤
  PFB17
    Ö Éx d valé
        x ù (sabs d val) ä
        (unit x = REP_PF((ABS_PF(fst x)) ó≤ (ABS_PF(snd x))))
  PFB18
    Ö Éx d valé
        x ù (sabs d val) ä (ABS_PF(snd x) = val(ABS_PF(fst x)))
  PFB19
    Ö Éx d valé
        x ù (sabs d val) ä
        (Ñy zé
          z à ¥≤ Ä
          (unit x = REP_PF(y ó≤ z)) Ä
          (z = val y) Ä
          (d ≤ y) à ¥≤)
  PFB20
    Ö Éx d valé
        (Ñy zé
          z à ¥≤ Ä
          (unit x = REP_PF(y ó≤ z)) Ä
          (z = val y) Ä
          (d ≤ y) à ¥≤) ä
        x ù (sabs d val)
  PFB21
    Ö Éx d valé
        x ù (sabs d val) =
        (Ñy zé
          z à ¥≤ Ä
          (unit x = REP_PF(y ó≤ z)) Ä
          (z = val y) Ä
          (d ≤ y) à ¥≤)
  PFB22
    Ö Éz d fé
        (REP_PF z) ù (domain(sabs d f)) ä
        (function_application(sabs d f)(REP_PF z) = REP_PF(f z))
  PFB23  Ö Éd valé pure_function(sabs d val)
  PFB24
    Ö Éd zé
        (d ≤ z) à ¥≤ = (REP_PF z) ù (domain(REP_PF d))
  PFB25
    Ö Éd f zé
        (REP_PF z) ù (domain(sabs d f)) =
        (REP_PF z) ù (domain(REP_PF d)) Ä (f z) à ¥≤
  PFB26  Ö Éd f zé (f z = ¥≤) ä ((abs d f) ≤ z = f z)
  PFB27
    Ö Éd f zé (d ≤ z) à ¥≤ ä ((abs d f) ≤ z = f z)
  PFB28
    Ö Éw yé
        pure_function w Ä pure_function y ä pure_function(w ï y)
  PFB29
    Ö Éx y zé
        pure_function x Ä pure_function y Ä pure_function z ä
        (function_application(x ï y)z =
         ((function_application y z = ¥) => 
          function_application x z | 
          function_application y z))
  PFB30
    Ö Éx y zé
        (x ï≤ y) ≤ z =
        ((y ≤ z = ¥≤) => x ≤ z | y ≤ z)
.DE
.KE
